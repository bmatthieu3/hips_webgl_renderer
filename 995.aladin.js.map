{"version":3,"sources":["webpack://hips_webgl_renderer/./node_modules/@fxpineau/healpix/healpix_bg.js"],"names":["cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getOrderMax","cachegetFloat64Memory0","getFloat64Memory0","buffer","Float64Array","WASM_VECTOR_LEN","passArrayF64ToWasm0","arg","malloc","ptr","length","set","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachegetUint32Memory0","lonlatToNested","depth","lon","lat","getArrayF64FromWasm0","len","subarray","multiLonlatToNested","coords","ptr0","len0","r0","r1","v1","slice","nestedCenter","hash","v0","nestedVertices","nestedNeighbours","ret","Neighbours","__wrap","nestedQueryConeBMOC","cone_lon","cone_lat","cone_radius","BMOC","nestedQueryCone","nestedQueryPolygonBMOC","vertices_coos","nestedQueryPolygon","obj","Object","create","prototype","free","this","getSize","getDepth","getCell","icell","Cell","getCellDepth","getCellHash","getCellFlag","undefined","PolygonMap","addPolygon","id","rmPolygon","polygonContaining","ra_deg","de_deg","Uint32Array","__wbindgen_throw","arg0","arg1","Error","Uint8Array"],"mappings":"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","file":"995.aladin.js","sourcesContent":["import * as wasm from './healpix_bg.wasm';\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* Returns the max order one can use in Javascipts.\n* Equals 24 since we store ou HEALPix indices on a Javascript number which is a double.\n* A double has a mantissa of 52 bits = 24 * 2 (2 bits per level) + 4 (4 bits to code base cells).\n* @returns {number}\n*/\nexport function getOrderMax() {\n    var ret = wasm.getOrderMax();\n    return ret;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8);\n    getFloat64Memory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* Returns the cell number (hash value) in the NESTED scheme associated with the given position\n* on the unit sphere\n* # Inputs\n* - `order`: the order of the HEALPix hash we want in output\n* - `lon`: longitude in degrees, support reasonably large positive and negative values\n*          producing accurate results with a naive range reduction like modulo 360\n*          (i.e. without having to resort on Cody-Waite or Payne Hanek range reduction).\n* - `lat`: latitude in degrees, must be in `[-90, 90]`\n* # Output\n* - the cell number (hash value) associated with the given position on the unit sphere,\n*   in `[0, 12*nside^2[`\n* # Panics\n*   If `lat` **not in** `[-90, 90]`, this method panics.\n* @param {number} depth\n* @param {number} lon\n* @param {number} lat\n* @returns {number}\n*/\nexport function lonlatToNested(depth, lon, lat) {\n    var ret = wasm.lonlatToNested(depth, lon, lat);\n    return ret;\n}\n\nfunction getArrayF64FromWasm0(ptr, len) {\n    return getFloat64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n/**\n* Returns the cell numbers (hash value) in the NESTED scheme associated with the given positions\n* on the unit sphere\n* # Inputs\n* - `order`: the order of the HEALPix hashes we want in output\n* - `coords`: an array storing consecutively the coordinates of the positions we look for the\n*             cell numbers: `[lon_1, lat_1, lon_2, lat_2, ..., lon_n, lat_n]`\n*   - `lon`: longitude in degrees, support reasonably large positive and negative values\n*            producing accurate results with a naive range reduction like modulo 2*pi\n*            (i.e. without having to resort on Cody-Waite or Payne Hanek range reduction).\n*   - `lat`: latitude in degrees, must be in `[-90, 90]`\n* # Output\n* - the cell number (hash value) associated with the given position on the unit sphere,\n*   in `[0, 12*nside^2[`\n* # Panics\n*   If `lat` **not in** `[-90, 90]`, this method panics.\n* @param {number} depth\n* @param {Float64Array} coords\n* @returns {Float64Array}\n*/\nexport function multiLonlatToNested(depth, coords) {\n    var ptr0 = passArrayF64ToWasm0(coords, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.multiLonlatToNested(8, depth, ptr0, len0);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v1;\n}\n\n/**\n* Compute the position on the unit sphere of the center (in the Euclidean projection plane)\n* of the cell associated to the given cell number.\n* # Input\n* - `order`: the order of the cell\n* - `icell`: the cell number value of the cell we look for the unprojected center, in the NESTED scheme\n* # Output\n* - `[lon, lat]` in degrees, the unprojected position (on the unit sphere) of the center of\n*   the cell in the Euclidean plane\n*   - `lon`, longitude in `[0, 360]` degrees;\n*   - `lat`, latitude in `[-90, 90]` degrees.\n*\n* # Panics\n* If the given `hash` value is not in `[0, 12*nside^2[`, this method panics.\n* @param {number} depth\n* @param {number} hash\n* @returns {Float64Array}\n*/\nexport function nestedCenter(depth, hash) {\n    wasm.nestedCenter(8, depth, hash);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Computes the location on the unit sphere of the 4 vertices of the given HEALPix cell\n* (define by its depth and number).\n* # Inputs\n* - `order` the order of the cell we look for the vertices\n* - `icell`: the cell number value of the cell we look for the unprojected center, in the NESTED scheme\n* # Output\n* - array containing the longitudes and latitudes (in degrees) of the vertices in the following order:\n*   `[SouthLon, SouthLat, EastLon, EastLat, NoethLon, NorthLat, WestLon, WestLat]`\n* @param {number} depth\n* @param {number} hash\n* @returns {Float64Array}\n*/\nexport function nestedVertices(depth, hash) {\n    wasm.nestedVertices(8, depth, hash);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Returns the hash values of all the neighbour cells of the cell of given cell number.\n* The given cell itself is included.\n* # Inputs\n* - `order` the order of the cell we look for the neighbours\n* - `icell` the nested number of the cell we look for the neighbours\n* @param {number} depth\n* @param {number} hash\n* @returns {Neighbours}\n*/\nexport function nestedNeighbours(depth, hash) {\n    var ret = wasm.nestedNeighbours(depth, hash);\n    return Neighbours.__wrap(ret);\n}\n\n/**\n* Returns the BMOC covered by the given cone.\n* # Inputs\n* - `order`: the maximum order of the cell in the returned BMOC\n* - `cone_lon`: cone center longitude, in degrees\n* - `cone_lat`: cone center latitude in degrees, must be in `[-90, 90]`\n* - `cone_radius`: radius of the cone, in degrees\n* # Outputs\n* - the BMOC covered by the given cone\n* @param {number} depth\n* @param {number} cone_lon\n* @param {number} cone_lat\n* @param {number} cone_radius\n* @returns {BMOC}\n*/\nexport function nestedQueryConeBMOC(depth, cone_lon, cone_lat, cone_radius) {\n    var ret = wasm.nestedQueryConeBMOC(depth, cone_lon, cone_lat, cone_radius);\n    return BMOC.__wrap(ret);\n}\n\n/**\n* Returns the flat list of HEALPix cell of given order covered by the given cone.\n* # Inputs\n* - `order`: the order of the returned cells\n* - `cone_lon`: cone center longitude, in degrees\n* - `cone_lat`: cone center latitude in degrees, must be in `[-90, 90]`\n* - `cone_radius`: radius of the cone, in degrees\n* # Outputs\n* - the flat list of HEALPix cell of given order covered by the given cone\n* @param {number} depth\n* @param {number} cone_lon\n* @param {number} cone_lat\n* @param {number} cone_radius\n* @returns {Float64Array}\n*/\nexport function nestedQueryCone(depth, cone_lon, cone_lat, cone_radius) {\n    wasm.nestedQueryCone(8, depth, cone_lon, cone_lat, cone_radius);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Returns the BMOC covered by the given polygon.\n* # Inputs\n* - `order`: the maximum order of the cell in the returned BMOC\n* - `vertices_coos`: the flat list of polygon vertices coordinates, in radians\n*    `[v1.lon, v1.lat, v2.lon, v2.lat, ..., vN.lon, vN.lat]`\n* # Outputs\n* - the BMOC covered by the given polygon\n* @param {number} depth\n* @param {Float64Array} vertices_coos\n* @returns {BMOC}\n*/\nexport function nestedQueryPolygonBMOC(depth, vertices_coos) {\n    var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.nestedQueryPolygonBMOC(depth, ptr0, len0);\n    return BMOC.__wrap(ret);\n}\n\n/**\n* Returns the BMOC covered by the given polygon.\n* # Inputs\n* - `order`: the order of the returned cells\n* - `vertices_coos`: the flat list of polygon vertices coordinates, in radians\n*    `[v1.lon, v1.lat, v2.lon, v2.lat, ..., vN.lon, vN.lat]`\n* # Outputs\n* - the BMOC covered by the given polygon\n* @param {number} depth\n* @param {Float64Array} vertices_coos\n* @returns {Float64Array}\n*/\nexport function nestedQueryPolygon(depth, vertices_coos) {\n    var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.nestedQueryPolygon(8, depth, ptr0, len0);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v1;\n}\n\n/**\n* Represents a BMOC object resulting from a cone search or a polygon query.\n* For practical reasons of data exchange between Javascript and WebAssembly, each elements\n* of a cell (depth, hash, flag) are stored in separate arrays.\n* (I firs wanted to return an array of Cell, but so far it is not possible with wasm-bindgen)\n*/\nexport class BMOC {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BMOC.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_bmoc_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get n_cells() {\n        var ret = wasm.__wbg_get_bmoc_n_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get depth_max() {\n        var ret = wasm.__wbg_get_bmoc_depth_max(this.ptr);\n        return ret;\n    }\n    /**\n    * Returns the number of cells (of various depth) in the BMOC\n    * @returns {number}\n    */\n    getSize() {\n        var ret = wasm.__wbg_get_bmoc_n_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the maximal depth of the BMOC\n    * @returns {number}\n    */\n    getDepth() {\n        var ret = wasm.__wbg_get_bmoc_depth_max(this.ptr);\n        return ret;\n    }\n    /**\n    * Utility method replacing the calls to `getCellDepth`, `getCellHash` and `getCellFlag`\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {Cell}\n    */\n    getCell(icell) {\n        var ret = wasm.bmoc_getCell(this.ptr, icell);\n        return Cell.__wrap(ret);\n    }\n    /**\n    * Returns the depth of cell number `i` in the BMOC\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {number}\n    */\n    getCellDepth(icell) {\n        var ret = wasm.bmoc_getCellDepth(this.ptr, icell);\n        return ret;\n    }\n    /**\n    * Returns the hash value (or pixel number) of the cell number `i` in the BMOC\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {number}\n    */\n    getCellHash(icell) {\n        var ret = wasm.bmoc_getCellHash(this.ptr, icell);\n        return ret;\n    }\n    /**\n    * Returns the status flag of the cell number `i` in the BMOC\n    * (`true`: cell fully covered; `false`: cell partially covered)\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {boolean}\n    */\n    getCellFlag(icell) {\n        var ret = wasm.bmoc_getCellFlag(this.ptr, icell);\n        return ret !== 0;\n    }\n}\n/**\n* Represents a BMOC cell: its depth, number and flag telling if the cell is fully/partially covered.\n*/\nexport class Cell {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Cell.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_cell_free(ptr);\n    }\n    /**\n    * The order of the HEALPix cell\n    * @returns {number}\n    */\n    get order() {\n        var ret = wasm.__wbg_get_cell_order(this.ptr);\n        return ret;\n    }\n    /**\n    * The nested HEALPix cell number\n    * @returns {number}\n    */\n    get icell() {\n        var ret = wasm.__wbg_get_cell_icell(this.ptr);\n        return ret;\n    }\n    /**\n    * The flag telling if the cell if fully or partially covered\n    * @returns {boolean}\n    */\n    get isfull() {\n        var ret = wasm.__wbg_get_cell_isfull(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Contains the list of the neighbours of the `center` HEALPix cell.\n* In general, a cell has 8 neighbours.\n* But the top and bottom corners of equatorial base cells do not have\n* north and south neighbours respectively.\n* The left most and right most corners of the polar caps base cells do not have\n* west and east corners respectively.\n*/\nexport class Neighbours {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Neighbours.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_neighbours_free(ptr);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get south() {\n        wasm.__wbg_get_neighbours_south(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get southeast() {\n        var ret = wasm.__wbg_get_neighbours_southeast(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get east() {\n        wasm.__wbg_get_neighbours_east(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get southwest() {\n        var ret = wasm.__wbg_get_neighbours_southwest(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get center() {\n        var ret = wasm.__wbg_get_neighbours_center(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get norhteast() {\n        var ret = wasm.__wbg_get_neighbours_norhteast(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get west() {\n        wasm.__wbg_get_neighbours_west(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get norhtwest() {\n        var ret = wasm.__wbg_get_neighbours_norhtwest(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get north() {\n        wasm.__wbg_get_neighbours_north(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n}\n/**\n*/\nexport class PolygonMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PolygonMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_polygonmap_free(ptr);\n    }\n    /**\n    * @returns {PolygonMap}\n    */\n    static new() {\n        var ret = wasm.polygonmap_new();\n        return PolygonMap.__wrap(ret);\n    }\n    /**\n    * Add a polygon of given identifier to the map, the provided liste is:\n    * [ra_v1_deg, dec_v1_deg, ra_v2_deg, de_v2_deg, ..., ra_vn_deg, de_vn_deg]\n    * @param {number} id\n    * @param {Float64Array} vertices_coos\n    */\n    addPolygon(id, vertices_coos) {\n        var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.polygonmap_addPolygon(this.ptr, id, ptr0, len0);\n    }\n    /**\n    * Remove the polygon of given identifier to the map.\n    * @param {number} id\n    */\n    rmPolygon(id) {\n        wasm.polygonmap_rmPolygon(this.ptr, id);\n    }\n    /**\n    * Returns the list of the identifiers of the polygon containing the given point.\n    * @param {number} ra_deg\n    * @param {number} de_deg\n    * @returns {Uint32Array}\n    */\n    polygonContaining(ra_deg, de_deg) {\n        wasm.polygonmap_polygonContaining(8, this.ptr, ra_deg, de_deg);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        var v0 = getArrayU32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v0;\n    }\n}\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"sourceRoot":""}