{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/core/img/kernel.png","webpack:///./src/core/src/shaders/catalogs/aitoff.vert","webpack:///./src/core/src/shaders/catalogs/arc.vert","webpack:///./src/core/src/shaders/catalogs/catalog.frag","webpack:///./src/core/src/shaders/catalogs/mercator.vert","webpack:///./src/core/src/shaders/catalogs/mollweide.vert","webpack:///./src/core/src/shaders/catalogs/ortho.frag","webpack:///./src/core/src/shaders/catalogs/ortho.vert","webpack:///./src/core/src/shaders/catalogs/tan.vert","webpack:///./src/core/src/shaders/colormaps/BluePastelRed.frag","webpack:///./src/core/src/shaders/colormaps/IDL_CB_BrBG.frag","webpack:///./src/core/src/shaders/colormaps/IDL_CB_GnBu.frag","webpack:///./src/core/src/shaders/colormaps/IDL_CB_YIGnBu.frag","webpack:///./src/core/src/shaders/colormaps/blackwhite.frag","webpack:///./src/core/src/shaders/colormaps/colormap.vert","webpack:///./src/core/src/shaders/colormaps/red.frag","webpack:///./src/core/src/shaders/grid/aitoff.frag","webpack:///./src/core/src/shaders/grid/arc.frag","webpack:///./src/core/src/shaders/grid/grid.vert","webpack:///./src/core/src/shaders/grid/grid_cpu.frag","webpack:///./src/core/src/shaders/grid/grid_cpu.vert","webpack:///./src/core/src/shaders/grid/mercator.frag","webpack:///./src/core/src/shaders/grid/mollweide.frag","webpack:///./src/core/src/shaders/grid/ortho.frag","webpack:///./src/core/src/shaders/grid/tan.frag","webpack:///./src/core/src/shaders/hips/rasterizer/aitoff.vert","webpack:///./src/core/src/shaders/hips/rasterizer/arc.vert","webpack:///./src/core/src/shaders/hips/rasterizer/color.frag","webpack:///./src/core/src/shaders/hips/rasterizer/gnomonic.vert","webpack:///./src/core/src/shaders/hips/rasterizer/grayscale_to_color.frag","webpack:///./src/core/src/shaders/hips/rasterizer/grayscale_to_color_i.frag","webpack:///./src/core/src/shaders/hips/rasterizer/grayscale_to_colormap.frag","webpack:///./src/core/src/shaders/hips/rasterizer/grayscale_to_colormap_i.frag","webpack:///./src/core/src/shaders/hips/rasterizer/mercator.vert","webpack:///./src/core/src/shaders/hips/rasterizer/mollweide.vert","webpack:///./src/core/src/shaders/hips/rasterizer/ortho.vert","webpack:///./src/core/src/shaders/hips/raytracer/color.frag","webpack:///./src/core/src/shaders/hips/raytracer/grayscale_to_color.frag","webpack:///./src/core/src/shaders/hips/raytracer/grayscale_to_color_i.frag","webpack:///./src/core/src/shaders/hips/raytracer/grayscale_to_colormap.frag","webpack:///./src/core/src/shaders/hips/raytracer/grayscale_to_colormap_i.frag","webpack:///./src/core/src/shaders/hips/raytracer/raytracer.vert","webpack:///./src/core/src/shaders/misc/text.frag","webpack:///./src/core/src/shaders/misc/text.vert","webpack:///./src/js/Aladin.js","webpack:///./src/js/AladinUtils.js","webpack:///./src/js/Catalog.js","webpack:///./src/js/Circle.js","webpack:///./src/js/Color.js","webpack:///./src/js/ColorMap.js","webpack:///./src/js/CooConversion.js","webpack:///./src/js/CooFrameEnum.js","webpack:///./src/js/DiscoveryTree.js","webpack:///./src/js/Downloader.js","webpack:///./src/js/Ellipse.js","webpack:///./src/js/Footprint.js","webpack:///./src/js/HealpixCache.js","webpack:///./src/js/HealpixGrid.js","webpack:///./src/js/HiPSDefinition.js","webpack:///./src/js/HpxImageSurvey.js","webpack:///./src/js/ImageSurveyLayer.js","webpack:///./src/js/Line.js","webpack:///./src/js/Location.js","webpack:///./src/js/Logger.js","webpack:///./src/js/MOC.js","webpack:///./src/js/MeasurementTable.js","webpack:///./src/js/Overlay.js","webpack:///./src/js/Polyline.js","webpack:///./src/js/Popup.js","webpack:///./src/js/ProgressiveCat.js","webpack:///./src/js/ProjectionEnum.js","webpack:///./src/js/Sesame.js","webpack:///./src/js/Shaders.js","webpack:///./src/js/SimbadPointer.js","webpack:///./src/js/Source.js","webpack:///./src/js/Tile.js","webpack:///./src/js/TileBuffer.js","webpack:///./src/js/URLBuilder.js","webpack:///./src/js/Utils.js","webpack:///./src/js/View.js","webpack:///./src/js/libs/RequestAnimationFrame.js","webpack:///./src/js/libs/Stats.js","webpack:///./src/js/libs/astro/astroMath.js","webpack:///./src/js/libs/astro/coo.js","webpack:///./src/js/libs/astro/projection.js","webpack:///./src/js/libs/fits.js","webpack:///./src/js/libs/healpix.js"],"names":[],"mappings":";QAAA;QACA;QACA;QACA;;;QAGA;QACA;QACA;QACA,QAAQ,oBAAoB;QAC5B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;;;QAGA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;;;;QAIA;QACA;QACA;QACA;;QAEA;QACA;;QAEA,6BAA6B,0BAA0B;;QAEvD;QACA;QACA;QACA;QACA;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA,OAAO;QACP;QACA;QACA;QACA;QACA;QACA,IAAI;QACJ;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI;QACJ;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;QACA;QACA;;;QAGA;;QAEA;QACA,iCAAiC;;QAEjC;QACA;QACA;QACA,KAAK;QACL;QACA;QACA;QACA,MAAM;QACN;;QAEA;QACA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,wBAAwB,kCAAkC;QAC1D,MAAM;QACN;QA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,0EAA0E,8DAAY;AACjI,+BAA+B,8DAAY,4EAA4E,8DAAY;AACnI,+BAA+B,8DAAY;AAC3C;AACA;AACA;AACA;;;AAGA;AACA;AACA,uJAAuJ;AACvJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;;;;;AAMT;AACA;;;AAGA;AACA;;AAEA;AACA,oCAAoC,sEAAgB;;;;AAIpD,2BAA2B,sDAAQ;;AAEnC;AACA,wBAAwB,6CAAI;AAC5B;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iCAAiC,kBAAkB,qBAAqB,cAAc,EAAE;;AAExF;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,aAAa;AACb,gEAAgE,kBAAkB,cAAc,EAAE;AAClG;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,6CAAI;AACtC,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,iEAAiE,kBAAkB,cAAc,EAAE;AACnG;;;AAGA,oDAAoD,sBAAsB;;AAE1E;AACA;AACA;AACA,YAAY,iDAAM;AAClB;;AAEA;;AAEA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;;AAEb;AACA;;;AAGA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B;AAC/B,SAAS;;;;AAIT,uCAAuC;;AAEvC;AACA;AACA;AACA,qCAAqC,gEAAa;AAClD;;AAEA;;AAEA;AACA;AACA;AACA,2CAA2C,oDAAoD,EAAE;AACjG;AACA;;AAEA;AACA,uBAAuB,2BAA2B,EAAE;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAY;AAC1C;AACA;AACA;AACA,iCAAiC,kEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA;;AAEA,mBAAmB,+CAAK;AACxB;AACA,oCAAoC;AACpC;;AAEA;AACA,oCAAoC,+CAAK,+DAA+D;AACxG,2BAA2B,+CAAK;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,8DAAY,uBAAuB,8DAAY;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,0BAA0B,uDAAG;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAM;AAClB,iCAAiC;AACjC;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAY;AAC9C,oBAAoB,gEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,qBAAqB,EAAE;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gCAAgC,yBAAyB,EAAE;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,6BAA6B,kEAAc;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,kEAAc;AACjC;;AAEA;AACA,mBAAmB,mDAAO;AAC1B;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,6CAAI;AAClC;AACA;AACA,8BAA8B,6CAAI;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D;AAC3D,qCAAqC;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA,qEAAqE;;;AAGrE;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,2DAAW;AACrC;AACA;AACA;;AAEA,0BAA0B,2DAAW;AACrC;AACA;AACA,0BAA0B,2DAAW;AACrC;;AAEA,mFAAmF;AACnF,6BAA6B,gDAAK;;AAElC;AACA;AACA,yGAAyG,2BAA2B;AACpI,yMAAyM,0BAA0B;AACnO;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,6DAA6D,kBAAkB,cAAc,EAAE;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;;;AAIb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,8DAAY;AAC9C,yBAAyB,gEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,eAAe,kDAAM;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,kEAAc;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAS;AACxB;;AAEA;AACA;AACA,eAAe,qDAAQ;AACvB;;;AAGA;AACA;AACA,eAAe,iDAAM;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAO;AACtB;;AAEA;AACA;AACA,eAAe,mDAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAgB;AAC/B;;AAEA;AACA;AACA,eAAe,oDAAO;AACtB;;AAEA;AACA;AACA,eAAe,kEAAc;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qEAAqE;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAG;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAG;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA,qDAAqD,qGAAqG,EAAE;AAC5J;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mDAAO;;AAE5B;AACA;;AAEA;AACA;AACA,kBAAkB,2CAAG;AACrB;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,2CAAG;AACrB;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI,oDAAO;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0DAAU;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAU;AAC5B;AACA;AACA,0BAA0B,uDAAG;AAC7B;AACA,kBAAkB,0DAAU;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0DAAU;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0DAAU;AACxB;AACA;;AAEA;AACA,IAAI,kEAAc;AAClB;;;AAGA,sBAAsB,6LAA2B,EAAE,mKAAqB;AACxE;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;;;;;;;;;;;;;ACz1DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACP;;AAE1C;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,wBAAwB;AACxB;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,yBAAyB;AACnD;;AAEA,0BAA0B,KAAK;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;;;;;;;;;AC1PD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;AACF;AACiB;AACF;AACd;AACY;AACL;;AAE1C;AACO;;AAEP;AACA;;AAEA,8BAA8B;AAC9B,mCAAmC,+CAAK;AACxC;AACA;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD,sDAAsD;;AAEtD,+BAA+B;AAC/B;AACA,uBAAuB,6DAAY;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,gDAAgD,OAAO;AACvD;AACA,wBAAwB,+CAAK,2CAA2C;AACxE;AACA;AACA,qB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,gDAAgD,OAAO;AACvD;AACA,wBAAwB,+CAAK,6CAA6C;AAC1E;AACA;AACA,qB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA,0BAA0B,sDAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA,mBAAmB,+CAAK,6BAA6B,+CAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAM;AACtC;AACA,gCAAgC;AAChC;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA,mBAAmB,+CAAK;AACxB;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,iDAAiD,+CAAK;AACtD;AACA;;AAEA;;AAEA,wF;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;;;AAGA;AACA,sBAAsB,sDAAG;AACzB;AACA,2BAA2B,sBAAsB;AACjD;AACA,gBAAgB,+CAAK,8BAA8B,+CAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC/oBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;AACY;AACE;AACZ;;AAErC;AACO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B,+CAAK;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH;AACtH,2BAA2B,2DAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,M;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACpND;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;AAGP;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC5ED;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;AAExC;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,gCAAgC,2DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC9QD;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIO;;AAEP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6D;;AAEA,oE;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC3ED;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP,mBAAmB;AACnB;AACA;;AAEA,gBAAgB,sCAAsC;AACtD,iBAAiB,uCAAuC;AACxD,eAAe,uCAAuC;;AAEtD;AACA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;;;;;;AC9DD;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC/HD;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA,2BAA2B;;;AAG3B;AACA,mBAAmB;AACnB,uBAAuB;AACvB,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA,CAAC;;;;;;;;;;;;;AC5HD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;AACY;AACE;AACZ;;AAErC;AACO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B,+CAAK;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,2DAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,2DAAW;AAC1C,gCAAgC,2DAAW;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,M;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC7OD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;AAE5B;AACP;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,+CAAK;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AClHD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEmD;;AAE5C;;AAEP;;AAEA,gCAAgC,UAAU;AAC1C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,sBAAsB,6DAAY;AAClC;AACA,gBAAgB,6DAAY;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,6DAAY;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;ACpFD;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA,CAAC;;;;;;;;;;;;;ACvED;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;AAE5B;;AAEP;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iIAAiI;AACjI,kIAAkI;;AAElI;AACA;AACA;AACA,gCAAgC,kCAAkC;;AAElE;AACA;;AAEA,mBAAmB,+CAAK;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,+CAAK,wBAAwB,iFAAiF;AACtH;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,4DAA4D;AACzG;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,+CAAK;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,+CAAK;AAChC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,aAAa;AACb;;AAEA;AACA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA,CAAC;;;;;;;;;;;;;;AChnBD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACiB;;AAE7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,+CAAK;;AAE3B;AACA,gBAAgB,+CAAK;AACrB;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAc;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC/ND;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACkB;;AAE9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,iEAAc;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,I;;;;;;;;;;;;AChED;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,I;;;;;;;;;;;;ACrFD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGqD;AACF;;AAE5C;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,sDAAG;AACzB,wBAAwB,6DAAY;AACpC;AACA;AACA,6BAA6B,6DAAY;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC1DD;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,6HAA6H;AAChJ;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACX;AACU;AACA;AACZ;AACc;AACJ;AACI;;;AAG9C;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB,4BAA4B;AAC5B,8BAA8B;;AAE9B;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iDAAM;AAC/C,4BAA4B,mDAAK;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;;;;AAIA;AACA;;AAEA,aAAa;AACb,wBAAwB;;AAExB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,YAAY,mDAAK;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE,6DAAY;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;;AAEA;AACA,4EAA4E,6DAAY;AACxF;AACA;AACA,qBAAqB,yCAAyC;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;;AAEA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,iDAAM;;AAE5B;AACA;AACA,qBAAqB,KAAK;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,qBAAqB,KAAK;AAC1B;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,iEAAc,+BAA+B,iEAAc;AAC9F;AACA;AACA;AACA;AACA,iBAAiB,2DAAW;AAC5B,iBAAiB,2DAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;;AAEA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA,yB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA,iB;AACA;AACA;;AAEA;AACA;;;;AAIA;;AAEA,CAAC;;;;;;;;;;;;;;;ACvhBD;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;AAGP;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,CAAC;;;;;;;;;;;;;;ACrED;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;AACJ;AACM;AAChB;;AAE1B;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,uDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,wBAAwB,cAAc;AACtC,+BAA+B,6CAAI;AACnC;AACA;AACA,iB;AACA;AACA;;AAEA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC9SD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;AACd;;AAE1B;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;;;AAGA,qBAAqB;AACrB;AACA,oBAAoB,4BAA4B;AAChD;AACA,wBAAwB,cAAc;AACtC,+BAA+B,6CAAI;AACnC;AACA;AACA,iB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC,I;;;;;;;;;;;;AC5ID;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;AAGP;AACA;AACA,wHAAwH;AACxH;;AAEA;;;AAGA;AACA;AACA,8DAA8D,aAAa;;AAE3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC1FD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAwC;AACxC,CAAsC;AACtC,CAAoC;AACpC,CAA2C;AAC3C,CAAoC;AACpC,CAAkD;;AAElD;AACA;AACO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+BAA+B;AAC/B;AACA,YAAY,+CAAK;AACjB;AACA;;AAEA;AACA,qBAAqB,6DAAY,yBAAyB,6DAAY;AACtE;AACA,8BAA8B;;AAE9B;AACA,sCAAsC,+CAAK;AAC3C;AACA;AACA;AACA,wCAAwC;;AAExC;AACA,oDAAoD;;;AAGpD,oDAAoD;;;;AAIpD;AACA,gCAAgC,+CAAK;;AAErC;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa;AACb,kCAAkC;AAClC;AACA;AACA,SAAS;;;;;;AAMT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sBAAsB,sDAAG;AACzB;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA,gBAAgB,+CAAK,sCAAsC,+CAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAM;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAY;;AAEjD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;;AAET,qBAAqB,mDAAO;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;;AAEb,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA,oBAAoB,mDAAO;AAC3B;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAO;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;;;AAIT;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;;AAEA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;;AAEA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,2BAA2B;AACpD;AACA,wCAAwC;AACxC;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,SAAS;;AAET,kCAAkC;AAClC;AACA;;;AAGA,MAAM;;;AAGN;AACA,CAAC;;;;;;;;;;;;;;AC7hBD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAyD;;AAEzD,CAAQ;AACR,SAAS,oEAAU;AACnB,aAAa,oEAAU;AACvB,eAAe,oEAAU;AACzB,UAAU,oEAAU;AACpB,UAAU,oEAAU;AACpB,SAAS,oEAAU;AACnB;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;AAE5B;AACP;;AAEA;;AAEA;;AAEA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iCAAiC;AACjC,kEAAkE;AAClE,oBAAoB;;AAEpB,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,+CAAK;AACjB;AACA;;;AAGA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA,CAAC;;;;;;;;;;;;;;ACpGD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACuE;AACE;AACR;AACA;AACO;AACH;AACA;AACH;;AAElE;AACoE;AACY;AACM;AACJ;AACA;AACI;AACT;;AAE7E;AACuD;AACQ;AACC;AACH;AACM;AACV;AACA;AACM;AACA;;AAE/D;AACA;AAC2E;AACC;AACuB;AACM;AACG;AACM;;AAElH;AAC8E;AACM;AACJ;AACI;AACV;AACO;AACH;AACuB;AACM;AACG;AACM;AACpH;AACuD;AACA;;AAEvD;AACA;AACA;AACA;AACA,iBAAiB,6EAAe;AAChC,KAAK;AACL;AACA;AACA,iBAAiB,+EAAe;AAChC,KAAK;AACL;AACA;AACA,iBAAiB,0EAAY;AAC7B,KAAK;AACL;AACA;AACA,iBAAiB,0EAAY;AAC7B,KAAK;AACL;AACA;AACA,iBAAiB,gFAAa;AAC9B,KAAK;AACL;AACA;AACA,iBAAiB,4EAAc;AAC/B,KAAK;AACL;AACA;AACA,iBAAiB,4EAAc;AAC/B,KAAK;AACL;AACA;AACA,iBAAiB,8EAAS;AAC1B,KAAK;AACL;AACA;AACA;AACA,iBAAiB,gFAAU;AAC3B,KAAK;AACL;AACA;AACA,iBAAiB,kFAAoB;AACrC,KAAK;AACL;AACA;AACA,iBAAiB,sFAAuB;AACxC,KAAK;AACL;AACA;AACA,iBAAiB,oFAAqB;AACtC,KAAK;AACL;AACA;AACA,iBAAiB,oFAAqB;AACtC,KAAK;AACL;AACA;AACA,iBAAiB,sFAAuB;AACxC,KAAK;AACL;AACA;AACA,iBAAiB,4EAAwB;AACzC,KAAK;AACL;AACA;AACA;AACA,iBAAiB,wEAAM;AACvB,KAAK;AACL;AACA;AACA,iBAAiB,0EAAY;AAC7B,KAAK;AACL;AACA;AACA,iBAAiB,6EAAU;AAC3B,KAAK;AACL;AACA;AACA,iBAAiB,yEAAW;AAC5B,KAAK;AACL;AACA;AACA,iBAAiB,4EAAc;AAC/B,KAAK;AACL;AACA;AACA,iBAAiB,uEAAS;AAC1B,KAAK;AACL;AACA;AACA,iBAAiB,uEAAS;AAC1B,KAAK;AACL;AACA;AACA,iBAAiB,4EAAU;AAC3B,KAAK;AACL;AACA;AACA,iBAAiB,4EAAU;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB,uFAAW;AAC5B,KAAK;AACL;AACA;AACA,iBAAiB,mFAAgB;AACjC,KAAK;AACL;AACA;AACA,iBAAiB,gGAA0B;AAC3C,KAAK;AACL;AACA;AACA,iBAAiB,mGAA6B;AAC9C,KAAK;AACL;AACA;AACA,iBAAiB,kGAAiC;AAClD,KAAK;AACL;AACA;AACA,iBAAiB,qGAAoC;AACrD,KAAK;AACL;AACA;AACA;AACA,iBAAiB,oFAAiB;AAClC,KAAK;AACL;AACA;AACA,iBAAiB,uFAAoB;AACrC,KAAK;AACL;AACA;AACA,iBAAiB,qFAAkB;AACnC,KAAK;AACL;AACA;AACA,iBAAiB,kFAAe;AAChC,KAAK;AACL;AACA;AACA,iBAAiB,uFAAoB;AACrC,KAAK;AACL;AACA;AACA,iBAAiB,wFAAgB;AACjC,KAAK;AACL;AACA;AACA,iBAAiB,oFAAiB;AAClC,KAAK;AACL;AACA;AACA,iBAAiB,iGAA2B;AAC5C,KAAK;AACL;AACA;AACA,iBAAiB,oGAA8B;AAC/C,KAAK;AACL;AACA;AACA,iBAAiB,mGAAkC;AACnD,KAAK;AACL;AACA;AACA,iBAAiB,sGAAqC;AACtD,KAAK;AACL;AACA;AACA;AACA,iBAAiB,wEAAM;AACvB,KAAK;AACL;AACA;AACA,iBAAiB,wEAAM;AACvB,KAAK;AACL;;AAEO;AACP;AACA;;;;;;;;;;;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA,8JAA8J;;;AAG9J;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iFAAiF;;AAEvI;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC7ED;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AClID;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA,CAAC;;;;;;;;;;;;;ACzED;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAkC;;AAE3B;AACP,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA,eAAe,gBAAgB;AAC/B,4BAA4B,6CAAI;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC3ED;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACP;AAC5B,8B;;AAEP;AACA;AACA;AACA;AACA,kCAAkC,sDAAG;AACrC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,kCAAkC,sDAAG;;AAErC;AACA;AACA;;AAEA;AACA,8DAA8D,+CAAK;AACnE;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA,CAAC;;;;;;;;;;;;;;AC5FD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;AAE9B;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,qEAAqE;AACrE;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;AASA;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,iDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,E;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;AC7TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACK;AACM;AACG;AACA;AACO;AACP;AACH;AACC;AACA;AACA;AACP;AACQ;AACH;AACA;AACA;AACR;AACE;AACN;AACY;AACE;AACgB;AACxB;AAC3C;AAC4C;AACa;;AAElD;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAK;;AAElC;AACA;AACA;AACA,0BAA0B,gEAAW;AACrC;;AAEA;AACA;AACA,0BAA0B,6DAAM;AAChC;AACA,uCAAuC,iDAAM;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;;AAEA,mCAAmC,2DAAW;;;AAG9C;AACA;;AAEA,oCAAoC,iEAAc;AAClD,kCAAkC,oEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,oBAAoB;;AAEnD;AACA;AACA,aAAa;AACb,gCAAgC,8DAAY;AAC5C;AACA,oCAAoC,8DAAY;AAChD;AACA,4BAA4B,iDAAM;AAClC;AACA,aAAa;AACb,kCAAkC,iDAAM;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE,gDAAgD,+CAA+C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA,kCAAkC,0DAAU,GAAG;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,0DAAU,OAAO;AACnD;;AAEA;;AAEA;;AAEA,kCAAkC;;AAElC;;;AAGA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+BAA+B;AACzF,aAAa;;;AAGb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,0CAA0C;;;AAG1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,gDAAK;;AAEb;AACA;;AAEA;AACA,kDAAkD;;;AAGlD;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,yBAAyB;AACzB,SAAS;;AAET;AACA,2EAA2E;AAC3E;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yCAAyC;AACnF;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,4H;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;;;;AAIA;AACA,0CAA0C;AAC1C;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,gBAAgB,gEAAa;;AAE7B,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,wDAAS,iBAAiB,kDAAM;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,wDAAS;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6EAA6E;AAClH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAoD;AACjG;AACA;AACA;AACA,6CAA6C,gDAAgD;AAC7F;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,sBAAsB;AACtB,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,SAAS,EAAE;;AAEX;AACA,uDAAuD,cAAc;;AAErE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,gDAAK,sBAAsB,+BAA+B;AACvG;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,wBAAwB,qDAAK;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,yCAAyC,gDAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0EAA0E,iCAAiC;;AAE3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,qDAAqD,iDAAM;AAC3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,sDAAQ;AACxB,gBAAgB,sDAAQ;AACxB,gBAAgB,sDAAQ;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,wFAAgB;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,kD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;;AAGT;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;;;AAIT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,S;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,6DAAY;AAC/B;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA,6BAA6B,6DAAY;AACzC;AACA,oCAAoC,8DAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,wBAAwB,6DAAY;AACpC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,wBAAwB,8DAAa;AACrC,wCAAwC;AACxC,mBAAmB,6DAAY;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA,6BAA6B,6DAAY;AACzC;AACA,oCAAoC,8DAAa;AACjD;AACA,qBAAqB,2DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAY;AACpD,6BAA6B,gEAAa,wC;AAC1C;AACA,6CAA6C,8DAAY;AACzD,6BAA6B,gEAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,wBAAwB,6DAAY;AACpC;AACA;AACA;;;AAGA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA,gD;AACA;AACA;AACA;AACA,sBAAsB,6DAAY;;AAElC,yBAAyB,KAAK;AAC9B;;AAEA;AACA;AACA,8CAA8C,8DAAY;AAC1D,oCAAoC,gEAAa,4C;AACjD;AACA;AACA;AACA,mDAAmD,8DAAY;AAC/D,oCAAoC,gEAAa,4C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,4CAA4C,iEAAc,oCAAoC,iEAAc;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,qBAAqB,2DAAW;AAChC,qBAAqB,2DAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,8DAAa;AACrC,wCAAwC;;;AAGxC,+BAA+B;AAC/B,sBAAsB,6DAAY;;AAElC,qBAAqB,KAAK;AAC1B;;AAEA;AACA;AACA,wDAAwD,8DAAY;AACpE,gCAAgC,gEAAa,4C;AAC7C;AACA;AACA;AACA,6DAA6D,8DAAY;AACzE,gCAAgC,gEAAa,4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,KAAK;AAC5B;AACA,SAAS;;AAET;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,mDAAmD;AACnD,iDAAiD;AACjD,SAAS;AACT,iDAAiD;AACjD,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,2BAA2B;AAC3B,oBAAoB,6DAAY,0CAA0C;AAC1E;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAY;AAC/B,qBAAqB,6DAAY;AACjC;AACA,0BAA0B,6DAAY;AACtC,4BAA4B,6DAAY;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,EAAE;AACX;AACA;AACA;;AAEA,sCAAsC,iEAAc;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,iEAAc;AACtD;AACA;AACA,wCAAwC,iEAAc;AACtD;AACA;AACA,wCAAwC,iEAAc;AACtD;AACA;AACA,wCAAwC,iEAAc;AACtD;AACA;AACA,wCAAwC,iEAAc;AACtD;AACA;AACA;AACA,wCAAwC,iEAAc;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAY;AAChD,qBAAqB,gEAAa;AAClC;AACA,wC;;AAEA,wBAAwB,iDAAM;AAC9B;AACA;AACA,yCAAyC,8DAAY;AACrD,wBAAwB,gEAAa;AACrC;AACA;;AAEA,8BAA8B,iDAAM;AACpC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iB;AACA,a;AACA,S;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,wBAAwB;AACjD;AACA,6BAA6B,2BAA2B;;AAExD;AACA;AACA;AACA,gCAAgC,4BAA4B;;AAE5D;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,iCAAiC,2DAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,gCAAgC,oBAAoB;;AAEpD,wCAAwC;AACxC,+DAA+D;AAC/D,mEAAmE;AACnE,wDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,gCAAgC;AAC7D,4DAA4D,kDAAM;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACjsED;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACpBD;AAAA;AAAA;AACO,qBAAqB,kBAAkB,UAAU,QAAQ,KAAK,YAAY,KAAK,yDAAyD,QAAQ,KAAK,4HAA4H,wHAAwH,KAAK,IAAI,eAAe,KAAK,iBAAiB,KAAK,IAAI,eAAe,KAAK,eAAe,KAAK,IAAI;AACnf,KAAK,KAAK,mBAAmB,gCAAgC,yBAAyB,qBAAqB,sBAAsB,uBAAuB,sCAAsC,IAAI,YAAY,uBAAuB,uBAAuB,uBAAuB,UAAU,+BAA+B,MAAM,+BAA+B,MAAM,gCAAgC,KAAK,gCAAgC;AAC5a,oCAAoC,kCAAkC,iBAAiB,gCAAgC,kDAAkD,yBAAyB,uBAAuB,kEAAkE,iCAAiC,wDAAwD,iBAAiB,mCAAmC,WAAW,YAAY,wBAAwB,yBAAyB;AAChf,qBAAqB,gEAAgE,iCAAiC,uCAAuC,gCAAgC,mHAAmH,kCAAkC,uBAAuB,iBAAiB,gCAAgC,kDAAkD,yBAAyB;AACre,MAAM,+DAA+D,iCAAiC,uDAAuD,iBAAiB,mCAAmC,WAAW,YAAY,wBAAwB,yBAAyB,iBAAiB,qBAAqB,6DAA6D,iCAAiC,uCAAuC,IAAI;AACxc,MAAM,UAAU,gCAAgC,mHAAmH,kCAAkC,uBAAuB,iBAAiB,gCAAgC,kDAAkD,yBAAyB,uBAAuB,+DAA+D,iCAAiC;AAC/c,iBAAiB,mCAAmC,WAAW,YAAY,wBAAwB,yBAAyB,iBAAiB,qBAAqB,sBAAsB,iCAAiC,uCAAuC,OAAO,+BAA+B,IAAI,uBAAuB,MAAM,gBAAgB,gBAAgB,wCAAwC,2EAA2E,sBAAsB,IAAI;AACpf,OAAO,0BAA0B,gBAAgB,gBAAgB,yCAAyC,4EAA4E,sBAAsB,4PAA4P,IAAI;;;;;;;;;;;;;;ACR5c;AAAA;AAAA;AACA;AACA;;AAEA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAsC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;;AAElE;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;;AAElE;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,W;AACA;AACA,EAAE;AACF,uBAAuB;AACvB;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AChSA;AAAA;AAAA;AAAA;AACA;AACA;;AAE2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,eAAe,uDAAS;;AAExB,kBAAkB,uDAAS;AAC3B,kBAAkB,uDAAS;AAC3B,WAAW,uDAAS,gB;AACpB,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH,cAAc,uDAAS;AACvB,cAAc,uDAAS;AACvB;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAS;AAC5B,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA,8BAA8B;AAC9B,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,aAAa,YAAY;AACzB;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,aAAa,YAAY;AACzB;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC,mCAAmC;AACnC;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,sB;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wB;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,sBAAsB;AACtB,2BAA2B;AAC3B,mCAAmC;AACnC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,sBAAsB;AACtB,2BAA2B;AAC3B;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClc2C;;AAEpC;AACP;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;;;AAGvC,wBAAwB;AACxB,yBAAyB;AACzB,wB;AACA,wBAAwB;AACxB,yBAAyB;AACzB,wBAAwB;AACxB,wBAAwB;AACxB,4BAA4B;AAC5B,2BAA2B;AAC3B,wBAAwB;AACxB,wBAAwB;AACxB;AACA,wB;AACA,wBAAwB;AACxB,4B;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,oCAAoC;AACpC,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA,cAAc;AACd;AACA,kBAAkB;AAClB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,qCAAqC;AACrC,yBAAyB;;AAEzB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA,MAAM,uDAAS,YAAY;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA,qC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,uDAAS;AAClB;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,SAAS,uDAAS;AAClB,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC;AAChC;AACA;AACA;AACA,QAAQ,uDAAS,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,QAAQ,uDAAS;AACjB,YAAY,uDAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,uDAAS;AACjB;AACA;AACA;AACA,QAAQ,uDAAS;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAS;AACtB,aAAa,uDAAS;AACtB,aAAa,uDAAS;AACtB,cAAc,uDAAS;AACvB;AACA,+B;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAS;;AAExB,kBAAkB,uDAAS;AAC3B,kBAAkB,uDAAS;AAC3B,SAAS,uDAAS;;AAElB;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc,c;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,SAAS,uDAAS;AAClB,SAAS,uDAAS;AAClB;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACndA;AAAA;AAAO;;AAEP;;AAEA;AACA,kBAAkB;AAClB,yCAAyC,0BAA0B,2DAA2D,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc,EAAE;AACnS;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qCAAqC;AAC9E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAwC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,6CAA6C,qCAAqC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,qCAAqC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,EAAE;AACzD;AACA,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wCAAwC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC;;;;;;;;;;;;;ACxrDD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAS;;AAET;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,4CAA4C;;AAE5E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,sCAAsC;;;;AAItC;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,+BAA+B;;;AAG/B,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,QAAQ;AAClC;AACA,oBAAoB;AACpB;AACA,IAAI;AACJ,oBAAoB;AACpB;AACA,KAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,kCAAkC;AAClC;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;;;;AAIA;AACA,gBAAgB;AAChB;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA,IAAI;AACJ;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;;AAErB,wBAAwB;AACxB;AACA;AACA;AACA,GAAG,0BAA0B;AAC7B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B;;AAE1B,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,mBAAmB,OAAO;AAC1B,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH,wCAAwC;AACxC;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,GAAG;AACH,kDAAkD;AAClD;AACA;AACA,0DAA0D;AAC1D,IAAI,OAAO;AACX;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iDAAiD;AACjD;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,kBAAkB,WAAW,OAAO;AACpC;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B,yBAAyB;AACzB;AACA,IAAI,6BAA6B;AACjC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA,+BAA+B;AAC/B,4BAA4B;AAC5B;;AAEA,4DAA4D;AAC5D;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C,4BAA4B;AAC5B,2CAA2C;AAC3C;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,IAAI,OAAO;AACX;;AAEA,0CAA0C;AAC1C,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,oBAAoB;AACpB,yBAAyB;AACzB;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ;AACR;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,I","file":"aladin.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"main\": 0\n \t};\n\n\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + chunkId + \".aladin.js\"\n \t}\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \tfunction promiseResolve() { return Promise.resolve(); }\n\n \tvar wasmImportObjects = {\n \t\t\"./src/core/pkg/index_bg.wasm\": function() {\n \t\t\treturn {\n \t\t\t\t\"./index_bg.js\": {\n \t\t\t\t\t\"__wbindgen_json_serialize\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_json_serialize\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_object_drop_ref\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_object_drop_ref\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_canvas_dd578e51a2bc736f\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_canvas_dd578e51a2bc736f\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_instanceof_HtmlCanvasElement_c9f334afe4eed430\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_instanceof_HtmlCanvasElement_c9f334afe4eed430\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setwidth_41b2497107faaff7\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setwidth_41b2497107faaff7\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setheight_e15cb9243262e701\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setheight_e15cb9243262e701\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_viewport_86b156d5858adab9\": function(p0i32,p1i32,p2i32,p3i32,p4i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_viewport_86b156d5858adab9\"](p0i32,p1i32,p2i32,p3i32,p4i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_scissor_1f78ef0050a93516\": function(p0i32,p1i32,p2i32,p3i32,p4i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_scissor_1f78ef0050a93516\"](p0i32,p1i32,p2i32,p3i32,p4i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_string_new\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_string_new\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_memory\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_memory\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_buffer_e35e010c3ba9f945\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_buffer_e35e010c3ba9f945\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_fe24eae01e10f223\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_fe24eae01e10f223\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_subarray_3c6f7cfb4edcc351\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_subarray_3c6f7cfb4edcc351\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_measureText_2a4b2ca71061d96c\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_measureText_2a4b2ca71061d96c\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_width_979b596f39ba8319\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_width_979b596f39ba8319\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_bindVertexArray_520c05423d3d6641\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_bindVertexArray_520c05423d3d6641\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_bindBuffer_4a7874f09df12419\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_bindBuffer_4a7874f09df12419\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_bufferSubData_51f29e78449b2095\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_bufferSubData_51f29e78449b2095\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_bufferData_80963d2bd1ecb1bc\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_bufferData_80963d2bd1ecb1bc\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_performance_800ff37c906b5f3b\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_performance_800ff37c906b5f3b\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_now_9f22124bc74da886\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_now_9f22124bc74da886\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_activeTexture_32edab6336bd38a9\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_activeTexture_32edab6336bd38a9\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_bindTexture_d659843380f373b5\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_bindTexture_d659843380f373b5\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_texSubImage2D_e13399a16dfb0646\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32,p7i32,p8i32,p9i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_texSubImage2D_e13399a16dfb0646\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32,p7i32,p8i32,p9i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_blendFuncSeparate_13c318610edadb4a\": function(p0i32,p1i32,p2i32,p3i32,p4i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_blendFuncSeparate_13c318610edadb4a\"](p0i32,p1i32,p2i32,p3i32,p4i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_enable_65590f4951fd0112\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_enable_65590f4951fd0112\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_cullFace_b0941c23a53ee9fc\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_cullFace_b0941c23a53ee9fc\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_innerWidth_aab6ec3242dff39e\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_innerWidth_aab6ec3242dff39e\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_number_get\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_number_get\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_innerHeight_7e514d9823f7864e\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_innerHeight_7e514d9823f7864e\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_17bf587bb9ce55f1\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_17bf587bb9ce55f1\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setcrossOrigin_054bb95c5a2b2640\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setcrossOrigin_054bb95c5a2b2640\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_4f8fb2c75215d83a\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_4f8fb2c75215d83a\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setresponseType_09ae5e5481a8947d\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setresponseType_09ae5e5481a8947d\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_createTexture_8ba2e566eb313fcf\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_createTexture_8ba2e566eb313fcf\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_object_clone_ref\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_object_clone_ref\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setonload_69f9426b613d7bd2\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setonload_69f9426b613d7bd2\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setonerror_e519d2d2cbd89b1d\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setonerror_e519d2d2cbd89b1d\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setsrc_8742008d92b4e70e\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setsrc_8742008d92b4e70e\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_texParameteri_c0b2b665319f6a16\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_texParameteri_c0b2b665319f6a16\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_texImage2D_a5dad82b8f689bbd\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32,p7i32,p8i32,p9i32,p10i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_texImage2D_a5dad82b8f689bbd\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32,p7i32,p8i32,p9i32,p10i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_createFramebuffer_edeb035499d73077\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_createFramebuffer_edeb035499d73077\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_bindFramebuffer_abbc9985c473f160\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_bindFramebuffer_abbc9985c473f160\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_framebufferTexture2D_bb45b3c3d234ddcd\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_framebufferTexture2D_bb45b3c3d234ddcd\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_createVertexArray_5cbff3d8bbe1c324\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_createVertexArray_5cbff3d8bbe1c324\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_useProgram_b1cc885b00b8f52c\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_useProgram_b1cc885b00b8f52c\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_createBuffer_4302ddbcbfc99048\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_createBuffer_4302ddbcbfc99048\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_lineWidth_a2c6059f833032d4\": function(p0i32,p1f32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_lineWidth_a2c6059f833032d4\"](p0i32,p1f32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_vertexAttribPointer_3bb013e284cd07bf\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_vertexAttribPointer_3bb013e284cd07bf\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_enableVertexAttribArray_413ef49912a23f9e\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_enableVertexAttribArray_413ef49912a23f9e\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_document_d8cce4c1031c64eb\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_document_d8cce4c1031c64eb\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getElementsByClassName_a5ef560ae6918226\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getElementsByClassName_a5ef560ae6918226\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getwithindex_bcf1a04b716019a9\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getwithindex_bcf1a04b716019a9\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setAttribute_fb8737b4573a65f8\": function(p0i32,p1i32,p2i32,p3i32,p4i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setAttribute_fb8737b4573a65f8\"](p0i32,p1i32,p2i32,p3i32,p4i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getContext_d277f710e8035242\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getContext_d277f710e8035242\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_instanceof_CanvasRenderingContext2d_fbca10ed951560f3\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_instanceof_CanvasRenderingContext2d_fbca10ed951560f3\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_scale_e0fdce059098cd1b\": function(p0i32,p1f64,p2f64) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_scale_e0fdce059098cd1b\"](p0i32,p1f64,p2f64);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_texImage2D_bc294af8c1a6a435\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_texImage2D_bc294af8c1a6a435\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_log_a39f164b49616cb0\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_log_a39f164b49616cb0\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_0c7ac30665ee26f8\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_newwithbyteoffsetandlength_0c7ac30665ee26f8\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_c77df81d6c892c35\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_c77df81d6c892c35\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_836859e5deb44d3f\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_newwithbyteoffsetandlength_836859e5deb44d3f\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_139e70222494b1ff\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_139e70222494b1ff\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_c274c3296a37fcb4\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_newwithbyteoffsetandlength_c274c3296a37fcb4\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_5b74a8dd0c5b71ac\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_5b74a8dd0c5b71ac\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_vertexAttribDivisor_bf07aa5a1a9fc2d1\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_vertexAttribDivisor_bf07aa5a1a9fc2d1\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_deleteBuffer_988823f4e76e697d\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_deleteBuffer_988823f4e76e697d\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_createProgram_128698dd90ec070d\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_createProgram_128698dd90ec070d\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_attachShader_5d53b7b00823cafb\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_attachShader_5d53b7b00823cafb\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_linkProgram_370ed11b34456c89\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_linkProgram_370ed11b34456c89\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getProgramParameter_b949ba1d9662f6a2\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getProgramParameter_b949ba1d9662f6a2\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_boolean_get\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_boolean_get\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getProgramInfoLog_f8f65be65281f691\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getProgramInfoLog_f8f65be65281f691\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getActiveUniform_70b770a58f551f8f\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getActiveUniform_70b770a58f551f8f\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_name_4f3b7294acbeabad\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_name_4f3b7294acbeabad\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getUniformLocation_472b7459010900a5\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getUniformLocation_472b7459010900a5\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_createShader_26e4f959d5d64d80\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_createShader_26e4f959d5d64d80\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_shaderSource_96ace5133c032f2f\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_shaderSource_96ace5133c032f2f\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_compileShader_f7e245515fa1405d\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_compileShader_f7e245515fa1405d\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getShaderParameter_cced0ff8ba83f3e7\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getShaderParameter_cced0ff8ba83f3e7\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getShaderInfoLog_5412e8bc642139e8\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getShaderInfoLog_5412e8bc642139e8\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_clearColor_fc22409197a5bd68\": function(p0i32,p1f32,p2f32,p3f32,p4f32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_clearColor_fc22409197a5bd68\"](p0i32,p1f32,p2f32,p3f32,p4f32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_clear_25e035ed3961f1c6\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_clear_25e035ed3961f1c6\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_width_d9e3643c351ff015\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_width_d9e3643c351ff015\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_height_b92a879a29e66010\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_height_b92a879a29e66010\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform1f_fa50abe89ff891ea\": function(p0i32,p1i32,p2f32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform1f_fa50abe89ff891ea\"](p0i32,p1i32,p2f32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform2f_ab7c909be2949448\": function(p0i32,p1i32,p2f32,p3f32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform2f_ab7c909be2949448\"](p0i32,p1i32,p2f32,p3f32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_drawElementsInstanced_6a606cd25bdbafb3\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_drawElementsInstanced_6a606cd25bdbafb3\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_drawElements_c109bfea7998fd99\": function(p0i32,p1i32,p2i32,p3i32,p4i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_drawElements_c109bfea7998fd99\"](p0i32,p1i32,p2i32,p3i32,p4i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform4f_9941fe9c32da60ea\": function(p0i32,p1i32,p2f32,p3f32,p4f32,p5f32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform4f_9941fe9c32da60ea\"](p0i32,p1i32,p2f32,p3f32,p4f32,p5f32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_drawArrays_f6e7af9c06f4f4ae\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_drawArrays_f6e7af9c06f4f4ae\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform1i_a1e8f5ad954fa6b5\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform1i_a1e8f5ad954fa6b5\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_clearRect_620b55f817af6080\": function(p0i32,p1f64,p2f64,p3f64,p4f64) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_clearRect_620b55f817af6080\"](p0i32,p1f64,p2f64,p3f64,p4f64);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setfont_7d7b206c4c017729\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setfont_7d7b206c4c017729\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_settextAlign_0ab90671be8e1137\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_settextAlign_0ab90671be8e1137\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setfillStyle_1b068f8d99084158\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setfillStyle_1b068f8d99084158\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_save_be2f4340f20bfe6f\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_save_be2f4340f20bfe6f\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_translate_a603cdd310297ee8\": function(p0i32,p1f64,p2f64) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_translate_a603cdd310297ee8\"](p0i32,p1f64,p2f64);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_rotate_4ae42333a58388ed\": function(p0i32,p1f64) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_rotate_4ae42333a58388ed\"](p0i32,p1f64);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_fillText_aee0d6016521a3b2\": function(p0i32,p1i32,p2i32,p3f64,p4f64) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_fillText_aee0d6016521a3b2\"](p0i32,p1i32,p2i32,p3f64,p4f64);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_restore_e6861230b7a8a25e\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_restore_e6861230b7a8a25e\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_disable_827be6d0f77447e1\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_disable_827be6d0f77447e1\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_parse_b89e797098b3bc7b\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_parse_b89e797098b3bc7b\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getContext_a5ae0a2c4fe6f42b\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_getContext_a5ae0a2c4fe6f42b\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_instanceof_WebGl2RenderingContext_acac10ed74c696cb\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_instanceof_WebGl2RenderingContext_acac10ed74c696cb\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_cb_drop\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_cb_drop\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_json_parse\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_json_parse\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform1fv_7b33ccba8ca090e4\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform1fv_7b33ccba8ca090e4\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniformMatrix4fv_82825540b9315680\": function(p0i32,p1i32,p2i32,p3i32,p4i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniformMatrix4fv_82825540b9315680\"](p0i32,p1i32,p2i32,p3i32,p4i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform1iv_2c8af1d8286865f0\": function(p0i32,p1i32,p2i32,p3i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform1iv_2c8af1d8286865f0\"](p0i32,p1i32,p2i32,p3i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_uniform3f_a7c04d3d1c2b18aa\": function(p0i32,p1i32,p2f32,p3f32,p4f32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_uniform3f_a7c04d3d1c2b18aa\"](p0i32,p1i32,p2f32,p3f32,p4f32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_isArray_3320300beb1837ab\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_isArray_3320300beb1837ab\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_length_8f15bbb4ecbf7e33\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_length_8f15bbb4ecbf7e33\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_get_40375c2067f479fc\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_get_40375c2067f479fc\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_response_c70a68323728a385\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_response_c70a68323728a385\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_length_2cfa674c2a529bc1\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_length_2cfa674c2a529bc1\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_set_d771848e3c7935bb\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_set_d771848e3c7935bb\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_59cb74e423758ede\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_new_59cb74e423758ede\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_stack_558ba5917b466edd\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_stack_558ba5917b466edd\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_error_4bb6c2a97407129a\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_error_4bb6c2a97407129a\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_deleteVertexArray_3f37aabaae61ca26\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_deleteVertexArray_3f37aabaae61ca26\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_disableVertexAttribArray_1401ee870505cf02\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_disableVertexAttribArray_1401ee870505cf02\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_deleteTexture_cf22af6782ebc54f\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_deleteTexture_cf22af6782ebc54f\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_self_eeabd9085c04fc17\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_self_eeabd9085c04fc17\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_window_f110c13310da2c8f\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_window_f110c13310da2c8f\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_globalThis_a2669bee93faee43\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_globalThis_a2669bee93faee43\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_global_a5584d717f4d6761\": function() {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_global_a5584d717f4d6761\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_is_undefined\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_is_undefined\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newnoargs_179d393e4626fcf7\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_newnoargs_179d393e4626fcf7\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_call_8487a9f580e47219\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_call_8487a9f580e47219\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_a20c8edf0fedac40\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_newwithbyteoffsetandlength_a20c8edf0fedac40\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_7b9a415096aef9c1\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_newwithbyteoffsetandlength_7b9a415096aef9c1\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_debug_string\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_debug_string\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_blendFunc_8bd5998b54c12fd3\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_blendFunc_8bd5998b54c12fd3\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_open_c1608202d44b7d1c\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_open_c1608202d44b7d1c\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setonload_c71ccab98777e104\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setonload_c71ccab98777e104\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_setonerror_1bea8ceda68d0d63\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_setonerror_1bea8ceda68d0d63\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_send_3e459af287bba919\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_send_3e459af287bba919\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_texSubImage2D_43d09711529aa698\": function(p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32,p7i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_texSubImage2D_43d09711529aa698\"](p0i32,p1i32,p2i32,p3i32,p4i32,p5i32,p6i32,p7i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_throw\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_throw\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_rethrow\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_rethrow\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_instanceof_Window_fa4595281eb5ba83\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbg_instanceof_Window_fa4595281eb5ba83\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_closure_wrapper166\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_closure_wrapper166\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_closure_wrapper170\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[\"./src/core/pkg/index_bg.js\"].exports[\"__wbindgen_closure_wrapper170\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t};\n \t\t},\n \t\t\"./node_modules/@fxpineau/healpix/healpix_bg.wasm\": function() {\n \t\t\treturn {\n \t\t\t\t\"./healpix_bg.js\": {\n \t\t\t\t\t\"__wbindgen_throw\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[\"./node_modules/@fxpineau/healpix/healpix_bg.js\"].exports[\"__wbindgen_throw\"](p0i32,p1i32);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t};\n \t\t},\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n\n \t\t// Fetch + compile chunk loading for webassembly\n\n \t\tvar wasmModules = {\"1\":[\"./src/core/pkg/index_bg.wasm\"],\"2\":[\"./node_modules/@fxpineau/healpix/healpix_bg.wasm\"]}[chunkId] || [];\n\n \t\twasmModules.forEach(function(wasmModuleId) {\n \t\t\tvar installedWasmModuleData = installedWasmModules[wasmModuleId];\n\n \t\t\t// a Promise means \"currently loading\" or \"already loaded\".\n \t\t\tif(installedWasmModuleData)\n \t\t\t\tpromises.push(installedWasmModuleData);\n \t\t\telse {\n \t\t\t\tvar importObject = wasmImportObjects[wasmModuleId]();\n \t\t\t\tvar req = fetch(__webpack_require__.p + \"\" + {\"./src/core/pkg/index_bg.wasm\":\"491ab684e58b8267047e\",\"./node_modules/@fxpineau/healpix/healpix_bg.wasm\":\"4b971868181910368ee1\"}[wasmModuleId] + \".module.wasm\");\n \t\t\t\tvar promise;\n \t\t\t\tif(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\n \t\t\t\t\tpromise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\n \t\t\t\t\t\treturn WebAssembly.instantiate(items[0], items[1]);\n \t\t\t\t\t});\n \t\t\t\t} else if(typeof WebAssembly.instantiateStreaming === 'function') {\n \t\t\t\t\tpromise = WebAssembly.instantiateStreaming(req, importObject);\n \t\t\t\t} else {\n \t\t\t\t\tvar bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\n \t\t\t\t\tpromise = bytesPromise.then(function(bytes) {\n \t\t\t\t\t\treturn WebAssembly.instantiate(bytes, importObject);\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t\tpromises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\n \t\t\t\t\treturn __webpack_require__.w[wasmModuleId] = (res.instance || res).exports;\n \t\t\t\t}));\n \t\t\t}\n \t\t});\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// object with all WebAssembly.instance exports\n \t__webpack_require__.w = {};\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/Aladin.js\");\n","export default __webpack_public_path__ + \"ccdb93d24585bd08a4261722b95e9e3d.png\";","module.exports = \"#version 300 es\\nprecision lowp float;\\nlayout (location = 0) in vec2 offset;\\nlayout (location = 1) in vec2 uv;\\n\\nlayout (location = 2) in vec3 center;\\nlayout (location = 3) in vec2 center_lonlat;\\n\\nuniform float current_time;\\nuniform mat4 model;\\nuniform mat4 inv_model;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\nuniform vec2 kernel_size;\\n\\nout vec2 out_uv;\\nout vec3 out_p;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\\n    p = check_inversed_longitude(p);\\n\\n    vec2 center_pos_clip_space = world2clip_aitoff(p);\\n\\n    vec2 pos_clip_space = center_pos_clip_space;\\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\\n\\n    out_uv = uv;\\n    out_p = p;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nlayout (location = 0) in vec2 offset;\\nlayout (location = 1) in vec2 uv;\\n\\nlayout (location = 2) in vec3 center;\\nlayout (location = 3) in vec2 center_lonlat;\\n\\nuniform float current_time;\\nuniform mat4 inv_model;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\nuniform vec2 kernel_size;\\n\\nout vec2 out_uv;\\nout vec3 out_p;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\\n    p = check_inversed_longitude(p);\\n\\n    vec2 center_pos_clip_space = world2clip_arc(p);\\n\\n    vec2 pos_clip_space = center_pos_clip_space;\\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\\n\\n    out_uv = uv;\\n    out_p = p;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nin vec3 out_p;\\n\\nout vec4 color;\\n\\nuniform sampler2D kernel_texture;\\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\\nuniform float fov;\\nuniform float strength;\\nvoid main() {\\n    color = texture(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\\n    color.r *= strength;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nlayout (location = 0) in vec2 offset;\\nlayout (location = 1) in vec2 uv;\\n\\nlayout (location = 2) in vec3 center;\\nlayout (location = 3) in vec2 center_lonlat;\\n\\nuniform float current_time;\\nuniform mat4 inv_model;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\nuniform vec2 kernel_size;\\n\\nout vec2 out_uv;\\nout vec3 out_p;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\\n    p = check_inversed_longitude(p);\\n\\n    vec2 center_pos_clip_space = world2clip_mercator(p);\\n\\n    vec2 pos_clip_space = center_pos_clip_space;\\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\\n\\n    out_uv = uv;\\n    out_p = p;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nlayout (location = 0) in vec2 offset;\\nlayout (location = 1) in vec2 uv;\\n\\nlayout (location = 2) in vec3 center;\\nlayout (location = 3) in vec2 center_lonlat;\\n\\nuniform float current_time;\\nuniform mat4 inv_model;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\nuniform vec2 kernel_size;\\n\\nout vec2 out_uv;\\nout vec3 out_p;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\\n    p = check_inversed_longitude(p);\\n\\n    vec2 center_pos_clip_space = world2clip_mollweide(p);\\n\\n    vec2 pos_clip_space = center_pos_clip_space;\\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\\n\\n    out_uv = uv;\\n    out_p = p;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nin vec3 out_p;\\n\\nout vec4 color;\\n\\nuniform sampler2D kernel_texture;\\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\\nuniform float fov;\\nuniform float strength;\\nvoid main() {\\n    if (out_p.z < 0.f) {\\n        discard;\\n    }\\n\\n    color = texture(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\\n    color.r *= strength;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nlayout (location = 0) in vec2 offset;\\nlayout (location = 1) in vec2 uv;\\n\\nlayout (location = 2) in vec3 center;\\nlayout (location = 3) in vec2 center_lonlat;\\n\\n\\nuniform float current_time;\\nuniform mat4 inv_model;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\nuniform vec2 kernel_size;\\n\\nout vec2 out_uv;\\nout vec3 out_p;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\\n    p = check_inversed_longitude(p);\\n\\n    vec2 center_pos_clip_space = world2clip_orthographic(p);\\n\\n    vec2 pos_clip_space = center_pos_clip_space;\\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\\n\\n    out_uv = uv;\\n    out_p = p;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nlayout (location = 0) in vec2 offset;\\nlayout (location = 1) in vec2 uv;\\n\\nlayout (location = 2) in vec3 center;\\nlayout (location = 3) in vec2 center_lonlat;\\n\\n\\nuniform float current_time;\\nuniform mat4 inv_model;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\nuniform vec2 kernel_size;\\n\\nout vec2 out_uv;\\nout vec3 out_p;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\\n    p = check_inversed_longitude(p);\\n\\n    vec2 center_pos_clip_space = world2clip_gnomonic(p);\\n\\n    vec2 pos_clip_space = center_pos_clip_space;\\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\\n\\n    out_uv = uv;\\n    out_p = p;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nprecision lowp sampler2D;\\n\\nin vec2 out_uv;\\nout vec4 color;\\n\\nuniform sampler2D texture_fbo;\\nuniform float alpha;\\n\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 colormap_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\nvoid main() {\\n    float opacity = texture(texture_fbo, out_uv).r;\\n\\n    float o = smoothstep(0.f, 0.1f, opacity);\\n\\n    color = colormap_f(opacity);\\n    color.a = o * alpha;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nout vec4 color;\\n\\nuniform sampler2D texture_fbo;\\nuniform sampler2D colormap;\\nuniform float alpha;\\nuniform float strength;\\n\\nfloat colormap_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 colormap_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\nvoid main() {\\n    float opacity = texture(texture_fbo, out_uv).r;\\n\\n    float o = smoothstep(0.f, 0.1f, opacity);\\n\\n    //color = texture(colormap, vec2(opacity, 0.5f));\\n    color = colormap_f(opacity);\\n    color.a = alpha * o;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nout vec4 color;\\n\\nuniform sampler2D texture_fbo;\\nuniform sampler2D colormap;\\nuniform float alpha;\\n\\nfloat colormap_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 colormap_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\nvoid main() {\\n    float opacity = texture(texture_fbo, out_uv).r;\\n\\n    float o = smoothstep(0.f, 0.1f, opacity);\\n\\n    //color = texture(colormap, vec2(opacity, 0.5f));\\n    color = colormap_f(opacity);\\n    color.a = alpha * o;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nout vec4 color;\\n\\nuniform sampler2D texture_fbo;\\nuniform sampler2D colormap;\\nuniform float alpha;\\n\\nfloat colormap_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 colormap_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\nvoid main() {\\n    float opacity = texture(texture_fbo, out_uv).r;\\n\\n    float o = smoothstep(0.f, 0.1f, opacity);\\n\\n    //color = texture(colormap, vec2(opacity, 0.5f));\\n    color = colormap_f(opacity);\\n    color.a = alpha * o;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nout vec4 color;\\n\\nuniform sampler2D texture_fbo;\\nuniform sampler2D colormap;\\nuniform float alpha;\\n\\nvec4 colormap_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n\\nvoid main() {\\n    float opacity = texture(texture_fbo, out_uv).r;\\n\\n    float o = smoothstep(0.f, 0.1f, opacity);\\n\\n    //color = texture(colormap, vec2(opacity, 0.5f));\\n    color = colormap_f(opacity);\\n    color.a = alpha * o;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nlayout (location = 0) in vec2 position;\\nlayout (location = 1) in vec2 uv;\\n\\nout vec2 out_uv;\\n\\nvoid main() {\\n    gl_Position = vec4(position, 0.f, 1.f);\\n    out_uv = uv;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nin vec2 out_uv;\\nout vec4 color;\\n\\nuniform sampler2D texture_fbo;\\nuniform sampler2D colormap;\\nuniform float alpha;\\n\\nfloat colormap_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat colormap_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat colormap_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 colormap_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(colormap_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(t) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\nvoid main() {\\n    float opacity = texture(texture_fbo, out_uv).r;\\n\\n    float o = smoothstep(0.f, 0.1f, opacity);\\n\\n    //color = texture(colormap, vec2(opacity, 0.5f));\\n    color = colormap_f(opacity);\\n    color.a = alpha * o;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nout vec4 c;\\nin vec2 pos_clip;\\n\\nuniform vec4 color;\\nuniform mat4 model;\\nuniform mat4 to_icrs;\\nuniform mat4 inv_model;\\nuniform float czf;\\n\\nuniform float meridians[20];\\nuniform int num_meridians;\\nuniform float parallels[10];\\nuniform int num_parallels;\\n\\nuniform vec2 window_size;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\n\\nbool is_included_inside_projection(vec2 pos_clip_space) {\\n    float px2 = pos_clip_space.x * pos_clip_space.x;\\n    float py2 = pos_clip_space.y * pos_clip_space.y;\\n\\n    return (px2 * 0.25 + py2) <= 0.25;\\n}\\n\\n/// View to world space transformation\\n/// \\n/// This returns a normalized vector along its first 3 dimensions.\\n/// Its fourth component is set to 1.\\n/// \\n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\\n/// \\n/// # Arguments\\n/// \\n/// * `x` - in normalized device coordinates between [-1; 1]\\n/// * `y` - in normalized device coordinates between [-1; 1]\\nvec3 clip2world_aitoff(vec2 pos_clip_space) {\\n    if(!is_included_inside_projection(pos_clip_space)) {\\n        discard;\\n    }\\n\\n    vec2 uv = vec2(pos_clip_space.x * PI * 0.5, pos_clip_space.y * PI);\\n    //da uv a lat/lon\\n    float c = length(uv);\\n\\n    float phi = asin(uv.y * sin(c) / c);\\n    float theta = atan(uv.x * sin(c), c * cos(c)) * 2.0;\\n\\n    vec3 world = vec3(\\n        sin(theta) * cos(phi),\\n        sin(phi),\\n        cos(theta) * cos(phi)\\n    );\\n    return world;\\n}\\n\\nfloat d_isolon(vec3 pos_model, float theta) {\\n    vec3 posmodel = pos_model;\\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\\n    // Discard the (theta + PI) meridian\\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\\n    if (dot(posmodel, e_xz) < 0.0) {\\n        return 1e3;\\n    }\\n\\n    float d = abs(dot(n, posmodel));\\n\\n    vec3 h_model = normalize(posmodel - n*d);\\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\\n    h_world = check_inversed_longitude(h_world);\\n\\n    // Project to screen x and h and compute the distance\\n    // between the two\\n    vec2 h_clip = world2clip_aitoff(h_world);\\n    \\n    return length(pos_clip - h_clip) * 2.0;\\n}\\nfloat d_isolat(vec3 pos_model, float delta) {\\n    vec3 posmodel = pos_model;\\n    float y = atan(posmodel.y, length(pos_model.xz));\\n    float d = abs(y - delta);\\n    return d;\\n}\\n\\nfloat grid_alpha(vec3 p) {\\n    float v = 1e10;\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float m = 0.0;\\n    float mdist = 10.0;\\n    for (int i = 0; i < num_meridians; i++) {\\n        float tmp = meridians[i];\\n        if (tmp > PI) {\\n            tmp -= 2.0 * PI;\\n        }\\n        float d = abs(theta - tmp);\\n        if (d < mdist) {\\n            mdist = d;\\n            m = tmp;\\n        }\\n    }\\n\\n    float par = 0.0;\\n    float pdist = 10.0;\\n    for (int i = 0; i < num_parallels; i++) {\\n        float d = abs(delta - parallels[i]);\\n        if (d < pdist) {\\n            pdist = d;\\n            par = parallels[i];\\n        }\\n    }\\n\\n    /*float a = 0.0;\\n    if (mdist < pdist) {\\n        a = d_isolon(p, m);\\n    } else {\\n        a = d_isolat(p, par);\\n    }\\n    v = min(a, v);*/\\n    v = min(d_isolon(p, m), v);\\n    v = min(d_isolat(p, par), v);\\n\\n    float eps = 3.0 * czf / window_size.x;\\n    return smoothstep(eps, 2.0*eps, v);\\n}\\n\\nvoid main() {\\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\\n\\n    vec3 pos_world = clip2world_aitoff(pos_clip);\\n    pos_world = check_inversed_longitude(pos_world);\\n\\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\\n\\n    float alpha = grid_alpha(pos_model);\\n    c = mix(color, transparency, alpha);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nout vec4 c;\\nin vec2 pos_clip;\\n\\nuniform vec4 color;\\nuniform mat4 model;\\nuniform mat4 inv_model;\\nuniform mat4 to_icrs;\\nuniform float czf;\\n\\nuniform float meridians[20];\\nuniform int num_meridians;\\nuniform float parallels[10];\\nuniform int num_parallels;\\n\\nuniform vec2 window_size;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nfloat sinc_positive(float x) {\\n    if (x > 1.0e-4) {\\n        return sin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        x = x*x;\\n        return 1.0 - x * (1.0 - x / 20.0) / 6.0;\\n    }\\n}\\n\\nvec3 clip2world_arc(vec2 pos_clip_space) {\\n    // r <= pi\\n    float x = pos_clip_space.x * PI;\\n    float y = pos_clip_space.y * PI;\\n    float r = length(vec2(x, y));\\n    if (r <= PI) {\\n        float z = cos(r);\\n        r = sinc_positive(r);\\n\\n        return vec3(x * r, y * r, z);\\n    }\\n    discard;\\n}\\n\\nfloat d_isolon(vec3 pos_model, float theta) {\\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\\n    // Discard the (theta + PI) meridian\\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\\n    if (dot(pos_model, e_xz) < 0.0) {\\n        return 1e3;\\n    }\\n\\n    float d = abs(dot(n, pos_model));\\n\\n    vec3 h_model = normalize(pos_model - n*d);\\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\\n\\n    // Project to screen x and h and compute the distance\\n    // between the two\\n    h_world = check_inversed_longitude(h_world);\\n    vec2 h_clip = world2clip_arc(h_world);\\n    \\n    return length(pos_clip - h_clip) * 2.0;\\n}\\nfloat d_isolat(vec3 pos_model, float delta) {\\n    float y = atan(pos_model.y, length(pos_model.xz));\\n    float d = abs(y - delta);\\n    return d;\\n}\\n\\nfloat grid_alpha(vec3 p) {\\n    float v = 1e10;\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float m = 0.0;\\n    float mdist = 10.0;\\n    for (int i = 0; i < num_meridians; i++) {\\n        float tmp = meridians[i];\\n        if (tmp > PI) {\\n            tmp -= 2.0 * PI;\\n        }\\n        float d = abs(theta - tmp);\\n        if (d < mdist) {\\n            mdist = d;\\n            m = tmp;\\n        }\\n    }\\n\\n    float par = 0.0;\\n    float pdist = 10.0;\\n    for (int i = 0; i < num_parallels; i++) {\\n        float d = abs(delta - parallels[i]);\\n        if (d < pdist) {\\n            pdist = d;\\n            par = parallels[i];\\n        }\\n    }\\n\\n    /*float a = 0.0;\\n    if (mdist < pdist) {\\n        a = d_isolon(p, m);\\n    } else {\\n        a = d_isolat(p, par);\\n    }\\n    v = min(a, v);*/\\n    v = min(d_isolon(p, m), v);\\n    v = min(d_isolat(p, par), v);\\n\\n    float eps = 3.0 * czf / window_size.x;\\n    return smoothstep(eps, 2.0*eps, v);\\n}\\n\\nvoid main() {\\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\\n\\n    vec3 pos_world = clip2world_arc(pos_clip);\\n    pos_world = check_inversed_longitude(pos_world);\\n\\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\\n    float alpha = grid_alpha(pos_model);\\n    c = mix(color, transparency, alpha);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nlayout (location = 0) in vec2 position;\\n\\nout vec2 pos_clip;\\n\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\n\\nvoid main() {\\n    pos_clip = position * (ndc_to_clip * czf);\\n\\n    gl_Position = vec4(position, 0.0, 1.0);\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nout vec4 frag_color;\\n\\nuniform vec4 color;\\nuniform float opacity;\\n\\nconst float PI = 3.141592653589793f;\\n\\nvoid main() {\\n    frag_color = color;\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\n\\nlayout (location = 0) in vec2 ndc_pos;\\n\\nvoid main() {\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nout vec4 c;\\nin vec2 pos_clip;\\n\\nuniform vec4 color;\\nuniform mat4 model;\\nuniform mat4 inv_model;\\nuniform mat4 to_icrs;\\nuniform float czf;\\n\\nuniform float meridians[20];\\nuniform int num_meridians;\\nuniform float parallels[10];\\nuniform int num_parallels;\\n\\nuniform vec2 window_size;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvec3 clip2world_mercator(vec2 p) {\\n    float theta = p.x * PI;\\n    float delta = atan(sinh(p.y)) * PI;\\n\\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\\n}\\n\\nfloat d_isolon(vec3 pos_model, float theta) {\\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\\n    // Discard the (theta + PI) meridian\\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\\n    if (dot(pos_model, e_xz) < 0.0) {\\n        return 1e3;\\n    }\\n\\n    float d = abs(dot(n, pos_model));\\n\\n    vec3 h_model = normalize(pos_model - n*d);\\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\\n    h_world = check_inversed_longitude(h_world);\\n\\n    // Project to screen x and h and compute the distance\\n    // between the two\\n    vec2 h_clip = world2clip_mercator(h_world);\\n    \\n    return length(pos_clip - h_clip) * 2.0;\\n}\\nfloat d_isolat(vec3 pos_model, float delta) {\\n    float y = atan(pos_model.y, length(pos_model.xz));\\n    float d = abs(y - delta);\\n    return d;\\n}\\n\\nfloat grid_alpha(vec3 p) {\\n    float v = 1e10;\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float m = 0.0;\\n    float mdist = 10.0;\\n    for (int i = 0; i < num_meridians; i++) {\\n        float tmp = meridians[i];\\n        if (tmp > PI) {\\n            tmp -= 2.0 * PI;\\n        }\\n        float d = abs(theta - tmp);\\n        if (d < mdist) {\\n            mdist = d;\\n            m = tmp;\\n        }\\n    }\\n\\n    float par = 0.0;\\n    float pdist = 10.0;\\n    for (int i = 0; i < num_parallels; i++) {\\n        float d = abs(delta - parallels[i]);\\n        if (d < pdist) {\\n            pdist = d;\\n            par = parallels[i];\\n        }\\n    }\\n\\n    /*float a = 0.0;\\n    if (mdist < pdist) {\\n        a = d_isolon(p, m);\\n    } else {\\n        a = d_isolat(p, par);\\n    }\\n    v = min(a, v);*/\\n    v = min(d_isolon(p, m), v);\\n    v = min(d_isolat(p, par), v);\\n\\n    float eps = 3.0 * czf / window_size.x;\\n    return smoothstep(eps, 2.0*eps, v);\\n}\\n\\nvoid main() {\\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\\n\\n    vec3 pos_world = clip2world_mercator(pos_clip);\\n    pos_world = check_inversed_longitude(pos_world);\\n\\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\\n\\n    float alpha = grid_alpha(pos_model);\\n    c = mix(color, transparency, alpha);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nout vec4 c;\\nin vec2 pos_clip;\\n\\nuniform vec4 color;\\nuniform mat4 model;\\nuniform mat4 inv_model;\\nuniform mat4 to_icrs;\\nuniform float czf;\\n\\nuniform float meridians[20];\\nuniform int num_meridians;\\nuniform float parallels[10];\\nuniform int num_parallels;\\n\\nuniform vec2 window_size;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nbool is_included_inside_projection(vec2 pos_clip_space) {\\n    float px2 = pos_clip_space.x * pos_clip_space.x;\\n    float py2 = pos_clip_space.y * pos_clip_space.y;\\n\\n    return (px2 * 0.25 + py2) <= 0.25;\\n}\\n\\n/// View to world space transformation\\n/// \\n/// This returns a normalized vector along its first 3 dimensions.\\n/// Its fourth component is set to 1.\\n/// \\n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\\n/// \\n/// # Arguments\\n/// \\n/// * `x` - in normalized device coordinates between [-1; 1]\\n/// * `y` - in normalized device coordinates between [-1; 1]\\nvec3 clip2world_mollweide(vec2 pos_clip_space) {\\n    if (!is_included_inside_projection(pos_clip_space)) {\\n        discard;\\n    }\\n\\n    float y2 = pos_clip_space.y * pos_clip_space.y;\\n    float k = sqrt(1.0 - 4.0 * y2);\\n\\n    float theta = PI * pos_clip_space.x / k;\\n    float delta = asin((2.0 * asin(2.0 * pos_clip_space.y) + 4.0 * pos_clip_space.y * k) / PI);\\n    \\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\\n}\\n\\nfloat d_isolon(vec3 pos_model, float theta) {\\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\\n    // Discard the (theta + PI) meridian\\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\\n    if (dot(pos_model, e_xz) < 0.0) {\\n        return 1e3;\\n    }\\n\\n    float d = abs(dot(n, pos_model));\\n\\n    vec3 h_model = normalize(pos_model - n*d);\\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\\n    h_world = check_inversed_longitude(h_world);\\n\\n    // Project to screen x and h and compute the distance\\n    // between the two\\n    vec2 h_clip = world2clip_mollweide(h_world);\\n    \\n    return length(pos_clip - h_clip) * 2.0;\\n}\\nfloat d_isolat(vec3 pos_model, float delta) {\\n    float y = atan(pos_model.y, length(pos_model.xz));\\n    float d = abs(y - delta);\\n    return d;\\n}\\n\\nfloat grid_alpha(vec3 p) {\\n    float v = 1e10;\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float m = 0.0;\\n    float mdist = 10.0;\\n    for (int i = 0; i < num_meridians; i++) {\\n        float tmp = meridians[i];\\n        if (tmp > PI) {\\n            tmp -= 2.0 * PI;\\n        }\\n        float d = abs(theta - tmp);\\n        if (d < mdist) {\\n            mdist = d;\\n            m = tmp;\\n        }\\n    }\\n\\n    float par = 0.0;\\n    float pdist = 10.0;\\n    for (int i = 0; i < num_parallels; i++) {\\n        float d = abs(delta - parallels[i]);\\n        if (d < pdist) {\\n            pdist = d;\\n            par = parallels[i];\\n        }\\n    }\\n\\n    /*float a = 0.0;\\n    if (mdist < pdist) {\\n        a = d_isolon(p, m);\\n    } else {\\n        a = d_isolat(p, par);\\n    }\\n    v = min(a, v);*/\\n    v = min(d_isolon(p, m), v);\\n    v = min(d_isolat(p, par), v);\\n\\n    float eps = 3.0 * czf / window_size.x;\\n    return smoothstep(eps, 2.0*eps, v);\\n}\\n\\nvoid main() {\\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\\n\\n    vec3 pos_world = clip2world_mollweide(pos_clip);\\n    pos_world = check_inversed_longitude(pos_world);\\n\\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\\n\\n    float alpha = grid_alpha(pos_model);\\n    c = mix(color, transparency, alpha);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nout vec4 c;\\nin vec2 pos_clip;\\n\\nuniform vec4 color;\\nuniform mat4 model;\\nuniform mat4 inv_model;\\nuniform mat4 to_icrs;\\nuniform float czf;\\n\\nuniform float meridians[20];\\nuniform int num_meridians;\\nuniform float parallels[10];\\nuniform int num_parallels;\\n\\nuniform vec2 window_size;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvec3 clip2world_orthographic(vec2 pos_clip_space) {\\n    float z = 1.f - dot(pos_clip_space, pos_clip_space);\\n    if (z > 0.f) {\\n        return vec3(pos_clip_space.x, pos_clip_space.y, sqrt(z));\\n    } else {\\n        discard;\\n    }\\n}\\n\\nfloat d_isolon(vec3 pos_model, float theta) {\\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\\n    // Discard the (theta + PI) meridian\\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\\n    if (dot(pos_model, e_xz) < 0.0) {\\n        return 1e3;\\n    }\\n\\n    float d = abs(dot(n, pos_model));\\n\\n    vec3 h_model = normalize(pos_model - n*d);\\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\\n    h_world = check_inversed_longitude(h_world);\\n\\n    // Project to screen x and h and compute the distance\\n    // between the two\\n    vec2 h_clip = world2clip_orthographic(h_world);\\n    \\n    return length(pos_clip - h_clip) * 2.0;\\n}\\nfloat d_isolat(vec3 pos_model, float delta) {\\n    float y = atan(pos_model.y, length(pos_model.xz));\\n    float d = abs(y - delta);\\n    return d*2.0;\\n}\\n\\nfloat grid_alpha(vec3 p) {\\n    float v = 1e10;\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float m = 0.0;\\n    float mdist = 10.0;\\n    for (int i = 0; i < num_meridians; i++) {\\n        float tmp = meridians[i];\\n        if (tmp > PI) {\\n            tmp -= 2.0 * PI;\\n        }\\n        float d = abs(theta - tmp);\\n        if (d < mdist) {\\n            mdist = d;\\n            m = tmp;\\n        }\\n    }\\n\\n    float par = 0.0;\\n    float pdist = 10.0;\\n    for (int i = 0; i < num_parallels; i++) {\\n        float d = abs(delta - parallels[i]);\\n        if (d < pdist) {\\n            pdist = d;\\n            par = parallels[i];\\n        }\\n    }\\n\\n    /*float a = 0.0;\\n    if (mdist < pdist) {\\n        a = d_isolon(p, m);\\n    } else {\\n        a = d_isolat(p, par);\\n    }\\n    v = min(a, v);*/\\n    v = min(d_isolon(p, m), v);\\n    v = min(d_isolat(p, par), v);\\n\\n    float eps = 3.0 * czf / window_size.x;\\n    return smoothstep(eps, 2.0*eps, v);\\n}\\n\\nvoid main() {\\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\\n\\n    vec3 pos_world = clip2world_orthographic(pos_clip);\\n    pos_world = check_inversed_longitude(pos_world);\\n\\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\\n\\n    float alpha = grid_alpha(pos_model);\\n    c = mix(color, transparency, alpha);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\n\\nout vec4 c;\\nin vec2 pos_clip;\\n\\nuniform vec4 color;\\nuniform mat4 model;\\nuniform mat4 inv_model;\\nuniform mat4 to_icrs;\\nuniform float czf;\\n\\nuniform float meridians[20];\\nuniform int num_meridians;\\nuniform float parallels[10];\\nuniform int num_parallels;\\n\\nuniform vec2 window_size;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\n/// View to world space transformation\\n/// \\n/// This returns a normalized vector along its first 3 dimensions.\\n/// Its fourth component is set to 1.\\n/// \\n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\\n/// \\n/// # Arguments\\n/// \\n/// * `x` - in normalized device coordinates between [-1; 1]\\n/// * `y` - in normalized device coordinates between [-1; 1]\\nvec3 clip2world_gnomonic(vec2 pos_clip_space) {\\n    float x_2d = pos_clip_space.x * PI;\\n    float y_2d = pos_clip_space.y * PI;\\n    float r = x_2d * x_2d + y_2d * y_2d;\\n\\n    float z = sqrt(1.0 + r);\\n    return vec3(z * x_2d, z * y_2d, z);\\n}\\n\\nfloat d_isolon(vec3 pos_model, float theta) {\\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\\n    // Discard the (theta + PI) meridian\\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\\n    if (dot(pos_model, e_xz) < 0.0) {\\n        return 1e3;\\n    }\\n\\n    float d = abs(dot(n, pos_model));\\n\\n    vec3 h_model = normalize(pos_model - n*d);\\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\\n    h_world = check_inversed_longitude(h_world);\\n\\n    // Project to screen x and h and compute the distance\\n    // between the two\\n    vec2 h_clip = world2clip_gnomonic(h_world);\\n    \\n    return length(pos_clip - h_clip) * 2.0;\\n}\\nfloat d_isolat(vec3 pos_model, float delta) {\\n    float y = atan(pos_model.y, length(pos_model.xz));\\n    float d = abs(y - delta);\\n    return d;\\n}\\n\\nfloat grid_alpha(vec3 p) {\\n    float v = 1e10;\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float m = 0.0;\\n    float mdist = 10.0;\\n    for (int i = 0; i < num_meridians; i++) {\\n        float tmp = meridians[i];\\n        if (tmp > PI) {\\n            tmp -= 2.0 * PI;\\n        }\\n        float d = abs(theta - tmp);\\n        if (d < mdist) {\\n            mdist = d;\\n            m = tmp;\\n        }\\n    }\\n\\n    float par = 0.0;\\n    float pdist = 10.0;\\n    for (int i = 0; i < num_parallels; i++) {\\n        float d = abs(delta - parallels[i]);\\n        if (d < pdist) {\\n            pdist = d;\\n            par = parallels[i];\\n        }\\n    }\\n\\n    /*float a = 0.0;\\n    if (mdist < pdist) {\\n        a = d_isolon(p, m);\\n    } else {\\n        a = d_isolat(p, par);\\n    }\\n    v = min(a, v);*/\\n    v = min(d_isolon(p, m), v);\\n    v = min(d_isolat(p, par), v);\\n\\n    float eps = 3.0 * czf / window_size.x;\\n    return smoothstep(eps, 2.0*eps, v);\\n}\\n\\nvoid main() {\\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\\n\\n    vec3 pos_world = clip2world_gnomonic(pos_clip);\\n    pos_world = check_inversed_longitude(pos_world);\\n\\n    vec3 pos_model = normalize(vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f)));\\n    float alpha = grid_alpha(pos_model);\\n    c = mix(color, transparency, alpha);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision mediump int;\\n\\nlayout (location = 0) in vec2 lonlat;\\n//layout (location = 1) in vec3 position;\\nlayout (location = 1) in vec2 ndc_pos;\\nlayout (location = 2) in vec3 uv_start;\\nlayout (location = 3) in vec3 uv_end;\\nlayout (location = 4) in float time_tile_received;\\nlayout (location = 5) in float m0;\\nlayout (location = 6) in float m1;\\n\\nout vec3 frag_uv_start;\\nout vec3 frag_uv_end;\\nout float frag_blending_factor;\\nout float m_start;\\nout float m_end;\\n\\nuniform mat4 inv_model;\\nuniform vec2 ndc_to_clip;\\n//uniform float czf;\\n\\n// current time in ms\\nuniform float current_time;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    /*\\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\\n    world_pos = check_inversed_longitude(world_pos);\\n\\n    gl_Position = vec4(world2clip_aitoff(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\\n    */\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n\\n    frag_uv_start = uv_start;\\n    frag_uv_end = uv_end;\\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\\n    m_start = m0;\\n    m_end = m1;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision mediump int;\\n\\nlayout (location = 0) in vec2 lonlat;\\n//layout (location = 1) in vec3 position;\\nlayout (location = 1) in vec2 ndc_pos;\\nlayout (location = 2) in vec3 uv_start;\\nlayout (location = 3) in vec3 uv_end;\\nlayout (location = 4) in float time_tile_received;\\nlayout (location = 5) in float m0;\\nlayout (location = 6) in float m1;\\n\\nout vec3 frag_uv_start;\\nout vec3 frag_uv_end;\\nout float frag_blending_factor;\\nout float m_start;\\nout float m_end;\\n\\nuniform mat4 inv_model;\\nuniform vec2 ndc_to_clip;\\n//uniform float czf;\\n\\n// current time in ms\\nuniform float current_time;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    /*\\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\\n    world_pos = check_inversed_longitude(world_pos);\\n\\n    gl_Position = vec4(world2clip_arc(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\\n    */\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n\\n    frag_uv_start = uv_start;\\n    frag_uv_end = uv_end;\\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\\n    m_start = m0;\\n    m_end = m1;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision mediump int;\\n\\nin vec3 frag_uv_start;\\nin vec3 frag_uv_end;\\nin float frag_blending_factor;\\nin float m_start;\\nin float m_end;\\n\\nout vec4 out_frag_color;\\nuniform float opacity;\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform sampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nvec4 get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return texture(tex[0], uv.xy);\\n    } else if (idx_texture == 1) {\\n        return texture(tex[1], uv.xy);\\n    } else if (idx_texture == 2) {\\n        return texture(tex[2], uv.xy);\\n    } else {\\n        return vec4(0.0, 1.0, 1.0, 1.0);\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nvec4 get_color_from_texture(vec3 UV) {\\n    return get_pixels(UV);\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\n\\nvoid main() {\\n    vec4 color_start = get_color_from_texture(frag_uv_start);\\n    vec4 color_end = get_color_from_texture(frag_uv_end);\\n\\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\\n    out_frag_color.a = opacity * out_frag_color.a;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision mediump int;\\n\\nlayout (location = 0) in vec2 lonlat;\\n//layout (location = 1) in vec3 position;\\nlayout (location = 1) in vec2 ndc_pos;\\nlayout (location = 2) in vec3 uv_start;\\nlayout (location = 3) in vec3 uv_end;\\nlayout (location = 4) in float time_tile_received;\\nlayout (location = 5) in float m0;\\nlayout (location = 6) in float m1;\\n\\nout vec3 frag_uv_start;\\nout vec3 frag_uv_end;\\nout float frag_blending_factor;\\nout float m_start;\\nout float m_end;\\n\\nuniform mat4 inv_model;\\nuniform vec2 ndc_to_clip;\\n//uniform float czf;\\n\\n// current time in ms\\nuniform float current_time;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    /*\\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\\n    world_pos = check_inversed_longitude(world_pos);\\n\\n    gl_Position = vec4(world2clip_gnomonic(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\\n    */\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n\\n    frag_uv_start = uv_start;\\n    frag_uv_end = uv_end;\\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\\n    m_start = m0;\\n    m_end = m1;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision mediump int;\\n\\nin vec3 frag_uv_start;\\nin vec3 frag_uv_end;\\nin float frag_blending_factor;\\nin float m_start;\\nin float m_end;\\n\\nout vec4 out_frag_color;\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform sampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nvec4 get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return texture(tex[0], uv.xy);\\n    } else if (idx_texture == 1) {\\n        return texture(tex[1], uv.xy);\\n    } else if (idx_texture == 2) {\\n        return texture(tex[2], uv.xy);\\n    } else {\\n        return vec4(0.0, 1.0, 1.0, 1.0);\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nvec4 get_color_from_texture(vec3 UV) {\\n    return get_pixels(UV);\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\n\\nuniform float opacity;\\n\\nvec4 get_color(vec3 uv, float empty) {\\n    vec4 color = get_color_from_grayscale_texture(uv);\\n    return color;\\n}\\n\\nvoid main() {\\n    vec4 color_start = get_color(frag_uv_start, m_start);\\n    vec4 color_end = get_color(frag_uv_end, m_end);\\n\\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\\n\\n\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision mediump int;\\n\\nin vec3 frag_uv_start;\\nin vec3 frag_uv_end;\\nin float frag_blending_factor;\\nin float m_start;\\nin float m_end;\\n\\nout vec4 out_frag_color;\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform isampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nfloat get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return float(texture(tex[0], uv.xy).r);\\n    } else if (idx_texture == 1) {\\n        return float(texture(tex[1], uv.xy).r);\\n    } else if (idx_texture == 2) {\\n        return float(texture(tex[2], uv.xy).r);\\n    } else {\\n        return 0.0;\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\n\\nuniform float opacity;\\n\\nvec4 get_color(vec3 uv, float empty) {\\n    vec4 color = get_color_from_grayscale_texture(uv);\\n    return color;\\n}\\n\\nvoid main() {\\n    vec4 color_start = get_color(frag_uv_start, m_start);\\n    vec4 color_end = get_color(frag_uv_end, m_end);\\n\\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision mediump int;\\n\\nin vec3 frag_uv_start;\\nin vec3 frag_uv_end;\\nin float frag_blending_factor;\\nin float m_start;\\nin float m_end;\\n\\nout vec4 out_frag_color;\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform sampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nvec4 get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return texture(tex[0], uv.xy);\\n    } else if (idx_texture == 1) {\\n        return texture(tex[1], uv.xy);\\n    } else if (idx_texture == 2) {\\n        return texture(tex[2], uv.xy);\\n    } else {\\n        return vec4(0.0, 1.0, 1.0, 1.0);\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nvec4 get_color_from_texture(vec3 UV) {\\n    return get_pixels(UV);\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\n\\nuniform float opacity;\\n\\nvec4 get_color(vec3 uv, float empty) {\\n    vec4 color = get_colormap_from_grayscale_texture(uv);\\n    return color;\\n}\\n\\nvoid main() {\\n    vec4 color_start = get_color(frag_uv_start, m_start);\\n    vec4 color_end = get_color(frag_uv_end, m_end);\\n\\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision mediump int;\\n\\nin vec3 frag_uv_start;\\nin vec3 frag_uv_end;\\nin float frag_blending_factor;\\nin float m_start;\\nin float m_end;\\n\\nout vec4 out_frag_color;\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform isampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nfloat get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return float(texture(tex[0], uv.xy).r);\\n    } else if (idx_texture == 1) {\\n        return float(texture(tex[1], uv.xy).r);\\n    } else if (idx_texture == 2) {\\n        return float(texture(tex[2], uv.xy).r);\\n    } else {\\n        return 0.0;\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\n\\nuniform float opacity;\\n\\nvec4 get_color(vec3 uv, float empty) {\\n    vec4 color = get_colormap_from_grayscale_texture(uv);\\n    return color;\\n}\\n\\nvoid main() {\\n    vec4 color_start = get_color(frag_uv_start, m_start);\\n    vec4 color_end = get_color(frag_uv_end, m_end);\\n\\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision mediump int;\\n\\nlayout (location = 0) in vec2 lonlat;\\n//layout (location = 1) in vec3 position;\\nlayout (location = 1) in vec2 ndc_pos;\\nlayout (location = 2) in vec3 uv_start;\\nlayout (location = 3) in vec3 uv_end;\\nlayout (location = 4) in float time_tile_received;\\nlayout (location = 5) in float m0;\\nlayout (location = 6) in float m1;\\n\\nout vec3 frag_uv_start;\\nout vec3 frag_uv_end;\\nout float frag_blending_factor;\\nout float m_start;\\nout float m_end;\\n\\nuniform mat4 inv_model;\\nuniform vec2 ndc_to_clip;\\n//uniform float czf;\\n\\n// current time in ms\\nuniform float current_time;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    /*\\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\\n    world_pos = check_inversed_longitude(world_pos);\\n\\n    gl_Position = vec4(world2clip_mercator(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\\n    */\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n\\n    frag_uv_start = uv_start;\\n    frag_uv_end = uv_end;\\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\\n    m_start = m0;\\n    m_end = m1;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision mediump int;\\n\\nlayout (location = 0) in vec2 lonlat;\\n//layout (location = 1) in vec3 position;\\nlayout (location = 1) in vec2 ndc_pos;\\nlayout (location = 2) in vec3 uv_start;\\nlayout (location = 3) in vec3 uv_end;\\nlayout (location = 4) in float time_tile_received;\\nlayout (location = 5) in float m0;\\nlayout (location = 6) in float m1;\\n\\nout vec3 frag_uv_start;\\nout vec3 frag_uv_end;\\nout float frag_blending_factor;\\nout float m_start;\\nout float m_end;\\n\\nuniform mat4 inv_model;\\nuniform vec2 ndc_to_clip;\\n//uniform float czf;\\n// current time in ms\\nuniform float current_time;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    /*\\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\\n    world_pos = check_inversed_longitude(world_pos);\\n\\n    gl_Position = vec4(world2clip_mollweide(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\\n    */\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n\\n    frag_uv_start = uv_start;\\n    frag_uv_end = uv_end;\\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\\n    m_start = m0;\\n    m_end = m1;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision mediump int;\\n\\nlayout (location = 0) in vec2 lonlat;\\n//layout (location = 1) in vec3 position;\\nlayout (location = 1) in vec2 ndc_pos;\\nlayout (location = 2) in vec3 uv_start;\\nlayout (location = 3) in vec3 uv_end;\\nlayout (location = 4) in float time_tile_received;\\nlayout (location = 5) in float m0;\\nlayout (location = 6) in float m1;\\n\\nout vec3 frag_uv_start;\\nout vec3 frag_uv_end;\\nout float frag_blending_factor;\\nout float m_start;\\nout float m_end;\\n\\nuniform mat4 inv_model;\\nuniform vec2 ndc_to_clip;\\n//uniform float czf;\\n\\n// current time in ms\\nuniform float current_time;\\n\\nconst float PI = 3.1415926535897932384626433832795f;\\n\\nuniform int inversed_longitude;\\n\\nconst mat3 inverseLongitude = mat3(\\n    -1.0, 0.0, 0.0,\\n    0.0, 1.0, 0.0,\\n    0.0, 0.0, 1.0\\n);\\n\\nconst mat4 GAL2J2000 = mat4(\\n    -0.4448296299195045,\\n    0.7469822444763707,\\n    0.4941094279435681,\\n    0.0,\\n\\n    -0.1980763734646737,\\n    0.4559837762325372,\\n    -0.8676661489811610,\\n    0.0,\\n\\n    -0.873437090247923,\\n    -0.4838350155267381,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nconst mat4 J20002GAL = mat4(\\n    -0.4448296299195045,\\n    -0.1980763734646737,\\n    -0.873437090247923,\\n    0.0,\\n\\n    0.7469822444763707,\\n    0.4559837762325372,\\n    -0.4838350155267381,\\n    0.0,\\n\\n    0.4941094279435681,\\n    -0.8676661489811610,\\n    -0.0548755604024359,\\n    0.0,\\n\\n    0.0,\\n    0.0,\\n    0.0,\\n    1.0\\n);\\n\\nvec3 check_inversed_longitude(vec3 p) {\\n    if (inversed_longitude == 1) {\\n        return inverseLongitude * p;\\n    } else {\\n        return p;\\n    }\\n}\\n\\nvec2 world2clip_orthographic(vec3 p) {\\n    return vec2(p.x, p.y);\\n}\\n\\nvec2 world2clip_aitoff(vec3 p) {\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float theta_by_two = theta * 0.5f;\\n\\n    float alpha = acos(cos(delta)*cos(theta_by_two));\\n    float inv_sinc_alpha = 1.f;\\n    if (alpha > 1e-3f) {\\n        inv_sinc_alpha = alpha / sin(alpha);\\n    }\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\\n    float y = inv_sinc_alpha * sin(delta);\\n\\n    return vec2(x / PI, y / PI);\\n}\\n\\nvec2 world2clip_mollweide(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n    int max_iter = 10;\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float cst = PI * sin(delta);\\n\\n    float phi = delta;\\n    float f = phi + sin(phi) - cst;\\n\\n    int k = 0;\\n    while (abs(f) > 1e-6 && k < max_iter) {\\n        phi = phi - f / (1.f + cos(phi));\\n        f = phi + sin(phi) - cst;\\n\\n        k = k + 1;\\n    }\\n\\n    phi = phi * 0.5f;\\n\\n    // The minus is an astronomical convention.\\n    // longitudes are increasing from right to left\\n    float x = (theta / PI) * cos(phi);\\n    float y = 0.5f * sin(phi);\\n\\n    return vec2(x, y);\\n}\\n\\nvec2 world2clip_mercator(vec3 p) {\\n    // X in [-1, 1]\\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\\n\\n    float delta = asin(p.y);\\n    float theta = atan(p.x, p.z);\\n\\n    float x = theta / PI;\\n    float y = asinh(tan(delta / PI));\\n\\n    return vec2(x, y);\\n}\\n\\nfloat arc_sinc(float x) {\\n    if (x > 1e-4) {\\n        return asin(x) / x;\\n    } else {\\n        // If a is mall, use Taylor expension of asin(a) / a\\n        // a = 1e-4 => a^4 = 1.e-16\\n        float x2 = x*x;\\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\\n    }\\n}\\n\\nvec2 world2clip_arc(vec3 p) {\\n    if (p.z > -1.0) {\\n        // Distance in the Euclidean plane (xy)\\n        // Angular distance is acos(x), but for small separation, asin(r)\\n        // is more accurate.\\n        float r = length(p.xy);\\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\\n            r = arc_sinc(r);\\n        } else { // Angular distance > PI/2, angular distance = acos(x)\\n            r = acos(p.z) / r;\\n        }\\n        float x = p.x * r;\\n        float y = p.y * r;\\n\\n        return vec2(x / PI, y / PI);\\n    } else {\\n        return vec2(1.0, 0.0);\\n    }\\n}\\n\\nvec2 world2clip_gnomonic(vec3 p) {\\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\\n        return vec2(1.0, 0.0);\\n    } else {\\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\\n    }\\n}\\n\\nvoid main() {\\n    /*\\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\\n    world_pos = check_inversed_longitude(world_pos);\\n\\n    vec2 ndc_pos = world2clip_orthographic(world_pos) / (ndc_to_clip * czf);\\n    */\\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\\n\\n    frag_uv_start = uv_start;\\n    frag_uv_end = uv_end;\\n\\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\\n    m_start = m0;\\n    m_end = m1;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision highp int;\\n\\nin vec3 out_vert_pos;\\n\\nout vec4 out_frag_color;\\n\\nuniform int user_action;\\n\\nstruct Tile {\\n    int uniq; // Healpix cell\\n    int texture_idx; // Index in the texture buffer\\n    float start_time; // Absolute time that the load has been done in ms\\n    int empty;\\n};\\n\\nuniform int current_depth;\\nuniform Tile textures_tiles[12];\\n\\nuniform float current_time; // current time in ms\\nstruct TileColor {\\n    Tile tile;\\n    vec4 color;\\n    bool found;\\n};\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform sampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nvec4 get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return texture(tex[0], uv.xy);\\n    } else if (idx_texture == 1) {\\n        return texture(tex[1], uv.xy);\\n    } else if (idx_texture == 2) {\\n        return texture(tex[2], uv.xy);\\n    } else {\\n        return vec4(0.0, 1.0, 1.0, 1.0);\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nvec4 get_color_from_texture(vec3 UV) {\\n    return get_pixels(UV);\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\nconst float TWICE_PI = 6.28318530718f;\\nconst float PI = 3.141592653589793f;\\nconst float FOUR_OVER_PI = 1.27323954474f;\\nconst float TRANSITION_Z = 0.66666666666f;\\nconst float TRANSITION_Z_INV = 1.5f;\\n\\nint quarter(vec2 p) {\\n    int x_neg = int(p.x < 0.0f);\\n    int y_neg = int(p.y < 0.0f);\\n    int q = (x_neg + y_neg) | (y_neg << 1);\\n    return q;\\n}\\n\\nfloat xpm1(vec2 p) {\\n    bool x_neg = (p.x < 0.0f);\\n    //debug_assert!(x_neg <= 1);\\n    bool y_neg = (p.y < 0.0f);\\n    //debug_assert!(y_neg <= 1);\\n    // The purpose it to have the same numerical precision for each base cell\\n    // by avoiding subtraction by 1 or 3 or 5 or 7\\n    float lon = atan(abs(p.y), abs(p.x));\\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\\n    float x02 = lon * FOUR_OVER_PI;\\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\\n        return 1.0f - x02;\\n    } else {\\n        return x02 - 1.0f;\\n    }\\n}\\n\\nfloat one_minus_z_pos(vec3 p) {\\n    //debug_assert!(z > 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n\\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return 1.0f - p.z;\\n}\\n\\nfloat one_minus_z_neg(vec3 p) {\\n    //debug_assert!(z < 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\\n        // 0.5 * d2 + 0.125 * d2 * d2\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return p.z + 1.0f;\\n}\\n\\n// Z-Order curve projection.\\nint ij2z(int i, int j) {\\n    int i1 = i | (j << 16);\\n\\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\\n    int i2 = i1 ^ j1 ^ (j1 << 8);\\n\\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\\n    int i3 = i2 ^ j2 ^ (j2 << 4);\\n\\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\\n    int i4 = i3 ^ j3 ^ (j3 << 2);\\n\\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\\n    int i5 = i4 ^ j4 ^ (j4 << 1);\\n\\n    return i5;\\n}\\n\\nstruct HashDxDy {\\n    int idx;\\n    float dx;\\n    float dy;\\n};\\n\\nuniform sampler2D ang2pixd;\\nHashDxDy hash_with_dxdy2(vec2 radec) {\\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\\n    vec3 v = texture(ang2pixd, aa).rgb;\\n    return HashDxDy(\\n        int(v.x * 255.0),\\n        v.y,\\n        v.z\\n    );\\n}\\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \\n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\\n// respect to the origin of the cell (South vertex).\\n// # Inputs:\\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\\n// - `x`: in `[-1.0, 1.0]`\\n// - `y`: in `[-1.0, 1.0]`\\n// - `z`: in `[-1.0, 1.0]`\\n// # Output\\n// - the cell number (hash value) associated with the given position on the unit sphere,\\n//   in `[0, 12*nside^2[`\\n// - `dx`: the positional offset $\\\\in [0, 1[$ along the south-to-east axis\\n// - `dy`: the positional offset $\\\\in [0, 1[$ along the south-to-west axis\\n// # WARNING\\n// - The function assumes, without checking, that the input vector is a unit vector \\n//   (hence `x^2 + y^2 + z^2 = 1`) !!\\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\\n    //assert!(depth <= 14);\\n    //assert!(-1.0 <= x && x <= 1.0);\\n    //assert!(-1.0 <= y && y <= 1.0);\\n    //assert!(-1.0 <= z && z <= 1.0);\\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\\n    // A f32 mantissa contains 23 bits.\\n    // - it basically means that when storing (x, y) coordinates,\\n    //   we can go as deep as depth 24 (or maybe 25)\\n    \\n    int nside = 1 << depth;\\n    float half_nside = float(nside) * 0.5f;\\n\\n    float x_pm1 = xpm1(p.xy);\\n    int q = quarter(p.xy);\\n\\n    int d0h = 0;\\n    vec2 p_proj = vec2(0.f);\\n    if (p.z > TRANSITION_Z) {\\n        // North polar cap, Collignon projection.\\n        // - set the origin to (PI/4, 0)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\\n        d0h = q;\\n    } else if (p.z < -TRANSITION_Z) {\\n        // South polar cap, Collignon projection\\n        // - set the origin to (PI/4, -PI/2)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\\n        d0h = q + 8;\\n    } else {\\n        // Equatorial region, Cylindrical equal area projection\\n        // - set the origin to (PI/4, 0)               if q = 2\\n        // - set the origin to (PI/4, -PI/2)           if q = 0\\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\\n        // let zero_or_one = (x_cea as u8) & 1;\\n        float y_pm1 = p.z * TRANSITION_Z_INV;\\n        // |\\\\2/|\\n        // .3X1.\\n        // |/0\\\\|\\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\\n        //debug_assert!(q01 == 0 || q01 == 1);\\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\\\1\\n        //debug_assert!(q12 == 0 || q12 == 1);\\n        int q03 = 1 - q12; // 1\\\\0\\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\\n        int q1 = q01 & q12; // = 1 if q1, 0 else\\n        //debug_assert!( q1 == 0 ||  q1 == 1);\\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \\n        //let y_proj = y_pm1 + (q01 + q03) as f32;\\n        p_proj = vec2(\\n            x_pm1 - float(q01 + q12 - 1),\\n            y_pm1 + float(q01 + q03)\\n        );\\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\\n    }\\n\\n    // Coords inside the base cell\\n    float x = (half_nside * (p_proj.x + p_proj.y));\\n    float y = (half_nside * (p_proj.y - p_proj.x));\\n    int i = int(x);\\n    int j = int(y);\\n\\n    return HashDxDy(\\n        (d0h << (depth << 1)) | ij2z(i, j),\\n        x - float(i),\\n        y - float(j)\\n    );\\n}\\n\\nuniform float opacity;\\n\\nTileColor get_tile_color(vec3 pos) {\\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\\n\\n    int idx = result.idx;\\n    vec2 uv = vec2(result.dy, result.dx);\\n\\n    Tile tile = textures_tiles[idx];\\n\\n    int idx_texture = tile.texture_idx >> 6;\\n    int off = tile.texture_idx & 0x3F;\\n    float idx_row = float(off >> 3); // in [0; 7]\\n    float idx_col = float(off & 0x7); // in [0; 7]\\n\\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\\n    vec3 UV = vec3(offset, float(idx_texture));\\n\\n    vec4 color = get_color_from_texture(UV);\\n    color.a = mix(color.a, blank_color.a, float(tile.empty));\\n    \\n    return TileColor(tile, color, true);\\n}\\n\\nconst float duration = 500.f; // 500ms\\nuniform int max_depth; // max depth of the HiPS\\n\\nvoid main() {\\n    vec3 frag_pos = normalize(out_vert_pos);\\n\\n    // Get the HEALPix cell idx and the uv in the texture\\n    TileColor current_tile = get_tile_color(frag_pos);\\n    float pixel_transparency = current_tile.color.a;\\n    out_frag_color = vec4(current_tile.color.rgb, opacity * pixel_transparency);\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision highp int;\\n\\nin vec3 out_vert_pos;\\nin vec2 pos_clip;\\nin vec2 out_lonlat;\\n\\nout vec4 out_frag_color;\\n\\nuniform int user_action;\\n\\nstruct Tile {\\n    int uniq; // Healpix cell\\n    int texture_idx; // Index in the texture buffer\\n    float start_time; // Absolute time that the load has been done in ms\\n    int empty;\\n};\\n\\nuniform int current_depth;\\n\\nuniform Tile textures_tiles[12];\\n\\nuniform float current_time; // current time in ms\\nstruct TileColor {\\n    Tile tile;\\n    vec4 color;\\n    bool found;\\n};\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform sampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nvec4 get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return texture(tex[0], uv.xy);\\n    } else if (idx_texture == 1) {\\n        return texture(tex[1], uv.xy);\\n    } else if (idx_texture == 2) {\\n        return texture(tex[2], uv.xy);\\n    } else {\\n        return vec4(0.0, 1.0, 1.0, 1.0);\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nvec4 get_color_from_texture(vec3 UV) {\\n    return get_pixels(UV);\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\nconst float TWICE_PI = 6.28318530718f;\\nconst float PI = 3.141592653589793f;\\nconst float FOUR_OVER_PI = 1.27323954474f;\\nconst float TRANSITION_Z = 0.66666666666f;\\nconst float TRANSITION_Z_INV = 1.5f;\\n\\nint quarter(vec2 p) {\\n    int x_neg = int(p.x < 0.0f);\\n    int y_neg = int(p.y < 0.0f);\\n    int q = (x_neg + y_neg) | (y_neg << 1);\\n    return q;\\n}\\n\\nfloat xpm1(vec2 p) {\\n    bool x_neg = (p.x < 0.0f);\\n    //debug_assert!(x_neg <= 1);\\n    bool y_neg = (p.y < 0.0f);\\n    //debug_assert!(y_neg <= 1);\\n    // The purpose it to have the same numerical precision for each base cell\\n    // by avoiding subtraction by 1 or 3 or 5 or 7\\n    float lon = atan(abs(p.y), abs(p.x));\\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\\n    float x02 = lon * FOUR_OVER_PI;\\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\\n        return 1.0f - x02;\\n    } else {\\n        return x02 - 1.0f;\\n    }\\n}\\n\\nfloat one_minus_z_pos(vec3 p) {\\n    //debug_assert!(z > 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n\\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return 1.0f - p.z;\\n}\\n\\nfloat one_minus_z_neg(vec3 p) {\\n    //debug_assert!(z < 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\\n        // 0.5 * d2 + 0.125 * d2 * d2\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return p.z + 1.0f;\\n}\\n\\n// Z-Order curve projection.\\nint ij2z(int i, int j) {\\n    int i1 = i | (j << 16);\\n\\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\\n    int i2 = i1 ^ j1 ^ (j1 << 8);\\n\\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\\n    int i3 = i2 ^ j2 ^ (j2 << 4);\\n\\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\\n    int i4 = i3 ^ j3 ^ (j3 << 2);\\n\\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\\n    int i5 = i4 ^ j4 ^ (j4 << 1);\\n\\n    return i5;\\n}\\n\\nstruct HashDxDy {\\n    int idx;\\n    float dx;\\n    float dy;\\n};\\n\\nuniform sampler2D ang2pixd;\\nHashDxDy hash_with_dxdy2(vec2 radec) {\\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\\n    vec3 v = texture(ang2pixd, aa).rgb;\\n    return HashDxDy(\\n        int(v.x * 255.0),\\n        v.y,\\n        v.z\\n    );\\n}\\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \\n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\\n// respect to the origin of the cell (South vertex).\\n// # Inputs:\\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\\n// - `x`: in `[-1.0, 1.0]`\\n// - `y`: in `[-1.0, 1.0]`\\n// - `z`: in `[-1.0, 1.0]`\\n// # Output\\n// - the cell number (hash value) associated with the given position on the unit sphere,\\n//   in `[0, 12*nside^2[`\\n// - `dx`: the positional offset $\\\\in [0, 1[$ along the south-to-east axis\\n// - `dy`: the positional offset $\\\\in [0, 1[$ along the south-to-west axis\\n// # WARNING\\n// - The function assumes, without checking, that the input vector is a unit vector \\n//   (hence `x^2 + y^2 + z^2 = 1`) !!\\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\\n    //assert!(depth <= 14);\\n    //assert!(-1.0 <= x && x <= 1.0);\\n    //assert!(-1.0 <= y && y <= 1.0);\\n    //assert!(-1.0 <= z && z <= 1.0);\\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\\n    // A f32 mantissa contains 23 bits.\\n    // - it basically means that when storing (x, y) coordinates,\\n    //   we can go as deep as depth 24 (or maybe 25)\\n    \\n    int nside = 1 << depth;\\n    float half_nside = float(nside) * 0.5f;\\n\\n    float x_pm1 = xpm1(p.xy);\\n    int q = quarter(p.xy);\\n\\n    int d0h = 0;\\n    vec2 p_proj = vec2(0.f);\\n    if (p.z > TRANSITION_Z) {\\n        // North polar cap, Collignon projection.\\n        // - set the origin to (PI/4, 0)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\\n        d0h = q;\\n    } else if (p.z < -TRANSITION_Z) {\\n        // South polar cap, Collignon projection\\n        // - set the origin to (PI/4, -PI/2)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\\n        d0h = q + 8;\\n    } else {\\n        // Equatorial region, Cylindrical equal area projection\\n        // - set the origin to (PI/4, 0)               if q = 2\\n        // - set the origin to (PI/4, -PI/2)           if q = 0\\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\\n        // let zero_or_one = (x_cea as u8) & 1;\\n        float y_pm1 = p.z * TRANSITION_Z_INV;\\n        // |\\\\2/|\\n        // .3X1.\\n        // |/0\\\\|\\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\\n        //debug_assert!(q01 == 0 || q01 == 1);\\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\\\1\\n        //debug_assert!(q12 == 0 || q12 == 1);\\n        int q03 = 1 - q12; // 1\\\\0\\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\\n        int q1 = q01 & q12; // = 1 if q1, 0 else\\n        //debug_assert!( q1 == 0 ||  q1 == 1);\\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \\n        //let y_proj = y_pm1 + (q01 + q03) as f32;\\n        p_proj = vec2(\\n            x_pm1 - float(q01 + q12 - 1),\\n            y_pm1 + float(q01 + q03)\\n        );\\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\\n    }\\n\\n    // Coords inside the base cell\\n    float x = (half_nside * (p_proj.x + p_proj.y));\\n    float y = (half_nside * (p_proj.y - p_proj.x));\\n    int i = int(x);\\n    int j = int(y);\\n\\n    return HashDxDy(\\n        (d0h << (depth << 1)) | ij2z(i, j),\\n        x - float(i),\\n        y - float(j)\\n    );\\n}\\n\\nuniform float opacity;\\n\\nTileColor get_tile_color(vec3 pos) {\\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\\n    int idx = result.idx;\\n    vec2 uv = vec2(result.dy, result.dx);\\n\\n    Tile tile = textures_tiles[idx];\\n\\n    int idx_texture = tile.texture_idx >> 6;\\n    int off = tile.texture_idx & 0x3F;\\n    float idx_row = float(off >> 3); // in [0; 7]\\n    float idx_col = float(off & 0x7); // in [0; 7]\\n\\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\\n    vec3 UV = vec3(offset, float(idx_texture));\\n\\n    vec4 color = mix(get_color_from_grayscale_texture(UV), blank_color, float(tile.empty));\\n    return TileColor(tile, color, true);\\n}\\n\\nconst float duration = 500.f; // 500ms\\nuniform int max_depth; // max depth of the HiPS\\n\\nvoid main() {\\n    vec3 frag_pos = normalize(out_vert_pos);\\n    // Get the HEALPix cell idx and the uv in the texture\\n\\n    TileColor current_tile = get_tile_color(frag_pos);\\n    out_frag_color = current_tile.color;\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision highp int;\\n\\nin vec3 out_vert_pos;\\nin vec2 pos_clip;\\nin vec2 out_lonlat;\\n\\nout vec4 out_frag_color;\\n\\nuniform int user_action;\\n\\nstruct Tile {\\n    int uniq; // Healpix cell\\n    int texture_idx; // Index in the texture buffer\\n    float start_time; // Absolute time that the load has been done in ms\\n    int empty;\\n};\\n\\nuniform int current_depth;\\n\\nuniform Tile textures_tiles[12];\\n\\nuniform float current_time; // current time in ms\\nstruct TileColor {\\n    Tile tile;\\n    vec4 color;\\n    bool found;\\n};\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform isampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nfloat get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return float(texture(tex[0], uv.xy).r);\\n    } else if (idx_texture == 1) {\\n        return float(texture(tex[1], uv.xy).r);\\n    } else if (idx_texture == 2) {\\n        return float(texture(tex[2], uv.xy).r);\\n    } else {\\n        return 0.0;\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\nconst float TWICE_PI = 6.28318530718f;\\nconst float PI = 3.141592653589793f;\\nconst float FOUR_OVER_PI = 1.27323954474f;\\nconst float TRANSITION_Z = 0.66666666666f;\\nconst float TRANSITION_Z_INV = 1.5f;\\n\\nint quarter(vec2 p) {\\n    int x_neg = int(p.x < 0.0f);\\n    int y_neg = int(p.y < 0.0f);\\n    int q = (x_neg + y_neg) | (y_neg << 1);\\n    return q;\\n}\\n\\nfloat xpm1(vec2 p) {\\n    bool x_neg = (p.x < 0.0f);\\n    //debug_assert!(x_neg <= 1);\\n    bool y_neg = (p.y < 0.0f);\\n    //debug_assert!(y_neg <= 1);\\n    // The purpose it to have the same numerical precision for each base cell\\n    // by avoiding subtraction by 1 or 3 or 5 or 7\\n    float lon = atan(abs(p.y), abs(p.x));\\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\\n    float x02 = lon * FOUR_OVER_PI;\\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\\n        return 1.0f - x02;\\n    } else {\\n        return x02 - 1.0f;\\n    }\\n}\\n\\nfloat one_minus_z_pos(vec3 p) {\\n    //debug_assert!(z > 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n\\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return 1.0f - p.z;\\n}\\n\\nfloat one_minus_z_neg(vec3 p) {\\n    //debug_assert!(z < 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\\n        // 0.5 * d2 + 0.125 * d2 * d2\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return p.z + 1.0f;\\n}\\n\\n// Z-Order curve projection.\\nint ij2z(int i, int j) {\\n    int i1 = i | (j << 16);\\n\\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\\n    int i2 = i1 ^ j1 ^ (j1 << 8);\\n\\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\\n    int i3 = i2 ^ j2 ^ (j2 << 4);\\n\\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\\n    int i4 = i3 ^ j3 ^ (j3 << 2);\\n\\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\\n    int i5 = i4 ^ j4 ^ (j4 << 1);\\n\\n    return i5;\\n}\\n\\nstruct HashDxDy {\\n    int idx;\\n    float dx;\\n    float dy;\\n};\\n\\nuniform sampler2D ang2pixd;\\nHashDxDy hash_with_dxdy2(vec2 radec) {\\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\\n    vec3 v = texture(ang2pixd, aa).rgb;\\n    return HashDxDy(\\n        int(v.x * 255.0),\\n        v.y,\\n        v.z\\n    );\\n}\\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \\n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\\n// respect to the origin of the cell (South vertex).\\n// # Inputs:\\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\\n// - `x`: in `[-1.0, 1.0]`\\n// - `y`: in `[-1.0, 1.0]`\\n// - `z`: in `[-1.0, 1.0]`\\n// # Output\\n// - the cell number (hash value) associated with the given position on the unit sphere,\\n//   in `[0, 12*nside^2[`\\n// - `dx`: the positional offset $\\\\in [0, 1[$ along the south-to-east axis\\n// - `dy`: the positional offset $\\\\in [0, 1[$ along the south-to-west axis\\n// # WARNING\\n// - The function assumes, without checking, that the input vector is a unit vector \\n//   (hence `x^2 + y^2 + z^2 = 1`) !!\\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\\n    //assert!(depth <= 14);\\n    //assert!(-1.0 <= x && x <= 1.0);\\n    //assert!(-1.0 <= y && y <= 1.0);\\n    //assert!(-1.0 <= z && z <= 1.0);\\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\\n    // A f32 mantissa contains 23 bits.\\n    // - it basically means that when storing (x, y) coordinates,\\n    //   we can go as deep as depth 24 (or maybe 25)\\n    \\n    int nside = 1 << depth;\\n    float half_nside = float(nside) * 0.5f;\\n\\n    float x_pm1 = xpm1(p.xy);\\n    int q = quarter(p.xy);\\n\\n    int d0h = 0;\\n    vec2 p_proj = vec2(0.f);\\n    if (p.z > TRANSITION_Z) {\\n        // North polar cap, Collignon projection.\\n        // - set the origin to (PI/4, 0)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\\n        d0h = q;\\n    } else if (p.z < -TRANSITION_Z) {\\n        // South polar cap, Collignon projection\\n        // - set the origin to (PI/4, -PI/2)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\\n        d0h = q + 8;\\n    } else {\\n        // Equatorial region, Cylindrical equal area projection\\n        // - set the origin to (PI/4, 0)               if q = 2\\n        // - set the origin to (PI/4, -PI/2)           if q = 0\\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\\n        // let zero_or_one = (x_cea as u8) & 1;\\n        float y_pm1 = p.z * TRANSITION_Z_INV;\\n        // |\\\\2/|\\n        // .3X1.\\n        // |/0\\\\|\\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\\n        //debug_assert!(q01 == 0 || q01 == 1);\\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\\\1\\n        //debug_assert!(q12 == 0 || q12 == 1);\\n        int q03 = 1 - q12; // 1\\\\0\\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\\n        int q1 = q01 & q12; // = 1 if q1, 0 else\\n        //debug_assert!( q1 == 0 ||  q1 == 1);\\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \\n        //let y_proj = y_pm1 + (q01 + q03) as f32;\\n        p_proj = vec2(\\n            x_pm1 - float(q01 + q12 - 1),\\n            y_pm1 + float(q01 + q03)\\n        );\\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\\n    }\\n\\n    // Coords inside the base cell\\n    float x = (half_nside * (p_proj.x + p_proj.y));\\n    float y = (half_nside * (p_proj.y - p_proj.x));\\n    int i = int(x);\\n    int j = int(y);\\n\\n    return HashDxDy(\\n        (d0h << (depth << 1)) | ij2z(i, j),\\n        x - float(i),\\n        y - float(j)\\n    );\\n}\\n\\nuniform float opacity;\\n\\nTileColor get_tile_color(vec3 pos) {\\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\\n    int idx = result.idx;\\n    vec2 uv = vec2(result.dy, result.dx);\\n\\n    Tile tile = textures_tiles[idx];\\n\\n    int idx_texture = tile.texture_idx >> 6;\\n    int off = tile.texture_idx & 0x3F;\\n    float idx_row = float(off >> 3); // in [0; 7]\\n    float idx_col = float(off & 0x7); // in [0; 7]\\n\\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\\n    vec3 UV = vec3(offset, float(idx_texture));\\n\\n    vec4 color = mix(get_color_from_grayscale_texture(UV), blank_color, float(tile.empty));\\n    return TileColor(tile, color, true);\\n}\\n\\nconst float duration = 500.f; // 500ms\\nuniform int max_depth; // max depth of the HiPS\\n\\nvoid main() {\\n    vec3 frag_pos = normalize(out_vert_pos);\\n    // Get the HEALPix cell idx and the uv in the texture\\n\\n    TileColor current_tile = get_tile_color(frag_pos);\\n    out_frag_color = current_tile.color;\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision highp int;\\n\\nin vec3 out_vert_pos;\\nin vec2 pos_clip;\\n\\nout vec4 out_frag_color;\\n\\nuniform int user_action;\\n\\nstruct Tile {\\n    int uniq; // Healpix cell\\n    int texture_idx; // Index in the texture buffer\\n    float start_time; // Absolute time that the load has been done in ms\\n    int empty;\\n};\\n\\nuniform int current_depth;\\n\\nuniform Tile textures_tiles[12];\\n\\nuniform float opacity;\\nuniform float current_time; // current time in ms\\nstruct TileColor {\\n    Tile tile;\\n    vec4 color;\\n    bool found;\\n};\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform sampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nvec4 get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return texture(tex[0], uv.xy);\\n    } else if (idx_texture == 1) {\\n        return texture(tex[1], uv.xy);\\n    } else if (idx_texture == 2) {\\n        return texture(tex[2], uv.xy);\\n    } else {\\n        return vec4(0.0, 1.0, 1.0, 1.0);\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nvec4 get_color_from_texture(vec3 UV) {\\n    return get_pixels(UV);\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv).r;\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\nconst float TWICE_PI = 6.28318530718f;\\nconst float PI = 3.141592653589793f;\\nconst float FOUR_OVER_PI = 1.27323954474f;\\nconst float TRANSITION_Z = 0.66666666666f;\\nconst float TRANSITION_Z_INV = 1.5f;\\n\\nint quarter(vec2 p) {\\n    int x_neg = int(p.x < 0.0f);\\n    int y_neg = int(p.y < 0.0f);\\n    int q = (x_neg + y_neg) | (y_neg << 1);\\n    return q;\\n}\\n\\nfloat xpm1(vec2 p) {\\n    bool x_neg = (p.x < 0.0f);\\n    //debug_assert!(x_neg <= 1);\\n    bool y_neg = (p.y < 0.0f);\\n    //debug_assert!(y_neg <= 1);\\n    // The purpose it to have the same numerical precision for each base cell\\n    // by avoiding subtraction by 1 or 3 or 5 or 7\\n    float lon = atan(abs(p.y), abs(p.x));\\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\\n    float x02 = lon * FOUR_OVER_PI;\\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\\n        return 1.0f - x02;\\n    } else {\\n        return x02 - 1.0f;\\n    }\\n}\\n\\nfloat one_minus_z_pos(vec3 p) {\\n    //debug_assert!(z > 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n\\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return 1.0f - p.z;\\n}\\n\\nfloat one_minus_z_neg(vec3 p) {\\n    //debug_assert!(z < 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\\n        // 0.5 * d2 + 0.125 * d2 * d2\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return p.z + 1.0f;\\n}\\n\\n// Z-Order curve projection.\\nint ij2z(int i, int j) {\\n    int i1 = i | (j << 16);\\n\\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\\n    int i2 = i1 ^ j1 ^ (j1 << 8);\\n\\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\\n    int i3 = i2 ^ j2 ^ (j2 << 4);\\n\\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\\n    int i4 = i3 ^ j3 ^ (j3 << 2);\\n\\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\\n    int i5 = i4 ^ j4 ^ (j4 << 1);\\n\\n    return i5;\\n}\\n\\nstruct HashDxDy {\\n    int idx;\\n    float dx;\\n    float dy;\\n};\\n\\nuniform sampler2D ang2pixd;\\nHashDxDy hash_with_dxdy2(vec2 radec) {\\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\\n    vec3 v = texture(ang2pixd, aa).rgb;\\n    return HashDxDy(\\n        int(v.x * 255.0),\\n        v.y,\\n        v.z\\n    );\\n}\\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \\n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\\n// respect to the origin of the cell (South vertex).\\n// # Inputs:\\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\\n// - `x`: in `[-1.0, 1.0]`\\n// - `y`: in `[-1.0, 1.0]`\\n// - `z`: in `[-1.0, 1.0]`\\n// # Output\\n// - the cell number (hash value) associated with the given position on the unit sphere,\\n//   in `[0, 12*nside^2[`\\n// - `dx`: the positional offset $\\\\in [0, 1[$ along the south-to-east axis\\n// - `dy`: the positional offset $\\\\in [0, 1[$ along the south-to-west axis\\n// # WARNING\\n// - The function assumes, without checking, that the input vector is a unit vector \\n//   (hence `x^2 + y^2 + z^2 = 1`) !!\\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\\n    //assert!(depth <= 14);\\n    //assert!(-1.0 <= x && x <= 1.0);\\n    //assert!(-1.0 <= y && y <= 1.0);\\n    //assert!(-1.0 <= z && z <= 1.0);\\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\\n    // A f32 mantissa contains 23 bits.\\n    // - it basically means that when storing (x, y) coordinates,\\n    //   we can go as deep as depth 24 (or maybe 25)\\n    \\n    int nside = 1 << depth;\\n    float half_nside = float(nside) * 0.5f;\\n\\n    float x_pm1 = xpm1(p.xy);\\n    int q = quarter(p.xy);\\n\\n    int d0h = 0;\\n    vec2 p_proj = vec2(0.f);\\n    if (p.z > TRANSITION_Z) {\\n        // North polar cap, Collignon projection.\\n        // - set the origin to (PI/4, 0)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\\n        d0h = q;\\n    } else if (p.z < -TRANSITION_Z) {\\n        // South polar cap, Collignon projection\\n        // - set the origin to (PI/4, -PI/2)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\\n        d0h = q + 8;\\n    } else {\\n        // Equatorial region, Cylindrical equal area projection\\n        // - set the origin to (PI/4, 0)               if q = 2\\n        // - set the origin to (PI/4, -PI/2)           if q = 0\\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\\n        // let zero_or_one = (x_cea as u8) & 1;\\n        float y_pm1 = p.z * TRANSITION_Z_INV;\\n        // |\\\\2/|\\n        // .3X1.\\n        // |/0\\\\|\\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\\n        //debug_assert!(q01 == 0 || q01 == 1);\\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\\\1\\n        //debug_assert!(q12 == 0 || q12 == 1);\\n        int q03 = 1 - q12; // 1\\\\0\\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\\n        int q1 = q01 & q12; // = 1 if q1, 0 else\\n        //debug_assert!( q1 == 0 ||  q1 == 1);\\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \\n        //let y_proj = y_pm1 + (q01 + q03) as f32;\\n        p_proj = vec2(\\n            x_pm1 - float(q01 + q12 - 1),\\n            y_pm1 + float(q01 + q03)\\n        );\\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\\n    }\\n\\n    // Coords inside the base cell\\n    float x = (half_nside * (p_proj.x + p_proj.y));\\n    float y = (half_nside * (p_proj.y - p_proj.x));\\n    int i = int(x);\\n    int j = int(y);\\n\\n    return HashDxDy(\\n        (d0h << (depth << 1)) | ij2z(i, j),\\n        x - float(i),\\n        y - float(j)\\n    );\\n}\\n\\nTileColor get_tile_color(vec3 pos) {\\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\\n\\n    int idx = result.idx;\\n    vec2 uv = vec2(result.dy, result.dx);\\n\\n    Tile tile = textures_tiles[idx];\\n\\n    int idx_texture = tile.texture_idx >> 6;\\n    int off = tile.texture_idx & 0x3F;\\n    float idx_row = float(off >> 3); // in [0; 7]\\n    float idx_col = float(off & 0x7); // in [0; 7]\\n\\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\\n    vec3 UV = vec3(offset, float(idx_texture));\\n\\n    vec4 color = mix(get_colormap_from_grayscale_texture(UV), blank_color, float(tile.empty));\\n    return TileColor(tile, color, true);\\n}\\n\\nconst float duration = 500.f; // 500ms\\nuniform int max_depth; // max depth of the HiPS\\n\\nvoid main() {\\n    vec3 frag_pos = normalize(out_vert_pos);\\n    // Get the HEALPix cell idx and the uv in the texture\\n\\n    TileColor current_tile = get_tile_color(frag_pos);\\n    out_frag_color = current_tile.color;\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp sampler2D;\\nprecision highp isampler2D;\\nprecision highp int;\\n\\nin vec3 out_vert_pos;\\nin vec2 pos_clip;\\nin vec2 out_lonlat;\\n\\nout vec4 out_frag_color;\\n\\nuniform int user_action;\\n\\nstruct Tile {\\n    int uniq; // Healpix cell\\n    int texture_idx; // Index in the texture buffer\\n    float start_time; // Absolute time that the load has been done in ms\\n    int empty;\\n};\\n\\nuniform int current_depth;\\n\\nuniform Tile textures_tiles[12];\\n\\nuniform float opacity;\\nuniform float current_time; // current time in ms\\nstruct TileColor {\\n    Tile tile;\\n    vec4 color;\\n    bool found;\\n};\\n\\n//const int MAX_NUM_TEX = 3;\\nuniform isampler2D tex[3];\\nuniform int num_tex;\\n\\nuniform float scale;\\nuniform float offset;\\nuniform float blank;\\n\\nuniform float min_value;\\nuniform float max_value;\\nuniform int H;\\n\\nuniform float size_tile_uv;\\n\\nuniform float tex_storing_integers;\\nuniform int tex_storing_fits;\\n\\n// Blue & Pastel & Red\\nfloat colormap_red(float x) {\\n    if (x < 0.1131206452846527) {\\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\\n    } else if (x < 0.5116005837917328) {\\n        return 0.0;\\n    } else if (x < 0.5705677568912506) {\\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\\n    } else if (x < 0.622047244) {\\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\\n    } else if (x < 0.7922459542751312) {\\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\\n    } else {\\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 0.114394336938858) {\\n        return 0.0;\\n    } else if (x < 0.4417250454425812) {\\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\\n    } else if (x < 0.4964917968308496) {\\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\\n    } else if (x < 0.6259051214039278) {\\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\\n    } else if (x < 0.8049814403057098) {\\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\\n    } else {\\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.4424893036638088) {\\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\\n    } else if (x < 0.5) {\\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\\n    } else if (x < 0.5691165986930345) {\\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\\n    } else if (x < 0.6279306709766388) {\\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\\n    } else {\\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\\n    }\\n}\\n\\nvec4 bluepastelred_f(float x) {\\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n\\n// Red\\nfloat c_red(float x) {\\n    return 1.448953446096850 * x - 5.02253539008443e-1;\\n}\\n\\nfloat c_green(float x) {\\n    return 1.889376646180860 * x - 2.272028094820020e2;\\n}\\n\\nfloat c_blue(float x) {\\n    return 3.92613636363636 * x - 7.46528409090909e+2;\\n}\\n\\nvec4 red_f(float x) {\\n    float t = x * 255.0;\\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\\n\\n    return vec4(r, g, b, 1.0);\\n}\\n// Gray\\nvec4 blackw_f(float x) {\\n    float d = clamp(x, 0.0, 1.0);\\n    return vec4(d, d, d, 1.0);\\n}\\n// IDLCBGnBu\\nfloat cbgnbu_red(float x) {\\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\\n    if (v < 8.0) {\\n        return 8.0;\\n    } else {\\n        return v;\\n    }\\n}\\n\\nfloat cbgnbu_green(float x) {\\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\\n}\\n\\nfloat cbgnbu_blue(float x) {\\n    if (x < 0.3756393599187693) {\\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\\n    } else if (x < 0.6215448666633865) {\\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\\n    } else if (x < 0.8830064316178203) {\\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\\n    } else {\\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\\n    }\\n}\\n\\nvec4 cbgnbu_f(float x) {\\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBYIGnBu\\nfloat CBYIGnBu_red(float x) {\\n    if (x < 0.2523055374622345) {\\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\\n    } else if (x < 0.6267540156841278) {\\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\\n    } else if (x < 0.8763731146612115) {\\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\\n    } else {\\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\\n    }\\n}\\n\\nfloat CBYIGnBu_green(float x) {\\n    if (x < 0.4578040540218353) {\\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\\n    } else {\\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\\n    }\\n}\\n\\nfloat CBYIGnBu_blue(float x) {\\n    if (x < 0.1239372193813324) {\\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\\n    } else if (x < 0.7535201013088226) {\\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\\n    } else {\\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\\n    }\\n}\\n\\nvec4 CBYIGnBu_f(float x) {\\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\n// IDLCBBrBG\\nfloat cbbrbg_red(float x) {\\n    if (x < 0.4128910005092621) {\\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\\n    } else if (x < 0.5004365747118258) {\\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\\n    } else if (x < 0.6000321805477142) {\\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\\n    } else {\\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\\n    }\\n}\\n\\nfloat cbbrbg_green(float x) {\\n    if (x < 0.3067105114459991) {\\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\\n    } else if (x < 0.4045854562297116) {\\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\\n    } else if (x < 0.5035906732082367) {\\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\\n    } else {\\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\\n    }\\n}\\n\\nfloat cbbrbg_blue(float x) {\\n    if (x < 0.1012683545126085) {\\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\\n    } else if (x < 0.2050940692424774) {\\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\\n    } else if (x < 0.5022056996822357) {\\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\\n    } else if (x < 0.5970333516597748) {\\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\\n    } else {\\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\\n    }\\n}\\n\\nvec4 cbbrbg_f(float x) {\\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\\n    return vec4(r, g, b, 1.0);\\n}\\nuniform int colormap;\\n/*\\nBlackWhiteLinear = 0,\\nRedTemperature = 1,\\nIDLCBGnBu = 2,\\nIDLCBYIGnBu = 3,\\nBluePastelRed = 4,\\nIDLCBBrBG = 5,\\n*/\\nvec4 colormap_f(float x) {\\n    // BlackWhiteLinear = 0,\\n    if (colormap == 0) {\\n        return blackw_f(x);\\n    // RedTemperature = 1,\\n    } else if (colormap == 1) {\\n        return red_f(x);\\n    // IDLCBGnBu = 2,\\n    } else if (colormap == 2) {\\n        return cbgnbu_f(x);\\n    // IDLCBYIGnBu = 3,\\n    } else if (colormap == 3) {\\n        return CBYIGnBu_f(x);\\n    // BluePastelRed = 4,\\n    } else if (colormap == 4) {\\n        return bluepastelred_f(x);\\n    // IDLCBBrBG = 5,\\n    } else {\\n        return cbbrbg_f(x);\\n    }\\n}\\nfloat linear_f(float x, float min_value, float max_value) {\\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\\n}\\n\\nfloat sqrt_f(float x, float min_value, float max_value) {\\n    float a = linear_f(x, min_value, max_value);\\n    return sqrt(a);\\n}\\n\\nfloat log_f(float x, float min_value, float max_value) {\\n    float y = linear_f(x, min_value, max_value);\\n    float a = 1000.0;\\n    return log(a*y + 1.0)/log(a);\\n}\\n\\nfloat asinh_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return asinh(10.0*d)/3.0;\\n}\\n\\nfloat pow2_f(float x, float min_value, float max_value) {\\n    float d = linear_f(x, min_value, max_value);\\n    return d*d;\\n}\\n\\nfloat transfer_func(int H, float x, float min_value, float max_value) {\\n    if (H == 0) {\\n        return linear_f(x, min_value, max_value);\\n    } else if (H == 1) {\\n        return sqrt_f(x, min_value, max_value);\\n    } else if (H == 2) {\\n        return log_f(x, min_value, max_value);\\n    } else if (H == 3) {\\n        return asinh_f(x, min_value, max_value);\\n    } else {\\n        return pow2_f(x, min_value, max_value);\\n    }\\n}\\n\\nfloat get_pixels(vec3 uv) {\\n    int idx_texture = int(uv.z);\\n    if (idx_texture == 0) {\\n        return float(texture(tex[0], uv.xy).r);\\n    } else if (idx_texture == 1) {\\n        return float(texture(tex[1], uv.xy).r);\\n    } else if (idx_texture == 2) {\\n        return float(texture(tex[2], uv.xy).r);\\n    } else {\\n        return 0.0;\\n    }\\n}\\n\\nvec3 reverse_uv(vec3 uv) {\\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\\n\\n    return uv;\\n}\\n\\nuniform vec4 blank_color;\\n\\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return colormap_f(h);\\n    }\\n}\\n\\nuniform vec3 C;\\nuniform float K;\\nvec4 get_color_from_grayscale_texture(vec3 UV) {\\n    vec3 uv = UV;\\n    // FITS data pixels are reversed along the y axis\\n    if (tex_storing_fits == 1) {\\n        uv = reverse_uv(uv);\\n    }\\n\\n    float x = get_pixels(uv);\\n    if (x == blank) {\\n        return blank_color;\\n    } else {\\n        float alpha = x * scale + offset;\\n        float h = transfer_func(H, alpha, min_value, max_value);\\n\\n        return vec4(C * K * h, 1.0);\\n    }\\n}\\nconst float TWICE_PI = 6.28318530718f;\\nconst float PI = 3.141592653589793f;\\nconst float FOUR_OVER_PI = 1.27323954474f;\\nconst float TRANSITION_Z = 0.66666666666f;\\nconst float TRANSITION_Z_INV = 1.5f;\\n\\nint quarter(vec2 p) {\\n    int x_neg = int(p.x < 0.0f);\\n    int y_neg = int(p.y < 0.0f);\\n    int q = (x_neg + y_neg) | (y_neg << 1);\\n    return q;\\n}\\n\\nfloat xpm1(vec2 p) {\\n    bool x_neg = (p.x < 0.0f);\\n    //debug_assert!(x_neg <= 1);\\n    bool y_neg = (p.y < 0.0f);\\n    //debug_assert!(y_neg <= 1);\\n    // The purpose it to have the same numerical precision for each base cell\\n    // by avoiding subtraction by 1 or 3 or 5 or 7\\n    float lon = atan(abs(p.y), abs(p.x));\\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\\n    float x02 = lon * FOUR_OVER_PI;\\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\\n        return 1.0f - x02;\\n    } else {\\n        return x02 - 1.0f;\\n    }\\n}\\n\\nfloat one_minus_z_pos(vec3 p) {\\n    //debug_assert!(z > 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n\\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return 1.0f - p.z;\\n}\\n\\nfloat one_minus_z_neg(vec3 p) {\\n    //debug_assert!(z < 0.0);\\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\\n        // 0.5 * d2 + 0.125 * d2 * d2\\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\\n    }\\n    return p.z + 1.0f;\\n}\\n\\n// Z-Order curve projection.\\nint ij2z(int i, int j) {\\n    int i1 = i | (j << 16);\\n\\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\\n    int i2 = i1 ^ j1 ^ (j1 << 8);\\n\\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\\n    int i3 = i2 ^ j2 ^ (j2 << 4);\\n\\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\\n    int i4 = i3 ^ j3 ^ (j3 << 2);\\n\\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\\n    int i5 = i4 ^ j4 ^ (j4 << 1);\\n\\n    return i5;\\n}\\n\\nstruct HashDxDy {\\n    int idx;\\n    float dx;\\n    float dy;\\n};\\n\\nuniform sampler2D ang2pixd;\\nHashDxDy hash_with_dxdy2(vec2 radec) {\\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\\n    vec3 v = texture(ang2pixd, aa).rgb;\\n    return HashDxDy(\\n        int(v.x * 255.0),\\n        v.y,\\n        v.z\\n    );\\n}\\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \\n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\\n// respect to the origin of the cell (South vertex).\\n// # Inputs:\\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\\n// - `x`: in `[-1.0, 1.0]`\\n// - `y`: in `[-1.0, 1.0]`\\n// - `z`: in `[-1.0, 1.0]`\\n// # Output\\n// - the cell number (hash value) associated with the given position on the unit sphere,\\n//   in `[0, 12*nside^2[`\\n// - `dx`: the positional offset $\\\\in [0, 1[$ along the south-to-east axis\\n// - `dy`: the positional offset $\\\\in [0, 1[$ along the south-to-west axis\\n// # WARNING\\n// - The function assumes, without checking, that the input vector is a unit vector \\n//   (hence `x^2 + y^2 + z^2 = 1`) !!\\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\\n    //assert!(depth <= 14);\\n    //assert!(-1.0 <= x && x <= 1.0);\\n    //assert!(-1.0 <= y && y <= 1.0);\\n    //assert!(-1.0 <= z && z <= 1.0);\\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\\n    // A f32 mantissa contains 23 bits.\\n    // - it basically means that when storing (x, y) coordinates,\\n    //   we can go as deep as depth 24 (or maybe 25)\\n    \\n    int nside = 1 << depth;\\n    float half_nside = float(nside) * 0.5f;\\n\\n    float x_pm1 = xpm1(p.xy);\\n    int q = quarter(p.xy);\\n\\n    int d0h = 0;\\n    vec2 p_proj = vec2(0.f);\\n    if (p.z > TRANSITION_Z) {\\n        // North polar cap, Collignon projection.\\n        // - set the origin to (PI/4, 0)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\\n        d0h = q;\\n    } else if (p.z < -TRANSITION_Z) {\\n        // South polar cap, Collignon projection\\n        // - set the origin to (PI/4, -PI/2)\\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\\n        d0h = q + 8;\\n    } else {\\n        // Equatorial region, Cylindrical equal area projection\\n        // - set the origin to (PI/4, 0)               if q = 2\\n        // - set the origin to (PI/4, -PI/2)           if q = 0\\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\\n        // let zero_or_one = (x_cea as u8) & 1;\\n        float y_pm1 = p.z * TRANSITION_Z_INV;\\n        // |\\\\2/|\\n        // .3X1.\\n        // |/0\\\\|\\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\\n        //debug_assert!(q01 == 0 || q01 == 1);\\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\\\1\\n        //debug_assert!(q12 == 0 || q12 == 1);\\n        int q03 = 1 - q12; // 1\\\\0\\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\\n        int q1 = q01 & q12; // = 1 if q1, 0 else\\n        //debug_assert!( q1 == 0 ||  q1 == 1);\\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \\n        //let y_proj = y_pm1 + (q01 + q03) as f32;\\n        p_proj = vec2(\\n            x_pm1 - float(q01 + q12 - 1),\\n            y_pm1 + float(q01 + q03)\\n        );\\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\\n    }\\n\\n    // Coords inside the base cell\\n    float x = (half_nside * (p_proj.x + p_proj.y));\\n    float y = (half_nside * (p_proj.y - p_proj.x));\\n    int i = int(x);\\n    int j = int(y);\\n\\n    return HashDxDy(\\n        (d0h << (depth << 1)) | ij2z(i, j),\\n        x - float(i),\\n        y - float(j)\\n    );\\n}\\n\\nTileColor get_tile_color(vec3 pos) {\\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\\n\\n    int idx = result.idx;\\n\\n    vec2 uv = vec2(result.dy, result.dx);\\n\\n    Tile tile = textures_tiles[idx];\\n\\n    int idx_texture = tile.texture_idx >> 6;\\n    int off = tile.texture_idx & 0x3F;\\n    float idx_row = float(off >> 3); // in [0; 7]\\n    float idx_col = float(off & 0x7); // in [0; 7]\\n\\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\\n    vec3 UV = vec3(offset, float(idx_texture));\\n\\n    vec4 color = mix(get_colormap_from_grayscale_texture(UV), blank_color, float(tile.empty));\\n    return TileColor(tile, color, true);\\n}\\n\\nconst float duration = 500.f; // 500ms\\nuniform int max_depth; // max depth of the HiPS\\n\\nvoid main() {\\n    vec3 frag_pos = normalize(out_vert_pos);\\n    // Get the HEALPix cell idx and the uv in the texture\\n\\n    TileColor current_tile = get_tile_color(frag_pos);\\n    out_frag_color = current_tile.color;\\n    out_frag_color.a = out_frag_color.a * opacity;\\n}\"","module.exports = \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n\\nlayout (location = 0) in vec2 pos_clip_space;\\nlayout (location = 1) in vec2 lonlat;\\nlayout (location = 2) in vec3 pos_world_space;\\n\\nout vec3 out_vert_pos;\\nout vec2 out_lonlat;\\n\\nuniform mat4 model;\\nuniform vec2 ndc_to_clip;\\nuniform float czf;\\n\\nvoid main() {\\n    gl_Position = vec4(pos_clip_space / (ndc_to_clip * czf), 0.0, 1.0);\\n    //out_vert_pos = vec3(inverse(gal_to_icrs) * model * vec4(pos_world_space, 1.f));\\n    out_vert_pos = vec3(model * vec4(pos_world_space, 1.f));\\n    out_lonlat = vec2(atan(out_vert_pos.x, out_vert_pos.z), asin(out_vert_pos.y));\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nprecision lowp sampler2DArray;\\n\\nuniform vec4 text_color;\\nuniform sampler2DArray font_textures;\\n\\nin vec3 out_uv;\\nout vec4 color;\\n\\nvoid main() {\\n    vec3 uv = vec3(out_uv.x, 1.f - out_uv.y, out_uv.z);\\n    vec4 mask = texture(font_textures, uv);\\n    color = text_color * mask;\\n    //color = vec4(1.0, 0.0, 0.0, 1.0);\\n}\"","module.exports = \"#version 300 es\\nprecision lowp float;\\nprecision lowp sampler2DArray;\\n\\nlayout (location = 0) in vec2 pos;\\nlayout (location = 1) in vec2 uv;\\n// Per instance attributes\\nlayout (location = 2) in vec2 center_letter;\\nlayout (location = 3) in vec2 size_letter;\\nlayout (location = 4) in vec2 pos_uv;\\nlayout (location = 5) in vec2 size_uv;\\nlayout (location = 6) in float idx_page;\\n\\nout vec3 out_uv;\\n\\nuniform vec2 window_size;\\nuniform float scaling;\\n\\nvec2 screen_to_ndc(vec2 p) {\\n    // Change of origin\\n    vec2 origin = p - window_size/2.0;\\n\\n    // Scale to fit in [-1, 1]\\n    return vec2(2.0 * (origin.x/window_size.x), -2.0 * (origin.y/window_size.y));\\n}\\n\\nvoid main() {\\n    vec2 ndc_pos = screen_to_ndc(center_letter + pos*32.0);\\n\\n    gl_Position = vec4(ndc_pos, 0.f, 1.f);\\n    out_uv = vec3(uv, idx_page);\\n}\"","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Aladin.js (main class)\n * Facade to expose Aladin Lite methods\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { View } from \"./View.js\";\nimport { MOC } from \"./MOC.js\";\nimport { Utils } from \"./Utils.js\";\nimport { Overlay } from \"./Overlay.js\";\nimport { Footprint } from \"./Footprint.js\";\nimport { Circle } from \"./Circle.js\";\nimport { Ellipse } from \"./Ellipse.js\";\nimport { Polyline } from \"./Polyline.js\";\nimport { AladinUtils } from \"./AladinUtils.js\";\nimport { Logger } from \"./Logger.js\";\nimport { Catalog } from \"./Catalog.js\";\nimport { ProgressiveCat } from \"./ProgressiveCat.js\";\nimport { Sesame } from \"./Sesame.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\nimport { MeasurementTable } from \"./MeasurementTable.js\";\nimport { Location } from \"./Location.js\";\nimport { Source } from \"./Source.js\";\nimport { HpxImageSurvey } from \"./HpxImageSurvey.js\";\nimport { Coo } from \"./libs/astro/coo.js\";\nimport { CooConversion } from \"./CooConversion.js\";\nimport { Color } from \"./Color.js\";\nimport { ColorMap } from \"./ColorMap.js\";\nimport { URLBuilder } from \"./URLBuilder.js\";\nimport { HiPSDefinition } from \"./HiPSDefinition.js\";\nimport { DiscoveryTree } from \"./DiscoveryTree.js\";\nimport { ImageSurveyLayer } from \"./ImageSurveyLayer.js\";\n\nexport let Aladin = (function () {\n\n    // Constructor\n    var Aladin = function (aladinDiv, requestedOptions) {\n        // check that aladinDiv exists, stop immediately otherwise\n        if ($(aladinDiv).length == 0) {\n            return;\n        }\n        this.webglAPI = null;\n\n        var self = this;\n\n        // if not options was set, try to retrieve them from the query string\n        if (requestedOptions === undefined) {\n            requestedOptions = this.getOptionsFromQueryString();\n        }\n        requestedOptions = requestedOptions || {};\n\n\n        // 'fov' option was previsouly called 'zoom'\n        if ('zoom' in requestedOptions) {\n            var fovValue = requestedOptions.zoom;\n            delete requestedOptions.zoom;\n            requestedOptions.fov = fovValue;\n        }\n        // merge with default options\n        var options = {};\n        for (var key in Aladin.DEFAULT_OPTIONS) {\n            if (requestedOptions[key] !== undefined) {\n                options[key] = requestedOptions[key];\n            }\n            else {\n                options[key] = Aladin.DEFAULT_OPTIONS[key];\n            }\n        }\n        for (var key in requestedOptions) {\n            if (Aladin.DEFAULT_OPTIONS[key] === undefined) {\n                options[key] = requestedOptions[key];\n            }\n        }\n\n        this.options = options;\n\n        $(\"<style type='text/css'> .aladin-reticleColor { color: \" + this.options.reticleColor + \"; font-weight:bold;} </style>\").appendTo(aladinDiv);\n\n\n\n        this.aladinDiv = aladinDiv;\n\n        this.reduceDeformations = true;\n\n        // parent div\n        $(aladinDiv).addClass(\"aladin-container\");\n\n\n        var cooFrame = CooFrameEnum.fromString(options.cooFrame, CooFrameEnum.J2000);\n        // locationDiv is the div where we write the position\n        var locationDiv = $('<div class=\"aladin-location\">'\n            + (options.showFrame ? '<select class=\"aladin-frameChoice\"><option value=\"' + CooFrameEnum.J2000.label + '\" '\n                + (cooFrame == CooFrameEnum.J2000 ? 'selected=\"selected\"' : '') + '>J2000</option><option value=\"' + CooFrameEnum.J2000d.label + '\" '\n                + (cooFrame == CooFrameEnum.J2000d ? 'selected=\"selected\"' : '') + '>J2000d</option><option value=\"' + CooFrameEnum.GAL.label + '\" '\n                + (cooFrame == CooFrameEnum.GAL ? 'selected=\"selected\"' : '') + '>GAL</option></select>' : '')\n            + '<span class=\"aladin-location-text\"></span></div>')\n            .appendTo(aladinDiv);\n        // div where FoV value is written\n        var fovDiv = $('<div class=\"aladin-fov\"></div>').appendTo(aladinDiv);\n\n\n        // zoom control\n        if (options.showZoomControl) {\n            $('<div class=\"aladin-zoomControl\"><a href=\"#\" class=\"zoomPlus\" title=\"Zoom in\">+</a><a href=\"#\" class=\"zoomMinus\" title=\"Zoom out\">&ndash;</a></div>').appendTo(aladinDiv);\n        }\n\n        // maximize control\n        if (options.showFullscreenControl) {\n            $('<div class=\"aladin-fullscreenControl aladin-maximize\" title=\"Full screen\"></div>')\n                .appendTo(aladinDiv);\n        }\n        this.fullScreenBtn = $(aladinDiv).find('.aladin-fullscreenControl')\n        this.fullScreenBtn.click(function () {\n            self.toggleFullscreen(self.options.realFullscreen);\n        });\n        // react to fullscreenchange event to restore initial width/height (if user pressed ESC to go back from full screen)\n        $(document).on('fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange', function (e) {\n            var fullscreenElt = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n            if (fullscreenElt === null || fullscreenElt === undefined) {\n                self.fullScreenBtn.removeClass('aladin-restore');\n                self.fullScreenBtn.addClass('aladin-maximize');\n                self.fullScreenBtn.attr('title', 'Full screen');\n                $(self.aladinDiv).removeClass('aladin-fullscreen');\n\n                var fullScreenToggledFn = self.callbacksByEventName['fullScreenToggled'];\n                var isInFullscreen = self.fullScreenBtn.hasClass('aladin-restore');\n                (typeof fullScreenToggledFn === 'function') && fullScreenToggledFn(isInFullscreen);\n            }\n        });\n\n\n\n\n\n        // Aladin logo\n        $(\"<div class='aladin-logo-container'><a href='https://aladin.unistra.fr/' title='Powered by Aladin Lite' target='_blank'><div class='aladin-logo'></div></a></div>\").appendTo(aladinDiv);\n\n\n        // we store the boxes\n        this.boxes = [];\n\n        // measurement table\n        this.measurementTable = new MeasurementTable(aladinDiv);\n\n\n\n        var location = new Location(locationDiv.find('.aladin-location-text'));\n\n        // set different options\n        this.view = new View(this, location, fovDiv, cooFrame, options.fov);\n        this.view.setShowGrid(options.showCooGrid);\n\n        // retrieve available surveys\n        // TODO: replace call with MocServer\n        /*$.ajax({\n            url: \"//aladin.unistra.fr/java/nph-aladin.pl\",\n            data: { \"frame\": \"aladinLiteDic\" },\n            method: 'GET',\n            dataType: 'jsonp', // could this be repaced by json ??\n            success: function (data) {\n                var map = {};\n                for (var k = 0; k < data.length; k++) {\n                    map[data[k].id] = true;\n                }\n                // retrieve existing surveys\n                for (var k = 0; k < HpxImageSurvey.SURVEYS.length; k++) {\n                    if (!map[HpxImageSurvey.SURVEYS[k].id]) {\n                        data.push(HpxImageSurvey.SURVEYS[k]);\n                    }\n                }\n                HpxImageSurvey.SURVEYS = data;\n                self.view.setUnknownSurveyIfNeeded();\n            },\n            error: function () {\n            }\n        });*/\n\n        // layers control panel\n        // TODO : valeur des checkbox en fonction des options\n        // TODO : classe LayerBox\n        if (options.showLayersControl) {\n            var d = $('<div class=\"aladin-layersControl-container\" title=\"Manage layers\"><div class=\"aladin-layersControl\"></div></div>');\n            d.appendTo(aladinDiv);\n\n            var layerBox = $('<div class=\"aladin-box aladin-layerBox aladin-cb-list\"></div>');\n            layerBox.appendTo(aladinDiv);\n\n            this.boxes.push(layerBox);\n\n            // we return false so that the default event is not submitted, and to prevent event bubbling\n            d.click(function () { self.hideBoxes(); self.showLayerBox(); return false; });\n\n        }\n\n\n        // goto control panel\n        if (options.showGotoControl) {\n            var d = $('<div class=\"aladin-gotoControl-container\" title=\"Go to position\"><div class=\"aladin-gotoControl\"></div></div>');\n            d.appendTo(aladinDiv);\n\n            var gotoBox =\n                $('<div class=\"aladin-box aladin-gotoBox\">' +\n                    '<a class=\"aladin-closeBtn\">&times;</a>' +\n                    '<div style=\"clear: both;\"></div>' +\n                    '<form class=\"aladin-target-form\">Go to: <input type=\"text\" placeholder=\"Object name/position\" /></form></div>');\n            gotoBox.appendTo(aladinDiv);\n            this.boxes.push(gotoBox);\n\n            var input = gotoBox.find('.aladin-target-form input');\n            input.on(\"paste keydown\", function () {\n                $(this).removeClass('aladin-unknownObject'); // remove red border\n            });\n\n            // TODO : classe GotoBox\n            d.click(function () {\n                self.hideBoxes();\n                input.val('');\n                input.removeClass('aladin-unknownObject');\n                gotoBox.show();\n                input.focus();\n\n\n                return false;\n            });\n            gotoBox.find('.aladin-closeBtn').click(function () { self.hideBoxes(); return false; });\n        }\n\n        // simbad pointer tool\n        if (options.showSimbadPointerControl) {\n            var d = $('<div class=\"aladin-simbadPointerControl-container\" title=\"SIMBAD pointer\"><div class=\"aladin-simbadPointerControl\"></div></div>');\n            d.appendTo(aladinDiv);\n\n            d.click(function () {\n                self.view.setMode(View.TOOL_SIMBAD_POINTER);\n            });\n        }\n\n        // share control panel\n        if (options.showShareControl) {\n            var d = $('<div class=\"aladin-shareControl-container\" title=\"Get link for current view\"><div class=\"aladin-shareControl\"></div></div>');\n            d.appendTo(aladinDiv);\n\n            var shareBox =\n                $('<div class=\"aladin-box aladin-shareBox\">' +\n                    '<a class=\"aladin-closeBtn\">&times;</a>' +\n                    '<div style=\"clear: both;\"></div>' +\n                    'Link to previewer: <span class=\"info\"></span>' +\n                    '<input type=\"text\" class=\"aladin-shareInput\" />' +\n                    '</div>');\n            shareBox.appendTo(aladinDiv);\n            this.boxes.push(shareBox);\n\n\n            // TODO : classe GotoBox, GenericBox\n            d.click(function () {\n                self.hideBoxes();\n                shareBox.show();\n                var url = self.getShareURL();\n                shareBox.find('.aladin-shareInput').val(url).select();\n                document.execCommand('copy');\n\n                return false;\n            });\n            shareBox.find('.aladin-closeBtn').click(function () { self.hideBoxes(); return false; });\n        }\n\n\n        this.gotoObject(options.target, undefined, {forceAnimation: false});\n\n        if (options.log) {\n            var params = requestedOptions;\n            params['version'] = Aladin.VERSION;\n            Logger.log(\"startup\", params);\n        }\n\n        this.showReticle(options.showReticle);\n\n        if (options.catalogUrls) {\n            for (var k = 0, len = options.catalogUrls.length; k < len; k++) {\n                this.createCatalogFromVOTable(options.catalogUrls[k]);\n            }\n        }\n        \n        /*let webglAPI = await import('../render/pkg/');\n        console.log('webgl imported');\n        let shaders = await loadShaders(webglAPI);\n        console.log(shaders);\n    \n        // Start our Rust application. You can find `WebClient` in `src/lib.rs`\n        let resources = {\n            'kernel': kernel,\n        };\n        Aladin.wasmLibs.webglAPI = new webglAPI.WebClient(shaders, resources);\n        let webgl = Aladin.wasmLibs.webglAPI;\n        webgl.resize(500, 400);*/\n\n        /*let imageSurveyInfo = HpxImageSurvey.getSurveyInfoFromId(options.survey);\n        console.log('image survey, ', imageSurveyInfo)\n        webgl.setImageSurvey(imageSurveyInfo);*/\n        // Add the image layers\n        // For that we check the survey key of options\n        // It can be given as a single string or an array of strings\n        // for multiple blending surveys\n        if (options.survey) {\n            (async () => {\n                if (typeof options.survey === Array) {\n                    let i = 0;\n                    options.survey.forEach(async (rootUrlOrId) => {\n                        const survey = await Aladin.createImageSurvey(rootUrlOrId);\n                        if (i == 0) {\n                            this.setImageSurvey(survey, \"base\");\n                        } else {\n                            this.addImageSurvey(survey, \"base\");\n                        }\n                        i++;\n                    });\n                } else {\n                    const survey = await Aladin.createImageSurvey(options.survey, \"base\");\n                    this.setImageSurvey(survey, \"base\");\n                }\n            })();\n\n        }\n        this.view.showCatalog(options.showCatalog);\n\n\n        var aladin = this;\n        $(aladinDiv).find('.aladin-frameChoice').change(function () {\n            aladin.setFrame($(this).val());\n        });\n\n\n        $(aladinDiv).find('.aladin-target-form').submit(function () {\n            aladin.gotoObject($(this).find('input').val(), function () {\n                $(aladinDiv).find('.aladin-target-form input').addClass('aladin-unknownObject');\n            });\n            return false;\n        });\n\n        var zoomPlus = $(aladinDiv).find('.zoomPlus');\n        zoomPlus.click(function () {\n            aladin.increaseZoom();\n            return false;\n        });\n        zoomPlus.bind('mousedown', function (e) {\n            e.preventDefault(); // to prevent text selection\n        });\n\n        var zoomMinus = $(aladinDiv).find('.zoomMinus');\n        zoomMinus.click(function () {\n            aladin.decreaseZoom();\n            return false;\n        });\n        zoomMinus.bind('mousedown', function (e) {\n            e.preventDefault(); // to prevent text selection\n        });\n\n\n\n        this.callbacksByEventName = {}; // we store the callback functions (on 'zoomChanged', 'positionChanged', ...) here\n\n        // initialize the Vue components\n        if (typeof Vue != \"undefined\") {\n            //Vue.component(\"layers\", Layers)\n            this.discoverytree = new DiscoveryTree(this);\n        }\n\n        this.view.redraw();\n\n        // go to full screen ?\n        if (options.fullScreen) {\n            // strange behaviour to wait for a sec\n            window.setTimeout(function () { self.toggleFullscreen(self.options.realFullscreen); }, 10);\n        }\n    };\n\n    /**** CONSTANTS ****/\n    Aladin.VERSION = \"{ALADIN-LITE-VERSION-NUMBER}\"; // will be filled by the build.sh script\n\n    Aladin.JSONP_PROXY = \"https://alasky.unistra.fr/cgi/JSONProxy\";\n    //Aladin.JSONP_PROXY = \"https://alaskybis.unistra.fr/cgi/JSONProxy\";\n\n    // access to WASM libraries\n    Aladin.wasmLibs = {};\n    Aladin.webglAPI = [];\n    Aladin.DEFAULT_OPTIONS = {\n        target: \"0 +0\",\n        cooFrame: \"J2000\",\n        survey: \"P/DSS2/color\",\n        fov: 60,\n        showReticle: true,\n        showZoomControl: true,\n        showFullscreenControl: true,\n        showLayersControl: true,\n        showGotoControl: true,\n        showSimbadPointerControl: false,\n        showShareControl: false,\n        showCatalog: true, // TODO: still used ??\n        showFrame: true,\n        showCooGrid: false,\n        fullScreen: false,\n        reticleColor: \"rgb(178, 50, 178)\",\n        reticleSize: 22,\n        log: true,\n        allowFullZoomout: false,\n        realFullscreen: false,\n        showAllskyRing: false,\n        allskyRingColor: '#c8c8ff',\n        allskyRingWidth: 8,\n        pixelateCanvas: true\n    };\n\n\n    // realFullscreen: AL div expands not only to the size of its parent, but takes the whole available screen estate \n    Aladin.prototype.toggleFullscreen = function (realFullscreen) {\n        realFullscreen = Boolean(realFullscreen);\n\n        this.fullScreenBtn.toggleClass('aladin-maximize aladin-restore');\n        var isInFullscreen = this.fullScreenBtn.hasClass('aladin-restore');\n        this.fullScreenBtn.attr('title', isInFullscreen ? 'Restore original size' : 'Full screen');\n        $(this.aladinDiv).toggleClass('aladin-fullscreen');\n\n        if (realFullscreen) {\n            // go to \"real\" full screen mode\n            if (isInFullscreen) {\n                var d = this.aladinDiv;\n\n                if (d.requestFullscreen) {\n                    d.requestFullscreen();\n                }\n                else if (d.webkitRequestFullscreen) {\n                    d.webkitRequestFullscreen();\n                }\n                else if (d.mozRequestFullScreen) { // notice the difference in capitalization for Mozilla functions ...\n                    d.mozRequestFullScreen();\n                }\n                else if (d.msRequestFullscreen) {\n                    d.msRequestFullscreen();\n                }\n            }\n            // exit from \"real\" full screen mode\n            else {\n                if (document.exitFullscreen) {\n                    document.exitFullscreen();\n                }\n                else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                }\n                else if (document.mozCancelFullScreen) {\n                    document.mozCancelFullScreen();\n                }\n                else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                }\n            }\n        }\n\n        this.view.fixLayoutDimensions();\n\n        // force call to zoomChanged callback\n        var fovChangedFn = this.callbacksByEventName['zoomChanged'];\n        (typeof fovChangedFn === 'function') && fovChangedFn(this.view.fov);\n\n        var fullScreenToggledFn = this.callbacksByEventName['fullScreenToggled'];\n        (typeof fullScreenToggledFn === 'function') && fullScreenToggledFn(isInFullscreen);\n    };\n\n    Aladin.prototype.updateSurveysDropdownList = function (surveys) {\n        surveys = surveys.sort(function (a, b) {\n            if (!a.order) {\n                return a.id > b.id;\n            }\n            return a.order && a.order > b.order ? 1 : -1;\n        });\n        var select = $(this.aladinDiv).find('.aladin-surveySelection');\n        select.empty();\n        for (var i = 0; i < surveys.length; i++) {\n            var isCurSurvey = this.view.imageSurvey.id == surveys[i].id;\n            select.append($(\"<option />\").attr(\"selected\", isCurSurvey).val(surveys[i].id).text(surveys[i].name));\n        };\n    };\n\n    Aladin.prototype.setAngleRotation = function (theta) {\n        this.view.setAngleRotation(theta)\n    }\n\n    Aladin.prototype.getOptionsFromQueryString = function () {\n        var options = {};\n        var requestedTarget = $.urlParam('target');\n        if (requestedTarget) {\n            options.target = requestedTarget;\n        }\n        var requestedFrame = $.urlParam('frame');\n        if (requestedFrame && CooFrameEnum[requestedFrame]) {\n            options.frame = requestedFrame;\n        }\n        var requestedSurveyId = $.urlParam('survey');\n        if (requestedSurveyId && HpxImageSurvey.getSurveyInfoFromId(requestedSurveyId)) {\n            options.survey = requestedSurveyId;\n        }\n        var requestedZoom = $.urlParam('zoom');\n        if (requestedZoom && requestedZoom > 0 && requestedZoom < 180) {\n            options.zoom = requestedZoom;\n        }\n\n        var requestedShowreticle = $.urlParam('showReticle');\n        if (requestedShowreticle) {\n            options.showReticle = requestedShowreticle.toLowerCase() == 'true';\n        }\n\n        var requestedCooFrame = $.urlParam('cooFrame');\n        if (requestedCooFrame) {\n            options.cooFrame = requestedCooFrame;\n        }\n\n        var requestedFullscreen = $.urlParam('fullScreen');\n        if (requestedFullscreen !== undefined) {\n            options.fullScreen = requestedFullscreen;\n        }\n\n        return options;\n    };\n\n    // @API\n    Aladin.prototype.setFoV = Aladin.prototype.setFov = function (fovDegrees) {\n        this.view.setZoom(fovDegrees);\n    };\n\n    // @API\n    // (experimental) try to adjust the FoV to the given object name. Does nothing if object is not known from Simbad\n    Aladin.prototype.adjustFovForObject = function (objectName) {\n        var self = this;\n        this.getFovForObject(objectName, function (fovDegrees) {\n            self.setFoV(fovDegrees);\n        });\n    };\n\n\n    Aladin.prototype.getFovForObject = function (objectName, callback) {\n        var query = \"SELECT galdim_majaxis, V FROM basic JOIN ident ON oid=ident.oidref JOIN allfluxes ON oid=allfluxes.oidref WHERE id='\" + objectName + \"'\";\n        var url = '//simbad.u-strasbg.fr/simbad/sim-tap/sync?query=' + encodeURIComponent(query) + '&request=doQuery&lang=adql&format=json&phase=run';\n\n        var ajax = Utils.getAjaxObject(url, 'GET', 'json', false)\n        ajax.done(function (result) {\n            var defaultFov = 4 / 60; // 4 arcmin\n            var fov = defaultFov;\n\n            if ('data' in result && result.data.length > 0) {\n                var galdimMajAxis = Utils.isNumber(result.data[0][0]) ? result.data[0][0] / 60.0 : null; // result gives galdim in arcmin\n                var magV = Utils.isNumber(result.data[0][1]) ? result.data[0][1] : null;\n\n                if (galdimMajAxis !== null) {\n                    fov = 2 * galdimMajAxis;\n                }\n                else if (magV !== null) {\n                    if (magV < 10) {\n                        fov = 2 * Math.pow(2.0, (6 - magV / 2.0)) / 60;\n                    }\n                }\n            }\n\n            (typeof callback === 'function') && callback(fov);\n        });\n    };\n\n    Aladin.prototype.setFrame = function (frameName) {\n        if (!frameName) {\n            return;\n        }\n        var newFrame = CooFrameEnum.fromString(frameName, CooFrameEnum.J2000);\n        if (newFrame == this.view.cooFrame) {\n            return;\n        }\n\n        this.view.changeFrame(newFrame);\n        // mj select box\n        $(this.aladinDiv).find('.aladin-frameChoice').val(newFrame.label);\n    };\n\n    Aladin.prototype.setProjection = function (projectionName) {\n        if (!projectionName) {\n            return;\n        }\n        projectionName = projectionName.toLowerCase();\n        /*console.log('setProj', projectionName);\n\n        let projectionOptionElt = document.getElementById(projectionName);\n        console.log(\"jKJHKSDJHF\")\n\n        console.log(projectionOptionElt);\n        if (projectionOptionElt) {\n            console.log(\"jKJHKSDJHF\")\n            projectionOptionElt.selected = 'selected';\n        }*/\n        \n        this.view.changeProjection(projectionName);\n        //this.view.fov_limit = this.webglAPI.getMaxFieldOfView() * 180 / Math.PI;\n    };\n\n    /** point view to a given object (resolved by Sesame) or position\n     * @api\n     *\n     * @param: target; object name or position\n     * @callbackOptions: (optional) the object with key 'success' and/or 'error' containing the success and error callback functions.\n     *\n     */\n    Aladin.prototype.gotoObject = function (targetName, callbackOptions, options) {\n        let successCallback = undefined;\n        let errorCallback   = undefined;\n        if (typeof callbackOptions === 'object') {\n            if (callbackOptions.hasOwnProperty('success')) {\n                successCallback = callbackOptions.success;\n            }\n            if (callbackOptions.hasOwnProperty('error')) {\n                errorCallback = callbackOptions.error;\n            }\n        }\n        // this is for compatibility reason with the previous method signature which was function(targetName, errorCallback)\n        else if (typeof callbackOptions === 'function') {\n            errorCallback = callbackOptions;\n        }\n\n\n        var isObjectName = /[a-zA-Z]/.test(targetName);\n\n        // try to parse as a position\n        if (!isObjectName) {\n            var coo = new Coo();\n\n            coo.parse(targetName);\n            var lonlat = [coo.lon, coo.lat];\n            // Convert it to icrs if the coo system is galactic\n            if (this.view.aladin.webglAPI.cooSystem() === Aladin.wasmLibs.webgl.GALCooSys()) {\n                lonlat = this.view.aladin.webglAPI.Gal2J2000(coo.lon, coo.lat);\n            }\n            this.view.pointTo(lonlat[0], lonlat[1], options);\n\n            (typeof successCallback === 'function') && successCallback(this.getRaDec());\n        }\n        // ask resolution by Sesame\n        else {\n            var self = this;\n            Sesame.resolve(targetName,\n                function (data) { // success callback\n                    // Location given in icrs at J2000\n                    var ra = data.Target.Resolver.jradeg;\n                    var dec = data.Target.Resolver.jdedeg;\n\n                    self.view.pointTo(ra, dec, options);\n\n                    (typeof successCallback === 'function') && successCallback(self.getRaDec());\n                },\n                function (data) { // errror callback\n                    if (console) {\n                        console.log(\"Could not resolve object name \" + targetName);\n                        console.log(data);\n                    }\n                    (typeof errorCallback === 'function') && errorCallback();\n                });\n        }\n    };\n\n\n\n    /**\n     * go to a given position, expressed in the current coordinate frame\n     * \n     * @API\n     */\n    Aladin.prototype.gotoPosition = function (lon, lat) {\n        var radec;\n        // first, convert to J2000 if needed\n        if (this.view.cooFrame == CooFrameEnum.GAL) {\n            radec = CooConversion.GalacticToJ2000([lon, lat]);\n        }\n        else {\n            radec = [lon, lat];\n        }\n        this.view.pointTo(radec[0], radec[1]);\n    };\n\n\n    var doAnimation = function (aladin) {\n        var params = aladin.animationParams;\n        if (params == null || !params['running']) {\n            return;\n        }\n        var now = new Date().getTime();\n        // this is the animation end: set the view to the end position, and call complete callback \n        if (now > params['end']) {\n            aladin.gotoRaDec(params['raEnd'], params['decEnd']);\n\n            if (params['complete']) {\n                params['complete']();\n            }\n\n            return;\n        }\n\n        // compute current position\n        var fraction = (now - params['start']) / (params['end'] - params['start']);\n        var curPos = intermediatePoint(params['raStart'], params['decStart'], params['raEnd'], params['decEnd'], fraction);\n        var curRa = curPos[0];\n        var curDec = curPos[1];\n        //var curRa =  params['raStart'] + (params['raEnd'] - params['raStart']) * (now-params['start']) / (params['end'] - params['start']);\n        //var curDec = params['decStart'] + (params['decEnd'] - params['decStart']) * (now-params['start']) / (params['end'] - params['start']);\n\n        aladin.gotoRaDec(curRa, curDec);\n\n        setTimeout(function () { doAnimation(aladin); }, 50);\n\n    };\n\n    /*\n     * Stop all animations that have been initiated  by animateToRaDec or by zoomToFoV\n     * @API\n     *\n     */\n    Aladin.prototype.stopAnimation = function () {\n        if (this.zoomAnimationParams) {\n            this.zoomAnimationParams['running'] = false;\n        }\n        if (this.animationParams) {\n            this.animationParams['running'] = false;\n        }\n    }\n\n    /*\n     * animate smoothly from the current position to the given ra, dec\n     * \n     * the total duration (in seconds) of the animation can be given (otherwise set to 5 seconds by default)\n     * \n     * complete: a function to call once the animation has completed\n     * \n     * @API\n     * \n     */\n    Aladin.prototype.animateToRaDec = function (ra, dec, duration, complete) {\n        duration = duration || 5;\n\n        this.animationParams = null;\n\n        var animationParams = {};\n        animationParams['start'] = new Date().getTime();\n        animationParams['end'] = new Date().getTime() + 1000 * duration;\n        var raDec = this.getRaDec();\n        animationParams['raStart'] = raDec[0];\n        animationParams['decStart'] = raDec[1];\n        animationParams['raEnd'] = ra;\n        animationParams['decEnd'] = dec;\n        animationParams['complete'] = complete;\n        animationParams['running'] = true;\n\n        this.animationParams = animationParams;\n\n        doAnimation(this);\n    };\n\n    var doZoomAnimation = function (aladin) {\n        var params = aladin.zoomAnimationParams;\n        if (params == null || !params['running']) {\n            return;\n        }\n        var now = new Date().getTime();\n        // this is the zoom animation end: set the view to the end fov, and call complete callback \n        if (now > params['end']) {\n            aladin.setFoV(params['fovEnd']);\n\n            if (params['complete']) {\n                params['complete']();\n            }\n\n            return;\n        }\n\n        // compute current position\n        var fraction = (now - params['start']) / (params['end'] - params['start']);\n        var curFov = params['fovStart'] + (params['fovEnd'] - params['fovStart']) * Math.sqrt(fraction);\n\n        aladin.setFoV(curFov);\n\n        setTimeout(function () { doZoomAnimation(aladin); }, 50);\n\n    };\n    /*\n     * zoom smoothly from the current FoV to the given new fov to the given ra, dec\n     * \n     * the total duration (in seconds) of the animation can be given (otherwise set to 5 seconds by default)\n     * \n     * complete: a function to call once the animation has completed\n     * \n     * @API\n     * \n     */\n    Aladin.prototype.zoomToFoV = function (fov, duration, complete) {\n        duration = duration || 5;\n\n        this.zoomAnimationParams = null;\n\n        var zoomAnimationParams = {};\n        zoomAnimationParams['start'] = new Date().getTime();\n        zoomAnimationParams['end'] = new Date().getTime() + 1000 * duration;\n        var fovArray = this.getFov();\n        zoomAnimationParams['fovStart'] = Math.max(fovArray[0], fovArray[1]);\n        zoomAnimationParams['fovEnd'] = fov;\n        zoomAnimationParams['complete'] = complete;\n        zoomAnimationParams['running'] = true;\n\n        this.zoomAnimationParams = zoomAnimationParams;\n        doZoomAnimation(this);\n    };\n\n\n\n    /**\n     *  Compute intermediate point between points (lng1, lat1) and (lng2, lat2)\n     *  at distance fraction times the total distance (fraction between 0 and 1)\n     *\n     *  Return intermediate points in degrees\n     *\n     */\n    function intermediatePoint(lng1, lat1, lng2, lat2, fraction) {\n        function degToRad(d) {\n            return d * Math.PI / 180;\n        }\n        function radToDeg(r) {\n            return r * 180 / Math.PI;\n        }\n        var lat1 = degToRad(lat1);\n        var lng1 = degToRad(lng1);\n        var lat2 = degToRad(lat2);\n        var lng2 = degToRad(lng2);\n        var d = 2 * Math.asin(\n            Math.sqrt(Math.pow((Math.sin((lat1 - lat2) / 2)),\n                2) +\n                Math.cos(lat1) * Math.cos(lat2) *\n                Math.pow(Math.sin((lng1 - lng2) / 2), 2)));\n        var A = Math.sin((1 - fraction) * d) / Math.sin(d);\n        var B = Math.sin(fraction * d) / Math.sin(d);\n        var x = A * Math.cos(lat1) * Math.cos(lng1) + B *\n            Math.cos(lat2) * Math.cos(lng2);\n        var y = A * Math.cos(lat1) * Math.sin(lng1) + B *\n            Math.cos(lat2) * Math.sin(lng2);\n        var z = A * Math.sin(lat1) + B * Math.sin(lat2);\n        var lon = Math.atan2(y, x);\n        var lat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) +\n            Math.pow(y, 2)));\n\n        return [radToDeg(lon), radToDeg(lat)];\n    };\n\n\n\n\n    /**\n     * get current [ra, dec] position of the center of the view\n     * \n     * @API\n     */\n    Aladin.prototype.getRaDec = function () {\n        /*if (this.view.cooFrame.system == CooFrameEnum.SYSTEMS.J2000) {\n            return [this.view.viewCenter.lon, this.view.viewCenter.lat];\n        }\n        else {\n            var radec = CooConversion.GalacticToJ2000([this.view.viewCenter.lon, this.view.viewCenter.lat]);\n            return radec;\n\n        }*/\n        let radec = this.webglAPI.getCenter();\n        return radec;\n    };\n\n\n    /**\n     * point to a given position, expressed as a ra,dec coordinate\n     * \n     * @API\n     */\n    Aladin.prototype.gotoRaDec = function (ra, dec) {\n        this.view.pointTo(ra, dec);\n    };\n\n    Aladin.prototype.showHealpixGrid = function (show) {\n        this.view.showHealpixGrid(show);\n    };\n\n    Aladin.prototype.showSurvey = function (show) {\n        this.view.showSurvey(show);\n    };\n    Aladin.prototype.showCatalog = function (show) {\n        this.view.showCatalog(show);\n    };\n    Aladin.prototype.showReticle = function (show) {\n        this.view.showReticle(show);\n        $('#displayReticle').attr('checked', show);\n    };\n    Aladin.prototype.removeLayers = function () {\n        this.view.removeLayers();\n    };\n\n    // these 3 methods should be merged into a unique \"add\" method\n    Aladin.prototype.addCatalog = function (catalog) {\n        this.view.addCatalog(catalog);\n    };\n    Aladin.prototype.addOverlay = function (overlay) {\n        this.view.addOverlay(overlay);\n    };\n    Aladin.prototype.addMOC = function (moc) {\n        this.view.addMOC(moc);\n    };\n    /*Aladin.prototype.addImageSurveyLayer = function (layer) {\n        console.log(\"add layer\", layer)\n        this.view.addImageSurveyLayer(layer)\n    };*/\n\n    // @api\n    /*Aladin.prototype.getBaseImageLayers = function () {\n        return this.view.imageSurvey;\n    };*/\n    // @param imageSurvey : HpxImageSurvey object or image survey identifier\n    // @api\n    // @old\n\n    Aladin.createImageSurvey = async function(rootUrlOrId) {\n        const survey = await HpxImageSurvey.create(rootUrlOrId);\n        return survey;\n    }\n\n    Aladin.prototype.setImageSurvey = function (survey, layer) {\n        let layerName;\n        if (layer) {\n            layerName = layer;\n        } else {\n            layerName = \"base\";\n        }\n\n        this.view.setImageSurvey(survey, layerName);\n    };\n\n    Aladin.prototype.setImageSurveysLayer = function (surveys, layer) {\n        let layerName;\n        if (layer) {\n            layerName = layer;\n        } else {\n            layerName = \"base\";\n        }\n\n        this.view.setImageSurveysLayer(surveys, layerName);\n    };\n\n    Aladin.prototype.removeImageSurveysLayer = function (layer) {\n        let layerName;\n        if (layer) {\n            layerName = layer;\n        } else {\n            layerName = \"base\";\n        }\n\n        this.view.removeImageSurveysLayer(layerName);\n    };\n\n    Aladin.prototype.moveImageSurveysLayerForward = function (layer) {\n        this.view.moveImageSurveysLayerForward(surveys, layerName);\n    };\n\n    Aladin.prototype.addImageSurvey = function (survey, layer) {\n        let layerName;\n        if (layer) {\n            layerName = layer;\n        } else {\n            layerName = \"base\";\n        }\n        this.view.addImageSurvey(survey, layerName);\n    };\n\n    Aladin.prototype.setOpacityLayer = function(opacity, layer) {\n        let layerName;\n        if (layer) {\n            layerName = layer;\n        } else {\n            layerName = \"base\";\n        }\n        this.webglAPI.setOpacityLayer(opacity, layer)\n    }\n\n    // @api\n    Aladin.prototype.setBaseImageSurveysLayer = function (surveys) {\n        this.view.setImageSurveysLayer(surveys, 'base');\n    };\n    Aladin.prototype.setBaseImageSurvey = function (survey) {\n        this.view.setImageSurvey(survey, 'base');\n    };\n    /*\n    // @api\n    Aladin.prototype.getOverlayImageLayer = function () {\n        return this.view.overlayImageSurvey;\n    };\n    // @api\n    Aladin.prototype.setOverlayImageLayer = function (imageSurvey, callback) {\n        this.view.setOverlayImageSurvey(imageSurvey, callback);\n    };\n    */\n\n    Aladin.prototype.increaseZoom = function (step) {\n        //if (!step) {\n        //    step = 5;\n        //}\n        //this.view.setZoomLevel(this.view.zoomLevel + step);\n        this.view.increaseZoom();\n    };\n\n    Aladin.prototype.decreaseZoom = function (step) {\n        //if (!step) {\n        //    step = 5;\n        //}\n        //this.view.setZoomLevel(this.view.zoomLevel - step);\n        this.view.decreaseZoom();\n    };\n\n\n    Aladin.prototype.createProgressiveCatalog = function (url, frame, maxOrder, options) {\n        return new ProgressiveCat(url, frame, maxOrder, options);\n    };\n\n    Aladin.prototype.createOverlay = function (options) {\n        return new Overlay(options);\n    };\n\n\n\n\n    Aladin.AVAILABLE_CALLBACKS = ['select', 'objectClicked', 'objectHovered', 'footprintClicked', 'footprintHovered', 'positionChanged', 'zoomChanged', 'click', 'mouseMove', 'fullScreenToggled', 'catalogReady'];\n    // API\n    //\n    // setting callbacks\n    Aladin.prototype.on = function (what, myFunction) {\n        if (Aladin.AVAILABLE_CALLBACKS.indexOf(what) < 0) {\n            return;\n        }\n\n        this.callbacksByEventName[what] = myFunction;\n    };\n\n    Aladin.prototype.select = function () {\n        this.fire('selectstart');\n    };\n\n    Aladin.prototype.fire = function (what, params) {\n        if (what === 'selectstart') {\n            this.view.setMode(View.SELECT);\n        }\n        else if (what === 'selectend') {\n            this.view.setMode(View.PAN);\n            var callbackFn = this.callbacksByEventName['select'];\n            (typeof callbackFn === 'function') && callbackFn(params);\n        }\n    };\n\n    Aladin.prototype.hideBoxes = function () {\n        if (this.boxes) {\n            for (var k = 0; k < this.boxes.length; k++) {\n                this.boxes[k].hide();\n            }\n        }\n    };\n\n    // ?\n    Aladin.prototype.updateCM = function () {\n\n    };\n\n    // TODO : LayerBox (or Stack?) must be extracted as a separate object\n    Aladin.prototype.showLayerBox = function () {\n        var self = this;\n\n        // first, update\n        var layerBox = $(this.aladinDiv).find('.aladin-layerBox');\n        layerBox.empty();\n        layerBox.append('<a class=\"aladin-closeBtn\">&times;</a>' +\n            '<div style=\"clear: both;\"></div>' +\n            '</div>');\n\n        layerBox.append('<div class=\"aladin-label\">Projection</div>' +\n        '<select id=\"projectionChoice\"><option id=\"sinus\" value=\"sinus\">SINUS</option><option id=\"aitoff\" value=\"aitoff\">AITOFF</option><option id=\"mollweide\" value=\"mollweide\">MOLLWEIDE</option><option id=\"mercator\" value=\"mercator\">MERCATOR</option><option id=\"arc\" value=\"arc\">ARC</option><option id=\"tan\" value=\"tan\">TAN</option></select><br/>');\n\n        $('#projectionChoice').change(function () {\n            //$(this).selected = $(this).val();\n            aladin.setProjection($(this).val());\n        });\n        \n        layerBox.append('<div class=\"aladin-box-separator\"></div>' +\n        '<div class=\"aladin-label\">Overlay layers</div>');\n\n        //var cmDiv = layerBox.find('.aladin-cmap');\n\n        // fill color maps options\n        /*var cmSelect = layerBox.find('.aladin-cmSelection');\n        for (var k = 0; k < ColorMap.MAPS_NAMES.length; k++) {\n            cmSelect.append($(\"<option />\").text(ColorMap.MAPS_NAMES[k]));\n        }\n        console.log(self.getBaseImageLayer())\n        console.log(self.getBaseImageLayer().getColorMap())\n        cmSelect.val(self.getBaseImageLayer().getColorMap().mapName);*/\n\n\n        // loop over all overlay layers\n        var layers = this.view.allOverlayLayers;\n        var str = '<ul>';\n        for (var k = layers.length - 1; k >= 0; k--) {\n            var layer = layers[k];\n            var name = layer.name;\n            var checked = '';\n            if (layer.isShowing) {\n                checked = 'checked=\"checked\"';\n            }\n\n            var tooltipText = '';\n            var iconSvg = '';\n            if (layer.type == 'catalog' || layer.type == 'progressivecat') {\n                var nbSources = layer.getSources().length;\n                tooltipText = nbSources + ' source' + (nbSources > 1 ? 's' : '');\n\n                iconSvg = AladinUtils.SVG_ICONS.CATALOG;\n            }\n            else if (layer.type == 'moc') {\n                tooltipText = 'Coverage: ' + (100 * layer.skyFraction()).toFixed(3) + ' % of sky';\n\n                iconSvg = AladinUtils.SVG_ICONS.MOC;\n            }\n            else if (layer.type == 'overlay') {\n                iconSvg = AladinUtils.SVG_ICONS.OVERLAY;\n            }\n\n            var rgbColor = $('<div></div>').css('color', layer.color).css('color'); // trick to retrieve the color as 'rgb(,,)' - does not work for named colors :(\n            var labelColor = Color.getLabelColorForBackground(rgbColor);\n\n            // retrieve SVG icon, and apply the layer color\n            var svgBase64 = window.btoa(iconSvg.replace(/FILLCOLOR/g, layer.color));\n            str += '<li><div class=\"aladin-stack-icon\" style=\\'background-image: url(\"data:image/svg+xml;base64,' + svgBase64 + '\");\\'></div>';\n            str += '<input type=\"checkbox\" ' + checked + ' id=\"aladin_lite_' + name + '\"></input><label for=\"aladin_lite_' + name + '\" class=\"aladin-layer-label\" style=\"background: ' + layer.color + '; color:' + labelColor + ';\" title=\"' + tooltipText + '\">' + name + '</label></li>';\n        }\n        str += '</ul>';\n        layerBox.append(str);\n\n        layerBox.append('<div class=\"aladin-blank-separator\"></div>');\n\n        // gestion du rticule\n        var checked = '';\n        if (this.view.displayReticle) {\n            checked = 'checked=\"checked\"';\n        }\n        var reticleCb = $('<input type=\"checkbox\" ' + checked + ' id=\"displayReticle\" />');\n        layerBox.append(reticleCb).append('<label for=\"displayReticle\">Reticle</label><br/>');\n        reticleCb.change(function () {\n            self.showReticle($(this).is(':checked'));\n        });\n\n        // Gestion grille Healpix\n        checked = '';\n        if (this.view.displayHpxGrid) {\n            checked = 'checked=\"checked\"';\n        }\n        var hpxGridCb = $('<input type=\"checkbox\" ' + checked + ' id=\"displayHpxGrid\"/>');\n        layerBox.append(hpxGridCb).append('<label for=\"displayHpxGrid\">HEALPix grid</label><br/>');\n        hpxGridCb.change(function () {\n            self.showHealpixGrid($(this).is(':checked'));\n        });\n\n        // Equatorial grid plot\n        checked = '';\n        if (this.view.showGrid) {\n            checked = 'checked=\"checked\"';\n        }\n        var equatorialGridCb = $('<input type=\"checkbox\" ' + checked + ' id=\"displayEquatorialGrid\"/>');\n        layerBox.append(equatorialGridCb).append('<label for=\"displayEquatorialGrid\">Equatorial grid</label><br/>');\n        equatorialGridCb.change(function () {\n            let isChecked = $(this).is(':checked');\n            self.view.setShowGrid(isChecked);\n        });\n\n\n        layerBox.append('<div class=\"aladin-box-separator\"></div>' +\n            '<div class=\"aladin-label\">Tools</div>');\n        var exportBtn = $('<button class=\"aladin-btn\" type=\"button\">Export view as PNG</button>');\n        layerBox.append(exportBtn);\n        exportBtn.click(function () {\n            self.exportAsPNG();\n        });\n\n        layerBox.find('.aladin-closeBtn').click(function () { self.hideBoxes(); return false; });\n\n        // update list of surveys\n        /*this.updateSurveysDropdownList(HpxImageSurvey.getAvailableSurveys());\n        var surveySelection = $(this.aladinDiv).find('.aladin-surveySelection');\n        surveySelection.change(function () {\n            var survey = HpxImageSurvey.getAvailableSurveys()[$(this)[0].selectedIndex];\n            self.setImageSurvey(survey.id, function () {\n                var baseImgLayer = self.getBaseImageLayer();\n\n                if (baseImgLayer.useCors) {\n                    // update color map list with current value color map\n                    cmSelect.val(baseImgLayer.getColorMap().mapName);\n                    cmDiv.show();\n\n                    exportBtn.show();\n                }\n                else {\n                    cmDiv.hide();\n\n                    exportBtn.hide();\n                }\n            });\n\n\n\n        });\n\n        //// COLOR MAP management ////////////////////////////////////////////\n        // update color map\n        cmDiv.find('.aladin-cmSelection').change(function () {\n            var cmName = $(this).find(':selected').val();\n            self.getBaseImageLayer().getColorMap().update(cmName);\n        });\n\n        // reverse color map\n        cmDiv.find('.aladin-reverseCm').click(function () {\n            self.getBaseImageLayer().getColorMap().reverse();\n        });\n        if (this.getBaseImageLayer().useCors) {\n            cmDiv.show();\n            exportBtn.show();\n        }\n        else {\n            cmDiv.hide();\n            exportBtn.hide();\n        }\n        layerBox.find('.aladin-reverseCm').parent().attr('disabled', true);\n        */\n        //////////////////////////////////////////////////////////////////////\n\n\n        // handler to hide/show overlays\n        $(this.aladinDiv).find('.aladin-layerBox ul input').change(function () {\n            var layerName = ($(this).attr('id').substr(12));\n            var layer = self.layerByName(layerName);\n            if ($(this).is(':checked')) {\n                layer.show();\n            }\n            else {\n                layer.hide();\n            }\n        });\n\n        // finally show\n        layerBox.show();\n\n    };\n\n    Aladin.prototype.layerByName = function (name) {\n        var c = this.view.allOverlayLayers;\n        for (var k = 0; k < c.length; k++) {\n            if (name == c[k].name) {\n                return c[k];\n            }\n        }\n        return null;\n    };\n\n    // TODO : integrate somehow into API ?\n    Aladin.prototype.exportAsPNG = function (imgFormat) {\n        var w = window.open();\n        w.document.write('<img src=\"' + this.getViewDataURL() + '\">');\n        w.document.title = 'Aladin Lite snapshot';\n    };\n\n    /**\n     * Return the current view as a data URL (base64-formatted string)\n     * Parameters:\n     * - options (optional): object with attributs\n     *     * format (optional): 'image/png' or 'image/jpeg'\n     *     * width: width in pixels of the image to output\n     *     * height: height in pixels of the image to output\n     *\n     * @API\n    */\n    Aladin.prototype.getViewDataURL = function (options) {\n        var options = options || {};\n        // support for old API signature\n        if (typeof options !== 'object') {\n            var imgFormat = options;\n            options = { format: imgFormat };\n        }\n\n        return this.view.getCanvasDataURL(options.format, options.width, options.height);\n    }\n\n    /**\n     * Return the current view WCS as a key-value dictionary\n     * Can be useful in coordination with getViewDataURL\n     *\n     * @API\n    */\n    Aladin.prototype.getViewWCS = function (options) {\n        var raDec = this.getRaDec();\n        var fov = this.getFov();\n        // TODO: support for other projection methods than SIN\n        return {\n            NAXIS: 2,\n            NAXIS1: this.view.width,\n            NAXIS2: this.view.height,\n            RADECSYS: 'ICRS',\n            CRPIX1: this.view.width / 2,\n            CRPIX2: this.view.height / 2,\n            CRVAL1: raDec[0],\n            CRVAL2: raDec[1],\n            CTYPE1: 'RA---SIN',\n            CTYPE2: 'DEC--SIN',\n            CD1_1: fov[0] / this.view.width,\n            CD1_2: 0.0,\n            CD2_1: 0.0,\n            CD2_2: fov[1] / this.view.height\n        }\n    }\n\n    /** restrict FOV range\n     * @API\n     * @param minFOV in degrees when zoom in at max\n     * @param maxFOV in degreen when zoom out at max\n    */\n    Aladin.prototype.setFovRange = Aladin.prototype.setFOVRange = function (minFOV, maxFOV) {\n        if (minFOV > maxFOV) {\n            var tmp = minFOV;\n            minFOV = maxFOV;\n            maxFOV = tmp;\n        }\n\n        this.view.minFOV = minFOV;\n        this.view.maxFOV = maxFOV;\n\n    };\n\n    /**\n     * Transform pixel coordinates to world coordinates\n     * \n     * Origin (0,0) of pixel coordinates is at top left corner of Aladin Lite view\n     * \n     * @API\n     * \n     * @param x\n     * @param y\n     * \n     * @return a [ra, dec] array with world coordinates in degrees. Returns undefined is something went wrong\n     * \n     */\n    Aladin.prototype.pix2world = function (x, y) {\n        // this might happen at early stage of initialization\n        if (!this.view) {\n            return undefined;\n        }\n\n        //var xy = AladinUtils.viewToXy(x, y, this.view.width, this.view.height, this.view.largestDim, this.view.zoomFactor);\n\n        var radec;\n        try {\n            //radec = this.view.projection.unproject(xy.x, xy.y);\n            radec = this.view.aladin.webglAPI.screenToWorld(x, y);\n        }\n        catch (e) {\n            return undefined;\n        }\n\n        var res;\n        // Convert it to icrs j2000\n        if (this.view.aladin.webglAPI.cooSystem() === Aladin.wasmLibs.webgl.GALCooSys()) {\n            res = this.view.aladin.webglAPI.Gal2J2000(radec[0], radec[1]);\n        }\n\n        return res;\n    };\n\n    /**\n     * Transform world coordinates to pixel coordinates in the view\n     * \n     * @API\n     * \n     * @param ra  \n     * @param dec\n     * \n     * @return a [x, y] array with pixel coordinates in the view. Returns null if the projection failed somehow\n     *   \n     */\n    Aladin.prototype.world2pix = function (ra, dec) {\n        // this might happen at early stage of initialization\n        if (!this.view) {\n            return;\n        }\n\n        var xy;\n        if (this.view.cooFrame == CooFrameEnum.GAL) {\n            var lonlat = CooConversion.J2000ToGalactic([ra, dec]);\n            xy = this.view.projection.project(lonlat[0], lonlat[1]);\n        }\n        else {\n            xy = this.view.projection.project(ra, dec);\n        }\n        if (xy) {\n            var xyview = AladinUtils.xyToView(xy.X, xy.Y, this.view.width, this.view.height, this.view.largestDim, this.view.zoomFactor);\n            return [xyview.vx, xyview.vy];\n        }\n        else {\n            return null;\n        }\n    };\n\n    /**\n     * \n     * @API\n     * \n     * @param ra  \n     * @param nbSteps the number of points to return along each side (the total number of points returned is 4*nbSteps)\n     * \n     * @return set of points along the current FoV with the following format: [[ra1, dec1], [ra2, dec2], ..., [ra_n, dec_n]]\n     *   \n     */\n    Aladin.prototype.getFovCorners = function (nbSteps) {\n        // default value: 1\n        if (!nbSteps || nbSteps < 1) {\n            nbSteps = 1;\n        }\n\n        var points = [];\n        var x1, y1, x2, y2;\n        for (var k = 0; k < 4; k++) {\n            x1 = (k == 0 || k == 3) ? 0 : this.view.width - 1;\n            y1 = (k < 2) ? 0 : this.view.height - 1;\n            x2 = (k < 2) ? this.view.width - 1 : 0;\n            y2 = (k == 1 || k == 2) ? this.view.height - 1 : 0;\n\n            for (var step = 0; step < nbSteps; step++) {\n                let radec = this.webglAPI.screenToWorld(x1 + step / nbSteps * (x2 - x1), y1 + step / nbSteps * (y2 - y1));\n                points.push(radec);\n            }\n        }\n\n        return points;\n\n    };\n\n    /**\n     * @API\n     * \n     * @return the current FoV size in degrees as a 2-elements array\n     */\n    Aladin.prototype.getFov = function () {\n        var fovX = this.view.fov;\n        var s = this.getSize();\n        var fovY = s[1] / s[0] * fovX;\n        // TODO : take into account AITOFF projection where fov can be larger than 180\n        fovX = Math.min(fovX, 180);\n        fovY = Math.min(fovY, 180);\n\n        return [fovX, fovY];\n    };\n\n    /**\n     * @API\n     * \n     * @return the size in pixels of the Aladin Lite view\n     */\n    Aladin.prototype.getSize = function () {\n        return [this.view.width, this.view.height];\n    };\n\n    /**\n     * @API\n     * \n     * @return the jQuery object representing the DIV element where the Aladin Lite instance lies\n     */\n    Aladin.prototype.getParentDiv = function () {\n        return $(this.aladinDiv);\n    };\n\n    return Aladin;\n})();\n\n///////////////////////////////\n/////// Aladin Lite API ///////\n///////////////////////////////\nlet A = {};\n//// New API ////\n// For developers using Aladin lite: all objects should be created through the API, \n// rather than creating directly the corresponding JS objects\n// This facade allows for more flexibility as objects can be updated/renamed harmlessly\n\n//@API\nA.aladin = function (divSelector, options) {\n    return new Aladin($(divSelector)[0], options);\n};\n\n/*//@API\n// TODO : lecture de properties\nA.imageLayer = function (rootURLOrHiPSDefinition, options) {\n    return new HpxImageSurvey(rootURLOrHiPSDefinition, options);\n};*/\n\n// @API\nA.source = function (ra, dec, data, options) {\n    return new Source(ra, dec, data, options);\n};\n\n// @API\nA.marker = function (ra, dec, options, data) {\n    options = options || {};\n    options['marker'] = true;\n    return A.source(ra, dec, data, options);\n};\n\nA.createImageSurvey = async function(rootUrlOrId) {\n    const survey = await HpxImageSurvey.create(rootUrlOrId);\n    return survey;\n}\n\n// @API\nA.polygon = function (raDecArray) {\n    var l = raDecArray.length;\n    if (l > 0) {\n        // close the polygon if needed\n        if (raDecArray[0][0] != raDecArray[l - 1][0] || raDecArray[0][1] != raDecArray[l - 1][1]) {\n            raDecArray.push([raDecArray[0][0], raDecArray[0][1]]);\n        }\n    }\n    return new Footprint(raDecArray);\n};\n\n//@API\nA.polyline = function (raDecArray, options) {\n    return new Polyline(raDecArray, options);\n};\n\n\n// @API\nA.circle = function (ra, dec, radiusDeg, options) {\n    return new Circle([ra, dec], radiusDeg, options);\n};\n\n/**\n * \n * @API\n * \n * @param ra \n * @param dec\n * @param radiusRaDeg the radius along the ra axis in degrees\n * @param radiusDecDeg the radius along the dec axis in degrees\n * @param rotationDeg the rotation angle in degrees\n *   \n */\nA.ellipse = function (ra, dec, radiusRaDeg, radiusDecDeg, rotationDeg, options) {\n    return new Ellipse([ra, dec], radiusRaDeg, radiusDecDeg, rotationDeg, options);\n};\n\n// @API\nA.graphicOverlay = function (options) {\n    return new Overlay(options);\n};\n\n// Create a new image survey layer\n//\n// One can attach multiple surveys to 1 layer.\n// Those survey colors are blended together.\n// Layers are overlaid to each other\nA.imageSurveyLayer = function(name) {\n    return new ImageSurveyLayer(name);\n}\n\n// @API\nA.catalog = function (options) {\n    return new Catalog(options);\n};\n\n// @API\nA.catalogHiPS = function (rootURL, options) {\n    return new ProgressiveCat(rootURL, null, null, options);\n};\n\n// @API\n/*\n * return a Box GUI element to insert content\n */\nAladin.prototype.box = function (options) {\n    var box = new Box(options);\n    box.$parentDiv.appendTo(this.aladinDiv);\n\n    return box;\n};\n\n// @API\n/*\n * show popup at ra, dec position with given title and content\n */\nAladin.prototype.showPopup = function (ra, dec, title, content) {\n    this.view.catalogForPopup.removeAll();\n    var marker = A.marker(ra, dec, { popupTitle: title, popupDesc: content, useMarkerDefaultIcon: false });\n    this.view.catalogForPopup.addSources(marker);\n    this.view.catalogForPopup.show();\n\n    this.view.popup.setTitle(title);\n    this.view.popup.setText(content);\n    this.view.popup.setSource(marker);\n    this.view.popup.show();\n};\n\n// @API\n/*\n * hide popup\n */\nAladin.prototype.hidePopup = function () {\n    this.view.popup.hide();\n};\n\n// @API\n/*\n * return a URL allowing to share the current view\n */\nAladin.prototype.getShareURL = function () {\n    var radec = this.getRaDec();\n    var coo = new Coo();\n    coo.prec = 7;\n    coo.lon = radec[0];\n    coo.lat = radec[1];\n\n    return 'https://aladin.unistra.fr/AladinLite/?target=' + encodeURIComponent(coo.format('s')) +\n        '&fov=' + this.getFov()[0].toFixed(2) + '&survey=' + encodeURIComponent(this.getBaseImageLayer().id || this.getBaseImageLayer().rootUrl);\n};\n\n// @API\n/*\n * return, as a string, the HTML embed code\n */\nAladin.prototype.getEmbedCode = function () {\n    var radec = this.getRaDec();\n    var coo = new Coo();\n    coo.prec = 7;\n    coo.lon = radec[0];\n    coo.lat = radec[1];\n\n    var survey = this.getBaseImageLayer().id;\n    var fov = this.getFov()[0];\n    var s = '';\n    s += '<link rel=\"stylesheet\" href=\"https://aladin.unistra.fr/AladinLite/api/v2/latest/aladin.min.css\" />\\n';\n    s += '<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.9.1.min.js\" charset=\"utf-8\"></script>\\n';\n    s += '<div id=\"aladin-lite-div\" style=\"width:400px;height:400px;\"></div>\\n';\n    s += '<script type=\"text/javascript\" src=\"https://aladin.unistra.fr/AladinLite/api/v2/latest/aladin.min.js\" charset=\"utf-8\"></script>\\n';\n    s += '<script type=\"text/javascript\">\\n';\n    s += 'var aladin = A.aladin(\"#aladin-lite-div\", {survey: \"' + survey + 'P/DSS2/color\", fov: ' + fov.toFixed(2) + ', target: \"' + coo.format('s') + '\"});\\n';\n    s += '</script>';\n    return s;\n};\n\n// @API\n/*\n * Creates remotely a HiPS from a FITS image URL and displays it\n */\nAladin.prototype.displayFITS = function (url, layerName, options, successCallback, errorCallback) {\n    options = options || {};\n    var data = { url: url };\n    if (options.color) {\n        data.color = true;\n    }\n    if (options.outputFormat) {\n        data.format = options.outputFormat;\n    }\n    if (options.order) {\n        data.order = options.order;\n    }\n    if (options.nocache) {\n        data.nocache = options.nocache;\n    }\n    let self = this;\n    $.ajax({\n        url: 'https://alasky.unistra.fr/cgi/fits2HiPS',\n        data: data,\n        method: 'GET',\n        dataType: 'json',\n        success: function (response) {\n            if (response.status != 'success') {\n                console.error('An error occured: ' + response.message);\n                if (errorCallback) {\n                    errorCallback(response.message);\n                }\n                return;\n            }\n            var label = options.label || \"FITS image\";\n            var meta = response.data.meta;\n\n            (async () => {\n                let survey = await Aladin.createImageSurvey(response.data.url);\n                var transparency = (options && options.transparency) || 1.0;\n    \n                var executeDefaultSuccessAction = true;\n                if (successCallback) {\n                    executeDefaultSuccessAction = successCallback(meta.ra, meta.dec, meta.fov);\n                }\n                if (executeDefaultSuccessAction === true) {\n                    self.webglAPI.setCenter(meta.ra, meta.dec);\n                    self.setFoV(meta.fov);\n                }\n                // TODO! set an image survey once the already loaded surveys\n                // are READY! Otherwise it can lead to some congestion and avoid\n                // downloading the base tiles of the other surveys loading!\n                // This has to be fixed in the backend but a fast fix is just to wait\n                // before setting a new image survey\n                \n                    self.setImageSurvey(survey, layerName)\n                    // set transparency\n                    self.setOpacityLayer(transparency, layerName)\n\n            })();\n        }\n    });\n\n};\n\n// @API\n/*\n * Creates remotely a HiPS from a JPEG or PNG image with astrometry info\n * and display it\n */\nAladin.prototype.displayJPG = Aladin.prototype.displayPNG = function (url, layerName, options, successCallback, errorCallback) {\n    options = options || {};\n    options.color = true;\n    options.label = \"JPG/PNG image\";\n    options.outputFormat = 'png';\n    this.displayFITS(url, layerName, options, successCallback, errorCallback);\n};\n\nAladin.prototype.setReduceDeformations = function (reduce) {\n    this.reduceDeformations = reduce;\n    this.view.requestRedraw();\n}\n\n// API\nA.footprintsFromSTCS = function (stcs) {\n    var footprints = Overlay.parseSTCS(stcs);\n\n    return footprints;\n}\n\n// API\nA.MOCFromURL = function (url, options, successCallback) {\n    var moc = new MOC(options);\n    moc.dataFromFITSURL(url, successCallback);\n\n    return moc;\n};\n\n// API\nA.MOCFromJSON = function (jsonMOC, options) {\n    var moc = new MOC(options);\n    moc.dataFromJSON(jsonMOC);\n\n    return moc;\n};\n\n\n// TODO: try first without proxy, and then with, if param useProxy not set\n// API\nA.catalogFromURL = function (url, options, successCallback, useProxy) {\n    var catalog = A.catalog(options);\n    // TODO: should be self-contained in Catalog class\n    Catalog.parseVOTable(url, function (sources) {\n        catalog.addSources(sources);\n        if (successCallback) {\n            successCallback(sources);\n        }\n    },\n        catalog.maxNbSources, useProxy,\n        catalog.raField, catalog.decField\n    );\n\n    return catalog;\n};\n\n// API\n// @param target: can be either a string representing a position or an object name, or can be an object with keys 'ra' and 'dec' (values being in decimal degrees)\nA.catalogFromSimbad = function (target, radius, options, successCallback) {\n    options = options || {};\n    if (!('name' in options)) {\n        options['name'] = 'Simbad';\n    }\n    var url = URLBuilder.buildSimbadCSURL(target, radius);\n    return A.catalogFromURL(url, options, successCallback, false);\n};\n\n// API\nA.catalogFromNED = function (target, radius, options, successCallback) {\n    options = options || {};\n    if (!('name' in options)) {\n        options['name'] = 'NED';\n    }\n    var url;\n    if (target && (typeof target === \"object\")) {\n        if ('ra' in target && 'dec' in target) {\n            url = URLBuilder.buildNEDPositionCSURL(target.ra, target.dec, radius);\n        }\n    }\n    else {\n        var isObjectName = /[a-zA-Z]/.test(target);\n        if (isObjectName) {\n            url = URLBuilder.buildNEDObjectCSURL(target, radius);\n        }\n        else {\n            var coo = new Coo();\n            coo.parse(target);\n            url = URLBuilder.buildNEDPositionCSURL(coo.lon, coo.lat, radius);\n        }\n    }\n\n    return A.catalogFromURL(url, options, successCallback);\n};\n\n// API\nA.catalogFromVizieR = function (vizCatId, target, radius, options, successCallback) {\n    options = options || {};\n    if (!('name' in options)) {\n        options['name'] = 'VizieR:' + vizCatId;\n    }\n    var url = URLBuilder.buildVizieRCSURL(vizCatId, target, radius, options);\n    console.log(url);\n    return A.catalogFromURL(url, options, successCallback, false);\n};\n\n// API\nA.catalogFromSkyBot = function (ra, dec, radius, epoch, queryOptions, options, successCallback) {\n    queryOptions = queryOptions || {};\n    options = options || {};\n    if (!('name' in options)) {\n        options['name'] = 'SkyBot';\n    }\n    var url = URLBuilder.buildSkyBotCSURL(ra, dec, radius, epoch, queryOptions);\n    return A.catalogFromURL(url, options, successCallback, false);\n};\n\nA.hipsDefinitionFromURL = function(url, successCallback) {\n    HiPSDefinition.fromURL(url, successCallback);\n};\n\n\nA.init = Promise.all([import('@fxpineau/healpix'), import('../core/pkg')]).then(async (values) => {\n    let [hpxAPI, webglAPI] = values;\n\n    // HEALPix library\n    Aladin.wasmLibs.hpx = hpxAPI;\n    // WebGL library\n    Aladin.wasmLibs.webgl = webglAPI;\n});\n\n// this is ugly for sure and there must be a better way using Webpack magic\nwindow.A = A;\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File AladinUtils\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Projection } from \"./libs/astro/projection.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\n\nexport let AladinUtils = (function() {\n\n    return {\n    \t/**\n    \t * passage de xy projection  xy dans la vue cran \n    \t * @param x\n    \t * @param y\n    \t * @param width\n    \t * @param height\n    \t * @param largestDim largest dimension of the view\n    \t * @returns position in the view\n    \t */\n    \txyToView: function(x, y, width, height, largestDim, zoomFactor, round) {\n    \t    if (round==undefined) {\n                // we round by default\n    \t        round = true;\n    \t    }\n\n    \t    if (round) {\n    \t        // we round the result for potential performance gains\n    \t        return {vx: AladinUtils.myRound(largestDim/2*(1+zoomFactor*x)-(largestDim-width)/2), vy: AladinUtils.myRound(largestDim/2*(1+zoomFactor*y)-(largestDim-height)/2)};\n\n    \t    }\n    \t    else {\n                return {vx: largestDim/2*(1+zoomFactor*x)-(largestDim-width)/2, vy: largestDim/2*(1+zoomFactor*y)-(largestDim-height)/2};\n    \t    }\n    \t},\n    \t\n    \t/**\n    \t * passage de xy dans la vue cran  xy projection\n    \t * @param vx\n    \t * @param vy\n    \t * @param width\n    \t * @param height\n    \t * @param largestDim\n    \t * @param zoomFactor\n    \t * @returns position in xy projection\n    \t */\n    \tviewToXy: function(vx, vy, width, height, largestDim, zoomFactor) {\n    \t\treturn {x: ((2*vx+(largestDim-width))/largestDim-1)/zoomFactor, y: ((2*vy+(largestDim-height))/largestDim-1)/zoomFactor};\n    \t},\n\n    \t/**\n    \t * convert a \n    \t * @returns position x,y in the view. Null if projection is impossible\n    \t */\n        /*radecToViewXy: function(ra, dec, currentProjection, currentFrame, width, height, largestDim, zoomFactor) {\n            var xy;\n            if (currentFrame.system != CooFrameEnum.SYSTEMS.J2000) {\n                var lonlat = CooConversion.J2000ToGalactic([ra, dec]);\n                xy = currentProjection.project(lonlat[0], lonlat[1]);\n            }\n            else {\n                xy = currentProjection.project(ra, dec);\n            }\n            if (!xy) {\n                return null;\n            }\n\n            return AladinUtils.xyToView(xy.X, xy.Y, width, height, largestDim, zoomFactor, false);\n        },*/\n        radecToViewXy: function(ra, dec, view) {\n            //var xy;\n            //if (currentFrame.system != CooFrameEnum.SYSTEMS.J2000) {\n            //    var lonlat = CooConversion.J2000ToGalactic([ra, dec]);\n            //    xy = view.aladin.webglAPI.worldToScreen(lonlat[0], lonlat[1]);\n            //}\n            //else {\n            //var lonlat = CooConversion.J2000ToGalactic([ra, dec]);\n            let xy = view.aladin.webglAPI.worldToScreen(ra, dec);\n            //}\n            //if (!xy) {\n            //    return null;\n            //}\n\n            return xy;\n        },\n    \t\n    \tmyRound: function(a) {\n    \t\tif (a<0) {\n    \t\t\treturn -1*( (-a) | 0);\n    \t\t}\n    \t\telse {\n    \t\t\treturn a | 0;\n    \t\t}\n    \t},\n    \t\n    \t/**\n    \t * Test whether a xy position is the view\n    \t * @param vx\n    \t * @param vy\n    \t * @param width\n    \t * @param height\n    \t * @returns a boolean whether (vx, vy) is in the screen\n    \t */\n    \tisInsideViewXy: function(vx, vy, width, height) {\n    \t\treturn vx >= 0 && vx < width && vy >= 0 && vy < height\n    \t},\n    \t\n    \t/**\n    \t * tests whether a healpix pixel is visible or not\n    \t * @param pixCorners array of position (xy view) of the corners of the pixel\n    \t * @param viewW\n    \t */\n    \tisHpxPixVisible: function(pixCorners, viewWidth, viewHeight) {\n    \t\tfor (var i = 0; i<pixCorners.length; i++) {\n    \t\t\tif ( pixCorners[i].vx>=-20 && pixCorners[i].vx<(viewWidth+20) &&\n    \t\t\t\t pixCorners[i].vy>=-20 && pixCorners[i].vy<(viewHeight+20) ) {\n    \t\t\t\treturn true;\n    \t\t\t}\n    \t\t}\n    \t\treturn false;\n    \t},\n    \t\n    \tipixToIpix: function(npixIn, norderIn, norderOut) {\n    \t\tvar npixOut = [];\n    \t\tif (norderIn>=norderOut) {\n    \t\t}\n    \t},\n        // Zoom is handled in the backend\n        /*getZoomFactorForAngle: function(angleInDegrees, projectionMethod) {\n            var p1 = {ra: 0, dec: 0};\n            var p2 = {ra: angleInDegrees, dec: 0};\n            var projection = new Projection(angleInDegrees/2, 0);\n            projection.setProjection(projectionMethod);\n            var p1Projected = projection.project(p1.ra, p1.dec);\n            var p2Projected = projection.project(p2.ra, p2.dec);\n           \n            var zoomFactor = 1/Math.abs(p1Projected.X - p2Projected.Y);\n\n            return zoomFactor;\n        },*/\n\n        counterClockwiseTriangle: function(x1, y1, x2, y2, x3, y3) {\n            // From: https://math.stackexchange.com/questions/1324179/how-to-tell-if-3-connected-points-are-connected-clockwise-or-counter-clockwise\n            // | x1, y1, 1 |\n            // | x2, y2, 1 | > 0 => the triangle is given in anticlockwise order\n            // | x3, y3, 1 |\n    \n            return x1*y2 + y1*x3 + x2*y3 - x3*y2 - y3*x1 - x2*y1 >= 0;\n        },\n\n        // grow array b of vx,vy view positions by *val* pixels\n        grow2: function(b, val) {\n            var j=0;\n            for ( var i=0; i<4; i++ ) {\n                if ( b[i]==null ) {\n                    j++;\n                }\n            }\n\n            if( j>1 ) {\n                return b;\n            }\n\n            var b1 = [];\n            for ( var i=0; i<4; i++ ) {\n                b1.push( {vx: b[i].vx, vy: b[i].vy} );\n            }\n    \n            for ( var i=0; i<2; i++ ) {\n                var a = i==1 ? 1 : 0;\n                var c = i==1 ? 3 : 2;\n\n                if ( b1[a]==null ) {\n                    var d,g;\n                    if ( a==0 || a==3 ) {\n                        d=1;\n                        g=2;\n                    }\n                    else {\n                        d=0;\n                        g=3;\n                    }\n                    b1[a] = {vx: (b1[d].vx+b1[g].vx)/2, vy: (b1[d].vy+b1[g].vy)/2};\n                }\n                if ( b1[c]==null ) {\n                    var d,g;\n                    if ( c==0 || c==3 ) {\n                        d=1;\n                        g=2;\n                    }\n                    else {\n                        d=0;\n                        g=3;\n                    }\n                    b1[c] = {vx: (b1[d].vx+b1[g].vx)/2, vy: (b1[d].vy+b1[g].vy)/2};\n                }\n                if( b1[a]==null || b1[c]==null ) {\n                    continue;\n                }\n\n                var angle = Math.atan2(b1[c].vy-b1[a].vy, b1[c].vx-b1[a].vx);\n                var chouilla = val*Math.cos(angle);\n                b1[a].vx -= chouilla;\n                b1[c].vx += chouilla;\n                chouilla = val*Math.sin(angle);\n                b1[a].vy-=chouilla;\n                b1[c].vy+=chouilla;\n            }\n            return b1;\n        },\n\n        // SVG icons templates are stored here rather than in a CSS, as to allow\n        // to dynamically change the fill color\n        // Pretty ugly, haven't found a prettier solution yet\n        //\n        // TODO: store this in the Stack class once it will exist\n        //\n        SVG_ICONS: {\n            CATALOG: '<svg xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"1,0,5,0,5,3,1,3\"  fill=\"FILLCOLOR\" /><polygon points=\"7,0,9,0,9,3,7,3\"  fill=\"FILLCOLOR\" /><polygon points=\"10,0,12,0,12,3,10,3\"  fill=\"FILLCOLOR\" /><polygon points=\"13,0,15,0,15,3,13,3\"  fill=\"FILLCOLOR\" /><polyline points=\"1,5,5,9\"  stroke=\"FILLCOLOR\" /><polyline points=\"1,9,5,5\" stroke=\"FILLCOLOR\" /><line x1=\"7\" y1=\"7\" x2=\"15\" y2=\"7\" stroke=\"FILLCOLOR\" stroke-width=\"2\" /><polyline points=\"1,11,5,15\"  stroke=\"FILLCOLOR\" /><polyline points=\"1,15,5,11\"  stroke=\"FILLCOLOR\" /><line x1=\"7\" y1=\"13\" x2=\"15\" y2=\"13\" stroke=\"FILLCOLOR\" stroke-width=\"2\" /></svg>',\n            MOC: '<svg xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"0.5,7,2.5,7,2.5,5,7,5,7,3,10,3,10,5,13,5,13,7,15,7,15,9,13,9,13,12,10,12,10,14,7,14,7,12,2.5,12,2.5,10,0.5,10,0.5,7\" stroke-width=\"1\" stroke=\"FILLCOLOR\" fill=\"transparent\" /><line x1=\"1\" y1=\"10\" x2=\"6\" y2=\"5\" stroke=\"FILLCOLOR\" stroke-width=\"0.5\" /><line x1=\"2\" y1=\"12\" x2=\"10\" y2=\"4\" stroke=\"FILLCOLOR\" stroke-width=\"0.5\" /><line x1=\"5\" y1=\"12\" x2=\"12\" y2=\"5\" stroke=\"FILLCOLOR\" stroke-width=\"0.5\" /><line x1=\"7\" y1=\"13\" x2=\"13\" y2=\"7\" stroke=\"FILLCOLOR\" stroke-width=\"0.5\" /><line x1=\"10\" y1=\"13\" x2=\"13\" y2=\"10\" stroke=\"FILLCOLOR\" stroke-width=\"0.5\" /></svg>',\n            OVERLAY: '<svg xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10,5,10,1,14,1,14,14,2,14,2,9,6,9,6,5\" fill=\"transparent\" stroke=\"FILLCOLOR\" stroke-width=\"2\"/></svg>'\n        }\n \n    };\n\n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Catalog\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Source } from \"./Source.js\"\nimport { Color } from \"./Color.js\"\nimport { HealpixIndex }   from \"./libs/healpix.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\nimport { Utils } from \"./Utils.js\";\nimport { AladinUtils } from \"./AladinUtils.js\";\nimport { Coo } from \"./libs/astro/coo.js\";\n\n// TODO : harmoniser parsing avec classe ProgressiveCat\nexport let Catalog = (function() {\n\n   function Catalog(options) {\n        options = options || {};\n\n        this.type = 'catalog';    \tthis.name = options.name || \"catalog\";\n    \tthis.color = options.color || Color.getNextColor();\n    \tthis.sourceSize = options.sourceSize || 8;\n    \tthis.markerSize = options.sourceSize || 12;\n    \tthis.shape = options.shape || \"square\";\n        this.maxNbSources = options.limit || undefined;\n        this.onClick = options.onClick || undefined;\n\n        this.raField = options.raField || undefined; // ID or name of the field holding RA\n        this.decField = options.decField || undefined; // ID or name of the field holding dec\n\n    \tthis.indexationNorder = 5; //  quel niveau indexe-t-on les sources\n    \tthis.sources = [];\n    \tthis.hpxIdx = new HealpixIndex(this.indexationNorder);\n    \tthis.hpxIdx.init();\n\n        this.displayLabel = options.displayLabel || false;\n        this.labelColor = options.labelColor || this.color;\n        this.labelFont = options.labelFont || '10px sans-serif';\n        if (this.displayLabel) {\n            this.labelColumn = options.labelColumn;\n            if (!this.labelColumn) {\n                this.displayLabel = false;\n            }\n        }\n    \t\n        if (this.shape instanceof Image || this.shape instanceof HTMLCanvasElement) {\n            this.sourceSize = this.shape.width;\n        }\n        this._shapeIsFunction = false; // if true, the shape is a function drawing on the canvas\n        if ($.isFunction(this.shape)) {\n            this._shapeIsFunction = true;\n        }\n        \n    \tthis.selectionColor = '#00ff00';\n    \t\n\n        // create this.cacheCanvas    \t\n    \t// cacheCanvas permet de ne crer le path de la source qu'une fois, et de le rutiliser (cf. http://simonsarris.com/blog/427-increasing-performance-by-caching-paths-on-canvas)\n        this.updateShape(options);\n\n        this.cacheMarkerCanvas = document.createElement('canvas');\n        this.cacheMarkerCanvas.width = this.markerSize;\n        this.cacheMarkerCanvas.height = this.markerSize;\n        var cacheMarkerCtx = this.cacheMarkerCanvas.getContext('2d');\n        cacheMarkerCtx.fillStyle = this.color;\n        cacheMarkerCtx.beginPath();\n        var half = (this.markerSize)/2.;\n        cacheMarkerCtx.arc(half, half, half-2, 0, 2 * Math.PI, false);\n        cacheMarkerCtx.fill();\n        cacheMarkerCtx.lineWidth = 2;\n        cacheMarkerCtx.strokeStyle = '#ccc';\n        cacheMarkerCtx.stroke();\n        \n\n        this.isShowing = true;\n    };\n    \n    Catalog.createShape = function(shapeName, color, sourceSize) {\n        if (shapeName instanceof Image || shapeName instanceof HTMLCanvasElement) { // in this case, the shape is already created\n            return shapeName;\n        }\n        var c = document.createElement('canvas');\n        c.width = c.height = sourceSize;\n        var ctx= c.getContext('2d');\n        ctx.beginPath();\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2.0;\n        if (shapeName==\"plus\") {\n            ctx.moveTo(sourceSize/2., 0);\n            ctx.lineTo(sourceSize/2., sourceSize);\n            ctx.stroke();\n            \n            ctx.moveTo(0, sourceSize/2.);\n            ctx.lineTo(sourceSize, sourceSize/2.);\n            ctx.stroke();\n        }\n        else if (shapeName==\"cross\") {\n            ctx.moveTo(0, 0);\n            ctx.lineTo(sourceSize-1, sourceSize-1);\n            ctx.stroke();\n            \n            ctx.moveTo(sourceSize-1, 0);\n            ctx.lineTo(0, sourceSize-1);\n            ctx.stroke();\n        }\n        else if (shapeName==\"rhomb\") {\n            ctx.moveTo(sourceSize/2, 0);\n            ctx.lineTo(0, sourceSize/2);\n            ctx.lineTo(sourceSize/2, sourceSize);\n            ctx.lineTo(sourceSize, sourceSize/2);\n            ctx.lineTo(sourceSize/2, 0);\n            ctx.stroke();\n        }\n        else if (shapeName==\"triangle\") {\n            ctx.moveTo(sourceSize/2, 0);\n            ctx.lineTo(0, sourceSize-1);\n            ctx.lineTo(sourceSize-1, sourceSize-1);\n            ctx.lineTo(sourceSize/2, 0);\n            ctx.stroke();\n        }\n        else if (shapeName==\"circle\") {\n            ctx.arc(sourceSize/2, sourceSize/2, sourceSize/2 - 1, 0, 2*Math.PI, true);\n            ctx.stroke();\n        }\n        else { // default shape: square\n            ctx.moveTo(1, 0);\n            ctx.lineTo(1,  sourceSize-1);\n            ctx.lineTo( sourceSize-1,  sourceSize-1);\n            ctx.lineTo( sourceSize-1, 1);\n            ctx.lineTo(1, 1);\n            ctx.stroke();\n        }\n        \n        return c;\n        \n    };\n    \n\n        // find RA, Dec fields among the given fields\n        //\n        // @param fields: list of objects with ucd, unit, ID, name attributes\n        // @param raField:  index or name of right ascension column (might be undefined)\n        // @param decField: index or name of declination column (might be undefined)\n        //\n        function findRADecFields(fields, raField, decField) {\n            var raFieldIdx,  decFieldIdx;\n            raFieldIdx = decFieldIdx = null;\n\n            // first, look if RA/DEC fields have been already given\n            if (raField) { // ID or name of RA field given at catalogue creation\n                for (var l=0, len=fields.length; l<len; l++) {\n                    var field = fields[l];\n                    if (Utils.isInt(raField) && raField<fields.length) { // raField can be given as an index\n                        raFieldIdx = raField;\n                        break;\n                    } \n                    if ( (field.ID && field.ID===raField) || (field.name && field.name===raField)) {\n                        raFieldIdx = l;\n                        break;\n                    }\n                }\n            }\n            if (decField) { // ID or name of dec field given at catalogue creation\n                for (var l=0, len=fields.length; l<len; l++) {\n                    var field = fields[l];\n                    if (Utils.isInt(decField) && decField<fields.length) { // decField can be given as an index\n                        decFieldIdx = decField;\n                        break;\n                    } \n                    if ( (field.ID && field.ID===decField) || (field.name && field.name===decField)) {\n                        decFieldIdx = l;\n                        break;\n                    }\n                }\n            }\n            // if not already given, let's guess position columns on the basis of UCDs\n            for (var l=0, len=fields.length; l<len; l++) {\n                if (raFieldIdx!=null && decFieldIdx!=null) {\n                    break;\n                }\n\n                var field = fields[l];\n                if ( ! raFieldIdx) {\n                    if (field.ucd) {\n                        var ucd = $.trim(field.ucd.toLowerCase());\n                        if (ucd.indexOf('pos.eq.ra')==0 || ucd.indexOf('pos_eq_ra')==0) {\n                            raFieldIdx = l;\n                            continue;\n                        }\n                    }\n                }\n                    \n                if ( ! decFieldIdx) {\n                    if (field.ucd) {\n                        var ucd = $.trim(field.ucd.toLowerCase());\n                        if (ucd.indexOf('pos.eq.dec')==0 || ucd.indexOf('pos_eq_dec')==0) {\n                            decFieldIdx = l;\n                            continue;\n                        }\n                    }\n                }\n            }\n\n            // still not found ? try some common names for RA and Dec columns\n            if (raFieldIdx==null && decFieldIdx==null) {\n                for (var l=0, len=fields.length; l<len; l++) {\n                    var field = fields[l];\n                    var name = field.name || field.ID || '';\n                    name = name.toLowerCase();\n                    \n                    if ( ! raFieldIdx) {\n                        if (name.indexOf('ra')==0 || name.indexOf('_ra')==0 || name.indexOf('ra(icrs)')==0 || name.indexOf('_ra')==0 || name.indexOf('alpha')==0) {\n                            raFieldIdx = l;\n                            continue;\n                        }\n                    }\n\n                    if ( ! decFieldIdx) {\n                        if (name.indexOf('dej2000')==0 || name.indexOf('_dej2000')==0 || name.indexOf('de')==0 || name.indexOf('de(icrs)')==0 || name.indexOf('_de')==0 || name.indexOf('delta')==0) {\n                            decFieldIdx = l;\n                            continue;\n                        }\n                    }\n                    \n                }\n            }\n\n            // last resort: take two first fieds\n            if (raFieldIdx==null || decFieldIdx==null) {\n                raFieldIdx  = 0;\n                decFieldIdx = 1\n            }\n\n            return [raFieldIdx, decFieldIdx];\n        };\n        \n    \n    \n    // return an array of Source(s) from a VOTable url\n    // callback function is called each time a TABLE element has been parsed\n    Catalog.parseVOTable = function(url, callback, maxNbSources, useProxy, raField, decField) {\n\n        // adapted from votable.js\n        function getPrefix($xml) {\n            var prefix;\n            // If Webkit chrome/safari/... (no need prefix)\n            if($xml.find('RESOURCE').length>0) {\n                prefix = '';\n            }\n            else {\n                // Select all data in the document\n                prefix = $xml.find(\"*\").first();\n\n                if (prefix.length==0) {\n                    return '';\n                }\n\n                // get name of the first tag\n                prefix = prefix.prop(\"tagName\");\n\n                var idx = prefix.indexOf(':');\n\n                prefix = prefix.substring(0, idx) + \"\\\\:\";\n\n\n            }\n\n            return prefix;\n        }\n\n        function doParseVOTable(xml, callback) {\n            xml = xml.replace(/^\\s+/g, ''); // we need to trim whitespaces at start of document\n            var attributes = [\"name\", \"ID\", \"ucd\", \"utype\", \"unit\", \"datatype\", \"arraysize\", \"width\", \"precision\"];\n            \n            var fields = [];\n            var k = 0;\n            var $xml = $($.parseXML(xml));\n            var prefix = getPrefix($xml);\n            $xml.find(prefix + \"FIELD\").each(function() {\n                var f = {};\n                for (var i=0; i<attributes.length; i++) {\n                    var attribute = attributes[i];\n                    if ($(this).attr(attribute)) {\n                        f[attribute] = $(this).attr(attribute);\n                    }\n                }\n                if ( ! f.ID) {\n                    f.ID = \"col_\" + k;\n                }\n                fields.push(f);\n                k++;\n            });\n                \n            var raDecFieldIdxes = findRADecFields(fields, raField, decField);\n            var raFieldIdx,  decFieldIdx;\n            raFieldIdx = raDecFieldIdxes[0];\n            decFieldIdx = raDecFieldIdxes[1];\n\n            var sources = [];\n            \n            var coo = new Coo();\n            var ra, dec;\n            $xml.find(prefix + \"TR\").each(function() {\n               var mesures = {};\n               var k = 0;\n               $(this).find(prefix + \"TD\").each(function() {\n                   var key = fields[k].name ? fields[k].name : fields[k].id;\n                   mesures[key] = $(this).text();\n                   k++;\n               });\n               var keyRa = fields[raFieldIdx].name ? fields[raFieldIdx].name : fields[raFieldIdx].id;\n               var keyDec = fields[decFieldIdx].name ? fields[decFieldIdx].name : fields[decFieldIdx].id;\n\n               if (Utils.isNumber(mesures[keyRa]) && Utils.isNumber(mesures[keyDec])) {\n                   ra = parseFloat(mesures[keyRa]);\n                   dec = parseFloat(mesures[keyDec]);\n               }\n               else {\n                   coo.parse(mesures[keyRa] + \" \" + mesures[keyDec]);\n                   ra = coo.lon;\n                   dec = coo.lat;\n               }\n               sources.push(new Source(ra, dec, mesures));\n               if (maxNbSources && sources.length==maxNbSources) {\n                   return false; // break the .each loop\n               }\n                \n            });\n            if (callback) {\n                callback(sources);\n            }\n        }\n        \n        var ajax = Utils.getAjaxObject(url, 'GET', 'text', useProxy);\n        ajax.done(function(xml) {\n            doParseVOTable(xml, callback);\n        });\n    };\n\n    // API\n    Catalog.prototype.updateShape = function(options) {\n        options = options || {};\n    \tthis.color = options.color || this.color || Color.getNextColor();\n    \tthis.sourceSize = options.sourceSize || this.sourceSize || 6;\n    \tthis.shape = options.shape || this.shape || \"square\";\n\n        this.selectSize = this.sourceSize + 2;\n\n        this.cacheCanvas = Catalog.createShape(this.shape, this.color, this.sourceSize); \n        this.cacheSelectCanvas = Catalog.createShape('square', this.selectionColor, this.selectSize);\n\n        this.reportChange();\n    };\n    \n    // API\n    Catalog.prototype.addSources = function(sourcesToAdd) {\n        sourcesToAdd = [].concat(sourcesToAdd); // make sure we have an array and not an individual source\n    \tthis.sources = this.sources.concat(sourcesToAdd);\n    \tfor (var k=0, len=sourcesToAdd.length; k<len; k++) {\n    \t    sourcesToAdd[k].setCatalog(this);\n    \t}\n        this.reportChange();\n    };\n\n    // API\n    //\n    // create sources from a 2d array and add them to the catalog\n    //\n    // @param columnNames: array with names of the columns\n    // @array: 2D-array, each item being a 1d-array with the same number of items as columnNames\n    Catalog.prototype.addSourcesAsArray = function(columnNames, array) {\n        var fields = [];\n        for (var colIdx=0 ; colIdx<columnNames.length; colIdx++) {\n            fields.push({name: columnNames[colIdx]});\n        }\n        var raDecFieldIdxes = findRADecFields(fields, this.raField, this.decField);\n        var raFieldIdx,  decFieldIdx;\n        raFieldIdx = raDecFieldIdxes[0];\n        decFieldIdx = raDecFieldIdxes[1];\n\n\n        var newSources = [];\n        var coo = new Coo();\n        var ra, dec, row, dataDict;\n        for (var rowIdx=0 ; rowIdx<array.length ; rowIdx++) {\n            row = array[rowIdx];\n            if (Utils.isNumber(row[raFieldIdx]) && Utils.isNumber(row[decFieldIdx])) {\n                   ra = parseFloat(row[raFieldIdx]);\n                   dec = parseFloat(row[decFieldIdx]);\n            }\n               else {\n                   coo.parse(row[raFieldIdx] + \" \" + row[decFieldIdx]);\n                   ra = coo.lon;\n                   dec = coo.lat;\n               }\n\n            dataDict = {};\n            for (var colIdx=0 ; colIdx<columnNames.length; colIdx++) {\n                dataDict[columnNames[colIdx]] = row[colIdx];\n            }\n\n            newSources.push(A.source(ra, dec, dataDict));\n        }\n\n        this.addSources(newSources);\n    };\n    \n    // return the current list of Source objects\n    Catalog.prototype.getSources = function() {\n        return this.sources;\n    };\n    \n    // TODO : fonction gnrique traversant la liste des sources\n    Catalog.prototype.selectAll = function() {\n        if (! this.sources) {\n            return;\n        }\n        \n        for (var k=0; k<this.sources.length; k++) {\n            this.sources[k].select();\n        }\n    };\n    \n    Catalog.prototype.deselectAll = function() {\n        if (! this.sources) {\n            return;\n        }\n        \n        for (var k=0; k<this.sources.length; k++) {\n            this.sources[k].deselect();\n        }\n    };\n    \n    // return a source by index\n    Catalog.prototype.getSource = function(idx) {\n        if (idx<this.sources.length) {\n            return this.sources[idx];\n        }\n        else {\n            return null;\n        }\n    };\n    \n    Catalog.prototype.setView = function(view) {\n        this.view = view;\n        this.reportChange();\n    };\n\n    // remove a source\n    Catalog.prototype.remove = function(source) {\n        var idx = this.sources.indexOf(source);\n        if (idx<0) {\n            return;\n        }\n\n        this.sources[idx].deselect();\n        this.sources.splice(idx, 1);\n\n        this.reportChange();\n    };\n    \n    Catalog.prototype.removeAll = Catalog.prototype.clear = function() {\n        // TODO : RAZ de l'index\n        this.sources = [];\n    };\n    \n    Catalog.prototype.draw = function(ctx, projection, frame, width, height, largestDim, zoomFactor) {\n        if (! this.isShowing) {\n            return;\n        }\n        // trac simple\n        //ctx.strokeStyle= this.color;\n\n        //ctx.lineWidth = 1;\n    \t//ctx.beginPath();\n        if (this._shapeIsFunction) {\n            ctx.save();\n        }\n        var sourcesInView = [];\n \t    for (var k=0, len = this.sources.length; k<len; k++) {\n\t\t    var inView = Catalog.drawSource(this, this.sources[k], ctx, projection, frame, width, height, largestDim, zoomFactor);\n            if (inView) {\n                sourcesInView.push(this.sources[k]);\n            }\n        }\n        if (this._shapeIsFunction) {\n            ctx.restore();\n        }\n        //ctx.stroke();\n\n    \t// trac slection\n        ctx.strokeStyle= this.selectionColor;\n        //ctx.beginPath();\n        var source;\n        for (var k=0, len = sourcesInView.length; k<len; k++) {\n            source = sourcesInView[k];\n            if (! source.isSelected) {\n                continue;\n            }\n            Catalog.drawSourceSelection(this, source, ctx);\n            \n        }\n        // NEEDED ?\n    \t//ctx.stroke();\n\n        // trac label\n        if (this.displayLabel) {\n            ctx.fillStyle = this.labelColor;\n            ctx.font = this.labelFont;\n            for (var k=0, len = sourcesInView.length; k<len; k++) {\n                Catalog.drawSourceLabel(this, sourcesInView[k], ctx);\n            }\n        }\n    };\n    \n    \n    \n    Catalog.drawSource = function(catalogInstance, s, ctx, projection, frame, width, height, largestDim, zoomFactor) {\n        if (! s.isShowing) {\n            return false;\n        }\n        var sourceSize = catalogInstance.sourceSize;\n        //console.log('COMPUTE', aladin.webglAPI.worldToScreen(s.ra, s.dec));\n        var xy = catalogInstance.view.aladin.webglAPI.worldToScreen(s.ra, s.dec);\n\n        /*\n        // TODO : we could factorize this code with Aladin.world2pix\n        var xy;\n        if (frame.system != CooFrameEnum.SYSTEMS.J2000) {\n            var lonlat = CooConversion.J2000ToGalactic([s.ra, s.dec]);\n            xy = projection.project(lonlat[0], lonlat[1]);\n        }\n        else {\n            xy = projection.project(s.ra, s.dec);\n        }\n        */\n\n        if (xy) {\n            //var xyview = AladinUtils.xyToView(xy.X, xy.Y, width, height, largestDim, zoomFactor, true);\n            var xyview = {vx: xy[0], vy: xy[1]};\n            var max = s.popup ? 100 : s.sourceSize;\n            if (xyview) {\n                // TODO : index sources by HEALPix cells at level 3, 4 ?\n\n                // check if source is visible in view\n                if (xyview.vx>(width+max)  || xyview.vx<(0-max) ||\n                    xyview.vy>(height+max) || xyview.vy<(0-max)) {\n                    s.x = s.y = undefined;\n                    return false;\n                }\n                \n                s.x = xyview.vx;\n                s.y = xyview.vy;\n                if (catalogInstance._shapeIsFunction) {\n                    catalogInstance.shape(s, ctx, catalogInstance.view.getViewParams());\n                }\n                else if (s.marker && s.useMarkerDefaultIcon) {\n                    ctx.drawImage(catalogInstance.cacheMarkerCanvas, s.x-sourceSize/2, s.y-sourceSize/2);\n                }\n                else {\n                    ctx.drawImage(catalogInstance.cacheCanvas, s.x-catalogInstance.cacheCanvas.width/2, s.y-catalogInstance.cacheCanvas.height/2);\n                }\n\n\n                // has associated popup ?\n                if (s.popup) {\n                    s.popup.setPosition(s.x, s.y);\n                }\n                \n                \n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n\n        \n    };\n    \n    Catalog.drawSourceSelection = function(catalogInstance, s, ctx) {\n        if (!s || !s.isShowing || !s.x || !s.y) {\n            return;\n        }\n        var sourceSize = catalogInstance.selectSize;\n        \n        ctx.drawImage(catalogInstance.cacheSelectCanvas, s.x-sourceSize/2, s.y-sourceSize/2);\n    };\n\n    Catalog.drawSourceLabel = function(catalogInstance, s, ctx) {\n        if (!s || !s.isShowing || !s.x || !s.y) {\n            return;\n        }\n\n        var label = s.data[catalogInstance.labelColumn];\n        if (!label) {\n            return;\n        }\n\n        ctx.fillText(label, s.x, s.y);\n    };\n\n    \n    // callback function to be called when the status of one of the sources has changed\n    Catalog.prototype.reportChange = function() {\n        this.view && this.view.requestRedraw();\n    };\n    \n    Catalog.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        this.reportChange();\n    };\n    \n    Catalog.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        if (this.view && this.view.popup && this.view.popup.source && this.view.popup.source.catalog==this) {\n            this.view.popup.hide();\n        }\n\n        this.reportChange();\n    };\n\n    return Catalog;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Circle\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Utils } from \"./Utils.js\";\nimport { AladinUtils } from \"./AladinUtils.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\nimport { Aladin } from \"./Aladin.js\";\n\n// TODO : Circle and Footprint should inherit from the same root object\nexport let Circle = (function() {\n    // constructor\n    let Circle = function(centerRaDec, radiusDegrees, options) {\n        options = options || {};\n\n        this.color = options['color'] || undefined;\n\n        // TODO : all graphic overlays should have an id\n        this.id = 'circle-' + Utils.uuidv4();\n\n        this.setCenter(centerRaDec);\n        this.setRadius(radiusDegrees);\n    \tthis.overlay = null;\n    \t\n    \tthis.isShowing = true;\n    \tthis.isSelected = false;\n    };\n\n    Circle.prototype.setOverlay = function(overlay) {\n        this.overlay = overlay;\n    };\n    \n    Circle.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Circle.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Circle.prototype.dispatchClickEvent = function() {\n        if (this.overlay) {\n            // footprint selection code adapted from Fabrizio Giordano dev. from Serco for ESA/ESDC\n            //window.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n            this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n                detail: {\n                    footprintId: this.id,\n                    overlayName: this.overlay.name\n                }\n            }));\n        }\n    };\n    \n    Circle.prototype.select = function() {\n        if (this.isSelected) {\n            return;\n        }\n        this.isSelected = true;\n        if (this.overlay) {\n/*\n            this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n                detail: {\n                    footprintId: this.id,\n                    overlayName: this.overlay.name\n                }\n            }));\n*/\n\n            this.overlay.reportChange();\n        }\n    };\n\n    Circle.prototype.deselect = function() {\n        if (! this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n\n    \n    Circle.prototype.setCenter = function(centerRaDec) {\n        this.centerRaDec = centerRaDec;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n    Circle.prototype.setRadius = function(radiusDegrees) {\n        this.radiusDegrees = radiusDegrees;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n    // TODO\n    Circle.prototype.draw = function(ctx, view, projection, frame, width, height, largestDim, zoomFactor, noStroke) {\n        if (! this.isShowing) {\n            return;\n        }\n        noStroke = noStroke===true || false;\n\n        /*var centerXy;\n        if (frame.system != CooFrameEnum.SYSTEMS.J2000) {\n            var lonlat = CooConversion.J2000ToGalactic([this.centerRaDec[0], this.centerRaDec[1]]);\n            centerXy = projection.project(lonlat[0], lonlat[1]);\n        }\n        else {\n            centerXy = projection.project(this.centerRaDec[0], this.centerRaDec[1]);\n        }\n        if (!centerXy) {\n            return;\n        }\n        var centerXyview = AladinUtils.xyToView(centerXy.X, centerXy.Y, width, height, largestDim, zoomFactor, false);*/\n        var centerXyview = AladinUtils.radecToViewXy(this.centerRaDec[0], this.centerRaDec[1], view);\n        if (!centerXyview) {\n            // the center goes out of the projection\n            // we do not draw it\n            return;\n        }\n        // compute value of radius in pixels in current projection\n        var ra = this.centerRaDec[0];\n        var dec = this.centerRaDec[1] + (ra>0 ? - this.radiusDegrees : this.radiusDegrees);\n        /*\n        var circlePtXy;\n        if (frame.system != CooFrameEnum.SYSTEMS.J2000) {\n            var lonlat = CooConversion.J2000ToGalactic([ra, dec]);\n            circlePtXy = projection.project(lonlat[0], lonlat[1]);\n        }\n        else {\n            circlePtXy = projection.project(ra, dec);\n        }\n        if (!circlePtXy) {\n            return;\n        }\n        var circlePtXyView = AladinUtils.xyToView(circlePtXy.X, circlePtXy.Y, width, height, largestDim, zoomFactor, false);\n        */\n        let circlePtXyView = AladinUtils.radecToViewXy(ra, dec, view);\n        if (!circlePtXyView) {\n            // the circle border goes out of the projection\n            // we do not draw it\n            return;\n        }\n        var dx = circlePtXyView[0] - centerXyview[0];\n        var dy = circlePtXyView[1] - centerXyview[1];\n        var radiusInPix = Math.sqrt(dx*dx + dy*dy);\n\n        // TODO : check each 4 point until show\n        var baseColor = this.color;\n        if (! baseColor && this.overlay) {\n            baseColor = this.overlay.color;\n        }\n        if (! baseColor) {\n            baseColor = '#ff0000';\n        }\n        \n        if (this.isSelected) {\n            ctx.strokeStyle= Overlay.increaseBrightness(baseColor, 50);\n        }\n        else {\n            ctx.strokeStyle= baseColor;\n        }\n\n        ctx.beginPath();\n        ctx.arc(centerXyview[0], centerXyview[1], radiusInPix, 0, 2*Math.PI, false);\n        if (!noStroke) {\n            ctx.stroke();\n        }\n    }; \n    \n    return Circle;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Color\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nexport let Color = (function() {\n\n\n    let Color = {};\n    \n    Color.curIdx = 0;\n    Color.colors = ['#ff0000', '#0000ff', '#99cc00', '#ffff00','#000066', '#00ffff', '#9900cc', '#0099cc', '#cc9900', '#cc0099', '#00cc99', '#663333', '#ffcc9a', '#ff9acc', '#ccff33', '#660000', '#ffcc33', '#ff00ff', '#00ff00', '#ffffff'];\n\n    \n    Color.getNextColor = function() {\n        var c = Color.colors[Color.curIdx % (Color.colors.length)];\n        Color.curIdx++;\n        return c;\n    };\n\n    /** return most suited (ie readable) color for a label, given a background color\n     * bkgdColor: color, given as a 'rgb(<r value>, <g value>, <v value>)' . This is returned by $(<element>).css('background-color')\n     * \n     * example call: Color.getLabelColorForBackground('rgb(3, 123, 42)')\n     * adapted from http://stackoverflow.com/questions/1855884/determine-font-color-based-on-background-color\n     */\n    Color.getLabelColorForBackground = function(rgbBkgdColor) {\n        var lightLabel = '#eee' \n        var darkLabel = '#111' \n        var rgb = rgbBkgdColor.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\n        if (rgb==null) {\n            // we return the dark label color if we can't parse the color\n            return darkLabel\n        }\n        var r = parseInt(rgb[1]);\n        var g = parseInt(rgb[2]);\n        var b = parseInt(rgb[3]);\n        \n        var d = 0;\n        // Counting the perceptive luminance - human eye favors green color... \n        var a = 1 - ( 0.299 * r + 0.587 * g + 0.114 * b) / 255;\n\n        if (a < 0.5) {\n            return darkLabel; // bright color --> dark font\n        }\n        else {\n            return lightLabel; // dark color --> light font\n        }\n    };\n    \n    return Color;\n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File ColorMap.js\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { AladinUtils } from \"./AladinUtils.js\";\n\nexport let ColorMap = (function() {\n    \n    \n    // constructor\n    let ColorMap = function(view) {\n        this.view = view;\n        this.reversed = false;\n        this.mapName = 'native';\n        this.sig = this.signature();\n    };\n    \nColorMap.MAPS = {};\n    \n    ColorMap.MAPS['eosb'] = {\n            name: 'Eos B',\n            r: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,9,18,27,36,45,49,57,72,81,91,100,109,118,127,\n                136,131,139,163,173,182,191,200,209,218,227,213,221,255,255,255,255,255,\n                255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,\n                255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,\n                255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,\n                229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,\n                255,229,229,255,255,255,255,255,255,255,255,229,229,255,253,251,249,247,\n                245,243,241,215,214,235,234,232,230,228,226,224,222,198,196,216,215,213,\n                211,209,207,205,203,181,179,197,196,194,192,190,188,186,184,164,162,178,\n                176,175,173,171,169,167,165,147,145,159,157,156,154,152,150,148,146,130,\n                128,140,138,137,135,133,131,129,127,113,111,121,119,117,117],\n            g: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,15,23,31,39,47,55,57,64,79,87,95,\n                103,111,119,127,135,129,136,159,167,175,183,191,199,207,215,200,207,239,\n                247,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,\n                229,255,255,255,255,255,255,255,255,229,229,255,250,246,242,238,233,229,\n                225,198,195,212,208,204,199,195,191,187,182,160,156,169,165,161,157,153,\n                148,144,140,122,118,127,125,123,121,119,116,114,112,99,97,106,104,102,\n                99,97,95,93,91,80,78,84,82,80,78,76,74,72,70,61,59,63,61,59,57,55,53,50,\n                48,42,40,42,40,38,36,33,31,29,27,22,21,21,19,16,14,12,13,8,6,3,1,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n            b: [116,121,127,131,136,140,144,148,153,\n                157,145,149,170,174,178,182,187,191,195,199,183,187,212,216,221,225,229,\n                233,238,242,221,225,255,247,239,231,223,215,207,199,172,164,175,167,159,\n                151,143,135,127,119,100,93,95,87,79,71,63,55,47,39,28,21,15,7,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0]\n    };\n    ColorMap.MAPS['rainbow'] = {\n            name: 'Rainbow',\n            r: [0,4,9,13,18,22,27,31,36,40,45,50,54,\n                58,61,64,68,69,72,74,77,79,80,82,83,85,84,86,87,88,86,87,87,87,85,84,84,\n                84,83,79,78,77,76,71,70,68,66,60,58,55,53,46,43,40,36,33,25,21,16,12,4,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,21,25,29,33,42,\n                46,51,55,63,67,72,76,80,89,93,97,101,110,114,119,123,131,135,140,144,153,\n                157,161,165,169,178,182,187,191,199,203,208,212,221,225,229,233,242,246,\n                250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255],\n            g: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,4,8,16,21,25,29,38,42,46,51,55,63,67,72,76,84,89,93,97,\n                106,110,114,119,127,131,135,140,144,152,157,161,165,174,178,182,187,195,\n                199,203,208,216,220,225,229,233,242,246,250,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,250,242,238,233,229,221,216,212,208,199,195,191,187,178,174,170,165,\n                161,153,148,144,140,131,127,123,119,110,106,102,97,89,85,80,76,72,63,59,\n                55,51,42,38,34,29,21,17,12,8,0],\n            b: [0,3,7,10,14,19,23,28,32,38,43,48,53,\n                59,63,68,72,77,81,86,91,95,100,104,109,113,118,122,127,132,136,141,145,\n                150,154,159,163,168,173,177,182,186,191,195,200,204,209,214,218,223,227,\n                232,236,241,245,250,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n                255,255,255,255,255,255,246,242,238,233,225,220,216,212,203,199,195,191,\n                187,178,174,170,165,157,152,148,144,135,131,127,123,114,110,106,102,97,\n                89,84,80,76,67,63,59,55,46,42,38,34,25,21,16,12,8,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    };\n    ColorMap.MAPS['cubehelix'] = {\n            name: 'Cubehelix',\n            r: [0,1,3,4,6,8,9,10,12,13,14,15,17,18,\n                19,20,20,21,22,23,23,24,24,25,25,25,26,26,26,26,26,26,26,26,26,26,26,25,\n                25,25,25,24,24,24,23,23,23,23,22,22,22,21,21,21,21,21,21,20,20,20,21,21,\n                21,21,21,22,22,22,23,23,24,25,26,27,27,28,30,31,32,33,35,36,38,39,41,43,\n                45,47,49,51,53,55,57,60,62,65,67,70,72,75,78,81,83,86,89,92,95,98,101,104,\n                107,110,113,116,120,123,126,129,132,135,138,141,144,147,150,153,155,158,\n                161,164,166,169,171,174,176,178,181,183,185,187,189,191,193,194,196,198,\n                199,201,202,203,204,205,206,207,208,209,209,210,211,211,211,212,212,212,\n                212,212,212,212,212,211,211,211,210,210,210,209,208,208,207,207,206,205,\n                205,204,203,203,202,201,201,200,199,199,198,197,197,196,196,195,195,194,\n                194,194,193,193,193,193,193,193,193,193,193,193,194,194,195,195,196,196,\n                197,198,199,200,200,202,203,204,205,206,208,209,210,212,213,215,217,218,\n                220,222,223,225,227,229,231,232,234,236,238,240,242,244,245,247,249,251,\n                253,255],\n            g: [0,0,1,1,2,2,3,4,4,5,6,6,7,8,9,10,\n                11,11,12,13,14,15,17,18,19,20,21,22,24,25,26,28,29,31,32,34,35,37,38,40,\n                41,43,45,46,48,50,52,53,55,57,58,60,62,64,66,67,69,71,73,74,76,78,79,81,\n                83,84,86,88,89,91,92,94,95,97,98,99,101,102,103,104,106,107,108,109,110,\n                111,112,113,114,114,115,116,116,117,118,118,119,119,120,120,120,121,121,\n                121,121,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,121,\n                121,121,121,121,121,121,121,121,120,120,120,120,120,120,120,120,120,120,\n                121,121,121,121,121,122,122,122,123,123,124,124,125,125,126,127,127,128,\n                129,130,131,131,132,133,135,136,137,138,139,140,142,143,144,146,147,149,\n                150,152,154,155,157,158,160,162,164,165,167,169,171,172,174,176,178,180,\n                182,183,185,187,189,191,193,194,196,198,200,202,203,205,207,208,210,212,\n                213,215,216,218,219,221,222,224,225,226,228,229,230,231,232,233,235,236,\n                237,238,239,240,240,241,242,243,244,244,245,246,247,247,248,248,249,250,\n                250,251,251,252,252,253,253,254,255],\n            b: [0,1,3,4,6,8,9,11,13,15,17,19,21,23,\n                25,27,29,31,33,35,37,39,41,43,45,47,48,50,52,54,56,57,59,60,62,63,65,66,\n                67,69,70,71,72,73,74,74,75,76,76,77,77,77,78,78,78,78,78,78,78,77,77,77,\n                76,76,75,75,74,73,73,72,71,70,69,68,67,66,66,65,64,63,61,60,59,58,58,57,\n                56,55,54,53,52,51,51,50,49,49,48,48,47,47,47,46,46,46,46,46,47,47,47,48,\n                48,49,50,50,51,52,53,55,56,57,59,60,62,64,65,67,69,71,74,76,78,81,83,86,\n                88,91,94,96,99,102,105,108,111,114,117,120,124,127,130,133,136,140,143,\n                146,149,153,156,159,162,165,169,172,175,178,181,184,186,189,192,195,197,\n                200,203,205,207,210,212,214,216,218,220,222,224,226,227,229,230,231,233,\n                234,235,236,237,238,239,239,240,241,241,242,242,242,243,243,243,243,243,\n                243,243,243,243,243,242,242,242,242,241,241,241,241,240,240,240,239,239,\n                239,239,239,238,238,238,238,238,238,238,238,239,239,239,240,240,240,241,\n                242,242,243,244,245,246,247,248,249,250,252,253,255]\n    };\n\n\n    \n    ColorMap.MAPS_CUSTOM = ['cubehelix', 'eosb', 'rainbow'];\n    ColorMap.MAPS_NAMES = ['native', 'grayscale'].concat(ColorMap.MAPS_CUSTOM);\n    \n    ColorMap.prototype.reverse = function(val) {\n        if (val) {\n            this.reversed = val;\n        }\n        else {\n            this.reversed = ! this.reversed;\n        }\n        this.sig = this.signature();\n        this.view.requestRedraw();\n    };\n    \n    \n    ColorMap.prototype.signature = function() {\n        var s = this.mapName;\n        \n        if (this.reversed) {\n            s += ' reversed';\n        }\n        \n        return s;\n    };\n    \n    ColorMap.prototype.update = function(mapName) {\n        this.mapName = mapName;\n        this.sig = this.signature();\n        this.view.requestRedraw();\n    };\n    \n    ColorMap.prototype.apply = function(img) {\n        if ( this.sig=='native' ) {\n            return img;\n        }\n        \n        if (img.cmSig==this.sig) {\n            return img.cmImg; // return cached pixels\n        }\n        \n        var canvas = document.createElement(\"canvas\");\n        canvas.width = img.width;\n        canvas.height = img.height;\n        var ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0);\n        \n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        var pixelData = imageData.data;\n        var length = pixelData.length;\n        var a, b, c;\n        var switchCase = 3;\n        if (this.mapName=='grayscale') {\n            switchCase = 1;\n        }\n        else if (ColorMap.MAPS_CUSTOM.indexOf(this.mapName)>=0) {\n            switchCase = 2;\n        }\n        for (var i = 0; i < length; i+= 4) {\n            switch(switchCase) {\n                case 1:\n                    a = b = c = AladinUtils.myRound((pixelData[i]+pixelData[i+1]+pixelData[i+2])/3);\n                    break;\n                case 2:\n                    if (this.reversed) {\n                        a = ColorMap.MAPS[this.mapName].r[255-pixelData[i]];\n                        b = ColorMap.MAPS[this.mapName].g[255-pixelData[i+1]];\n                        c = ColorMap.MAPS[this.mapName].b[255-pixelData[i+2]];\n                    }\n                    else {\n                        a = ColorMap.MAPS[this.mapName].r[pixelData[i]];\n                        b = ColorMap.MAPS[this.mapName].g[pixelData[i+1]];\n                        c = ColorMap.MAPS[this.mapName].b[pixelData[i+2]];\n                    }\n                    break;\n                default:\n                    a = pixelData[i];\n                    b = pixelData[i + 1];\n                    c = pixelData[i + 2];\n                    \n            }\n            if (switchCase!=2 && this.reversed) {\n                a = 255-a;\n                b = 255-b;\n                c = 255-c;\n              \n            }\n            pixelData[i]     = a;\n            pixelData[i + 1] = b;\n            pixelData[i + 2] = c;\n            \n        }\n        //imageData.data = pixelData;  // not needed, and create an error in strict mode !\n        ctx.putImageData(imageData, 0, 0);\n        \n        // cache image with color map applied\n        img.cmSig = this.sig;\n        img.cmImg = canvas;\n\n        return img.cmImg;\n    };\n    \n    return ColorMap;\n})();\n    \n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\nexport let CooConversion = (function() {\n\n    let CooConversion = {};\n    \n    CooConversion.GALACTIC_TO_J2000 = [\n       -0.0548755604024359,  0.4941094279435681, -0.8676661489811610,\n       -0.8734370902479237, -0.4448296299195045, -0.1980763734646737,\n       -0.4838350155267381,  0.7469822444763707,  0.4559837762325372 ];\n    \n    CooConversion.J2000_TO_GALACTIC = [\n        -0.0548755604024359, -0.873437090247923, -0.4838350155267381,\n         0.4941094279435681, -0.4448296299195045, 0.7469822444763707,\n        -0.8676661489811610, -0.1980763734646737, 0.4559837762325372 ];\n    \n    // adapted from www.robertmartinayers.org/tools/coordinates.html\n    // radec : array of ra, dec in degrees\n    // return coo in degrees\n    CooConversion.Transform = function( radec, matrix ) {// returns a radec array of two elements\n        radec[0] = radec[0]*Math.PI/180;\n        radec[1] = radec[1]*Math.PI/180;\n      var r0 = new Array ( \n       Math.cos(radec[0]) * Math.cos(radec[1]),\n       Math.sin(radec[0]) * Math.cos(radec[1]),\n       Math.sin(radec[1]) );\n        \n     var s0 = new Array (\n       r0[0]*matrix[0] + r0[1]*matrix[1] + r0[2]*matrix[2], \n       r0[0]*matrix[3] + r0[1]*matrix[4] + r0[2]*matrix[5], \n       r0[0]*matrix[6] + r0[1]*matrix[7] + r0[2]*matrix[8] ); \n     \n      var r = Math.sqrt ( s0[0]*s0[0] + s0[1]*s0[1] + s0[2]*s0[2] ); \n    \n      var result = new Array ( 0.0, 0.0 );\n      result[1] = Math.asin ( s0[2]/r ); // New dec in range -90.0 -- +90.0 \n      // or use sin^2 + cos^2 = 1.0  \n      var cosaa = ( (s0[0]/r) / Math.cos(result[1] ) );\n      var sinaa = ( (s0[1]/r) / Math.cos(result[1] ) );\n      result[0] = Math.atan2 (sinaa,cosaa);\n      if ( result[0] < 0.0 ) result[0] = result[0] + 2*Math.PI;\n    \n        result[0] = result[0]*180/Math.PI;\n        result[1] = result[1]*180/Math.PI;\n      return result;\n    };\n    \n    // coo : array of lon, lat in degrees\n    CooConversion.GalacticToJ2000 = function(coo) {\n        return CooConversion.Transform(coo, CooConversion.GALACTIC_TO_J2000);\n    };\n    // coo : array of lon, lat in degrees\n    CooConversion.J2000ToGalactic = function(coo) {\n        return CooConversion.Transform(coo, CooConversion.J2000_TO_GALACTIC);\n    };\n    return CooConversion;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File CooFrameEnum\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n \nexport let CooFrameEnum = (function() {\n\n    var systems = {J2000: 'J2000', GAL: 'Galactic'};\n    return {\n        SYSTEMS: systems,\n\n        J2000: {label: \"J2000\", system: systems.J2000},\n        J2000d: {label: \"J2000d\", system: systems.J2000},\n        GAL:  {label: \"Galactic\", system: systems.GAL},\n\n        fromString: function(str, defaultValue) {\n            if (! str) {\n                return defaultValue ? defaultValue : null;\n            }\n            \n            str = str.toLowerCase().replace(/^\\s+|\\s+$/g, ''); // convert to lowercase and trim\n            \n            if (str.indexOf('j2000d')==0 || str.indexOf('icrsd')==0) {\n                return CooFrameEnum.J2000d;\n            }\n            else if (str.indexOf('j2000')==0 || str.indexOf('icrs')==0) {\n                return CooFrameEnum.J2000;\n            }\n            else if (str.indexOf('gal')==0) {\n                return CooFrameEnum.GAL;\n            }\n            else {\n                return defaultValue ? defaultValue : null;\n            }\n        }\n    };\n \n})();\n\n\n\n\n\n","export let DiscoveryTree = (function () {\n    // Constructor\n    var DiscoveryTree = function (aladin) {\n        // activate Vue on the <div> that contains the component\n        new Vue({\n            el: '#ui',\n            methods: {\n                // Define the methods for the discovery-tree component\n                // to interact with the aladin viewer\n                getFovCorners() {\n                    return aladin.getFovCorners();\n                },\n                getCenter() {\n                    return aladin.getRaDec();\n                },\n                // Called when the user add a image survey\n                addImage(metadata) {\n                    const order = (+metadata.hips_order);\n                    const hipsTileFormat = metadata.hips_tile_format.split(' ');\n            \n                    let tileFormat;\n                    let color;\n                    if (hipsTileFormat.indexOf('fits') >= 0) {\n                        tileFormat = {\n                            FITSImage: {\n                                bitpix: parseInt(metadata.hips_pixel_bitpix)\n                            }\n                        };\n                        color = {\n                            Grayscale2Color: {\n                                color: [1.0, 1.0, 1.0],\n                                k: 1.0,\n                                transfer: \"asinh\"\n                            }\n                        };\n                    } else {\n                        color = \"Color\";\n\n                        if (hipsTileFormat.indexOf('png') >= 0) {\n                            tileFormat = {\n                                Image: {\n                                    format: \"png\"\n                                }\n                            };\n                        } else {\n                            tileFormat = {\n                                Image: {\n                                    format: \"jpeg\"\n                                }\n                            };\n                        }\n                    }\n\n                    let cuts = [undefined, undefined];\n                    if (metadata.hips_pixel_cut) {\n                        cuts = metadata.hips_pixel_cut.split(\" \");\n                    }\n                    let tileSize = 512;\n                    // Verify the validity of the tile width\n                    if (metadata.hips_tile_width) {\n                        let hipsTileWidth = parseInt(metadata.hips_tile_width);\n                        let isPowerOfTwo = hipsTileWidth && !(hipsTileWidth & (hipsTileWidth - 1));\n\n                        if (isPowerOfTwo === true) {\n                            tileSize = hipsTileWidth;\n                        }\n                    }\n                    let url = metadata.hips_service_url;\n                    if (url.startsWith('http://alasky')) {\n                        // From alasky one can directly use the https access\n                        url = url.replace('http', 'https');\n                    } else {\n                        // Pass by a proxy for extern http urls\n                        url = 'https://alasky.u-strasbg.fr/cgi/JSONProxy?url=' + url;\n                    }\n                    let survey = {\n                        properties: {\n                            url: url,\n                            maxOrder:  parseInt(metadata.hips_order),\n                            frame: {\n                                label: \"J2000\",\n                                system: \"J2000\"\n                            },\n                            tileSize: tileSize,\n                            format: tileFormat,\n                            minCutout: parseFloat(cuts[0]),\n                            maxCutout: parseFloat(cuts[1]),\n                        },\n                        color: color\n                    };\n\n                    aladin.webglAPI.setHiPS([survey]);\n                },\n                // Called when the user add a catalog survey\n                addCatalog(metadata, center, radius) {\n                    if (metadata.hips_service_url) {\n                        const hips = A.catalogHiPS(metadata.hips_service_url, {\n                            onClick: 'showTable',\n                            name: metadata.ID,\n                        });\n                        aladin.addCatalog(hips);\n                    } else {\n                        console.log(metadata.obs_id, \"center, \", center, \" radius, \", radius)\n                        const catalog = A.catalogFromVizieR(\n                            metadata.obs_id,\n                            {\n                                ra: center[0],\n                                dec: center[1]\n                            },\n                            radius, {\n                                onClick: 'showTable',\n                                limit: 1000,\n                            }\n                        );\n                        aladin.addCatalog(catalog);\n                    }\n                },\n                // Called when the user add a HEALPix coverage\n                addCoverage(metadata) {\n                    const moc = A.MOCFromURL(metadata.moc_access_url);\n                    aladin.addMOC(moc);\n                },\n            },\n        });\n    }\n\n    return DiscoveryTree;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Downloader\n * Queue downloading for image elements\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nexport let Downloader = (function() {\n\n\tvar NB_MAX_SIMULTANEOUS_DL = 4;\n\t// TODO : le fading ne marche pas bien actuellement\n\tvar FADING_ENABLED = false;\n\tvar FADING_DURATION = 700; // in milliseconds\n\t\n\t\n\tlet Downloader = function(view) {\n\t\tthis.view = view; // reference to the view to be able to request redraw\n\t\tthis.nbDownloads = 0; // number of current downloads\n\t\tthis.dlQueue = []; // queue of items being downloaded\n        this.urlsInQueue = {};\n\t};\n\n\tDownloader.prototype.emptyQueue = function() {\n\t\tthis.dlQueue = [];\n        this.urlsInQueue = {};\n    };\n\t\n\tDownloader.prototype.requestDownload = function(img, url, cors) {\n        // first check if url already in queue\n        if (url in this.urlsInQueue)  {\n            return;\n        }\n\t\t// put in queue\n\t\tthis.dlQueue.push({img: img, url: url, cors: cors});\n\t\tthis.urlsInQueue[url] = 1;\n\t\t\n\t\tthis.tryDownload();\n\t};\n\t\n\t// try to download next items in queue if possible\n\tDownloader.prototype.tryDownload = function() {\n\t    //if (this.dlQueue.length>0 && this.nbDownloads<NB_MAX_SIMULTANEOUS_DL) {\n\t\twhile (this.dlQueue.length>0 && this.nbDownloads<NB_MAX_SIMULTANEOUS_DL) {\n\t\t\tthis.startDownloadNext();\n\t\t}\n\t};\n\t\n\tDownloader.prototype.startDownloadNext = function() {\n\t\t// get next in queue\n\t\tvar next = this.dlQueue.shift();\n\t\tif ( ! next) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.nbDownloads++;\n\t\tvar downloaderRef = this;\n\t\tnext.img.onload = function() {\n\t\t\tdownloaderRef.completeDownload(this, true); // in this context, 'this' is the Image\n\t\t};\n\t\t\t\n\t\tnext.img.onerror = function(e) {\n\t\t\tdownloaderRef.completeDownload(this, false); // in this context, 'this' is the Image\n\t\t};\n\t\tif (next.cors) {\n\t\t    next.img.crossOrigin = 'anonymous';\n\t\t}\n\t\t\n\t\telse {\n\t\t    if (next.img.crossOrigin !== undefined) {\n\t\t        delete next.img.crossOrigin;\n\t\t    }\n\t\t}\n\t\t\n\t\t\n\t\tnext.img.src = next.url;\n\t};\n\t\n\tDownloader.prototype.completeDownload = function(img, success) {\n        delete this.urlsInQueue[img.src];\n\t\timg.onerror = null;\n\t\timg.onload = null;\n\t\tthis.nbDownloads--;\n\t\tif (success) {\n\t\t\tif (FADING_ENABLED) {\n\t\t\t\tvar now = new Date().getTime();\n\t\t\t\timg.fadingStart = now;\n\t\t\t\timg.fadingEnd = now + FADING_DURATION;\n\t\t\t}\n\t\t\tthis.view.requestRedraw();\n\t\t}\n\t\telse {\n\t\t    img.dlError = true;\n\t\t}\n\t\t\n\t\tthis.tryDownload();\n\t};\n\t\n\t\n\t\n\treturn Downloader;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Ellipse\n * \n * Author: Matthieu Baumann[CDS]\n * \n *****************************************************************************/\n\nimport { Utils } from \"./Utils.js\";\nimport { AladinUtils } from \"./AladinUtils.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\nimport { Aladin } from \"./Aladin.js\";\n\n// TODO : Ellipse, Circle and Footprint should inherit from the same root object\nexport let Ellipse = (function() {\n    // constructor\n    let Ellipse = function(centerRaDec, rayonXDegrees, rayonYDegrees, rotationDegrees, options) {\n        options = options || {};\n\n        this.color = options['color'] || undefined;\n\n        // TODO : all graphic overlays should have an id\n        this.id = 'ellipse-' + Utils.uuidv4();\n\n        this.setCenter(centerRaDec);\n        this.setRadiuses(rayonXDegrees, rayonYDegrees);\n        this.setRotation(rotationDegrees);\n    \tthis.overlay = null;\n    \t\n    \tthis.isShowing = true;\n        this.isSelected = false;\n    };\n\n    Ellipse.prototype.setOverlay = function(overlay) {\n        this.overlay = overlay;\n    };\n    \n    Ellipse.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Ellipse.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Ellipse.prototype.dispatchClickEvent = function() {\n        if (this.overlay) {\n            // footprint selection code adapted from Fabrizio Giordano dev. from Serco for ESA/ESDC\n            //window.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n            this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n                detail: {\n                    footprintId: this.id,\n                    overlayName: this.overlay.name\n                }\n            }));\n        }\n    };\n    \n    Ellipse.prototype.select = function() {\n        if (this.isSelected) {\n            return;\n        }\n        this.isSelected = true;\n        if (this.overlay) {\n/*\n            this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n                detail: {\n                    footprintId: this.id,\n                    overlayName: this.overlay.name\n                }\n            }));\n*/\n\n            this.overlay.reportChange();\n        }\n    };\n\n    Ellipse.prototype.deselect = function() {\n        if (! this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n\n    \n    Ellipse.prototype.setCenter = function(centerRaDec) {\n        this.centerRaDec = centerRaDec;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n    Ellipse.prototype.setRotation = function(rotationDegrees) {\n        // radians\n        let theta = rotationDegrees * Math.PI / 180;\n        this.rotation = theta;\n        // rotation in clockwise in the 2d canvas\n        // we must transform it so that it is a north to east rotation\n        //this.rotation = -theta - Math.PI/2;\n\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n    Ellipse.prototype.setRadiuses = function(radiusXDegrees, radiusYDegrees) {\n        this.radiusXDegrees = radiusXDegrees;\n        this.radiusYDegrees = radiusYDegrees;\n\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n    // TODO\n    Ellipse.prototype.draw = function(ctx, view, projection, frame, width, height, largestDim, zoomFactor, noStroke) {\n        if (! this.isShowing) {\n            return;\n        }\n        noStroke = noStroke===true || false;\n\n        var centerXyview = AladinUtils.radecToViewXy(this.centerRaDec[0], this.centerRaDec[1], view);\n        if (!centerXyview) {\n            // the center goes out of the projection\n            // we do not draw it\n            return;\n        }\n\n        let circlePtXyViewRa = AladinUtils.radecToViewXy(this.centerRaDec[0] + this.radiusXDegrees, this.centerRaDec[1], view);\n        let circlePtXyViewDec = AladinUtils.radecToViewXy(this.centerRaDec[0], this.centerRaDec[1] + this.radiusYDegrees, view);\n\n        if (!circlePtXyViewRa || !circlePtXyViewDec) {\n            // the circle border goes out of the projection\n            // we do not draw it\n            return;\n        }\n\n        var dxRa = circlePtXyViewRa[0] - centerXyview[0];\n        var dyRa = circlePtXyViewRa[1] - centerXyview[1];\n        var radiusInPixX = Math.sqrt(dxRa*dxRa + dyRa*dyRa);\n\n        var dxDec = circlePtXyViewDec[0] - centerXyview[0];\n        var dyDec = circlePtXyViewDec[1] - centerXyview[1];\n        var radiusInPixY = Math.sqrt(dxDec*dxDec + dyDec*dyDec);\n\n        // Ellipse crossing the projection\n        if ((dxRa*dyDec - dxDec*dyRa) <= 0.0) {\n            // We do not draw it\n            return;\n        }\n        // TODO : check each 4 point until show\n        var baseColor = this.color;\n        if (! baseColor && this.overlay) {\n            baseColor = this.overlay.color;\n        }\n        if (! baseColor) {\n            baseColor = '#ff0000';\n        }\n        \n        if (this.isSelected) {\n            ctx.strokeStyle= Overlay.increaseBrightness(baseColor, 50);\n        }\n        else {\n            ctx.strokeStyle= baseColor;\n        }\n\n        // 1. Find the spherical tangent vector going to the north\n        let origin = this.centerRaDec;\n        let toNorth = [this.centerRaDec[0], this.centerRaDec[1] + 1e-3];\n\n        // 2. Project it to the screen\n        let originScreen = this.overlay.view.aladin.webglAPI.worldToScreen(origin[0], origin[1]);\n        let toNorthScreen = this.overlay.view.aladin.webglAPI.worldToScreen(toNorth[0], toNorth[1]);\n\n        // 3. normalize this vector\n        let toNorthVec = [toNorthScreen[0] - originScreen[0], toNorthScreen[1] - originScreen[1]];\n        let norm = Math.sqrt(toNorthVec[0]*toNorthVec[0] + toNorthVec[1]*toNorthVec[1]);\n        \n        toNorthVec = [toNorthVec[0] / norm, toNorthVec[1] / norm];\n        let toWestVec = [1.0, 0.0];\n\n        let x1 = toWestVec[0];\n        let y1 = toWestVec[1];\n        let x2 = toNorthVec[0];\n        let y2 = toNorthVec[1];\n        // 4. Compute the west to north angle\n        let westToNorthAngle = Math.atan2(x1*y2-y1*x2, x1*x2+y1*y2);\n\n        // 5. Get the correct ellipse angle\n        let theta = -this.rotation + westToNorthAngle;\n\n        ctx.beginPath();\n        ctx.ellipse(centerXyview[0], centerXyview[1], radiusInPixX, radiusInPixY, theta, 0, 2*Math.PI, false);\n        if (!noStroke) {\n            ctx.stroke();\n        }\n    }; \n    \n    return Ellipse;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Footprint\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Utils } from \"./Utils.js\";\n\nexport let Footprint = (function() {\n    // constructor\n    let Footprint = function(polygons) {\n        this.polygons = polygons;\n    \tthis.overlay = null;\n\n        // TODO : all graphic overlays should have an id\n        this.id = 'footprint-' + Utils.uuidv4();\n    \t\n    \tthis.isShowing = true;\n    \tthis.isSelected = false;\n    };\n    \n    Footprint.prototype.setOverlay = function(overlay) {\n        this.overlay = overlay;\n    };\n    \n    Footprint.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Footprint.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n\n    Footprint.prototype.dispatchClickEvent = function() {\n        if (this.overlay) {\n            // footprint selection code adapted from Fabrizio Giordano dev. from Serco for ESA/ESDC\n            //window.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n            this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n                detail: {\n                    footprintId: this.id,\n                    overlayName: this.overlay.name\n                }\n            }));\n        }\n    };\n    \n    Footprint.prototype.select = function() {\n        if (this.isSelected) {\n            return;\n        }\n        this.isSelected = true;\n        if (this.overlay) {\n/*\n            // footprint selection code adapted from Fabrizio Giordano dev. from Serco for ESA/ESDC\n            //window.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n            this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent(\"footprintClicked\", {\n                detail: {\n                    footprintId: this.id,\n                    overlayName: this.overlay.name\n                }\n            }));\n*/\n\n            this.overlay.reportChange();\n        }\n    };\n\n    Footprint.prototype.deselect = function() {\n        if (! this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    return Footprint;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File HealpixCache\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\n// class holding some HEALPix computations for better performances\n//\n// it is made of :\n// - a static cache for HEALPix corners at nside=8 \n// - a dynamic cache for \n\nimport { HealpixIndex }   from \"./libs/healpix.js\";\n\nexport let HealpixCache = (function() {\n\n    let HealpixCache = {};\n    \n    HealpixCache.staticCache = {corners: {nside8: []}};\n    // TODO : utilisation du dynamicCache\n    HealpixCache.dynamicCache = {};\n    \n    HealpixCache.lastNside = 8;\n    \n    HealpixCache.hpxIdxCache = null;\n    \n    // TODO : conserver en cache le dernier rsultat ?\n    \n    HealpixCache.init = function() {\n    \t// pre-compute corners position for nside=8\n    \tvar hpxIdx = new HealpixIndex(8);\n    \thpxIdx.init();\n    \tvar npix = HealpixIndex.nside2Npix(8);\n        let corners;\n    \tfor (var ipix=0; ipix<npix; ipix++) {\n            corners =  hpxIdx.corners_nest(ipix, 1);\n    \t\tHealpixCache.staticCache.corners.nside8.push(corners);\n    \t}\n    \t\n    \tHealpixCache.hpxIdxCache = hpxIdx;\n    };\n\n    HealpixCache.init();\n    \n    HealpixCache.corners_nest = function(ipix, nside) {\n    \tif (nside==8) {\n    \t\treturn HealpixCache.staticCache.corners.nside8[ipix];\n    \t}\n    \t\n    \tif (nside != HealpixCache.lastNside) {\n    \t\tHealpixCache.hpxIdxCache = new HealpixIndex(nside);\n    \t\tHealpixCache.hpxIdxCache.init();\n    \t\tHealpixCache.lastNside = nside;\n    \t}\n    \t\n    \treturn HealpixCache.hpxIdxCache.corners_nest(ipix, 1);\n    \t\n    };\n    \n    return HealpixCache;\n})();\n\t\n","// Copyright 2015 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File HealpixGrid\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nexport let HealpixGrid = (function() {\n\tfunction HealpixGrid() {\n\t}\n\t\n\tHealpixGrid.prototype.redraw = function(ctx, cornersXYViewMap, fov, norder) {\n\t\t// on dessine les lignes\n\t\tctx.lineWidth = 1;\n\t\tctx.strokeStyle = \"rgb(150,150,220)\";\n\t\tctx.beginPath();\n\t\tvar cornersXYView;\n\t\tvar ipix;\n\t\tfor (var k=0, len=cornersXYViewMap.length; k<len; k++) {\n\t\t\tcornersXYView = cornersXYViewMap[k];\n\t\t\tipix = cornersXYView.ipix;\n\t\t\t\n\t\t\t// draw pixel\n\t\t\tctx.moveTo(cornersXYView[0].vx, cornersXYView[0].vy);\n\t\t\tctx.lineTo(cornersXYView[1].vx, cornersXYView[1].vy);\n\t\t\tctx.lineTo(cornersXYView[2].vx, cornersXYView[2].vy);\n\t\t\t//ctx.lineTo(cornersXYView[3].vx, cornersXYView[3].vy);\n\t\t\t\n\n            //ctx.strokeText(ipix, (cornersXYView[0].vx + cornersXYView[2].vx)/2, (cornersXYView[0].vy + cornersXYView[2].vy)/2);\n\t\t}\n\t\tctx.stroke();\n\t\t\n\t\t// on dessine les numros de pixel HEALpix\n        ctx.strokeStyle=\"#FFDDDD\";\n\t\tctx.beginPath();\n\t\tfor (var k=0, len=cornersXYViewMap.length; k<len; k++) {\n\t\t\tcornersXYView = cornersXYViewMap[k];\n\t\t\tipix = cornersXYView.ipix;\n\n            ctx.strokeText(norder + '/' + ipix, (cornersXYView[0].vx + cornersXYView[2].vx)/2, (cornersXYView[0].vy + cornersXYView[2].vy)/2);\n\t\t}\n\t\tctx.stroke();\n\t};\n\n\t\n\t\n\treturn HealpixGrid;\n})();\n","// Copyright 2013-2017 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File HiPSDefinition\n * \n * Author: Thomas Boch [CDS]\n * \n *****************************************************************************/\n\nimport { Utils } from \"./Utils.js\";\n\nexport let HiPSDefinition = (function() {\n\n    // constructor\n    function HiPSDefinition(properties) {\n        this.properties = properties; // key-value object corresponding to the properties file\n\n        this.id = this.getID();\n        this.obsTitle = properties['obs_title'];\n        this.frame = properties['hips_frame'];\n        this.order = parseInt(properties['hips_order']);\n        this.clientSortKey = properties['client_sort_key'];\n        this.tileFormats = properties.hasOwnProperty('hips_tile_format') && properties['hips_tile_format'].split(' ');\n        this.urls = [];\n        this.urls.push(properties['hips_service_url']);\n        var k = 1;\n        while (properties.hasOwnProperty('hips_service_url_' + k)) {\n            this.urls.push(properties['hips_service_url_' + k]);\n            k++;\n        }\n\n        this.clientApplications = properties['client_application'];\n    };\n\n    HiPSDefinition.prototype = {\n\n        getServiceURLs: function(httpsOnly) {\n            httpsOnly = httpsOnly === true;\n\n            // TODO: TO BE COMPLETED\n        },\n\n        // return the ID according to the properties\n        getID: function() {\n            // ID is explicitely given\n            if (this.properties.hasOwnProperty('ID')) {\n                return this.properties['ID'];\n            }\n\n            var id = null;\n            // ID might be built from different fields\n            if (this.properties.hasOwnProperty('creator_did')) {\n                id = this.properties['creator_did'];\n            }\n            if (id==null && this.properties.hasOwnProperty('publisher_did')) {\n                id = this.properties['publisher_did'];\n            }\n\n            if (id != null) {\n                // remove ivo:// prefix\n                if (id.slice(0, 6) === 'ivo://') {\n                    id = id.slice(6);\n                }\n\n                // '?' are replaced by '/'\n                id = id.replace(/\\?/g, '/')\n            }\n\n            return id;\n        }\n\n\n\n    };\n\n    // cache (at the source code level) of the list of HiPS\n    // this is the result to a query to http://alasky.u-strasbg.fr/MocServer/query?dataproduct_type=image&client_application=AladinLite&fmt=json&fields=ID,obs_title,client_sort_key,client_application,hips_service_url*,hips_order,hips_tile_format,hips_frame\n    var AL_CACHE_CLASS_LEVEL = [\n    /*{\n    \"ID\": \"CDS/P/2MASS/color\",\n    \"obs_title\": \"2MASS color J (1.23 microns), H (1.66 microns), K (2.16 microns)\",\n    \"client_sort_key\": \"04-001-00\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"9\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/2MASS/Color\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/2MASS/Color\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/2MASS/Color\"\n    }, {\n    \"ID\": \"CDS/P/AKARI/FIS/Color\",\n    \"obs_title\": \"AKARI Far-infrared All-Sky Survey - color composition WideL/WideS/N60\",\n    \"client_sort_key\": \"04-05-00\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"5\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"png jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/AKARI-FIS/ColorLSN60\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/AKARI-FIS/ColorLSN60\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/AKARI-FIS/ColorLSN60\"\n    }, {\n    \"ID\": \"CDS/P/DECaLS/DR3/color\",\n    \"obs_title\": \"DECaLS DR3 color\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_order\": \"11\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/DECaLS/DR3/color\"\n}, {\n    \"ID\": \"CDS/P/DSS2/blue\",\n    \"obs_title\": \"DSS2 Blue (XJ+S)\",\n    \"client_sort_key\": \"03-01-03\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"9\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg fits\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/DSS/DSS2-blue-XJ-S\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/DSS/DSS2-blue-XJ-S\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/DSS/DSS2-blue-XJ-S\",\n    \"hips_service_url_3\": \"http://healpix.ias.u-psud.fr/DSS2Blue\"\n}, {\n    \"ID\": \"CDS/P/DSS2/color\",\n    \"obs_title\": \"DSS colored\",\n    \"client_sort_key\": \"03-00\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"9\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/DSS/DSSColor\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/DSS/DSSColor\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/DSS/DSSColor\",\n    \"hips_service_url_3\": \"http://healpix.ias.u-psud.fr/DSSColorNew\",\n    \"hips_service_url_4\": \"http://skies.esac.esa.int/DSSColor/\"\n}, {\n    \"ID\": \"CDS/P/DSS2/red\",\n    \"obs_title\": \"DSS2 Red (F+R)\",\n    \"client_sort_key\": \"03-01-02\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"9\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg fits\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/DSS/DSS2Merged\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/DSS/DSS2Merged\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/DSS/DSS2Merged\",\n    \"hips_service_url_3\": \"http://healpix.ias.u-psud.fr/DSS2Merged\"\n}, {\n    \"ID\": \"P/PanSTARRS/DR1/g\",\n    \"hips_service_url\": \"http://alasky.u-strasbg.fr/Pan-STARRS/DR1/g\",\n    \"obs_title\": \"PanSTARRS DR1 g\",\n    \"hips_order\": 11,\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg fits\"\n}, {\n    \"ID\": \"CDS/P/Fermi/color\",\n    \"obs_title\": \"Fermi Color HEALPix survey\",\n    \"client_sort_key\": \"00-01-01\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"3\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/Fermi/Color\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/Fermi/Color\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/Fermi/Color\"\n}, {\n    \"ID\": \"CDS/P/Finkbeiner\",\n    \"obs_title\": \"Finkbeiner Halpha composite survey\",\n    \"client_sort_key\": \"06-01\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"3\",\n    \"hips_frame\": \"galactic\",\n    \"hips_tile_format\": \"jpeg fits\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/FinkbeinerHalpha\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/FinkbeinerHalpha\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/FinkbeinerHalpha\"\n}, {\n    \"ID\": \"CDS/P/GALEXGR6/AIS/color\",\n    \"obs_title\": \"GALEX GR6 AIS (until March 2014)- Color composition\",\n    \"client_sort_key\": \"02-01-01\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"8\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"png jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/GALEX/GR6-03-2014/AIS-Color\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/GALEX/GR6-03-2014/AIS-Color\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/GALEX/GR6-03-2014/AIS-Color\"\n}, {\n    \"ID\": \"CDS/P/IRIS/color\",\n    \"obs_title\": \"IRAS-IRIS HEALPix survey, color\",\n    \"client_sort_key\": \"04-02-01\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"3\",\n    \"hips_frame\": \"galactic\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/IRISColor\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/IRISColor\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/IRISColor\",\n    \"hips_service_url_3\": \"http://healpix.ias.u-psud.fr/IRISColor\",\n    \"hips_service_url_4\": \"http://skies.esac.esa.int/IRISColor/\"\n}, {\n    \"ID\": \"CDS/P/Mellinger/color\",\n    \"obs_title\": \"Mellinger optical survey, color\",\n    \"client_sort_key\": \"03-03\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"4\",\n    \"hips_frame\": \"galactic\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/MellingerRGB\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/MellingerRGB\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/MellingerRGB\"\n}, {\n    \"ID\": \"CDS/P/SDSS9/color\",\n    \"obs_title\": \"SDSS 9 color\",\n    \"client_sort_key\": \"03-02-01\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"10\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/SDSS/DR9/color\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/SDSS/DR9/color\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/SDSS/DR9/color\",\n    \"hips_service_url_3\": \"http://healpix.ias.u-psud.fr/SDSS9Color\",\n    \"hips_service_url_4\": \"http://skies.esac.esa.int/SDSS9Color/\"\n}, {\n    \"ID\": \"CDS/P/SPITZER/color\",\n    \"obs_title\": \"IRAC HEALPix survey, color\",\n    \"client_sort_key\": \"04-03-00\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"9\",\n    \"hips_frame\": \"galactic\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/SpitzerI1I2I4color\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/SpitzerI1I2I4color\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/SpitzerI1I2I4color\",\n    \"hips_service_url_3\": \"http://healpix.ias.u-psud.fr/SPITZERColor\"\n}, {\n    \"ID\": \"CDS/P/allWISE/color\",\n    \"obs_title\": \"AllWISE color  Red (W4) , Green (W2) , Blue (W1) from raw Atlas Images\",\n    \"client_sort_key\": \"04-003-00\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"8\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://alasky.unistra.fr/AllWISE/RGB-W4-W2-W1\",\n    \"hips_service_url_1\": \"http://alaskybis.unistra.fr/AllWISE/RGB-W4-W2-W1\",\n    \"hips_service_url_2\": \"https://alaskybis.unistra.fr/AllWISE/RGB-W4-W2-W1\"\n}, {\n    \"ID\": \"IPAC/P/GLIMPSE360\",\n    \"obs_title\": \"GLIMPSE360: Spitzer's Infrared Milky Way\",\n    \"client_sort_key\": \"04-03-0\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"9\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"jpeg\",\n    \"hips_service_url\": \"http://www.spitzer.caltech.edu/glimpse360/aladin/data\"\n}, {\n    \"ID\": \"JAXA/P/MAXI_SSC_SUM\",\n    \"hips_tile_format\": \"png\",\n    \"hips_frame\": \"equatorial\",\n    \"obs_title\": \"MAXI SSC all-sky image integrated for 4.5 years\",\n    \"hips_order\": \"6\",\n    \"hips_service_url\": \"http://darts.isas.jaxa.jp/pub/judo2/HiPS/maxi_ssc_sum\",\n    \"hips_service_url_1\": \"http://alasky.unistra.fr//JAXA/JAXA_P_MAXI_SSC_SUM\",\n    \"hips_service_url_2\": \"http://alaskybis.unistra.fr//JAXA/JAXA_P_MAXI_SSC_SUM\",\n    \"hips_service_url_3\": \"https://alaskybis.unistra.fr//JAXA/JAXA_P_MAXI_SSC_SUM\"\n}, {\n    \"ID\": \"JAXA/P/SWIFT_BAT_FLUX\",\n    \"hips_tile_format\": \"png\",\n    \"hips_frame\": \"equatorial\",\n    \"obs_title\": \"Swift-BAT 70-month all-sray hard X-ray survey image\",\n    \"hips_order\": \"6\",\n    \"hips_service_url\": \"http://darts.isas.jaxa.jp/pub/judo2/HiPS/swift_bat_flux/\",\n    \"hips_service_url_1\": \"http://alasky.unistra.fr//JAXA/JAXA_P_SWIFT_BAT_FLUX\",\n    \"hips_service_url_2\": \"http://alaskybis.unistra.fr//JAXA/JAXA_P_SWIFT_BAT_FLUX\",\n    \"hips_service_url_3\": \"https://alaskybis.unistra.fr//JAXA/JAXA_P_SWIFT_BAT_FLUX\"\n}, {\n    \"ID\": \"ov-gso/P/VTSS/Ha\",\n    \"obs_title\": \"Virginia Tech Spectral-Line Survey (VTSS) - Halpha image\",\n    \"client_sort_key\": \"06-xx\",\n    \"client_application\":[ \"AladinLite\", \"AladinDesktop\"],\n    \"hips_order\": \"3\",\n    \"hips_frame\": [\"galactic\", \"galactic\"],\n    \"hips_tile_format\": \"png jpeg fits\",\n    \"hips_service_url\": \"http://cade.irap.omp.eu/documents/Ancillary/4Aladin/VTSS\",\n    \"hips_service_url_1\": \"http://alasky.unistra.fr/IRAP/VTSS\",\n    \"hips_service_url_2\": \"http://alaskybis.unistra.fr/IRAP/VTSS\",\n    \"hips_service_url_3\": \"https://alaskybis.unistra.fr/IRAP/VTSS\"\n}, {\n    \"ID\": \"xcatdb/P/XMM/EPIC\",\n    \"obs_title\": \"XMM-Newton stacked EPIC images\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_order\": \"7\",\n    \"hips_service_url\": \"http://saada.u-strasbg.fr/xmmallsky\",\n    \"hips_tile_format\": \"png fits\",\n    \"hips_service_url_1\": \"http://alasky.unistra.fr/SSC/xmmallsky\",\n    \"hips_service_url_2\": \"http://alaskybis.unistra.fr/SSC/xmmallsky\",\n    \"hips_service_url_3\": \"https://alaskybis.unistra.fr/SSC/xmmallsky\"\n}, {\n    \"ID\": \"xcatdb/P/XMM/PN/color\",\n    \"obs_title\": \"False color X-ray images (Red=0.5-1 Green=1-2 Blue=2-4.5)Kev\",\n    \"hips_order\": \"7\",\n    \"hips_frame\": \"equatorial\",\n    \"hips_tile_format\": \"png jpeg\",\n    \"hips_service_url\": \"http://saada.unistra.fr/PNColor\",\n    \"hips_service_url_1\": \"http://alasky.u-strasbg.fr/SSC/xcatdb_P_XMM_PN_color\",\n    \"hips_service_url_2\": \"http://alaskybis.u-strasbg.fr/SSC/xcatdb_P_XMM_PN_color\",\n    \"hips_service_url_3\": \"https://alaskybis.u-strasbg.fr/SSC/xcatdb_P_XMM_PN_color\"\n}\n*/\n];\n\n    var listHipsProperties = []; // this variable stores our current knowledge\n\n    HiPSDefinition.LOCAL_STORAGE_KEY = 'aladin:hips-list';\n    \n    var RETRIEVAL_TIMESTAMP_KEY = '_timestamp_retrieved';\n    var LAST_URL_KEY = '_last_used_url'; // URL previousy used to retrieve data from this HiPS\n    // retrieve definitions previousy stored in local storage\n    // @return an array with the HiPS definitions, empty array if nothing found or if an error occured\n    HiPSDefinition.getLocalStorageDefinitions = function() {\n        try {\n            var defs = window.localStorage.getItem(HiPSDefinition.LOCAL_STORAGE_KEY);\n            return defs === null ? [] : window.JSON.parse(defs);\n        }\n        catch(e) {\n            // silently fail and return empty array\n            return [];\n        }\n    };\n\n    // store in local storage a list of HiPSDefinition objects\n    // @return true if storage was successful\n    HiPSDefinition.storeInLocalStorage = function(properties) {\n        try {\n            window.localStorage.setItem(HiPSDefinition.LOCAL_STORAGE_KEY, window.JSON.stringify(properties));\n        }\n        catch(e) {\n            // silently fail and return false\n            return false;\n        }\n\n        return true;\n    };\n\n    var MOCSERVER_MIRRORS_HTTP = ['http://alasky.u-strasbg.fr/MocServer/query', 'http://alaskybis.u-strasbg.fr/MocServer/query']; // list of base URL for MocServer mirrors, available in HTTP\n    var MOCSERVER_MIRRORS_HTTPS = ['https://alasky.u-strasbg.fr/MocServer/query', 'https://alaskybis.unistra.fr/MocServer/query']; // list of base URL for MocServer mirrors, available in HTTPS\n\n    // get HiPS definitions, by querying the MocServer\n    // return data as dict-like objects\n    HiPSDefinition.getRemoteDefinitions = function(params, successCallbackFn, failureCallbackFn) {\n        var params = params || {client_application: 'AladinLite'}; // by default, retrieve only HiPS tagged \"Aladin Lite\"\n\n        params['fmt'] = 'json';\n        params['fields'] = 'ID,obs_title,client_sort_key,client_application,hips_service_url*,hips_order,hips_tile_format,hips_frame';\n\n        var urls = Utils.isHttpsContext() ? MOCSERVER_MIRRORS_HTTPS : MOCSERVER_MIRRORS_HTTP;\n\n        var successCallback = function(data) {\n            (typeof successCallbackFn === 'function') && successCallbackFn(data);\n        };\n        var failureCallback = function() {\n            console.error('Could not load HiPS definitions from urls ' + urls);\n            (typeof failureCallbackFn === 'function') && failureCallbackFn();\n        };\n\n        Utils.loadFromMirrors(urls, {data: params, onSuccess: successCallback, onFailure: failureCallback, timeout: 5});\n    };\n\n    // complement the baseList with the items in newList\n    var merge = function(baseList, newList) {\n        var updatedList = [];\n        var newListById = {};\n        for (var k=0; k<newList.length; k++) {\n            var item = newList[k];\n            newListById[item.ID] = item;\n        }\n\n        for (var k=0; k<baseList.length; k++) {\n            var item = baseList[k];\n            var id = item.ID;\n            if (newListById.hasOwnProperty(id)) {\n                var itemToAdd = newListById[id];\n                // we keep the last used URL property\n                if (item.hasOwnProperty(LAST_URL_KEY) && ! itemToAdd.hasOwnProperty(LAST_URL_KEY)) {\n                    itemToAdd[LAST_URL_KEY] = item[LAST_URL_KEY];\n                }\n                updatedList.push(itemToAdd);\n            }\n            else {\n                updatedList.push(item);\n            }\n        }\n\n        return updatedList;\n    };\n\n    HiPSDefinition.CACHE_RETENTION_TIME_SECONDS = 7 * 86400; // definitions can be kept 7 days\n    HiPSDefinition.init = function() {\n        // first, merge local definitions at class level with definitions in local storage\n        listHipsProperties = AL_CACHE_CLASS_LEVEL;\n\n        // second, remove old definitions (client != AladinLite and timestamp older than CACHE_RETENTION_TIME_SECONDS) and merge\n        var localDefs = HiPSDefinition.getLocalStorageDefinitions();\n        // 2.1 remove old defs\n        var now = new Date().getTime();\n        var indicesToRemove = [];\n        for (var k=0; k<localDefs.length; k++) {\n            var def = localDefs[k];\n            if (def.hasOwnProperty(RETRIEVAL_TIMESTAMP_KEY) && (now - def[RETRIEVAL_TIMESTAMP_KEY]) > 1000 * HiPSDefinition.CACHE_RETENTION_TIME_SECONDS) {\n                indicesToRemove.push(k);\n            }\n        }\n        // we have to browse the array in reverse order in order not to mess up indices\n        for (var k = indicesToRemove.length - 1; k >= 0; k--) {\n            localDefs.splice(indicesToRemove[k],1);\n        }\n        // 2.2 merge\n        listHipsProperties = merge(listHipsProperties, localDefs);\n\n        // third, retrieve remote definitions, merge and save\n        HiPSDefinition.getRemoteDefinitions({dataproduct_type: 'image', client_application: 'AladinLite'}, function(remoteDefs) {\n            // adding timestamp of retrieval\n            var now = new Date().getTime();\n            for (var k=0; k<remoteDefs.length; k++) {\n                remoteDefs[k][RETRIEVAL_TIMESTAMP_KEY] = now;\n            }\n            listHipsProperties = merge(listHipsProperties, remoteDefs);\n            HiPSDefinition.storeInLocalStorage(listHipsProperties);\n        });\n\n    };\n\n    // return list of HiPSDefinition objects, filtering out definitions whose client_application is not AladinLite\n    HiPSDefinition.getALDefaultHiPSDefinitions = function() {\n        // filter out definitions with client_application != 'AladinLite'\n        var ret = [];\n        for (var k=0; k<listHipsProperties.length; k++) {\n            var properties = listHipsProperties[k];\n            if ( ! properties.hasOwnProperty('client_application') || properties['client_application'].indexOf('AladinLite')<0) {\n                continue;\n            }\n\n            ret.push(new HiPSDefinition(properties));\n        }\n\n        return ret;\n    };\n\n    // return list of known HiPSDefinition objects\n    HiPSDefinition.getDefinitions = function() {\n        var ret = [];\n        for (var k=0; k<listHipsProperties.length; k++) {\n            var properties = listHipsProperties[k];\n            ret.push(new HiPSDefinition(properties));\n        }\n\n        return ret;\n    };\n\n    // parse a HiPS properties and return a dict-like object with corresponding key-values\n    // return null if parsing failed\n    HiPSDefinition.parseHiPSProperties = function(propertiesStr) {\n        if (propertiesStr==null) {\n            return null;\n        }\n\n        var propertiesDict = {};\n        // remove CR characters\n        propertiesStr = propertiesStr.replace(/[\\r]/g, '');\n        // split on LF\n        var lines = propertiesStr.split('\\n');\n        for (var k=0; k<lines.length; k++)  {\n            var l = $.trim(lines[k]);\n            // ignore comments lines\n            if (l.slice(0, 1)==='#') {\n                continue;\n            }\n            var idx = l.indexOf('=');\n            if (idx<0) {\n                continue;\n            }\n            var key = $.trim(l.slice(0, idx));\n            var value = $.trim(l.slice(idx+1));\n\n            propertiesDict[key] = value;\n        }\n\n        return propertiesDict;\n    };\n\n\n    // find a HiPSDefinition by id.\n    // look first locally, and remotely only if local search was unsuccessful\n    //\n    // call callback function with a list of HiPSDefinition candidates, empty array if nothing found\n\n    HiPSDefinition.findByID = function(id, callback) {\n        // look first locally\n        var candidates = findByIDLocal(id);\n        if (candidates.length>0) {\n            (typeof callback === 'function') && callback(candidates);\n            return;\n        }\n\n        // then remotely\n        findByIDRemote(id, callback);\n    };\n\n    // find a HiPSDefinition by id.\n    // search is done on the local knowledge of HiPSDefinitions\n    HiPSDefinition.findByIDLocal = function(id2search, callback) {\n        var candidates = [];\n        for (var k=0; k<listHipsProperties.length; k++) {\n            var properties = listHipsProperties[k];\n            var id = properties['ID'];\n            if (id.match(id2search) != null ) {\n                candidates.push(new HiPSDefinition(properties));\n            }\n        }\n\n        return candidates;\n    };\n\n    // find remotely a HiPSDefinition by ID\n    HiPSDefinition.findByIDRemote = function(id, callback) {\n        HiPSDefinition.findHiPSRemote({ID: '*' + id + '*'}, callback);\n    };\n\n    // search a HiPS according to some criteria\n    HiPSDefinition.findHiPSRemote = function(searchOptions, callback) {\n        searchOptions = searchOptions || {};\n        if (! searchOptions.hasOwnProperty('dataproduct_type')) {\n            searchOptions['dataproduct_type'] = 'image';\n        }\n        HiPSDefinition.getRemoteDefinitions(searchOptions, function(candidates) {\n            var defs = [];\n            for (var k=0; k<candidates.length; k++) {\n                defs.push(new HiPSDefinition(candidates[k]));\n            }\n            (typeof callback === 'function') && callback(defs);\n        });\n    };\n\n\n    // Create a HiPSDefinition object from a URL\n    //\n    // If the URL ends with 'properties', it is assumed to be the URL of the properties file\n    // else, it is assumed to be the base URL of the HiPS\n    //\n    // return a HiPSDefinition if successful, null if it failed\n    HiPSDefinition.fromURL = function(url, callback) {\n        var hipsUrl, propertiesUrl;\n        if (url.slice(-10) === 'properties') {\n            propertiesUrl = url;\n            hipsUrl = propertiesUrl.slice(0, -11);\n        }\n        else {\n            if (url.slice(-1) === '/') {\n                url = url.slice(0, -1);\n            }\n            hipsUrl = url;\n            propertiesUrl = hipsUrl + '/properties';\n        }\n\n        var callbackWhenPropertiesLoaded = function(properties) {\n            // Sometimes, hips_service_url is missing. That can happen for instance Hipsgen does not set the hips_service_url keyword\n            // --> in that case, we add as an attribyte the URL that was given as input parameter\n            var hipsPropertiesDict = HiPSDefinition.parseHiPSProperties(properties);\n            if (! hipsPropertiesDict.hasOwnProperty('hips_service_url')) {\n                hipsPropertiesDict['hips_service_url'] = hipsUrl;\n            }\n            (typeof callback === 'function') && callback(new HiPSDefinition(hipsPropertiesDict));\n        };\n\n        // try first without proxy\n        var ajax = Utils.getAjaxObject(propertiesUrl, 'GET', 'text', false);\n        ajax\n            .done(function(data) {\n                callbackWhenPropertiesLoaded(data);\n            })\n            .fail(function() {\n                // if not working, try with the proxy\n                var ajax = Utils.getAjaxObject(propertiesUrl, 'GET', 'text', true);\n                ajax\n                    .done(function(data) {\n                        callbackWhenPropertiesLoaded(data);\n                    })\n                    .fail(function() {\n                        (typeof callback === 'function') && callback(null);\n                    })\n            });\n    };\n\n    // HiPSDefinition generation from a properties dict-like object\n    HiPSDefinition.fromProperties = function(properties) {\n        return new HiPSDefinition(properties);\n    };\n\n\n\n\n    HiPSDefinition.init();\n\n    return HiPSDefinition;\n\n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File HpxImageSurvey\n * \n * Authors: Thomas Boch & Matthieu Baumann [CDS]\n * \n *****************************************************************************/\nimport { Utils } from \"./Utils.js\";\nimport { HiPSDefinition} from \"./HiPSDefinition.js\";\n\nexport let HpxImageSurvey = (function() {\n    /** Constructor\n     * cooFrame and maxOrder can be set to null\n     * They will be determined by reading the properties file\n     *  \n     */\n    let HpxImageSurvey = function(rootURLOrId) {\n        if (!rootURLOrId) {\n            throw 'An hosting survey URL or an ID (i.e. DSS2/red) must be given';\n        }\n\n        let isUrl = false;\n        console.log(\"root url\", rootURLOrId)\n        if (rootURLOrId.includes(\"http\")) {\n            isUrl = true;\n        }\n\n        const request = async (url) => {\n            const response = await fetch(url);\n            const json = await response.json();\n\n            return json;\n        };\n\n        // If an HiPS id has been given\n        let url = null;\n        if (!isUrl) {\n            // Use the MOCServer to retrieve the\n            // properties\n            const id = rootURLOrId;\n            const MOCServerUrl = 'http://alasky.unistra.fr/MocServer/query?ID=*' + encodeURIComponent(id) + '*&get=record&fmt=json';\n\n            return (async () => {\n                let metadata = await request(MOCServerUrl);\n\n                // We get the property here\n\n                // 1. Ensure there is exactly one survey matching\n                if (!metadata) {\n                    throw 'no surveys matching';\n                } else {\n                    if (metadata.length > 1) {\n                        let ids = [];\n                        metadata.forEach((prop) => {\n                            ids.push(prop.ID)\n                        });\n                        throw ids + ' surveys are matching. Please use one from this list.';\n                    } else if (metadata.length === 0) {\n                        throw 'no surveys matching';\n                    } else {\n                        // Exactly one matching\n                        metadata = metadata[0];\n                    }\n                }\n                // Let is build the survey object\n                const survey = HpxImageSurvey.parseSurveyProperties(metadata);\n                return survey\n            })();\n        } else {\n            // Fetch the properties of the survey\n            let rootURL = rootURLOrId;\n            // Use the url for retrieving the HiPS properties\n            // remove final slash\n            if (rootURL.slice(-1) === '/') {\n                rootURL = rootURL.substr(0, rootURL.length-1);\n            }\n\n            // make URL absolute\n            rootURL = Utils.getAbsoluteURL(rootURL);\n\n            // fast fix for HTTPS support --> will work for all HiPS served by CDS\n            if (Utils.isHttpsContext() && ( /u-strasbg.fr/i.test(rootURL) || /unistra.fr/i.test(rootURL)  ) ) {\n                rootURL = rootURL.replace('http://', 'https://');\n            }\n\n            console.log(\"ROOT URL\", rootURL);\n            url = rootURL + '/properties';\n\n\n            return (async () => {\n                console.log(\"properties url\", url);\n                let metadata = await fetch(url)\n                    .then((response) => response.text());\n                // We get the property here\n                metadata = HiPSDefinition.parseHiPSProperties(metadata);\n                console.log(\"metadata\", metadata);\n\n                // 1. Ensure there is exactly one survey matching\n                if (!metadata) {\n                    throw 'no surveys matching';\n                }\n                // Let is build the survey object\n                const survey = HpxImageSurvey.parseSurveyProperties(metadata);\n                console.log(\"survey \", survey);\n\n                return survey\n            })();\n        }\n    };\n\n    HpxImageSurvey.parseSurveyProperties = function(metadata) {\n        const order = (+metadata.hips_order);\n        const hipsTileFormat = metadata.hips_tile_format.split(' ');\n\n        let tileFormat;\n        let color;\n        if (hipsTileFormat.indexOf('fits') >= 0) {\n            tileFormat = {\n                FITSImage: {\n                    bitpix: parseInt(metadata.hips_pixel_bitpix)\n                }\n            };\n            color = {\n                Grayscale2Color: {\n                    color: [1.0, 1.0, 1.0],\n                    k: 1.0,\n                    transfer: \"asinh\"\n                }\n            };\n        } else {\n            color = \"Color\";\n\n            if (hipsTileFormat.indexOf('png') >= 0) {\n                tileFormat = {\n                    Image: {\n                        format: \"png\"\n                    }\n                };\n            } else {\n                tileFormat = {\n                    Image: {\n                        format: \"jpeg\"\n                    }\n                };\n            }\n        }\n\n\n        let cuts = [undefined, undefined];\n        if (metadata.hips_pixel_cut) {\n            cuts = metadata.hips_pixel_cut.split(\" \");\n        }\n        let tileSize = 512;\n        // Verify the validity of the tile width\n        if (metadata.hips_tile_width) {\n            let hipsTileWidth = parseInt(metadata.hips_tile_width);\n            let isPowerOfTwo = hipsTileWidth && !(hipsTileWidth & (hipsTileWidth - 1));\n\n            if (isPowerOfTwo === true) {\n                tileSize = hipsTileWidth;\n            }\n        }\n        let url = metadata.hips_service_url;\n        if (!url) {\n            throw 'no valid service URL for retrieving the tiles'\n        }\n\n        if (url.startsWith('http://alasky')) {\n            // From alasky one can directly use the https access\n            url = url.replace('http', 'https');\n        } else {\n            // Pass by a proxy for extern http urls\n            url = 'https://alasky.u-strasbg.fr/cgi/JSONProxy?url=' + url;\n        }\n        return {\n            properties: {\n                url: url,\n                maxOrder:  parseInt(metadata.hips_order),\n                frame: {\n                    label: \"J2000\",\n                    system: \"J2000\"\n                },\n                tileSize: tileSize,\n                format: tileFormat,\n                minCutout: parseFloat(cuts[0]),\n                maxCutout: parseFloat(cuts[1]),\n            },\n            color: color\n        };\n    }\n\n    HpxImageSurvey.create = async function(idOrRootUrl, options) {\n        if (!idOrRootUrl) {\n            return;\n        }\n    \n        let survey = await new HpxImageSurvey(idOrRootUrl);\n        return survey;\n    };\n\n    return HpxImageSurvey;\n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File ImageSurveyLayer\n * \n * Authors: Thomas Boch & Matthieu Baumann [CDS]\n * \n *****************************************************************************/\nimport { Utils } from \"./Utils.js\";\nimport { HpxImageSurvey } from \"./HpxImageSurvey.js\";\n\nexport let ImageSurveyLayer = (function() {\n    /** Constructor\n     * cooFrame and maxOrder can be set to null\n     * They will be determined by reading the properties file\n     *  \n     */\n    /** Constructor\n     *  \n     */\n    let ImageSurveyLayer = function(name) {\n        this.surveys = new Map();\n        this.name = name;\n    }\n\n    ImageSurveyLayer.prototype.addImageSurvey = async function(rootUrlOrId) {\n        const survey = await HpxImageSurvey.create(rootUrlOrId);\n        this.surveys.set(rootUrlOrId, survey);\n    };\n\n    ImageSurveyLayer.prototype.removeImageSurvey = function(rootUrlOrId) {\n        this.surveys.remove(rootUrlOrId);\n    };\n\n    ImageSurveyLayer.prototype.clear = function() {\n        this.surveys.clear();\n    };\n\n    ImageSurveyLayer.prototype.getSurveys = function() {\n        return this.surveys.values();\n    };\n\n    return ImageSurveyLayer;\n})();","// Copyright 2015 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * Class Line\n * \n * A line is a graphical overlay connecting 2 points\n * \n * Author: Matthieu Baumann[CDS]\n * \n *****************************************************************************/\n\nexport let Line = (function() {\n    // constructor\n    let Line = function(x1, y1, x2, y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    };\n\n    // Method for testing whether a line is inside the view\n    // http://www.jeffreythompson.org/collision-detection/line-rect.php\n    Line.prototype.isInsideView = function(rw, rh) {\n        if (this.x1 >= 0 && this.x1 <= rw && this.y1 >= 0 && this.y1 <= rh) {\n            return true;\n        }\n        if (this.x2 >= 0 && this.x2 <= rw && this.y2 >= 0 && this.y2 <= rh) {\n            return true;\n        }\n\n        // check if the line has hit any of the rectangle's sides\n        // uses the Line/Line function below\n        let left =   Line.intersectLine(this.x1, this.y1, this.x2, this.y2, 0, 0, 0, rh);\n        let right =  Line.intersectLine(this.x1, this.y1, this.x2, this.y2, rw, 0, rw, rh);\n        let top =    Line.intersectLine(this.x1, this.y1, this.x2, this.y2, 0, 0, rw, 0);\n        let bottom = Line.intersectLine(this.x1, this.y1, this.x2, this.y2, 0, rh, rw, rh);\n    \n        // if ANY of the above are true, the line\n        // has hit the rectangle\n        if (left || right || top || bottom) {\n            return true;\n        }\n\n        return false;\n    };\n\n    Line.prototype.draw = function(ctx) {\n        ctx.moveTo(this.x1, this.y1);\n        ctx.lineTo(this.x2, this.y2);\n    };\n\n    Line.intersectLine = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        // Calculate the direction of the lines\n        let uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\n        let uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\n    \n        // If uA and uB are between 0-1, lines are colliding\n        if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n            return true;\n        }\n        return false;\n    };\n\n    return Line;\n})();","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Location.js\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\n\nimport { Coo }            from \"./libs/astro/coo.js\";\nimport { CooFrameEnum }   from \"./CooFrameEnum.js\";\n\nexport let Location = (function () {\n    // constructor\n    function Location(locationDiv) {\n        this.$div = $(locationDiv);\n    };\n\n    Location.prototype.update = function (lon, lat, cooFrame, isViewCenterPosition) {\n        isViewCenterPosition = (isViewCenterPosition && isViewCenterPosition === true) || false;\n\n        var coo = new Coo(lon, lat, 7);\n        if (cooFrame == CooFrameEnum.J2000) {\n            this.$div.html(coo.format('s/'));\n        }\n        else if (cooFrame == CooFrameEnum.J2000d) {\n            this.$div.html(coo.format('d/'));\n        }\n        else {\n            this.$div.html(coo.format('d/'));\n        }\n\n        this.$div.toggleClass('aladin-reticleColor', isViewCenterPosition);\n    };\n\n    return Location;\n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n// log \nexport let Logger = {};\n\nLogger.log = function(action, params) {\n    try {\n        var logUrl = \"//alasky.unistra.fr/cgi/AladinLiteLogger/log.py\";\n        var paramStr = \"\";\n        if (params) {\n            paramStr = JSON.stringify(params);\n        }\n        \n        $.ajax({\n            url: logUrl,\n            data: {\"action\": action, \"params\": paramStr, \"pageUrl\": window.location.href, \"referer\": document.referrer ? document.referrer : \"\"},\n            method: 'GET',\n            dataType: 'json' // as alasky supports CORS, we do not need JSONP any longer\n        });\n        \n    }\n    catch(e) {\n        window.console && console.log('Exception: ' + e);\n    }\n\n};\n","/******************************************************************************\n * Aladin Lite project\n * \n * File MOC\n *\n * This class represents a MOC (Multi Order Coverage map) layer\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { SpatialVector }   from \"./libs/healpix.js\";\nimport { astro }   from \"./libs/fits.js\";\nimport { CooFrameEnum }   from \"./CooFrameEnum.js\";\nimport { HealpixCache }   from \"./HealpixCache.js\";\nimport { Aladin }   from \"./Aladin.js\";\nimport { ProjectionEnum } from \"./ProjectionEnum.js\";\nimport { AladinUtils }   from \"./AladinUtils.js\";\nimport { CooConversion }   from \"./CooConversion.js\";\n\n\nexport let MOC = (function() {\n    let MOC = function(options) {\n        this.order = undefined;\n\n        this.type = 'moc';\n\n        // TODO homogenize options parsing for all kind of overlay (footprints, catalog, MOC)\n        options = options || {};\n        this.name = options.name || \"MOC\";\n        this.color = options.color || Color.getNextColor();\n        this.opacity = options.opacity || 1;\n        this.opacity = Math.max(0, Math.min(1, this.opacity)); // 0 <= this.opacity <= 1\n        this.lineWidth = options[\"lineWidth\"] || 1;\n        this.adaptativeDisplay = options['adaptativeDisplay'] !== false;\n\n        this.proxyCalled = false; // this is a flag to check whether we already tried to load the MOC through the proxy\n\n        // index of MOC cells at high and low resolution\n        this._highResIndexOrder3 = new Array(768);\n        this._lowResIndexOrder3 = new Array(768);\n        for (var k=0; k<768; k++) {\n            this._highResIndexOrder3[k] = {};\n            this._lowResIndexOrder3[k] = {};\n        }\n\n        this.nbCellsDeepestLevel = 0; // needed to compute the sky fraction of the MOC\n\n        this.isShowing = true;\n        this.ready = false;\n    }\n\n    \n    function log2(val) {\n        return Math.log(val) / Math.LN2;\n    }\n\n    // max norder we can currently handle (limitation of healpix.js)\n    MOC.MAX_NORDER = 13; // NSIDE = 8192\n\n    MOC.LOWRES_MAXORDER = 6; // 5 or 6 ??\n    MOC.HIGHRES_MAXORDER = 11; // ??\n\n    // TODO: options to modifiy this ?\n    MOC.PIVOT_FOV = 30; // when do we switch from low res cells to high res cells (fov in degrees)\n\n    // at end of parsing, we need to remove duplicates from the 2 indexes\n    MOC.prototype._removeDuplicatesFromIndexes = function() {\n        var a, aDedup;\n        for (var k=0; k<768; k++) {\n            for (var key in this._highResIndexOrder3[k]) {\n                a = this._highResIndexOrder3[k][key];\n                aDedup = uniq(a);\n                this._highResIndexOrder3[k][key] = aDedup;\n            }\n            for (var key in this._lowResIndexOrder3[k]) {\n                a = this._lowResIndexOrder3[k][key];\n                aDedup = uniq(a);\n                this._lowResIndexOrder3[k][key] = aDedup;\n            }\n        }\n        \n    }\n\n    // add pixel (order, ipix)\n    MOC.prototype._addPix = function(order, ipix) {\n        var ipixOrder3 = Math.floor( ipix * Math.pow(4, (3 - order)) );\n        // fill low and high level cells\n        // 1. if order <= LOWRES_MAXORDER, just store value in low and high res cells\n        if (order<=MOC.LOWRES_MAXORDER) {\n            if (! (order in this._lowResIndexOrder3[ipixOrder3])) {\n                this._lowResIndexOrder3[ipixOrder3][order] = [];\n                this._highResIndexOrder3[ipixOrder3][order] = [];\n            }\n            this._lowResIndexOrder3[ipixOrder3][order].push(ipix);\n            this._highResIndexOrder3[ipixOrder3][order].push(ipix);\n        }\n        // 2. if LOWRES_MAXORDER < order <= HIGHRES_MAXORDER , degrade ipix for low res cells\n        else if (order<=MOC.HIGHRES_MAXORDER) {\n            if (! (order in this._highResIndexOrder3[ipixOrder3])) {\n                this._highResIndexOrder3[ipixOrder3][order] = [];\n            }\n            this._highResIndexOrder3[ipixOrder3][order].push(ipix);\n            \n            var degradedOrder = MOC.LOWRES_MAXORDER; \n            var degradedIpix  = Math.floor(ipix / Math.pow(4, (order - degradedOrder)));\n            var degradedIpixOrder3 = Math.floor( degradedIpix * Math.pow(4, (3 - degradedOrder)) );\n            if (! (degradedOrder in this._lowResIndexOrder3[degradedIpixOrder3])) {\n                this._lowResIndexOrder3[degradedIpixOrder3][degradedOrder]= [];\n            }\n            this._lowResIndexOrder3[degradedIpixOrder3][degradedOrder].push(degradedIpix);\n        }\n        // 3. if order > HIGHRES_MAXORDER , degrade ipix for low res and high res cells\n        else {\n            // low res cells\n            var degradedOrder = MOC.LOWRES_MAXORDER; \n            var degradedIpix  = Math.floor(ipix / Math.pow(4, (order - degradedOrder)));\n            var degradedIpixOrder3 = Math.floor(degradedIpix * Math.pow(4, (3 - degradedOrder)) );\n            if (! (degradedOrder in this._lowResIndexOrder3[degradedIpixOrder3])) {\n                this._lowResIndexOrder3[degradedIpixOrder3][degradedOrder]= [];\n            }\n            this._lowResIndexOrder3[degradedIpixOrder3][degradedOrder].push(degradedIpix);\n\n            \n            // high res cells\n            degradedOrder = MOC.HIGHRES_MAXORDER; \n            degradedIpix  = Math.floor(ipix / Math.pow(4, (order - degradedOrder)));\n            var degradedIpixOrder3 = Math.floor(degradedIpix * Math.pow(4, (3 - degradedOrder)) );\n            if (! (degradedOrder in this._highResIndexOrder3[degradedIpixOrder3])) {\n                this._highResIndexOrder3[degradedIpixOrder3][degradedOrder]= [];\n            }\n            this._highResIndexOrder3[degradedIpixOrder3][degradedOrder].push(degradedIpix);\n        }\n\n        this.nbCellsDeepestLevel += Math.pow(4, (this.order - order));\n    };\n\n\n    /**\n     *  Return a value between 0 and 1 denoting the fraction of the sky\n     *  covered by the MOC\n     */\n    MOC.prototype.skyFraction = function() {\n        return this.nbCellsDeepestLevel / (12 * Math.pow(4, this.order));\n    };\n\n    /**\n     * set MOC data by parsing a MOC serialized in JSON\n     * (as defined in IVOA MOC document, section 3.1.1)\n     */\n    MOC.prototype.dataFromJSON = function(jsonMOC) {\n        var order, ipix;\n        for (var orderStr in jsonMOC) {\n            if (jsonMOC.hasOwnProperty(orderStr)) {\n                order = parseInt(orderStr);\n                if (this.order===undefined || order > this.order) {\n                    this.order = order;\n                }\n                for (var k=0; k<jsonMOC[orderStr].length; k++) {\n                    ipix = jsonMOC[orderStr][k];\n                    this._addPix(order, ipix);\n                }\n            }\n        }\n\n        this.reportChange();\n        this.ready = true;\n    };\n\n    /**\n     * set MOC data by parsing a URL pointing to a FITS MOC file\n     */\n    MOC.prototype.dataFromFITSURL = function(mocURL, successCallback) {\n        var self = this;\n        var callback = function() {\n            // note: in the callback, 'this' refers to the FITS instance\n\n            // first, let's find MOC norder\n            var hdr0;\n            try {\n                // A zero-length hdus array might mean the served URL does not have CORS header\n                // --> let's try again through the proxy\n                if (this.hdus.length == 0) {\n                    if (self.proxyCalled !== true) {\n                        self.proxyCalled = true;\n                        var proxiedURL = Aladin.JSONP_PROXY + '?url=' + encodeURIComponent(self.dataURL);\n                        new astro.FITS(proxiedURL, callback);\n                    }\n\n                    return;\n                }\n                hdr0 = this.getHeader(0);\n            }\n            catch (e) {\n                console.error('Could not get header of extension #0');\n                return;\n            }\n            var hdr1 = this.getHeader(1);\n\n            if (hdr0.contains('HPXMOC')) {\n                self.order = hdr0.get('HPXMOC')\n            }\n            else if (hdr0.contains('MOCORDER')) {\n                self.order = hdr0.get('MOCORDER')\n            }\n            else if (hdr1.contains('HPXMOC')) {\n                self.order = hdr1.get('HPXMOC')\n            }\n            else if (hdr1.contains('MOCORDER')) {\n                self.order = hdr1.get('MOCORDER')\n            }\n            else {\n                console.error('Can not find MOC order in FITS file');\n                return;\n            }\n\n\n            var data = this.getDataUnit(1);\n            var colName = data.columns[0];\n            data.getRows(0, data.rows, function(rows) {\n                for (var k=0; k<rows.length; k++) {\n                    var uniq = rows[k][colName];\n                    var order = Math.floor(Math.floor(log2(Math.floor(uniq/4))) / 2);\n                    var ipix = uniq - 4 *(Math.pow(4, order));\n\n\n\n                    self._addPix(order, ipix);\n                }\n\n            });\n            data = null; // this helps releasing memory\n\n            self._removeDuplicatesFromIndexes();\n\n            if (successCallback) {\n                successCallback();\n            }\n\n            self.reportChange();\n            self.ready = true;\n        }; // end of callback function\n\n        this.dataURL = mocURL;\n\n        // instantiate the FITS object which will fetch the URL passed as parameter\n        new astro.FITS(this.dataURL, callback);\n    };\n\n    MOC.prototype.setView = function(view) {\n        this.view = view;\n        this.reportChange();\n    };\n    \n    MOC.prototype.draw = function(ctx, projection, viewFrame, width, height, largestDim, zoomFactor, fov) {\n        if (! this.isShowing || ! this.ready) {\n            return;\n        }\n        var mocCells = fov > MOC.PIVOT_FOV && this.adaptativeDisplay ? this._lowResIndexOrder3 : this._highResIndexOrder3;\n\n        this._drawCells(ctx, mocCells, fov, projection, viewFrame, CooFrameEnum.J2000, width, height, largestDim, zoomFactor);\n    };\n\n    MOC.prototype._drawCells = function(ctx, mocCellsIdxOrder3, fov, projection, viewFrame, surveyFrame, width, height, largestDim, zoomFactor) {\n        ctx.lineWidth = this.lineWidth;\n        // if opacity==1, we draw solid lines, else we fill each HEALPix cell\n        if (this.opacity==1) {\n            ctx.strokeStyle = this.color;\n        }\n        else {\n            ctx.fillStyle = this.color;\n            ctx.globalAlpha = this.opacity;\n        }\n\n\n        ctx.beginPath();\n\n        var orderedKeys = [];\n        for (var k=0; k<768; k++) {\n            var mocCells = mocCellsIdxOrder3[k];\n            for (var key in mocCells) {\n                orderedKeys.push(parseInt(key));\n            }\n        }\n        orderedKeys.sort(function(a, b) {return a - b;});\n        var norderMax = orderedKeys[orderedKeys.length-1];\n\n        var nside, xyCorners, ipix;\n        var potentialVisibleHpxCellsOrder3 = this.view.getVisiblePixList(3, CooFrameEnum.J2000);\n        var visibleHpxCellsOrder3 = [];\n        // let's test first all potential visible cells and keep only the one with a projection inside the view\n        for (var k=0; k<potentialVisibleHpxCellsOrder3.length; k++) {\n            var ipix = potentialVisibleHpxCellsOrder3[k];\n            xyCorners = getXYCorners(8, ipix, viewFrame, surveyFrame, width, height, largestDim, zoomFactor, projection, this.view);\n            if (xyCorners) {\n                visibleHpxCellsOrder3.push(ipix);\n            }\n        }\n\n        var counter = 0;\n        var mocCells;\n        var norder3Ipix;\n        for (var norder=0; norder<=norderMax; norder++) {\n            nside = 1 << norder;\n\n            for (var i=0; i<visibleHpxCellsOrder3.length; i++) {\n                var ipixOrder3 = visibleHpxCellsOrder3[i];\n                mocCells = mocCellsIdxOrder3[ipixOrder3];\n                if (typeof mocCells[norder]==='undefined') {\n                    continue;\n                }\n            \n                if (norder<=3) {\n                    for (var j=0; j<mocCells[norder].length; j++) {\n                        ipix = mocCells[norder][j];\n                        var factor = Math.pow(4, (3-norder));\n                        var startIpix = ipix * factor;\n                        for (var k=0; k<factor; k++) {\n                            norder3Ipix = startIpix + k;\n                            xyCorners = getXYCorners(8, norder3Ipix, viewFrame, surveyFrame, width, height, largestDim, zoomFactor, projection, this.view);\n                            if (xyCorners) {\n                                drawCorners(ctx, xyCorners);\n                            }\n                        }\n                    }\n                }\n                else {\n                    for (var j=0; j<mocCells[norder].length; j++) {\n                        ipix = mocCells[norder][j];\n                        var parentIpixOrder3 = Math.floor(ipix/Math.pow(4, norder-3));\n                        xyCorners = getXYCorners(nside, ipix, viewFrame, surveyFrame, width, height, largestDim, zoomFactor, projection, this.view);\n                        if (xyCorners) {\n                            drawCorners(ctx, xyCorners);\n                        }\n                    }\n                }\n            }\n        }\n\n\n        if (this.opacity==1) {\n            ctx.stroke();\n        }\n        else {\n            ctx.fill();\n            ctx.globalAlpha = 1.0;\n        }\n    };\n\n    var drawCorners = function(ctx, xyCorners) {\n        //console.log(xyCorners);\n        ctx.moveTo(xyCorners[0].vx, xyCorners[0].vy);\n        ctx.lineTo(xyCorners[1].vx, xyCorners[1].vy);\n        ctx.lineTo(xyCorners[2].vx, xyCorners[2].vy);\n        ctx.lineTo(xyCorners[3].vx, xyCorners[3].vy);\n        ctx.lineTo(xyCorners[0].vx, xyCorners[0].vy);\n    }\n\n    // remove duplicate items from array a\n    var uniq = function(a) {\n        var seen = {};\n        var out = [];\n        var len = a.length;\n        var j = 0;\n        for (var i = 0; i < len; i++) {\n            var item = a[i];\n            if (seen[item] !== 1) {\n                seen[item] = 1;\n                out[j++] = item;\n            }\n        }\n\n        return out;\n    };\n\n\n    // TODO: merge with what is done in View.getVisibleCells\n    //var _spVec = new SpatialVector();\n    var getXYCorners = function(nside, ipix, viewFrame, surveyFrame, width, height, largestDim, zoomFactor, projection, view) {\n        var cornersXYView = [];\n        var cornersXY = [];\n\n        //var spVec = _spVec;\n\n        //var corners = HealpixCache.corners_nest(ipix, nside);\n        var corners = Aladin.wasmLibs.hpx.nestedVertices(Math.log2(nside), ipix);\n\n        var ra, dec;\n        var lon, lat;\n        for (var k=0; k<4; k++) {\n            //spVec.setXYZ(corners[k].x, corners[k].y, corners[k].z);\n\n            ra = corners[2*k];\n            dec = corners[2*k + 1];\n            // need for frame transformation ?\n            /*if (surveyFrame && surveyFrame.system != viewFrame.system) {\n                if (surveyFrame.system == CooFrameEnum.SYSTEMS.J2000) {\n                    var radec = CooConversion.J2000ToGalactic([ra, dec]);\n                    lon = radec[0];\n                    lat = radec[1];\n                }\n                else if (surveyFrame.system == CooFrameEnum.SYSTEMS.GAL) {\n                    var radec = CooConversion.GalacticToJ2000([ra, dec]);\n                    lon = radec[0];\n                    lat = radec[1];\n                }\n            }\n            else {\n                lon = ra;\n                lat = dec;\n            }*/\n            lon = ra;\n            lat = dec;\n\n            //cornersXY[k] = projection.project(lon, lat);\n            cornersXYView[k] = view.aladin.webglAPI.worldToScreen(lon, lat);\n            if (!cornersXYView[k]) {\n                return null;\n            } else {\n                //console.log(lon, lat);\n                cornersXYView[k] = {\n                    vx: cornersXYView[k][0],\n                    vy: cornersXYView[k][1],\n                };\n            }\n            //console.log(cornersXYView[k]);\n        }\n\n        /*if (cornersXYView[0] == null ||  cornersXYView[1] == null  ||  cornersXYView[2] == null ||  cornersXYView[3] == null ) {\n            return null;\n        }*/\n        /*if (cornersXY[0] == null ||  cornersXY[1] == null  ||  cornersXY[2] == null ||  cornersXY[3] == null ) {\n            return null;\n        }\n\n        for (var k=0; k<4; k++) {\n            cornersXYView[k] = AladinUtils.xyToView(cornersXY[k].X, cornersXY[k].Y, width, height, largestDim, zoomFactor);\n        }*/\n        \n        // detect pixels outside view. Could be improved !\n        // we minimize here the number of cells returned\n        if( cornersXYView[0].vx<0 && cornersXYView[1].vx<0 && cornersXYView[2].vx<0 &&cornersXYView[3].vx<0) {\n            return null;\n        }\n        if( cornersXYView[0].vy<0 && cornersXYView[1].vy<0 && cornersXYView[2].vy<0 &&cornersXYView[3].vy<0) {\n            return null;\n        }\n        if( cornersXYView[0].vx>=width && cornersXYView[1].vx>=width && cornersXYView[2].vx>=width &&cornersXYView[3].vx>=width) {\n            return null;\n        }\n        if( cornersXYView[0].vy>=height && cornersXYView[1].vy>=height && cornersXYView[2].vy>=height &&cornersXYView[3].vy>=height) {\n            return null;\n        }\n\n        // check if we have a pixel at the edge of the view in allsky projections\n        if (projection.PROJECTION!=ProjectionEnum.SIN && projection.PROJECTION!=ProjectionEnum.TAN) {\n            // Faster approach: when a vertex from a cell gets to the other side of the projection\n            // its vertices order change from counter-clockwise to clockwise!\n            // So if the vertices describing a cell are given in clockwise order\n            // we know it crosses the projection, so we do not plot them!\n            if (!AladinUtils.counterClockwiseTriangle(cornersXYView[0].vx, cornersXYView[0].vy, cornersXYView[1].vx, cornersXYView[1].vy, cornersXYView[2].vx, cornersXYView[2].vy) ||\n                !AladinUtils.counterClockwiseTriangle(cornersXYView[0].vx, cornersXYView[0].vy, cornersXYView[2].vx, cornersXYView[2].vy, cornersXYView[3].vx, cornersXYView[3].vy)) {\n                return null;\n            }\n        }\n\n        //cornersXYView = AladinUtils.grow2(cornersXYView, 1);\n        return cornersXYView;\n    };\n\n    MOC.prototype.reportChange = function() {\n        this.view && this.view.requestRedraw();\n    };\n\n    MOC.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        this.reportChange();\n    };\n\n    MOC.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        this.reportChange();\n    };\n\n    // Tests whether a given (ra, dec) point on the sky is within the current MOC object\n    //\n    // returns true if point is contained, false otherwise\n    MOC.prototype.contains = function(ra, dec) {\n        var hpxIdx = new HealpixIndex(Math.pow(2, this.order));\n        hpxIdx.init();\n        var polar = HealpixIndex.utils.radecToPolar(ra, dec);\n        var ipix = hpxIdx.ang2pix_nest(polar.theta, polar.phi);\n        var ipixMapByOrder = {};\n        for (var curOrder=0; curOrder<=this.order; curOrder++) {\n            ipixMapByOrder[curOrder] = Math.floor(ipix / Math.pow(4, this.order - curOrder));\n        }\n\n        // first look for large HEALPix cells (order<3)\n        for (var ipixOrder3=0; ipixOrder3<768; ipixOrder3++) {\n            var mocCells = this._highResIndexOrder3[ipixOrder3];\n            for (var order in mocCells) {\n                if (order<3) {\n                    for (var k=mocCells[order].length; k>=0; k--) {\n                        if (ipixMapByOrder[order] == mocCells[order][k]) {\n                            return true;\n                        }   \n                    }\n                }\n            }\n        }\n\n        // look for finer cells\n        var ipixOrder3 = ipixMapByOrder[3];\n        var mocCells = this._highResIndexOrder3[ipixOrder3];\n        for (var order in mocCells) {\n            for (var k=mocCells[order].length; k>=0; k--) {\n                if (ipixMapByOrder[order] == mocCells[order][k]) {\n                    return true;\n                }   \n            }\n        }\n\n        return false;\n    };\n\n\n\n    return MOC;\n\n})();\n\n    \n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File MeasurementTable\n *\n * Graphic object showing measurement of a catalog\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nexport let MeasurementTable = (function() {\n\n\n    // constructor\n    function MeasurementTable(aladinLiteDiv) {\n        this.isShowing = false;\n\n        this.divEl = $('<div class=\"aladin-measurement-div\"></div>');\n        \n        $(aladinLiteDiv).append(this.divEl);\n    }\n\n    // show measurement associated with a given source\n    MeasurementTable.prototype.showMeasurement = function(source) {\n        this.divEl.empty();\n        var header = '<thead><tr>';\n        var content = '<tr>';\n        for (let key in source.data) {\n            header += '<th>' + key + '</th>';\n            content += '<td>' + source.data[key] + '</td>';\n        }\n        header += '</tr></thead>';\n        content += '</tr>';\n        this.divEl.append('<table>' + header + content + '</table>');\n        this.show();\n    };\n\n    MeasurementTable.prototype.show = function() {\n        this.divEl.show();\n    };\n    \n    MeasurementTable.prototype.hide = function() {\n        this.divEl.hide();\n    };\n    \n    \n    return MeasurementTable;\n})();\n\n","// Copyright 2015 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Overlay\n *\n * Description: a plane holding overlays (footprints, polylines, circles)\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { AladinUtils } from \"./AladinUtils.js\";\nimport { Footprint } from \"./Footprint.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\nimport { Line } from './Line.js';\n\nexport let Overlay = (function() {\n   let Overlay = function(options) {\n        options = options || {};\n\n        this.type = 'overlay';\n\n    \tthis.name = options.name || \"overlay\";\n    \tthis.color = options.color || Color.getNextColor();\n        \n    \tthis.lineWidth = options[\"lineWidth\"] || 2;\n    \t\n    \t//this.indexationNorder = 5; // at which level should we index overlays?\n    \tthis.overlays = [];\n    \tthis.overlay_items = []; // currently Circle or Polyline\n    \t//this.hpxIdx = new HealpixIndex(this.indexationNorder);\n    \t//this.hpxIdx.init();\n    \t\n    \tthis.isShowing = true;\n    };\n    \n\n    // TODO : show/hide methods should be integrated in a parent class \n    Overlay.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        this.reportChange();\n    };\n    \n    Overlay.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        this.reportChange();\n    };\n    \n    // return an array of Footprint from a STC-S string\n    Overlay.parseSTCS = function(stcs) {\n        var footprints = [];\n        var parts = stcs.match(/\\S+/g);\n        var k = 0, len = parts.length;\n        while(k<len) {\n            var s = parts[k].toLowerCase();\n            if(s=='polygon') {\n                var curPolygon = [];\n                k++;\n                frame = parts[k].toLowerCase();\n                if (frame=='icrs' || frame=='j2000' || frame=='fk5') {\n                    while(k+2<len) {\n                        var ra = parseFloat(parts[k+1]);\n                        if (isNaN(ra)) {\n                            break;\n                        }\n                        var dec = parseFloat(parts[k+2]);\n                        curPolygon.push([ra, dec]);\n                        k += 2;\n                    }\n                    curPolygon.push(curPolygon[0]);\n                    footprints.push(new Footprint(curPolygon));\n                }\n            }\n            else if (s=='circle') {\n                var frame;\n                k++;\n                frame = parts[k].toLowerCase();\n\n                if (frame=='icrs' || frame=='j2000' || frame=='fk5') {\n                    var ra, dec, radiusDegrees;\n\n                    ra = parseFloat(parts[k+1]);\n                    dec = parseFloat(parts[k+2]);\n                    radiusDegrees = parseFloat(parts[k+3]);\n\n                    footprints.push(A.circle(ra, dec, radiusDegrees)); \n\n                    k += 3;\n                }\n            }\n\n            k++;\n        }\n\n        return footprints;\n    };\n    \n    // ajout d'un tableau d'overlays (= objets Footprint, Circle ou Polyline)\n    Overlay.prototype.addFootprints = function(overlaysToAdd) {\n    \tfor (var k=0, len=overlaysToAdd.length; k<len; k++) {\n            this.add(overlaysToAdd[k], false);\n        }\n\n        this.view.requestRedraw();\n    };\n\n    // TODO : item doit pouvoir prendre n'importe quoi en param (footprint, circle, polyline)\n    Overlay.prototype.add = function(item, requestRedraw) {\n        requestRedraw = requestRedraw !== undefined ? requestRedraw : true;\n\n        if (item instanceof Footprint) {\n            this.overlays.push(item);\n        }\n        else {\n            this.overlay_items.push(item);\n        }\n        item.setOverlay(this);\n        \n        if (requestRedraw) {\n            this.view.requestRedraw();\n        }\n    };\n\n    \n    // return a footprint by index\n   Overlay.prototype.getFootprint = function(idx) {\n        if (idx<this.footprints.length) {\n            return this.footprints[idx];\n        }\n        else {\n            return null;\n        }\n    };\n    \n    Overlay.prototype.setView = function(view) {\n        this.view = view;\n    };\n    \n    Overlay.prototype.removeAll = function() {\n        // TODO : RAZ de l'index\n        this.overlays = [];\n        this.overlay_items = [];\n    };\n    \n    Overlay.prototype.draw = function(ctx, projection, frame, width, height, largestDim, zoomFactor) {\n        if (!this.isShowing) {\n            return;\n        }\n        \n        // simple drawing\n        ctx.strokeStyle= this.color;\n\n        // 1. Drawing polygons\n        \n        // TODO: les overlay polygons devrait se tracer lui meme (methode draw)\n        ctx.lineWidth = this.lineWidth;\n    \tctx.beginPath();\n    \tvar xyviews = [];\n    \tfor (var k=0, len = this.overlays.length; k<len; k++) {\n    \t\txyviews.push(this.drawFootprint(this.overlays[k], ctx, projection, frame, width, height, largestDim, zoomFactor));\n    \t}\n        ctx.stroke();\n\n    \t// selection drawing\n        ctx.strokeStyle= Overlay.increaseBrightness(this.color, 50);\n        ctx.beginPath();\n        for (var k=0, len = this.overlays.length; k<len; k++) {\n            if (! this.overlays[k].isSelected) {\n                continue;\n            }\n            this.drawFootprintSelected(ctx, xyviews[k]);\n            \n        }\n    \tctx.stroke();\n    \t\n        // 2. Circle and polylines drawing\n    \tfor (var k=0; k<this.overlay_items.length; k++) {\n    \t    this.overlay_items[k].draw(ctx, this.view, projection, frame, width, height, largestDim, zoomFactor);\n    \t}\n    };\n\n    Overlay.increaseBrightness = function(hex, percent){\n        // strip the leading # if it's there\n        hex = hex.replace(/^\\s*#|\\s*$/g, '');\n\n        // convert 3 char codes --> 6, e.g. `E0F` --> `EE00FF`\n        if(hex.length == 3){\n            hex = hex.replace(/(.)/g, '$1$1');\n        }\n\n        var r = parseInt(hex.substr(0, 2), 16),\n            g = parseInt(hex.substr(2, 2), 16),\n            b = parseInt(hex.substr(4, 2), 16);\n\n        return '#' +\n                ((0|(1<<8) + r + (256 - r) * percent / 100).toString(16)).substr(1) +\n                ((0|(1<<8) + g + (256 - g) * percent / 100).toString(16)).substr(1) +\n                ((0|(1<<8) + b + (256 - b) * percent / 100).toString(16)).substr(1);\n    };\n    \n    \n    Overlay.prototype.drawFootprint = function(f, ctx, projection, frame, width, height, largestDim, zoomFactor) {\n        if (! f.isShowing) {\n            return null;\n        }\n        var xyviewArray = [];\n        //var show = false;\n        var radecArray = f.polygons;\n        for(var l=0; l<radecArray.length-1; l++) {\n            let pts = this.view.aladin.webglAPI.projectLine(radecArray[l][0], radecArray[l][1], radecArray[l+1][0], radecArray[l+1][1]);\n            for(var k=0; k<pts.length; k+=4) {\n                let line = new Line(pts[k], pts[k+1], pts[k+2], pts[k+3]);\n                if (line.isInsideView(width, height)) {\n                    line.draw(ctx);\n                }    \n            }\n        }\n\n        // for\n            /*for (var k=0, len=radecArray.length; k<len; k++) {\n                var xy;\n                if (frame.system != CooFrameEnum.SYSTEMS.J2000) {\n                    var lonlat = CooConversion.J2000ToGalactic([radecArray[k][0], radecArray[k][1]]);\n                    xy = projection.project(lonlat[0], lonlat[1]);\n                }\n                else {\n                    xy = projection.project(radecArray[k][0], radecArray[k][1]);\n                }\n                if (!xy) {\n                    return null;\n                }\n                var xyview = AladinUtils.xyToView(xy.X, xy.Y, width, height, largestDim, zoomFactor);\n                xyviewArray.push(xyview);\n                if (!show && xyview.vx<width  && xyview.vx>=0 && xyview.vy<=height && xyview.vy>=0) {\n                    show = true;\n                }\n            }\n\n            if (show) {\n                ctx.moveTo(xyviewArray[0].vx, xyviewArray[0].vy);\n                for (var k=1, len=xyviewArray.length; k<len; k++) {\n                    ctx.lineTo(xyviewArray[k].vx, xyviewArray[k].vy);\n                }\n            }\n            else {\n                //return null;\n            }\n        // end for*/\n\n        return xyviewArray;\n\n\n\n    };\n\n    Overlay.prototype.drawFootprintSelected = function(ctx, xyview) {\n        if (!xyview) {\n            return;\n        }\n\n        var xyviewArray = xyview;\n        ctx.moveTo(xyviewArray[0].vx, xyviewArray[0].vy);\n        for (var k=1, len=xyviewArray.length; k<len; k++) {\n            ctx.lineTo(xyviewArray[k].vx, xyviewArray[k].vy);\n        }\n    };\n\n\n    \n    // callback function to be called when the status of one of the footprints has changed\n    Overlay.prototype.reportChange = function() {\n        this.view.requestRedraw();\n    };\n\n    return Overlay;\n})();\n","// Copyright 2015 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * Class Polyline\n * \n * A Polyline is a graphical overlay made of several connected points\n * \n * TODO: Polyline and Circle should derive from a common base class\n * TODO: index polyline, Circle in HEALPix pixels to avoid unneeded calls to draw \n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { AladinUtils } from './AladinUtils.js';\nimport { Line } from './Line.js';\n\nexport let Polyline= (function() {\n    // constructor\n    let Polyline = function(radecArray, options) {\n        options = options || {};\n        this.color = options['color'] || undefined;\n        \n        this.radecArray = radecArray;\n        this.overlay = null;\n    \t\n    \tthis.isShowing = true;\n    \tthis.isSelected = false;\n    };\n    \n    Polyline.prototype.setOverlay = function(overlay) {\n        this.overlay = overlay;\n    };\n    \n    Polyline.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Polyline.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Polyline.prototype.select = function() {\n        if (this.isSelected) {\n            return;\n        }\n        this.isSelected = true;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Polyline.prototype.deselect = function() {\n        if (! this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        if (this.overlay) {\n            this.overlay.reportChange();\n        }\n    };\n    \n    Polyline.prototype.draw = function(ctx, view, projection, frame, width, height, largestDim, zoomFactor) {\n        if (! this.isShowing) {\n            return;\n        }\n\n        if (! this.radecArray || this.radecArray.length<2) {\n            return;\n        }\n        \n        if (this.color) {\n            ctx.strokeStyle= this.color;\n        }\n        /*var start = AladinUtils.radecToViewXy(this.radecArray[0][0], this.radecArray[0][1], projection, frame, width, height, largestDim, zoomFactor);\n        if (! start) {\n            return;\n        }\n       \n        ctx.beginPath();\n        ctx.moveTo(start.vx, start.vy);\n        var pt;\n        for (var k=1; k<this.radecArray.length; k++) {\n            pt = AladinUtils.radecToViewXy(this.radecArray[k][0], this.radecArray[k][1], projection, frame, width, height, largestDim, zoomFactor);\n            if (!pt) {\n                break;\n            }\n            ctx.lineTo(pt.vx, pt.vy);\n        }\n        \n        \n        ctx.stroke();*/\n        ctx.beginPath();\n        for(var l=0; l<this.radecArray.length-1; l++) {\n            let pts = view.aladin.webglAPI.projectLine(this.radecArray[l][0], this.radecArray[l][1], this.radecArray[l+1][0], this.radecArray[l+1][1]);\n            for(var k=0; k<pts.length; k+=4) {\n                let line = new Line(pts[k], pts[k+1], pts[k+2], pts[k+3]);\n                if (line.isInsideView(width, height)) {\n                    line.draw(ctx);\n                }    \n            }\n        }\n\n        ctx.stroke();\n    };\n\n    return Polyline;\n})();","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Popup.js\n * \n * Author: Thomas Boch [CDS]\n * \n *****************************************************************************/\n\nexport let Popup = (function() {\n    \n    \n    // constructor\n    function Popup(parentDiv, view) {\n        this.domEl = $('<div class=\"aladin-popup-container\"><div class=\"aladin-popup\"><a class=\"aladin-closeBtn\">&times;</a><div class=\"aladin-popupTitle\"></div><div class=\"aladin-popupText\"></div></div><div class=\"aladin-popup-arrow\"></div></div>');\n        this.domEl.appendTo(parentDiv);\n\n        this.view = view;\n\n\n        var self = this;\n        // close popup\n        this.domEl.find('.aladin-closeBtn').click(function() {self.hide();});\n        \n    };\n    \n    Popup.prototype.hide = function() {\n        this.domEl.hide();\n\n        this.view.mustClearCatalog=true;\n        this.view.catalogForPopup.hide();\n    };\n\n    Popup.prototype.show = function() {\n        this.domEl.show();\n    };\n\n    Popup.prototype.setTitle = function(title) {\n        this.domEl.find('.aladin-popupTitle').html(title || '');\n    };\n\n    Popup.prototype.setText = function(text) {\n        this.domEl.find('.aladin-popupText').html(text || '');\n        this.w = this.domEl.outerWidth();\n        this.h = this.domEl.outerHeight();\n    };\n\n    Popup.prototype.setSource = function(source) {\n        // remove reference to popup for previous source\n        if (this.source) {\n            this.source.popup = null;\n        }\n        source.popup = this;\n        this.source = source;\n        this.setPosition(source.x, source.y);\n    };\n\n    Popup.prototype.setPosition = function(x, y) {\n        var newX = x - this.w/2;\n        var newY = y - this.h;\n        if (this.source) {\n            newY += this.source.catalog.sourceSize/2;\n        }\n\n        this.domEl[0].style.left = newX + 'px';\n        this.domEl[0].style.top  = newY + 'px';\n    };\n    \n    return Popup;\n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File ProgressiveCat.js\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\n import { Catalog } from \"./Catalog.js\";\n import { Source } from \"./Source.js\";\n import { Color } from \"./Color.js\";\n import { Coo } from \"./libs/astro/coo.js\";\n import { Utils } from \"./Utils.js\";\n import { CooFrameEnum } from \"./CooFrameEnum.js\";\n\n// TODO: index sources according to their HEALPix ipix\n// TODO : merge parsing with class Catalog\nexport let ProgressiveCat = (function() {\n    \n    // TODO : test if CORS support. If no, need to pass through a proxy\n    // currently, we suppose CORS is supported\n    \n    // constructor\n    let ProgressiveCat = function(rootUrl, frameStr, maxOrder, options) {\n        options = options || {};\n\n        this.type = 'progressivecat';\n        \n        this.rootUrl = rootUrl; // TODO: method to sanitize rootURL (absolute, no duplicate slashes, remove end slash if existing)\n        // fast fix for HTTPS support --> will work for all HiPS served by CDS\n        if (Utils.isHttpsContext() && ( /u-strasbg.fr/i.test(this.rootUrl) || /unistra.fr/i.test(this.rootUrl)  ) ) {\n            this.rootUrl = this.rootUrl.replace('http://', 'https://');\n        }\n\n        this.frameStr = frameStr;\n        this.frame = CooFrameEnum.fromString(frameStr) || CooFrameEnum.J2000;\n        this.maxOrder = maxOrder;\n        this.isShowing = true; // TODO : inherit from catalogue\n\n        this.name = options.name || \"progressive-cat\";\n        this.color = options.color || Color.getNextColor();\n        this.shape = options.shape || \"square\";\n        this.sourceSize = options.sourceSize || 6;\n        this.selectSize = this.sourceSize + 2;\n        this.selectionColor = '#00ff00'; // TODO: to be merged with Catalog\n\n        // allows for filtering of sources\n        this.filterFn = options.filter ||undefined; // TODO: do the same for catalog\n\n\n        this.onClick = options.onClick || undefined; // TODO: inherit from catalog\n\n        \n\n        // we cache the list of sources in each healpix tile. Key of the cache is norder+'-'+npix\n        this.sourcesCache = new Utils.LRUCache(100);\n\n        this.updateShape(options);\n\n\n\n\n        this.maxOrderAllsky = 2;\n        this.isReady = false;\n    };\n\n    // TODO: to be put higher in the class diagram, in a HiPS generic class\n    ProgressiveCat.readProperties = function(rootUrl, successCallback, errorCallback) {\n        if (! successCallback) {\n            return;\n        }\n\n        var propertiesURL = rootUrl + '/properties';\n        $.ajax({\n            url: propertiesURL,\n            method: 'GET',\n            dataType: 'text',\n            success: function(propertiesTxt) {\n                var props = {};\n                var lines = propertiesTxt.split('\\n');\n                for (var k=0; k<lines.length; k++) {\n                    var line = lines[k];\n                    var idx = line.indexOf('=');\n                    var propName  = $.trim(line.substring(0, idx));\n                    var propValue = $.trim(line.substring(idx + 1));\n                    \n                    props[propName] = propValue;\n                }\n    \n                successCallback(props);\n                \n            },\n            error: function(err) { // TODO : which parameters should we put in the error callback\n                errorCallback && errorCallback(err);\n            }\n        });\n\n\n\n\n        \n    };\n\n    function getFields(instance, xml) {\n        var attributes = [\"name\", \"ID\", \"ucd\", \"utype\", \"unit\", \"datatype\", \"arraysize\", \"width\", \"precision\"];\n\n        var fields = [];\n        var k = 0;\n        instance.keyRa = instance.keyDec = null;\n        $(xml).find(\"FIELD\").each(function() {\n            var f = {};\n            for (var i=0; i<attributes.length; i++) {\n                var attribute = attributes[i];\n                if ($(this).attr(attribute)) {\n                    f[attribute] = $(this).attr(attribute);\n                }\n                \n            }\n            if ( ! f.ID) {\n                f.ID = \"col_\" + k;\n            }\n            \n            if (!instance.keyRa && f.ucd && (f.ucd.indexOf('pos.eq.ra')==0 || f.ucd.indexOf('POS_EQ_RA')==0)) {\n                if (f.name) {\n                    instance.keyRa = f.name;\n                }\n                else {\n                    instance.keyRa = f.ID;\n                }\n            }\n            if (!instance.keyDec && f.ucd && (f.ucd.indexOf('pos.eq.dec')==0 || f.ucd.indexOf('POS_EQ_DEC')==0)) {\n                if (f.name) {\n                    instance.keyDec = f.name;\n                }\n                else {\n                    instance.keyDec = f.ID;\n                }\n            }\n            \n            fields.push(f);\n            k++;\n        });\n\n        return fields;\n    }\n\n    function getSources(instance, csv, fields) {\n        // TODO : find ra and dec key names (see in Catalog)\n        if (!instance.keyRa || ! instance.keyDec) {\n            return [];\n        }\n        var lines = csv.split('\\n');\n        var mesureKeys = [];\n        for (var k=0; k<fields.length; k++) {\n            if (fields[k].name) {\n                mesureKeys.push(fields[k].name);\n            }\n            else {\n                mesureKeys.push(fields[k].ID);\n            }\n        }\n        \n\n        var sources = [];\n        var coo = new Coo();\n        var newSource;\n        // start at i=1, as first line repeat the fields names\n        for (var i=2; i<lines.length; i++) {\n            var mesures = {};\n            var data = lines[i].split('\\t');\n            if (data.length<mesureKeys.length) {\n                continue;\n            }\n            for (var j=0; j<mesureKeys.length; j++) {\n                mesures[mesureKeys[j]] = data[j];\n            }\n            var ra, dec;\n            if (Utils.isNumber(mesures[instance.keyRa]) && Utils.isNumber(mesures[instance.keyDec])) {\n                ra = parseFloat(mesures[instance.keyRa]);\n                dec = parseFloat(mesures[instance.keyDec]);\n            }\n            else {\n                coo.parse(mesures[instance.keyRa] + \" \" + mesures[instance.keyDec]);\n                ra = coo.lon;\n                dec = coo.lat;\n            }\n            newSource = new Source(ra, dec, mesures);\n            sources.push(newSource);\n            newSource.setCatalog(instance);\n        }\n        return sources;\n    };\n\n    //ProgressiveCat.prototype.updateShape = Catalog.prototype.updateShape;\n\n    ProgressiveCat.prototype = {\n\n        init: function(view) {\n            var self = this;\n            this.view = view;\n\n            if (this.maxOrder && this.frameStr) {\n                this._loadMetadata();\n            }\n\n            else {\n                ProgressiveCat.readProperties(self.rootUrl,\n                    function (properties) {\n                        self.properties = properties;\n                        self.maxOrder = self.properties['hips_order'];\n                        self.frame = CooFrameEnum.fromString(self.properties['hips_frame']);\n\n                        self._loadMetadata();\n                    }, function(err) {\n                        console.log('Could not find properties for HiPS ' + self.rootUrl);\n                    }\n                );\n            }\n        },\n\n        updateShape: Catalog.prototype.updateShape,\n\n        _loadMetadata: function() {\n            var self = this;\n            $.ajax({\n                url: self.rootUrl + '/' + 'Metadata.xml',\n                method: 'GET',\n                success: function(xml) {\n                    self.fields = getFields(self, xml);\n                    self._loadAllskyNewMethod();\n                },\n                error: function(err) {\n                    self._loadAllskyOldMethod();\n                }\n            });\n        },\n\n        _loadAllskyNewMethod: function() {\n            var self = this;\n            $.ajax({\n                url: self.rootUrl + '/' + 'Norder1/Allsky.tsv',\n                method: 'GET',\n                success: function(tsv) {\n                    self.order1Sources = getSources(self, tsv, self.fields);\n\n                    if (self.order2Sources) {\n                        self.isReady = true;\n                        self._finishInitWhenReady();\n                    }\n                },\n                error: function(err) {\n                    console.log('Something went wrong: ' + err);\n                }\n            });\n\n            $.ajax({\n                url: self.rootUrl + '/' + 'Norder2/Allsky.tsv',\n                method: 'GET',\n                success: function(tsv) {\n                    self.order2Sources = getSources(self, tsv, self.fields);\n\n                    if (self.order1Sources) {\n                        self.isReady = true;\n                        self._finishInitWhenReady();\n                    }\n                },\n                error: function(err) {\n                    console.log('Something went wrong: ' + err);\n                }\n            });\n\n        },\n\n        _loadAllskyOldMethod: function() {\n            this.maxOrderAllsky = 3;\n            this._loadLevel2Sources();\n            this._loadLevel3Sources();\n        },\n\n        _loadLevel2Sources: function() {\n            var self = this;\n            $.ajax({\n                url: self.rootUrl + '/' + 'Norder2/Allsky.xml',\n                method: 'GET',\n                success: function(xml) {\n                    self.fields = getFields(self, xml);\n                    self.order2Sources = getSources(self, $(xml).find('CSV').text(), self.fields);\n                    if (self.order3Sources) {\n                        self.isReady = true;\n                        self._finishInitWhenReady();\n                    }\n                },\n                error: function(err) {\n                    console.log('Something went wrong: ' + err);\n                }\n            });\n        },\n\n        _loadLevel3Sources: function() {\n            var self = this;\n            $.ajax({\n                url: self.rootUrl + '/' + 'Norder3/Allsky.xml',\n                method: 'GET',\n                success: function(xml) {\n                    self.order3Sources = getSources(self, $(xml).find('CSV').text(), self.fields);\n                    if (self.order2Sources) {\n                        self.isReady = true;\n                        self._finishInitWhenReady();\n                    }\n                },\n                error: function(err) {\n                    console.log('Something went wrong: ' + err);\n                }\n            });\n        },\n\n        _finishInitWhenReady: function() {\n            this.view.requestRedraw();\n            this.loadNeededTiles();\n        },\n\n        draw: function(ctx, projection, frame, width, height, largestDim, zoomFactor) {\n            if (! this.isShowing || ! this.isReady) {\n                return;\n            }\n            this.drawSources(this.order1Sources, ctx, projection, frame, width, height, largestDim, zoomFactor);\n            this.drawSources(this.order2Sources, ctx, projection, frame, width, height, largestDim, zoomFactor);\n            this.drawSources(this.order3Sources, ctx, projection, frame, width, height, largestDim, zoomFactor);\n            \n            if (!this.tilesInView) {\n                return;\n            }\n            var sources, key, t;\n            for (var k=0; k<this.tilesInView.length; k++) {\n                t = this.tilesInView[k];\n                key = t[0] + '-' + t[1];\n                sources = this.sourcesCache.get(key);\n                if (sources) {\n                    this.drawSources(sources, ctx, projection, frame, width, height, largestDim, zoomFactor);\n                }\n            }\n            \n            \n            \n        },\n        drawSources: function(sources, ctx, projection, frame, width, height, largestDim, zoomFactor) {\n            if (! sources) {\n                return;\n            }\n            var s;\n            for (var k=0, len = sources.length; k<len; k++) {\n                s = sources[k];\n                if (!this.filterFn || this.filterFn(s)) {\n                    Catalog.drawSource(this, s, ctx, projection, frame, width, height, largestDim, zoomFactor);\n                }\n            }\n            for (var k=0, len = sources.length; k<len; k++) {\n                s = sources[k];\n                if (! s.isSelected) {\n                    continue;\n                }\n                if (!this.filterFn || this.filterFn(s)) {\n                    Catalog.drawSourceSelection(this, s, ctx);\n                }\n            }\n        },\n\n        getSources: function() {\n            var ret = [];\n            if (this.order1Sources) {\n                ret = ret.concat(this.order1Sources);\n            }\n            if (this.order2Sources) {\n                ret = ret.concat(this.order2Sources);\n            }\n            if (this.order3Sources) {\n                ret = ret.concat(this.order3Sources);\n            }\n            if (this.tilesInView) {\n                var sources, key, t;\n                for (var k=0; k<this.tilesInView.length; k++) {\n                    t = this.tilesInView[k];\n                    key = t[0] + '-' + t[1];\n                    sources = this.sourcesCache.get(key);\n                    if (sources) {\n                        ret = ret.concat(sources);\n                    }\n                }\n            }\n            \n            return ret;\n        },\n\n\n        \n        deselectAll: function() {\n            if (this.order1Sources) {\n                for (var k=0; k<this.order1Sources.length; k++) {\n                    this.order1Sources[k].deselect();\n                }\n            }\n\n            if (this.order2Sources) {\n                for (var k=0; k<this.order2Sources.length; k++) {\n                    this.order2Sources[k].deselect();\n                }\n            }\n\n            if (this.order3Sources) {\n                for (var k=0; k<this.order3Sources.length; k++) {\n                    this.order3Sources[k].deselect();\n                }\n            }\n            var keys = this.sourcesCache.keys();\n            for (key in keys) {\n                if ( ! this.sourcesCache[key]) {\n                    continue;\n                }\n                var sources = this.sourcesCache[key];\n                for (var k=0; k<sources.length; k++) {\n                    sources[k].deselect();\n                }\n            }\n        },\n\n        show: function() {\n            if (this.isShowing) {\n                return;\n            }\n            this.isShowing = true;\n            this.loadNeededTiles();\n            this.reportChange();\n        },\n        hide: function() {\n            if (! this.isShowing) {\n                return;\n            }\n            this.isShowing = false;\n            this.reportChange();\n        },\n        reportChange: function() {\n            this.view.requestRedraw();\n        },\n        \n        getTileURL: function(norder, npix) {\n            var dirIdx = Math.floor(npix/10000)*10000;\n            return this.rootUrl + \"/\" + \"Norder\" + norder + \"/Dir\" + dirIdx + \"/Npix\" + npix + \".tsv\";\n        },\n    \n        loadNeededTiles: function() {\n            if ( ! this.isShowing) {\n                return;\n            }\n            this.tilesInView = [];\n            \n            var norder = this.view.realNorder;\n            if (norder>this.maxOrder) {\n                norder = this.maxOrder;\n            }\n            if (norder<=this.maxOrderAllsky) {\n                return; // nothing to do, hurrayh !\n            }\n            var cells = this.view.getVisibleCells(norder, this.frame);\n            var ipixList, ipix;\n            for (var curOrder=3; curOrder<=norder; curOrder++) {\n                ipixList = [];\n                for (var k=0; k<cells.length; k++) {\n                    ipix = Math.floor(cells[k].ipix / Math.pow(4, norder - curOrder));\n                    if (ipixList.indexOf(ipix)<0) {\n                        ipixList.push(ipix);\n                    }\n                }\n                \n                // load needed tiles\n                for (var i=0; i<ipixList.length; i++) {\n                    this.tilesInView.push([curOrder, ipixList[i]]);\n                }\n            }\n            \n            var t, key;\n            var self = this;\n            for (var k=0; k<this.tilesInView.length; k++) {\n                t = this.tilesInView[k];\n                key = t[0] + '-' + t[1]; // t[0] is norder, t[1] is ipix\n                if (!this.sourcesCache.get(key)) {\n                    (function(self, norder, ipix) { // wrapping function is needed to be able to retrieve norder and ipix in ajax success function\n                        var key = norder + '-' + ipix;\n                        $.ajax({\n                            /*\n                            url: Aladin.JSONP_PROXY,\n                            data: {\"url\": self.getTileURL(norder, ipix)},\n                            */\n                            // ATTENTIOn : je passe en JSON direct, car je n'arrive pas a choper les 404 en JSONP\n                            url: self.getTileURL(norder, ipix),\n                            method: 'GET',\n                            //dataType: 'jsonp',\n                            success: function(tsv) {\n                                self.sourcesCache.set(key, getSources(self, tsv, self.fields));\n                                //self.view.requestRedraw();\n                            },\n                            error: function() {\n                                // on suppose qu'il s'agit d'une erreur 404\n                                self.sourcesCache.set(key, []);\n                            }\n                        });\n                    })(this, t[0], t[1]);\n                }\n            }\n        },\n\n        reportChange: function() { // TODO: to be shared with Catalog\n            this.view && this.view.requestRedraw();\n        }\n    \n\n    }; // END OF .prototype functions\n    \n    \n    return ProgressiveCat;\n})();\n    \n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File CooFrameEnum\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\n import { Projection } from \"./libs/astro/projection.js\";\n\n export let ProjectionEnum = {\n    SIN: Projection.PROJ_SIN,\n    AITOFF:  Projection.PROJ_AITOFF,\n    MERCATOR:  Projection.PROJ_MERCATOR,\n    ARC:  Projection.PROJ_ARC,\n    TAN:  Projection.PROJ_TAN,\n    MOL: Projection.PROJ_MOLLWEIDE,\n };\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Sesame.js\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Utils } from \"./Utils.js\";\n\nexport let Sesame = (function() {\n    let Sesame = {};\n    \n    Sesame.cache = {};\n\n    Sesame.SESAME_URL = \"http://cds.u-strasbg.fr/cgi-bin/nph-sesame.jsonp\";\n\n    /** find RA, DEC for any target (object name or position)\n     *  if successful, callback is called with an object {ra: <ra-value>, dec: <dec-value>}\n     *  if not successful, errorCallback is called\n     */\n    Sesame.getTargetRADec = function(target, callback, errorCallback) {\n        if (!callback) {\n            return;\n        }\n        var isObjectName = /[a-zA-Z]/.test(target);\n\n        // try to parse as a position\n        if ( ! isObjectName) {\n            var coo = new Coo();\n\n            coo.parse(target);\n            if (callback) {\n                callback({ra: coo.lon, dec: coo.lat});\n            }\n        }\n        // ask resolution by Sesame\n        else {\n            Sesame.resolve(target,\n                   function(data) { // success callback\n                       callback({ra:  data.Target.Resolver.jradeg,\n                                 dec: data.Target.Resolver.jdedeg});\n                   },\n\n                   function(data) { // error callback\n                       if (errorCallback) {\n                           errorCallback();\n                       }\n                   }\n           );\n        }\n    };\n    \n    Sesame.resolve = function(objectName, callbackFunctionSuccess, callbackFunctionError) {\n        var sesameUrl = Sesame.SESAME_URL;\n        if (Utils.isHttpsContext()) {\n            sesameUrl = sesameUrl.replace('http://', 'https://')\n        }\n            \n\n        $.ajax({\n            url: sesameUrl ,\n            data: {\"object\": objectName},\n            method: 'GET',\n            dataType: 'jsonp',\n            success: function(data) {\n                if (data.Target && data.Target.Resolver && data.Target.Resolver) {\n                    callbackFunctionSuccess(data);\n                }\n                else {\n                    callbackFunctionError(data);\n                }\n            },\n            error: callbackFunctionError\n            });\n    };\n    \n    return Sesame;\n})();\n\n","/* Import all the shaders here*/ \n// Catalog shaders\nimport CatalogAitoffVS from '../core/src/shaders/catalogs/aitoff.vert';\nimport CatalogMercatVS from '../core/src/shaders/catalogs/mercator.vert';\nimport CatalogArcVS from '../core/src/shaders/catalogs/arc.vert';\nimport CatalogTanVS from '../core/src/shaders/catalogs/tan.vert';\nimport CatalogMollVS from '../core/src/shaders/catalogs/mollweide.vert';\nimport CatalogOrthoVS from '../core/src/shaders/catalogs/ortho.vert';\nimport CatalogOrthoFS from '../core/src/shaders/catalogs/ortho.frag';\nimport CatalogFS from '../core/src/shaders/catalogs/catalog.frag';\n\n// Colormap shaders\nimport ColormapVS from '../core/src/shaders/colormaps/colormap.vert'\nimport ColormapBlackWhiteFS from '../core/src/shaders/colormaps/blackwhite.frag'\nimport ColormapBluePastelRedFS from '../core/src/shaders/colormaps/BluePastelRed.frag'\nimport ColormapIDL_CB_BrBGFS from '../core/src/shaders/colormaps/IDL_CB_BrBG.frag'\nimport ColormapIDL_CB_GnBuFS from '../core/src/shaders/colormaps/IDL_CB_GnBu.frag'\nimport ColormapIDL_CB_YIGnBuFS from '../core/src/shaders/colormaps/IDL_CB_YIGnBu.frag'\nimport ColormapRedTemperatureFS from '../core/src/shaders/colormaps/red.frag'\n\n// Grid shader\nimport GridVS from '../core/src/shaders/grid/grid.vert'\nimport GridAitoffFS from '../core/src/shaders/grid/aitoff.frag'\nimport GridMollFS from '../core/src/shaders/grid/mollweide.frag'\nimport GridOrthoFS from '../core/src/shaders/grid/ortho.frag'\nimport GridMercatorFS from '../core/src/shaders/grid/mercator.frag'\nimport GridArcFS from '../core/src/shaders/grid/arc.frag'\nimport GridTanFS from '../core/src/shaders/grid/tan.frag'\nimport GridVS_CPU from '../core/src/shaders/grid/grid_cpu.vert'\nimport GridFS_CPU from '../core/src/shaders/grid/grid_cpu.frag'\n\n// HiPS shaders\n// Raytracer\nimport RayTracerVS from '../core/src/shaders/hips/raytracer/raytracer.vert'\nimport RayTracerColorFS from '../core/src/shaders/hips/raytracer/color.frag'\nimport RayTracerGrayscale2ColorFS from '../core/src/shaders/hips/raytracer/grayscale_to_color.frag'\nimport RayTracerGrayscale2ColormapFS from '../core/src/shaders/hips/raytracer/grayscale_to_colormap.frag'\nimport RayTracerGrayscale2ColorIntegerFS from '../core/src/shaders/hips/raytracer/grayscale_to_color_i.frag'\nimport RayTracerGrayscale2ColormapIntegerFS from '../core/src/shaders/hips/raytracer/grayscale_to_colormap_i.frag'\n\n// Rasterizer\nimport RasterizerOrthoVS from '../core/src/shaders/hips/rasterizer/ortho.vert'\nimport RasterizerMercatorVS from '../core/src/shaders/hips/rasterizer/mercator.vert'\nimport RasterizerAitoffVS from '../core/src/shaders/hips/rasterizer/aitoff.vert'\nimport RasterizerGnomonicVS from '../core/src/shaders/hips/rasterizer/gnomonic.vert'\nimport RasterizerArcVS from '../core/src/shaders/hips/rasterizer/arc.vert'\nimport RasterizerMollVS from '../core/src/shaders/hips/rasterizer/mollweide.vert'\nimport RasterizerColorFS from '../core/src/shaders/hips/rasterizer/color.frag'\nimport RasterizerGrayscale2ColorFS from '../core/src/shaders/hips/rasterizer/grayscale_to_color.frag'\nimport RasterizerGrayscale2ColormapFS from '../core/src/shaders/hips/rasterizer/grayscale_to_colormap.frag'\nimport RasterizerGrayscale2ColorIntegerFS from '../core/src/shaders/hips/rasterizer/grayscale_to_color_i.frag'\nimport RasterizerGrayscale2ColormapIntegerFS from '../core/src/shaders/hips/rasterizer/grayscale_to_colormap_i.frag'\n// Misc\nimport TextVS from '../core/src/shaders/misc/text.vert'\nimport TextFS from '../core/src/shaders/misc/text.frag'\n\nlet shaders = [\n    // Catalog shaders\n    {\n        id: \"CatalogAitoffVS\",\n        content: CatalogAitoffVS,\n    },\n    {\n        id: \"CatalogMercatVS\",\n        content: CatalogMercatVS,\n    },\n    {\n        id: \"CatalogArcVS\",\n        content: CatalogArcVS,\n    },\n    {\n        id: \"CatalogTanVS\",\n        content: CatalogTanVS,\n    },\n    {\n        id: \"CatalogMollVS\",\n        content: CatalogMollVS,\n    },\n    {\n        id: \"CatalogOrthoVS\",\n        content: CatalogOrthoVS,\n    },\n    {\n        id: \"CatalogOrthoFS\",\n        content: CatalogOrthoFS,\n    },\n    {\n        id: \"CatalogFS\",\n        content: CatalogFS,    \n    },\n    // Colormap shaders\n    {\n        id: \"ColormapVS\",\n        content: ColormapVS,\n    },\n    {\n        id: \"ColormapBlackWhiteFS\",\n        content: ColormapBlackWhiteFS\n    },\n    {\n        id: \"ColormapBluePastelRedFS\",\n        content: ColormapBluePastelRedFS\n    },\n    {\n        id: \"ColormapIDL_CB_BrBGFS\",\n        content: ColormapIDL_CB_BrBGFS\n    },\n    {\n        id: \"ColormapIDL_CB_GnBuFS\",\n        content: ColormapIDL_CB_GnBuFS\n    },\n    {\n        id: \"ColormapIDL_CB_YIGnBuFS\",\n        content: ColormapIDL_CB_YIGnBuFS\n    },\n    {\n        id: \"ColormapRedTemperatureFS\",\n        content: ColormapRedTemperatureFS\n    },\n    // Grid shader\n    {\n        id: \"GridVS\",\n        content: GridVS,\n    },\n    {\n        id: \"GridAitoffFS\",\n        content: GridAitoffFS,\n    },\n    {\n        id: \"GridMollFS\",\n        content: GridMollFS,\n    },\n    {\n        id: \"GridOrthoFS\",\n        content: GridOrthoFS,\n    },\n    {\n        id: \"GridMercatorFS\",\n        content: GridMercatorFS,\n    },\n    {\n        id: \"GridArcFS\",\n        content: GridArcFS,\n    },\n    {\n        id: \"GridTanFS\",\n        content: GridTanFS,\n    },\n    {\n        id: \"GridFS_CPU\",\n        content: GridFS_CPU,\n    },\n    {\n        id: \"GridVS_CPU\",\n        content: GridVS_CPU,\n    },\n    // HiPS shaders\n    // Raytracer\n    {\n        id: \"RayTracerVS\",\n        content: RayTracerVS,\n    },\n    {\n        id: \"RayTracerColorFS\",\n        content: RayTracerColorFS,\n    },\n    {\n        id: \"RayTracerGrayscale2ColorFS\",\n        content: RayTracerGrayscale2ColorFS,\n    },\n    {\n        id: \"RayTracerGrayscale2ColormapFS\",\n        content: RayTracerGrayscale2ColormapFS,\n    },\n    {\n        id: \"RayTracerGrayscale2ColorIntegerFS\",\n        content: RayTracerGrayscale2ColorIntegerFS,\n    },\n    {\n        id: \"RayTracerGrayscale2ColormapIntegerFS\",\n        content: RayTracerGrayscale2ColormapIntegerFS,\n    },\n    /// Rasterizer\n    {\n        id: \"RasterizerOrthoVS\",\n        content: RasterizerOrthoVS,\n    },\n    {\n        id: \"RasterizerMercatorVS\",\n        content: RasterizerMercatorVS,\n    },\n    {\n        id: \"RasterizerAitoffVS\",\n        content: RasterizerAitoffVS,\n    },\n    {\n        id: \"RasterizerArcVS\",\n        content: RasterizerArcVS,\n    },\n    {\n        id: \"RasterizerGnomonicVS\",\n        content: RasterizerGnomonicVS,\n    },\n    {\n        id: \"RasterizerMollVS\",\n        content: RasterizerMollVS,\n    },\n    {\n        id: \"RasterizerColorFS\",\n        content: RasterizerColorFS,\n    },\n    {\n        id: \"RasterizerGrayscale2ColorFS\",\n        content: RasterizerGrayscale2ColorFS,\n    },\n    {\n        id: \"RasterizerGrayscale2ColormapFS\",\n        content: RasterizerGrayscale2ColormapFS,\n    },\n    {\n        id: \"RasterizerGrayscale2ColorIntegerFS\",\n        content: RasterizerGrayscale2ColorIntegerFS,\n    },\n    {\n        id: \"RasterizerGrayscale2ColormapIntegerFS\",\n        content: RasterizerGrayscale2ColormapIntegerFS,\n    },\n    // Misc\n    {\n        id: \"TextVS\",\n        content: TextVS,\n    },\n    {\n        id: \"TextFS\",\n        content: TextFS,\n    },\n];\n\nexport function loadShaders() {\n    return shaders;\n}\n","// Copyright 2018 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File SimbadPointer.js\n *\n * The SIMBAD pointer will query Simbad for a given position and radius and\n * return information on the object with \n *  \n * Author: Thomas Boch [CDS]\n * \n *****************************************************************************/\n\nSimbadPointer = (function() {\n    \n    \n    SimbadPointer = {};\n\n    SimbadPointer.MIRRORS = ['https://alasky.u-strasbg.fr/cgi/simbad-flat/simbad-quick.py', 'https://alaskybis.u-strasbg.fr/cgi/simbad-flat/simbad-quick.py']; // list of base URL for Simbad pointer service\n\n    \n    SimbadPointer.query = function(ra, dec, radiusDegrees, aladinInstance) {\n        var coo = new Coo(ra, dec, 7);\n        var params = {Ident: coo.format('s/'), SR: radiusDegrees}\n        var successCallback = function(result) {\n            aladinInstance.view.setCursor('pointer');\n\n            var regexp = /(.*?)\\/(.*?)\\((.*?),(.*?)\\)/g;\n            var match = regexp.exec(result);\n            if (match) {\n                var objCoo = new Coo();\n                objCoo.parse(match[1]);\n                var objName = match[2];\n                var title = '<div class=\"aladin-sp-title\"><a target=\"_blank\" href=\"http://simbad.u-strasbg.fr/simbad/sim-id?Ident=' + encodeURIComponent(objName) + '\">' + objName + '</a></div>';\n                var content = '<div class=\"aladin-sp-content\">';\n                content += '<em>Type: </em>' + match[4] + '<br>';\n                var magnitude = match[3];\n                if (Utils.isNumber(magnitude)) {\n                    content += '<em>Mag: </em>' + magnitude + '<br>';\n                }\n                content += '<br><a target=\"_blank\" href=\"http://cdsportal.u-strasbg.fr/?target=' + encodeURIComponent(objName) + '\">Query in CDS portal</a>';\n                content += '</div>';\n                aladinInstance.showPopup(objCoo.lon, objCoo.lat, title, content);\n            }\n            else {\n                aladinInstance.hidePopup();\n            }\n        };\n        var failureCallback = function() {\n            aladinInstance.view.setCursor('pointer');\n            aladinInstance.hidePopup();\n        };\n        Utils.loadFromMirrors(SimbadPointer.MIRRORS, {data: params, onSuccess: successCallback, onFailure: failureCallback, timeout: 5});\n\n    };\n\n    return SimbadPointer;\n})();\n    \n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Source\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nexport let Source = (function() {\n    // constructor\n    let Source = function(ra, dec, data, options) {\n    \tthis.ra = ra;\n    \tthis.dec = dec;\n    \tthis.data = data;\n    \tthis.catalog = null;\n    \t\n        this.marker = (options && options.marker) || false;\n        if (this.marker) {\n            this.popupTitle = (options && options.popupTitle) ? options.popupTitle : '';\n            this.popupDesc = (options && options.popupDesc) ? options.popupDesc : '';\n            this.useMarkerDefaultIcon = (options && options.useMarkerDefaultIcon!==undefined) ? options.useMarkerDefaultIcon : true;\n        }\n\n    \tthis.isShowing = true;\n    \tthis.isSelected = false;\n    };\n    \n    Source.prototype.setCatalog = function(catalog) {\n        this.catalog = catalog;\n    };\n    \n    Source.prototype.show = function() {\n        if (this.isShowing) {\n            return;\n        }\n        this.isShowing = true;\n        if (this.catalog) {\n            this.catalog.reportChange();\n        }\n    };\n    \n    Source.prototype.hide = function() {\n        if (! this.isShowing) {\n            return;\n        }\n        this.isShowing = false;\n        if (this.catalog) {\n            this.catalog.reportChange();\n        }\n    };\n    \n    Source.prototype.select = function() {\n        if (this.isSelected) {\n            return;\n        }\n        this.isSelected = true;\n        if (this.catalog) {\n            this.catalog.reportChange();\n        }\n    };\n    \n    Source.prototype.deselect = function() {\n        if (! this.isSelected) {\n            return;\n        }\n        this.isSelected = false;\n        if (this.catalog) {\n            this.catalog.reportChange();\n        }\n    };\n\n    // function called when a source is clicked. Called by the View object\n    Source.prototype.actionClicked = function() {\n        if (this.catalog && this.catalog.onClick) {\n            var view = this.catalog.view;\n            if (this.catalog.onClick=='showTable') {\n                view.aladin.measurementTable.showMeasurement(this);\n                this.select();\n            }\n            else if (this.catalog.onClick=='showPopup') {\n                view.popup.setTitle('<br><br>');\n                var m = '<div class=\"aladin-marker-measurement\">';\n                m += '<table>';\n                for (var key in this.data) {\n                    m += '<tr><td>' + key + '</td><td>' + this.data[key] + '</td></tr>';\n                }\n                m += '</table>';\n                m += '</div>';\n                view.popup.setText(m);\n                view.popup.setSource(this);\n                view.popup.show();\n            }\n            else if (typeof this.catalog.onClick === 'function') {\n                this.catalog.onClick(this);\n                view.lastClickedObject = this;\n            }\n\n        }\n    };\n\n    \n    Source.prototype.actionOtherObjectClicked = function() {\n        if (this.catalog && this.catalog.onClick) {\n            this.deselect();\n        }\n    };\n    \n    return Source;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Tile\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nexport let Tile = (function() {\n    // constructor\n\tfunction Tile(img, url) {\n\t\tthis.img = img;\n\t\tthis.url = url;\n\t};\n\t\n\t// check whether the image corresponding to the tile is loaded and ready to be displayed\n\t//\n\t// source : http://www.sajithmr.me/javascript-check-an-image-is-loaded-or-not\n\tTile.isImageOk = function(img) {\n\t\tif (img.allSkyTexture) {\n\t\t\treturn true;\n\t\t}\n\t\t\n        if (!img.src) {\n            return false;\n        }\n\n\t    // During the onload event, IE correctly identifies any images that\n\t    // werent downloaded as not complete. Others should too. Gecko-based\n\t    // browsers act like NS4 in that they report this incorrectly.\n\t    if (!img.complete) {\n\t        return false;\n\t    }\n\n\t    // However, they do have two very useful properties: naturalWidth and\n\t    // naturalHeight. These give the true size of the image. If it failed\n\t    // to load, either of these should be zero.\n\n\t    if (typeof img.naturalWidth != \"undefined\" && img.naturalWidth == 0) {\n\t        return false;\n\t    }\n\n        // TODO: Add a method checking if the tile has been copied to the GPU texture\n        \n\n\t    // No other way of checking: assume its ok.\n\t    return true;\n\t};\n\t\n\n\treturn Tile;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File TileBuffer\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\n import { Tile } from \"./Tile.js\";\n\nexport let TileBuffer = (function() {\n\tvar NB_MAX_TILES = 800; // buffer size\n\t\n\t// constructor\n\tfunction TileBuffer() {\n\t\tthis.pointer = 0;\n\t\tthis.tilesMap = {};\n\t\tthis.tilesArray = new Array(NB_MAX_TILES);\n\n\t\tfor (var i=0; i<NB_MAX_TILES; i++) {\n\t\t\tthis.tilesArray[i] = new Tile(new Image(), null);\n\t\t}\n\t};\n\t\n\tTileBuffer.prototype.addTile = function(url) {\n\t    // return null if already in buffer\n        if (this.getTile(url)) {\n            return null;\n        }\n\n        // delete existing tile\n        var curTile = this.tilesArray[this.pointer];\n        if (curTile.url != null) {\n            curTile.img.src = null;\n            delete this.tilesMap[curTile.url];\n        }\n\n        this.tilesArray[this.pointer].url = url;\n        this.tilesMap[url] = this.tilesArray[this.pointer];\n\n        this.pointer++;\n        if (this.pointer>=NB_MAX_TILES) {\n            this.pointer = 0;\n        }\n\n        return this.tilesMap[url];\n\t};\n\t\n\tTileBuffer.prototype.getTile = function(url) {\n        return this.tilesMap[url];\n\t};\n\t\n\treturn TileBuffer;\n})();\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File URLBuilder\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\nimport { Coo } from './libs/astro/coo.js';\nimport { Utils } from './Utils.js';\nexport let URLBuilder = (function() {    \n\n    let URLBuilder = {\n        buildSimbadCSURL: function(target, radiusDegrees) {\n            if (target && (typeof target  === \"object\")) {\n                if ('ra' in target && 'dec' in target) {\n                    var coo = new Coo(target.ra, target.dec, 7);\n                    target = coo.format('s');\n                }\n            }\n            return 'https://alasky.unistra.fr/cgi/simbad-flat/simbad-cs.py?target=' + encodeURIComponent(target) + '&SR=' + radiusDegrees + '&format=votable&SRUNIT=deg&SORTBY=nbref';\n        },\n\n        buildNEDPositionCSURL: function(ra, dec, radiusDegrees) {\n                return 'https://ned.ipac.caltech.edu/cgi-bin/nph-objsearch?search_type=Near+Position+Search&of=xml_main&RA=' + ra + '&DEC=' + dec + '&SR=' + radiusDegrees;\n        },\n\n        buildNEDObjectCSURL: function(object, radiusDegrees) {\n                return 'https://ned.ipac.caltech.edu/cgi-bin/nph-objsearch?search_type=Near+Name+Search&radius=' + (60 * radiusDegrees) + '&of=xml_main&objname=' + object;\n        },\n\n        buildVizieRCSURL: function(vizCatId, target, radiusDegrees, options) {\n            console.log(target)\n            if (target && (typeof target  === \"object\")) {\n                if ('ra' in target && 'dec' in target) {\n                    var coo = new Coo(target.ra, target.dec, 7);\n\n                    target = coo.format('s');\n                }\n            }\n\n            var maxNbSources = 1e5;\n            if (options && options.hasOwnProperty('limit') && Utils.isNumber(options.limit)) {\n                maxNbSources = parseInt(options.limit);\n            }\n            return 'https://vizier.unistra.fr/viz-bin/votable?-source=' + vizCatId + '&-c=' + encodeURIComponent(target) + '&-out.max=' + maxNbSources + '&-c.rd=' + radiusDegrees;\n        },\n\n        buildSkyBotCSURL: function(ra, dec, radius, epoch, queryOptions) {\n            var url = 'http://vo.imcce.fr/webservices/skybot/skybotconesearch_query.php?-from=AladinLite';\n            url += '&RA=' + encodeURIComponent(ra);\n            url += '&DEC=' + encodeURIComponent(dec);\n            url += '&SR=' + encodeURIComponent(radius);\n            url += '&EPOCH=' + encodeURIComponent(epoch);\n\n            if (queryOptions) {\n                for (var key in queryOptions) {\n                    if (queryOptions.hasOwnProperty(key)) {\n                            url += '&' + key + '=' + encodeURIComponent(queryOptions[key]);\n                    }\n                }\n            }\n\n            return url;\n        }\n    \n\n    };\n\n    return URLBuilder;\n    \n})();\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File Utils\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Aladin } from \"./Aladin.js\";\n\nexport let Utils = {};\n\nUtils.cssScale = undefined;\n// adding relMouseCoords to HTMLCanvasElement prototype (see http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element ) \nfunction relMouseCoords(event) {\n    var totalOffsetX = 0;\n    var totalOffsetY = 0;\n    var canvasX = 0;\n    var canvasY = 0;\n    var currentElement = this;\n   \n    if (event.offsetX) {\n        return {x: event.offsetX, y:event.offsetY};\n    } \n    else {\n        if (!Utils.cssScale) {\n            var st = window.getComputedStyle(document.body, null);\n            var tr = st.getPropertyValue(\"-webkit-transform\") ||\n                    st.getPropertyValue(\"-moz-transform\") ||\n                    st.getPropertyValue(\"-ms-transform\") ||\n                    st.getPropertyValue(\"-o-transform\") ||\n                    st.getPropertyValue(\"transform\");\n            var matrixRegex = /matrix\\((-?\\d*\\.?\\d+),\\s*0,\\s*0,\\s*(-?\\d*\\.?\\d+),\\s*0,\\s*0\\)/;\n            var matches = tr.match(matrixRegex);\n            if (matches) {\n                Utils.cssScale = parseFloat(matches[1]);\n            }\n            else {\n                Utils.cssScale = 1;\n            }\n        }\n        var e = event;\n        var canvas = e.target;\n        // http://www.jacklmoore.com/notes/mouse-position/\n        var target = e.target || e.srcElement;\n        var style = target.currentStyle || window.getComputedStyle(target, null);\n        var borderLeftWidth = parseInt(style['borderLeftWidth'], 10);\n        var borderTopWidth = parseInt(style['borderTopWidth'], 10);\n        var rect = target.getBoundingClientRect();\n\n        var clientX = e.clientX;\n        var clientY = e.clientY;\n        if (e.clientX) {\n            clientX = e.clientX;\n            clientY = e.clientY;\n        }\n        else {\n            clientX = e.originalEvent.changedTouches[0].clientX;\n            clientY = e.originalEvent.changedTouches[0].clientY;\n        }\n\n        var offsetX = clientX - borderLeftWidth - rect.left;\n        var offsetY = clientY - borderTopWidth - rect.top\n\n        return {x: parseInt(offsetX/Utils.cssScale), y: parseInt(offsetY/Utils.cssScale)};\n    }\n}\nHTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;\n\n\n\n//Function.prototype.bind polyfill from \n//https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function (obj) {\n        // closest thing possible to the ECMAScript 5 internal IsCallable function\n        if (typeof this !== 'function') {\n            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n        }\n\n        var slice = [].slice,\n        args = slice.call(arguments, 1),\n        self = this,\n        nop = function () { },\n        bound = function () {\n            return self.apply(this instanceof nop ? this : (obj || {}),\n                    args.concat(slice.call(arguments)));\n        };\n\n        bound.prototype = this.prototype;\n\n        return bound;\n    };\n}\n\n\n\n\n\n\n\n\n//$ = $ || jQuery;\n\n/* source : http://stackoverflow.com/a/8764051 */\n$.urlParam = function(name, queryString){\n    if (queryString===undefined) {\n        queryString = location.search;\n    }\n\treturn decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(queryString)||[,\"\"])[1].replace(/\\+/g, '%20'))||null;\n};\n\n/* source: http://stackoverflow.com/a/1830844 */\nUtils.isNumber = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nUtils.isInt = function(n) {\n    return Utils.isNumber(n) && Math.floor(n)==n;\n};\n\n/* a debounce function, used to prevent multiple calls to the same function if less than delay milliseconds have passed */\nUtils.debounce = function(fn, delay) {\n    var timer = null;\n    return function () {\n      var context = this, args = arguments;\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, delay);\n    };\n};\n\n/* return a throttled function, to rate limit the number of calls (by default, one call every 250 milliseconds) */\nUtils.throttle = function(fn, threshhold, scope) {\n  threshhold || (threshhold = 250);\n  var last,\n      deferTimer;\n  return function () {\n    var context = scope || this;\n\n    var now = +new Date,\n        args = arguments;\n    if (last && now < last + threshhold) {\n      // hold on to it\n      clearTimeout(deferTimer);\n      deferTimer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshhold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\n\n\n/* A LRU cache, inspired by https://gist.github.com/devinus/409353#file-gistfile1-js */\n// TODO : utiliser le LRU cache pour les tuiles images\nUtils.LRUCache = function (maxsize) {\n    this._keys = [];\n    this._items = {};\n    this._expires = {};\n    this._size = 0;\n    this._maxsize = maxsize || 1024;\n};\n   \nUtils.LRUCache.prototype = {\n        set: function (key, value) {\n            var keys = this._keys,\n                items = this._items,\n                expires = this._expires,\n                size = this._size,\n                maxsize = this._maxsize;\n\n            if (size >= maxsize) { // remove oldest element when no more room\n                keys.sort(function (a, b) {\n                    if (expires[a] > expires[b]) return -1;\n                    if (expires[a] < expires[b]) return 1;\n                    return 0;\n                });\n\n                size--;\n                delete expires[keys[size]];\n                delete items[keys[size]];\n            }\n\n            keys[size] = key;\n            items[key] = value;\n            expires[key] = Date.now();\n            size++;\n\n            this._keys = keys;\n            this._items = items;\n            this._expires = expires;\n            this._size = size;\n        },\n\n        get: function (key) {\n            var item = this._items[key];\n            if (item) this._expires[key] = Date.now();\n            return item;\n        },\n        \n        keys: function() {\n            return this._keys;\n        }\n};\n\n////////////////////////////////////////////////////////////////////////////:\n\n/**\n  Make an AJAX call, given a list of potential mirrors\n  First successful call will result in options.onSuccess being called back\n  If all calls fail, onFailure is called back at the end\n\n  This method assumes the URL are CORS-compatible, no proxy will be used\n */\nUtils.loadFromMirrors = function(urls, options) {\n    var data    = options && options.data || null;\n    var method = options && options.method || 'GET';\n    var dataType = options && options.dataType || null;\n    var timeout = options && options.timeout || 20;\n\n    var onSuccess = options && options.onSuccess || null;\n    var onFailure = options && options.onFailure || null;\n\n    if (urls.length === 0) {\n        (typeof onFailure === 'function') && onFailure();\n    }\n    else {\n        var ajaxOptions = {\n            url: urls[0],\n            data: data\n        }\n        if (dataType) {\n            ajaxOptions.dataType = dataType;\n        }\n\n        $.ajax(ajaxOptions)\n        .done(function(data) {\n            (typeof onSuccess === 'function') && onSuccess(data);\n        })\n        .fail(function() {\n             Utils.loadFromMirrors(urls.slice(1), options);\n        });\n    }\n} \n\n// return the jquery ajax object configured with the requested parameters\n// by default, we use the proxy (safer, as we don't know if the remote server supports CORS)\nUtils.getAjaxObject = function(url, method, dataType, useProxy) {\n        if (useProxy!==false) {\n            useProxy = true;\n        }\n\n        if (useProxy===true) {\n            var urlToRequest = Aladin.JSONP_PROXY + '?url=' + encodeURIComponent(url);\n        }\n        else {\n            urlToRequest = url;\n        }\n        method = method || 'GET';\n        dataType = dataType || null;\n\n        return $.ajax({\n            url: urlToRequest,\n            method: method,\n            dataType: dataType\n        }); \n};\n\n// return true if script is executed in a HTTPS context\n// return false otherwise\nUtils.isHttpsContext = function() {\n    return ( window.location.protocol === 'https:' );\n};\n\n// generate an absolute URL from a relative URL\n// example: getAbsoluteURL('foo/bar/toto') return http://cds.unistra.fr/AL/foo/bar/toto if executed from page http://cds.unistra.fr/AL/\nUtils.getAbsoluteURL = function(url) {\n    var a = document.createElement('a');\n    a.href = url;\n\n    return a.href;\n};\n\n// generate a valid v4 UUID\nUtils.uuidv4 = function() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\n","// Copyright 2013 - UDS/CNRS\n// The Aladin Lite program is distributed under the terms\n// of the GNU General Public License version 3.\n//\n// This file is part of Aladin Lite.\n//\n//    Aladin Lite is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, version 3 of the License.\n//\n//    Aladin Lite is distributed in the hope that it will be useful,\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//    GNU General Public License for more details.\n//\n//    The GNU General Public License is available in COPYING file\n//    along with Aladin Lite.\n//\n\n\n\n\n/******************************************************************************\n * Aladin Lite project\n * \n * File View.js\n * \n * Author: Thomas Boch[CDS]\n * \n *****************************************************************************/\n\nimport { Aladin }   from \"./Aladin.js\";\nimport { Popup }          from \"./Popup.js\";\nimport { HealpixGrid }    from \"./HealpixGrid.js\";\nimport { HpxImageSurvey } from \"./HpxImageSurvey.js\";\nimport { ProjectionEnum } from \"./ProjectionEnum.js\";\nimport { Projection }     from \"./libs/astro/projection.js\";\nimport { Coo }            from \"./libs/astro/coo.js\";\nimport { AladinUtils }    from \"./AladinUtils.js\";\nimport { HealpixIndex }   from \"./libs/healpix.js\";\nimport { HealpixCache }   from \"./HealpixCache.js\";\nimport { SpatialVector }  from \"./libs/healpix.js\";\nimport { Utils }          from \"./Utils.js\";\nimport { SimbadPointer }  from \"./SimbadPointer.js\";\nimport { TileBuffer }     from \"./TileBuffer.js\";\nimport { Downloader }     from \"./Downloader.js\";\nimport { Stats }          from \"./libs/Stats.js\";\nimport { ColorMap } from \"./ColorMap.js\";\nimport { Footprint } from \"./Footprint.js\";\nimport { Circle } from \"./Circle.js\";\nimport { CooFrameEnum } from \"./CooFrameEnum.js\";\nimport { CooConversion } from \"./CooConversion.js\";\nimport { requestAnimFrame } from \"./libs/RequestAnimationFrame.js\";\nimport { loadShaders } from './Shaders.js';\n// Import kernel image\nimport kernel from '../core/img/kernel.png';\nimport { ImageSurveyLayer } from \"./ImageSurveyLayer.js\";\n\nexport let View = (function() {\n\n    /** Constructor */\n    function View (aladin, location, fovDiv, cooFrame, zoom) {\n            this.aladin = aladin;\n            // Add a reference to the WebGL API\n            //this.webglAPI = aladin.webglAPI;\n            this.options = aladin.options;\n            this.aladinDiv = this.aladin.aladinDiv;\n            this.popup = new Popup(this.aladinDiv, this);\n\n            this.createCanvases();\n            // Init the WebGL context\n            // At this point, the view has been created so the image canvas too\n            let shaders = loadShaders();\n            //console.log(shaders);\n        \n            // Start our Rust application. You can find `WebClient` in `src/lib.rs`\n            let resources = {\n                'kernel': kernel,\n            };\n            this.aladin.webglAPI = new Aladin.wasmLibs.webgl.WebClient(shaders, resources);\n            this.aladin.webglAPI.resize(500, 400);\n            //this.aladin.webglAPI.setHiPS(aladin.survey);\n\n            this.location = location;\n            this.fovDiv = fovDiv;\n            this.mustClearCatalog = true;\n            this.mustRedrawReticle = true;\n            this.imageSurveysToSet = [];\n            this.mode = View.PAN;\n            \n            this.minFOV = this.maxFOV = null; // by default, no restriction\n            this.fov_limit = 180.0;\n            \n            this.healpixGrid = new HealpixGrid(this.imageCanvas);\n\n            \n            var lon, lat;\n            lon = lat = 0;\n            \n            this.projectionMethod = ProjectionEnum.SIN;\n            this.projection = new Projection(lon, lat);\n            this.projection.setProjection(this.projectionMethod);\n            //this.zoomLevel = 0;\n            // Prev time of the last frame\n            this.prev = 0;\n            //this.zoomFactor = this.computeZoomFactor(this.zoomLevel);\n            this.zoomFactor = this.aladin.webglAPI.getClipZoomFactor();\n    \n            this.viewCenter = {lon: lon, lat: lat}; // position of center of view\n\n            if (cooFrame) {\n                this.cooFrame = cooFrame;\n            } else {\n                this.cooFrame = CooFrameEnum.GAL;\n            }\n            if (cooFrame.system === CooFrameEnum.SYSTEMS.GAL) {\n                console.log()\n                const GAL = Aladin.wasmLibs.webgl.GALCooSys();\n                this.aladin.webglAPI.setCooSystem(GAL);\n            } else {\n                const ICRSJ2000 = Aladin.wasmLibs.webgl.ICRSJ2000CooSys();\n                this.aladin.webglAPI.setCooSystem(ICRSJ2000);\n            }\n\n            if (zoom) {\n                this.setZoom(zoom);\n            }\n            \n            // current reference image survey displayed\n            this.imageSurveys = new Map();\n            // current catalogs displayed\n            this.catalogs = [];\n            // a dedicated catalog for the popup\n            var c = document.createElement('canvas');\n            c.width = c.height = 24;\n            var ctx= c.getContext('2d');\n            ctx.lineWidth = 6.0;\n            ctx.beginPath();\n            ctx.strokeStyle = '#eee';\n            ctx.arc(12, 12, 8, 0, 2*Math.PI, true);\n            ctx.stroke();\n            ctx.lineWidth = 3.0;\n            ctx.beginPath();\n            ctx.strokeStyle = '#c38';\n            ctx.arc(12, 12, 8, 0, 2*Math.PI, true);\n            ctx.stroke();\n            this.catalogForPopup = A.catalog({shape: c, sourceSize: 24});\n            //this.catalogForPopup = A.catalog({sourceSize: 18, shape: 'circle', color: '#c38'});\n            this.catalogForPopup.hide();\n            this.catalogForPopup.setView(this);\n            // overlays (footprints for instance)\n            this.overlays = [];\n            // MOCs\n            this.mocs = [];\n            // reference to all overlay layers (= catalogs + overlays + mocs)\n            this.allOverlayLayers = []\n            \n    \n            \n            this.tileBuffer = new TileBuffer(); // tile buffer is shared across different image surveys\n            this.fixLayoutDimensions();\n            \n            this.firstHiPS = true;\n            this.curNorder = 1;\n            this.realNorder = 1;\n            this.curOverlayNorder = 1;\n            \n            // some variables for mouse handling\n            this.dragging = false;\n            this.dragx = null;\n            this.dragy = null;\n            this.needRedraw = true;\n\n            // zoom pinching\n            this.pinchZoomParameters = {\n                isPinching: false, // true if a pinch zoom is ongoing\n                initialFov: undefined,\n                initialDistance: undefined\n            };\n    \n            this.downloader = new Downloader(this); // the downloader object is shared across all HpxImageSurveys\n            this.flagForceRedraw = false;\n    \n            this.fadingLatestUpdate = null;\n            \n            this.dateRequestRedraw = null;\n            \n            this.showGrid = false; // coordinates grid\n            \n            init(this);\n            \n\n            // listen to window resize and reshape canvases\n            this.resizeTimer = null;\n            var self = this;\n            $(window).resize(function() {\n                clearTimeout(self.resizeTimer);\n                self.resizeTimer = setTimeout(function() {self.fixLayoutDimensions(self)}, 100);\n            });\n\n\n            // in some contexts (Jupyter notebook for instance), the parent div changes little time after Aladin Lite creation\n            // this results in canvas dimension to be incorrect.\n            // The following line tries to fix this issue\n            setTimeout(function() {\n                var computedWidth = $(self.aladinDiv).width();\n                var computedHeight = $(self.aladinDiv).height();\n\n                if (self.width!==computedWidth || self.height===computedHeight) {\n                    self.fixLayoutDimensions();\n                    // As the WebGL backend has been resized correctly by\n                    // the previous call, we can get the zoom factor from it\n                    \n                    self.updateZoomState(); // needed to force recomputation of displayed FoV\n                }\n           }, 1000);\n\n        };\n    \n    // different available modes\n    View.PAN = 0;\n    View.SELECT = 1;\n    View.TOOL_SIMBAD_POINTER = 2;\n        \n    \n    // TODO: should be put as an option at layer level    \n    View.DRAW_SOURCES_WHILE_DRAGGING = true;\n    View.DRAW_MOCS_WHILE_DRAGGING = true;\n\n    View.CALLBACKS_THROTTLE_TIME_MS = 100; // minimum time between two consecutive callback calls\n\n    \n    // (re)create needed canvases\n    View.prototype.createCanvases = function() {\n        var a = $(this.aladinDiv);\n        //a.find('.aladin-webglCanvas').remove();\n        a.find('.aladin-imageCanvas').remove();\n        a.find('.aladin-catalogCanvas').remove();\n        a.find('.aladin-reticleCanvas').remove();\n        a.find('.aladin-gridCanvas').remove();\n\n        // canvas to draw the images\n        //this.webglCanvas = $(\"<canvas class='aladin-webglCanvas'></canvas>\").appendTo(this.aladinDiv)[0];\n        // canvas to draw the overlays\n        this.imageCanvas = $(\"<canvas class='aladin-imageCanvas'></canvas>\").appendTo(this.aladinDiv)[0];\n        // canvas to draw the grid\n        this.gridCanvas = $(\"<canvas class='aladin-gridCanvas'></canvas>\").appendTo(this.aladinDiv)[0];\n        // canvas to draw the catalogs\n        this.catalogCanvas = $(\"<canvas class='aladin-catalogCanvas'></canvas>\").appendTo(this.aladinDiv)[0];\n        // canvas to draw the reticle\n        this.reticleCanvas = $(\"<canvas class='aladin-reticleCanvas'></canvas>\").appendTo(this.aladinDiv)[0];\n\n    };\n    \n    // called at startup and when window is resized\n    // The WebGL backend is resized\n    View.prototype.fixLayoutDimensions = function() {\n        Utils.cssScale = undefined;\n        \n        var computedWidth = $(this.aladinDiv).width();\n        var computedHeight = $(this.aladinDiv).height();\n\n        this.width = Math.max(computedWidth, 1);\n        this.height = Math.max(computedHeight, 1); // this prevents many problems when div size is equal to 0\n        \n        \n        this.cx = this.width/2;\n        this.cy = this.height/2;\n        \n        this.largestDim = Math.max(this.width, this.height);\n        this.smallestDim = Math.min(this.width, this.height);\n        this.ratio = this.largestDim/this.smallestDim;\n\n        \n        this.mouseMoveIncrement = 160/this.largestDim;\n\n        // reinitialize 2D context\n        this.imageCtx = this.imageCanvas.getContext(\"webgl2\");\n        this.aladin.webglAPI.resize(this.width, this.height);\n        \n        this.catalogCtx = this.catalogCanvas.getContext(\"2d\");\n        this.reticleCtx = this.reticleCanvas.getContext(\"2d\");\n        this.gridCtx = this.gridCanvas.getContext(\"2d\");\n\n        this.imageCtx.canvas.width = this.width;\n        this.catalogCtx.canvas.width = this.width;\n        this.reticleCtx.canvas.width = this.width;\n        this.gridCtx.canvas.width = this.width;\n        \n        this.imageCtx.canvas.height = this.height;\n        this.catalogCtx.canvas.height = this.height;\n        this.reticleCtx.canvas.height = this.height;\n        this.gridCtx.canvas.height = this.height;\n\n        pixelateCanvasContext(this.imageCtx, this.aladin.options.pixelateCanvas);\n\n        // change logo\n        if (!this.logoDiv) {\n            this.logoDiv = $(this.aladinDiv).find('.aladin-logo')[0];\n        }\n        if (this.width>800) {\n            $(this.logoDiv).removeClass('aladin-logo-small');\n            $(this.logoDiv).addClass('aladin-logo-large');\n            $(this.logoDiv).css('width', '90px');\n        }\n        else {\n            $(this.logoDiv).addClass('aladin-logo-small');\n            $(this.logoDiv).removeClass('aladin-logo-large');\n            $(this.logoDiv).css('width', '32px');\n        }\n\n        \n        this.computeNorder();\n        //this.requestRedraw();\n    };\n\n    var pixelateCanvasContext = function(ctx, pixelateFlag) {\n        var enableSmoothing = ! pixelateFlag;\n        ctx.imageSmoothingEnabled = enableSmoothing;\n        ctx.webkitImageSmoothingEnabled = enableSmoothing;\n        ctx.mozImageSmoothingEnabled = enableSmoothing;\n        ctx.msImageSmoothingEnabled = enableSmoothing;\n        ctx.oImageSmoothingEnabled = enableSmoothing;\n    }\n    \n\n    View.prototype.setMode = function(mode) {\n        this.mode = mode;\n        if (this.mode==View.SELECT) {\n            this.setCursor('crosshair');\n        }\n        else if (this.mode==View.TOOL_SIMBAD_POINTER) {\n            this.popup.hide();\n            this.reticleCanvas.style.cursor = '';\n            $(this.reticleCanvas).addClass('aladin-sp-cursor');\n        }\n        else {\n            this.setCursor('default');\n        }\n    };\n    \n    View.prototype.setCursor = function(cursor) {\n        if (this.reticleCanvas.style.cursor==cursor) {\n            return;\n        }\n        if (this.mode==View.TOOL_SIMBAD_POINTER) {\n            return;\n        }\n        this.reticleCanvas.style.cursor = cursor;\n    };\n\n    \n    \n    /**\n     * return dataURL string corresponding to the current view\n     */\n    View.prototype.getCanvasDataURL = function(imgType, width, height) {\n        imgType = imgType || \"image/png\"; \n        var c = document.createElement('canvas');\n        width = width ||this.width;\n        height = height ||this.height;\n        c.width = width;\n        c.height = height;\n        var ctx = c.getContext('2d');\n        ctx.drawImage(this.imageCanvas, 0, 0, c.width, c.height);\n        ctx.drawImage(this.catalogCanvas, 0, 0, c.width, c.height);\n        ctx.drawImage(this.reticleCanvas, 0, 0, c.width, c.height);\n        ctx.drawImage(this.gridCanvas, 0, 0, c.width, c.height);\n\n        return c.toDataURL(imgType);\n        //return c.toDataURL(\"image/jpeg\", 0.01); // setting quality only works for JPEG (?)\n    };\n\n\n    /**\n     * Compute the FoV in degrees of the view and update mouseMoveIncrement\n     * \n     * @param view\n     * @returns FoV (array of 2 elements : width and height) in degrees\n     */\n/*   function computeFov(view) {\n        var fov = doComputeFov(view, view.zoomFactor);\n        \n        \n        view.mouseMoveIncrement = fov/view.imageCanvas.width;\n            \n        return fov;\n    }\n\n    function doComputeFov(view, zoomFactor) {\n        // if zoom factor < 1, we view 180\n        var fov;\n        if (view.zoomFactor<1) {\n            fov = 180.0;\n            //fov = 360;\n        }\n        else {\n            // TODO : fov sur les 2 dimensions !!\n            // to compute FoV, we first retrieve 2 points at coordinates (0, view.cy) and (width-1, view.cy)\n            var xy1 = AladinUtils.viewToXy(0, view.cy, view.width, view.height, view.largestDim, zoomFactor);\n            var lonlat1 = view.projection.unproject(xy1.x, xy1.y);\n            \n            var xy2 = AladinUtils.viewToXy(view.imageCanvas.width-1, view.cy, view.width, view.height, view.largestDim, zoomFactor);\n            var lonlat2 = view.projection.unproject(xy2.x, xy2.y);\n            \n            \n            fov = new Coo(lonlat1.ra, lonlat1.dec).distance(new Coo(lonlat2.ra, lonlat2.dec));\n        }\n\n        fov = Math.min(180.0, fov);\n        \n        return fov;\n    }\n    */\n    function updateFovDiv(view) {\n        if (isNaN(view.fov)) {\n            view.fovDiv.html(\"FoV:\");\n            return;\n        }\n        // update FoV value\n        var fovStr;\n        if (view.fov>1) {\n            fovStr = Math.round(view.fov*100)/100 + \"\";\n        }\n        else if (view.fov*60>1) {\n            fovStr = Math.round(view.fov*60*100)/100 + \"'\";\n        }\n        else {\n            fovStr = Math.round(view.fov*3600*100)/100 + '\"';\n        }\n        view.fovDiv.html(\"FoV: \" + fovStr);\n    }\n    \n    \n    var createListeners = function(view) {\n        var hasTouchEvents = false;\n        if ('ontouchstart' in window) {\n            hasTouchEvents = true;\n        }\n        \n        // various listeners\n        let onDblClick = function(e) {\n            var xymouse = view.imageCanvas.relMouseCoords(e);\n\n            //var xy = AladinUtils.viewToXy(xymouse.x, xymouse.y, view.width, view.height, view.largestDim, view.zoomFactor);\n            try {\n                var lonlat = view.aladin.webglAPI.screenToWorld(xymouse.x, xymouse.y);\n            }\n            catch(err) {\n                return;\n            }\n            var radec;\n            /*if (view.aladin.webglAPI.cooSystem() === Aladin.wasmLibs.webgl.GALCooSys()) {\n                radec = view.aladin.webglAPI.Gal2J2000(lonlat[0], lonlat[1]);\n            } else {*/\n                radec = lonlat;\n            //}\n            //var radec = view.aladin.webglAPI.;\n            // convert to J2000 if needed\n            /*if (view.cooFrame.system==CooFrameEnum.SYSTEMS.GAL) {\n                radec = CooConversion.GalacticToJ2000([lonlat.ra, lonlat.dec]);\n            }\n            else {\n                radec = lonlat;\n            }*/\n\n            view.pointTo(radec[0], radec[1], {forceAnimation: true});\n        };\n        if (! hasTouchEvents) {\n            $(view.reticleCanvas).dblclick(onDblClick);\n        }\n        \n        \n        $(view.reticleCanvas).bind(\"mousedown touchstart\", function(e) {\n            // zoom pinching\n            if (e.type==='touchstart' && e.originalEvent && e.originalEvent.targetTouches && e.originalEvent.targetTouches.length==2) {\n                view.dragging = false;\n\n                view.pinchZoomParameters.isPinching = true;\n                //var fov = view.aladin.getFov();\n                //view.pinchZoomParameters.initialFov = Math.max(fov[0], fov[1]);\n                var fov = view.aladin.webglAPI.getFieldOfView();\n                view.pinchZoomParameters.initialFov = fov;\n                view.pinchZoomParameters.initialDistance = Math.sqrt(Math.pow(e.originalEvent.targetTouches[0].clientX - e.originalEvent.targetTouches[1].clientX, 2) + Math.pow(e.originalEvent.targetTouches[0].clientY - e.originalEvent.targetTouches[1].clientY, 2));\n\n                return;\n            }\n\n            var xymouse = view.imageCanvas.relMouseCoords(e);\n            if (e.originalEvent && e.originalEvent.targetTouches) {\n                view.dragx = e.originalEvent.targetTouches[0].clientX;\n                view.dragy = e.originalEvent.targetTouches[0].clientY;\n            }\n            else {\n                /*\n                view.dragx = e.clientX;\n                view.dragy = e.clientY;\n                */\n                view.dragx = xymouse.x;\n                view.dragy = xymouse.y;\n            }\n\n\n            view.dragging = true;\n            if (view.mode==View.PAN) {\n                view.setCursor('move');\n            }\n            else if (view.mode==View.SELECT) {\n                view.selectStartCoo = {x: view.dragx, y: view.dragy};\n            }\n            view.aladin.webglAPI.pressLeftMouseButton();\n            return false; // to disable text selection\n        });\n\n        //$(view.reticleCanvas).bind(\"mouseup mouseout touchend\", function(e) {\n        $(view.reticleCanvas).bind(\"click mouseout touchend\", function(e) { // reacting on 'click' rather on 'mouseup' is more reliable when panning the view\n            if (e.type==='touchend' && view.pinchZoomParameters.isPinching) {\n                view.pinchZoomParameters.isPinching = false;\n                view.pinchZoomParameters.initialFov = view.pinchZoomParameters.initialDistance = undefined;\n    \n                return;\n            }\n\n\n            var wasDragging = view.realDragging === true;\n            var selectionHasEnded = view.mode===View.SELECT && view.dragging;\n\n            if (view.dragging) { // if we were dragging, reset to default cursor\n                view.setCursor('default');\n                view.dragging = false;\n\n                if (wasDragging) {\n                    view.realDragging = false;\n                \n                    // call positionChanged one last time after dragging, with dragging: false\n                    var posChangedFn = view.aladin.callbacksByEventName['positionChanged'];\n                    if (typeof posChangedFn === 'function') {\n                        var pos = view.aladin.pix2world(view.width/2, view.height/2);\n                        if (pos !== undefined) {\n                            posChangedFn({ra: pos[0], dec: pos[1], dragging: false});\n                        }\n                    }\n                }\n            } // end of \"if (view.dragging) ... \"\n\n            if (selectionHasEnded) {\n                view.aladin.fire('selectend', \n                                 view.getObjectsInBBox(view.selectStartCoo.x, view.selectStartCoo.y,\n                                                       view.dragx-view.selectStartCoo.x, view.dragy-view.selectStartCoo.y));    \n\n                view.mustRedrawReticle = true; // pour effacer selection bounding box\n                view.requestRedraw();\n\n                return;\n            }\n\n\n\n            view.mustClearCatalog = true;\n            view.mustRedrawReticle = true; // pour effacer selection bounding box\n            view.dragx = view.dragy = null;\n\n\n\n            if (e.type===\"mouseout\" || e.type===\"touchend\") {\n                view.requestRedraw(true);\n                updateLocation(view, view.width/2, view.height/2, true);\n\n\n                if (e.type===\"mouseout\") {\n                    if (view.mode===View.TOOL_SIMBAD_POINTER) {\n                        view.setMode(View.PAN);\n                    }\n\n                    return;\n                }\n            }\n\n            var xymouse = view.imageCanvas.relMouseCoords(e);\n\n            if (view.mode==View.TOOL_SIMBAD_POINTER) {\n                var radec = view.aladin.pix2world(xymouse.x, xymouse.y);\n\n                view.setMode(View.PAN);\n                view.setCursor('wait');\n\n                SimbadPointer.query(radec[0], radec[1], Math.min(1, 15 * view.fov / view.largestDim), view.aladin);\n\n                return; // when in TOOL_SIMBAD_POINTER mode, we do not call the listeners\n            }\n\n            // popup to show ?\n            var objs = view.closestObjects(xymouse.x, xymouse.y, 5);\n            if (! wasDragging && objs) {\n                var o = objs[0];\n\n                // footprint selection code adapted from Fabrizio Giordano dev. from Serco for ESA/ESDC\n                if (o instanceof Footprint || o instanceof Circle) {\n                    o.dispatchClickEvent();\n                }\n\n                // display marker\n                else if (o.marker) {\n                    // could be factorized in Source.actionClicked\n                    view.popup.setTitle(o.popupTitle);\n                    view.popup.setText(o.popupDesc);\n                    view.popup.setSource(o);\n                    view.popup.show();\n                }\n                // show measurements\n                else {\n                    if (view.lastClickedObject) {\n                        view.lastClickedObject.actionOtherObjectClicked && view.lastClickedObject.actionOtherObjectClicked();\n                    }\n                    o.actionClicked();\n                }\n                view.lastClickedObject = o;\n                var objClickedFunction = view.aladin.callbacksByEventName['objectClicked'];\n                (typeof objClickedFunction === 'function') && objClickedFunction(o);\n            }\n            else {\n                if (view.lastClickedObject && ! wasDragging) {\n                    view.aladin.measurementTable.hide();\n                    view.popup.hide();\n\n                    if (view.lastClickedObject instanceof Footprint) {\n                        //view.lastClickedObject.deselect();\n                    }\n                    else {\n                        view.lastClickedObject.actionOtherObjectClicked();\n                    }\n\n                    view.lastClickedObject = null;\n                    var objClickedFunction = view.aladin.callbacksByEventName['objectClicked'];\n                    (typeof objClickedFunction === 'function') && objClickedFunction(null);\n                }\n            }\n\n            // call listener of 'click' event\n            var onClickFunction = view.aladin.callbacksByEventName['click'];\n            if (typeof onClickFunction === 'function') {\n                var pos = view.aladin.pix2world(xymouse.x, xymouse.y);\n                if (pos !== undefined) {\n                    onClickFunction({ra: pos[0], dec: pos[1], x: xymouse.x, y: xymouse.y, isDragging: wasDragging});\n                }\n            }\n\n\n            // TODO : remplacer par mecanisme de listeners\n            // on avertit les catalogues progressifs\n            view.refreshProgressiveCats();\n\n            view.requestRedraw(true);\n            view.aladin.webglAPI.releaseLeftButtonMouse();\n        });\n        var lastHoveredObject; // save last object hovered by mouse\n        var lastMouseMovePos = null;\n        let webglAPI = view.aladin.webglAPI;\n        $(view.reticleCanvas).bind(\"mousemove touchmove\", function(e) {\n            e.preventDefault();\n\n            if (e.type==='touchmove' && view.pinchZoomParameters.isPinching && e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length==2) {\n                var dist = Math.sqrt(Math.pow(e.originalEvent.touches[0].clientX - e.originalEvent.touches[1].clientX, 2) + Math.pow(e.originalEvent.touches[0].clientY - e.originalEvent.touches[1].clientY, 2));\n                view.setZoom(view.pinchZoomParameters.initialFov * view.pinchZoomParameters.initialDistance / dist);\n\n                return;\n            }\n\n            var xymouse = view.imageCanvas.relMouseCoords(e);\n            if (!view.dragging || hasTouchEvents) {\n                // update location box\n                updateLocation(view, xymouse.x, xymouse.y);\n                // call listener of 'mouseMove' event\n                var onMouseMoveFunction = view.aladin.callbacksByEventName['mouseMove'];\n                if (typeof onMouseMoveFunction === 'function') {\n                    var pos = view.aladin.pix2world(xymouse.x, xymouse.y);\n                    if (pos !== undefined) {\n                        onMouseMoveFunction({ra: pos[0], dec: pos[1], x: xymouse.x, y: xymouse.y});\n                    }\n                    // send null ra and dec when we go out of the \"sky\"\n                    else if (lastMouseMovePos != null) {\n                        onMouseMoveFunction({ra: null, dec: null, x: xymouse.x, y: xymouse.y});\n                    }\n                    lastMouseMovePos = pos;\n                }\n\n\n                if (!view.dragging && ! view.mode==View.SELECT) {\n                    // objects under the mouse ?\n                    var closest = view.closestObjects(xymouse.x, xymouse.y, 5);\n                    if (closest) {\n                        view.setCursor('pointer');\n                        var objHoveredFunction = view.aladin.callbacksByEventName['objectHovered'];\n                        if (typeof objHoveredFunction === 'function' && closest[0]!=lastHoveredObject) {\n                            var ret = objHoveredFunction(closest[0]);\n                        }\n                        lastHoveredObject = closest[0];\n        \n                    }\n                    else {\n                        view.setCursor('default');\n                        var objHoveredFunction = view.aladin.callbacksByEventName['objectHovered'];\n                        if (typeof objHoveredFunction === 'function' && lastHoveredObject) {\n                            lastHoveredObject = null;\n                            // call callback function to notify we left the hovered object\n                            var ret = objHoveredFunction(null);\n                        }\n                    }\n                }\n                if (!hasTouchEvents) {\n                    return;\n                }\n            }\n\n            if (! view.dragging) {\n                return;\n            }\n\n            //var xoffset, yoffset;\n            var s1, s2;\n            if (e.originalEvent && e.originalEvent.targetTouches) {\n                /*xoffset = e.originalEvent.targetTouches[0].clientX-view.dragx;\n                yoffset = e.originalEvent.targetTouches[0].clientY-view.dragy;\n                var xy1 = AladinUtils.viewToXy(e.originalEvent.targetTouches[0].clientX, e.originalEvent.targetTouches[0].clientY, view.width, view.height, view.largestDim, view.zoomFactor);\n                var xy2 = AladinUtils.viewToXy(view.dragx, view.dragy, view.width, view.height, view.largestDim, view.zoomFactor);\n\n                pos1 = view.projection.unproject(xy1.x, xy1.y);\n                pos2 = view.projection.unproject(xy2.x, xy2.y);*/\n                s1 = {x: view.dragx, y: view.dragy};\n                s2 = {x: e.originalEvent.targetTouches[0].clientX, y: e.originalEvent.targetTouches[0].clientY};\n            }\n            else {\n                /*\n                xoffset = e.clientX-view.dragx;\n                yoffset = e.clientY-view.dragy;\n\n                xoffset = xymouse.x-view.dragx;\n                yoffset = xymouse.y-view.dragy;\n                var xy1 = AladinUtils.viewToXy(xymouse.x, xymouse.y, view.width, view.height, view.largestDim, view.zoomFactor);\n                var xy2 = AladinUtils.viewToXy(view.dragx, view.dragy, view.width, view.height, view.largestDim, view.zoomFactor);\n                */\n                //pos1 = view.projection.unproject(xy1.x, xy1.y);\n                //pos2 = view.projection.unproject(xy2.x, xy2.y);\n                //console.log(view.dragx, view.dragy)\n                //console.log(xymouse)\n\n                /*pos1 = webglAPI.screenToWorld(view.dragx, view.dragy);\n                pos2 = webglAPI.screenToWorld(xymouse.x, xymouse.y);\n\n                if (pos2 == undefined)  {\n                    return;\n                }*/\n                s1 = {x: view.dragx, y: view.dragy};\n                s2 = {x: xymouse.x, y: xymouse.y};\n            }\n            \n            // TODO : faut il faire ce test ??\n//            var distSquared = xoffset*xoffset+yoffset*yoffset;\n//            if (distSquared<3) {\n//                return;\n//            }\n            if (e.originalEvent && e.originalEvent.targetTouches) {\n                view.dragx = e.originalEvent.targetTouches[0].clientX;\n                view.dragy = e.originalEvent.targetTouches[0].clientY;\n            }\n            else {\n                view.dragx = xymouse.x;\n                view.dragy = xymouse.y;\n                /*\n                view.dragx = e.clientX;\n                view.dragy = e.clientY;\n                */\n            }\n            \n            if (view.mode==View.SELECT) {\n                  view.requestRedraw();\n                  return;\n            }\n\n            //view.viewCenter.lon += xoffset*view.mouseMoveIncrement/Math.cos(view.viewCenter.lat*Math.PI/180.0);\n            /*\n            view.viewCenter.lon += xoffset*view.mouseMoveIncrement;\n            view.viewCenter.lat += yoffset*view.mouseMoveIncrement;\n            */\n            \n            //view.viewCenter.lon = pos2.ra -  pos1.ra;\n            //view.viewCenter.lat = pos2.dec - pos1.dec;\n            //view.viewCenter.lon = pos2.ra;\n            //view.viewCenter.lon = pos2.ra;\n\n            \n            // can not go beyond poles\n            if (view.viewCenter.lat>90) {\n                view.viewCenter.lat = 90;\n            }\n            else if (view.viewCenter.lat < -90) {\n                view.viewCenter.lat = -90;\n            }\n            \n            // limit lon to [0, 360]\n            if (view.viewCenter.lon < 0) {\n                view.viewCenter.lon = 360 + view.viewCenter.lon;\n            }\n            else if (view.viewCenter.lon > 360) {\n                view.viewCenter.lon = view.viewCenter.lon % 360;\n            }\n            view.realDragging = true;\n\n            //webglAPI.goFromTo(pos1[0], pos1[1], pos2[0], pos2[1]);\n            webglAPI.goFromTo(s1.x, s1.y, s2.x, s2.y);\n            //webglAPI.setCenter(pos2[0], pos2[1]);\n            let viewCenter = webglAPI.getCenter();\n            view.viewCenter.lon = viewCenter[0];\n            view.viewCenter.lat = viewCenter[1];\n\n\n            //console.log(view.viewCenter);\n\n            view.requestRedraw();\n        }); //// endof mousemove ////\n        \n        // disable text selection on IE\n        $(view.aladinDiv).onselectstart = function () { return false; }\n\n        $(view.reticleCanvas).on('wheel', function(event) {\n            event.preventDefault();\n            event.stopPropagation();\n            //var level = view.zoomLevel;\n\n            var delta = event.deltaY;\n            // this seems to happen in context of Jupyter notebook --> we have to invert the direction of scroll\n            // hope this won't trigger some side effects ...\n            if (event.hasOwnProperty('originalEvent')) {\n                delta = -event.originalEvent.deltaY;\n            } \n            /*if (delta>0) {\n                level += 1;\n                //zoom\n            }\n            else {\n                level -= 1;\n                //unzoom\n            }*/\n            // The value of the field of view is determined\n            // inside the backend\n            view.aladin.webglAPI.registerWheelEvent(delta);\n            view.updateZoomState();\n\n            if (! view.debounceProgCatOnZoom) {\n                var self = view;\n                view.debounceProgCatOnZoom = Utils.debounce(function() {self.refreshProgressiveCats();}, 300);\n            }\n            view.debounceProgCatOnZoom();\n            //view.setZoomLevel(level);\n            //view.refreshProgressiveCats();\n            return false;\n        });\n\n    };\n    \n    var init = function(view) {\n        var stats = new Stats();\n        stats.domElement.style.top = '50px';\n        if ($('#aladin-statsDiv').length>0) {\n            $('#aladin-statsDiv')[0].appendChild( stats.domElement );\n        }\n        \n        view.stats = stats;\n\n        createListeners(view);\n\n        view.executeCallbacksThrottled = Utils.throttle(\n            function() {\n                var pos = view.aladin.pix2world(view.width/2, view.height/2);\n                var fov = view.fov;\n                if (pos===undefined || fov===undefined) {\n                    return;\n                }\n\n                var ra = pos[0];\n                var dec = pos[1];\n                // trigger callback only if position has changed !\n                if (ra!==this.ra || dec!==this.dec) {\n                    var posChangedFn = view.aladin.callbacksByEventName['positionChanged'];\n                    (typeof posChangedFn === 'function') && posChangedFn({ra: ra, dec: dec, dragging: true});\n    \n                    // finally, save ra and dec value\n                    this.ra = ra;\n                    this.dec = dec;\n                }\n\n                // trigger callback only if FoV (zoom) has changed !\n                if (fov!==this.old_fov) {\n                    var fovChangedFn = view.aladin.callbacksByEventName['zoomChanged'];\n                    (typeof fovChangedFn === 'function') && fovChangedFn(fov);\n    \n                    // finally, save fov value\n                    this.old_fov = fov;\n                }\n\n            },\n            View.CALLBACKS_THROTTLE_TIME_MS);\n\n\n        view.displayHpxGrid = false;\n        view.displaySurvey = true;\n        view.displayCatalog = false;\n        view.displayReticle = true;\n\n        // initial draw\n        //view.fov = computeFov(view);\n        //updateFovDiv(view);\n        //view.redraw();\n    };\n\n    function updateLocation(view, x, y, isViewCenterPosition) {\n        if (!view.projection) {\n            return;\n        }\n        //var xy = AladinUtils.viewToXy(x, y, view.width, view.height, view.largestDim, view.zoomFactor);\n\n        var lonlat;\n        try {\n            lonlat = view.aladin.webglAPI.screenToWorld(x, y);\n            //lonlat = view.projection.unproject(xy.x, xy.y);\n        } catch(err) {\n        }\n        \n        if (lonlat) {\n            // Convert it to galactic\n            if (view.aladin.webglAPI.cooSystem() === Aladin.wasmLibs.webgl.GALCooSys()) {\n                lonlat = view.aladin.webglAPI.J20002Gal(lonlat[0], lonlat[1]);\n            }\n\n            view.location.update(lonlat[0], lonlat[1], view.cooFrame, isViewCenterPosition);\n        }\n    }\n    \n    View.prototype.requestRedrawAtDate = function(date) {\n        this.dateRequestDraw = date;\n    };\n\n    /**\n     * Return the color of the lowest intensity pixel \n     * in teh current color map of the current background image HiPS\n     */\n    View.prototype.getBackgroundColor = function() {\n        var white = 'rgb(255, 255, 255)';\n        var black = 'rgb(0, 0, 0)';\n\n        if (! this.imageSurvey) {\n            return black;\n        }\n\n        var cm = this.imageSurvey.getColorMap();\n        if (!cm) {\n            return black;\n        }\n        if (cm.mapName == 'native' || cm.mapName == 'grayscale') {\n            return cm.reversed ? white : black;\n        }\n\n        var idx = cm.reversed ? 255 : 0;\n        var r = ColorMap.MAPS[cm.mapName].r[idx];\n        var g = ColorMap.MAPS[cm.mapName].g[idx];\n        var b = ColorMap.MAPS[cm.mapName].b[idx];\n\n        return 'rgb(' + r + ',' + g + ',' + b + ')';\n    };\n\n    View.prototype.getViewParams = function() {\n        var resolution = this.width > this.height ? this.fov / this.width : this.fov / this.height;\n        return {\n            fov: [this.width * resolution, this.height * resolution],   \n            width: this.width,   \n            height: this.height   \n        };\n    };\n\n    /**\n     * redraw the whole view\n     */\n    View.prototype.redraw = function() {\n        var saveNeedRedraw = this.needRedraw;\n        requestAnimFrame(this.redraw.bind(this));\n        var now = Date.now();\n        var dt = now - this.prev;\n\n        this.ready = this.aladin.webglAPI.isReady();\n        if (this.imageSurveysToSet !== null && (this.firstHiPS || this.ready)) {\n            console.log(\"surveyes\", this.imageSurveysToSet)\n            this.aladin.webglAPI.setImageSurveys(this.imageSurveysToSet);\n\n            this.imageSurveysToSet = null;\n            this.firstHiPS = false;\n        }\n\n        this.aladin.webglAPI.update(dt, this.needRedraw);\n        // This is called at each frame\n        // Better way is to give this function\n        // to Rust so that the backend executes it\n        // only when necessary, i.e. during the zoom\n        // animation\n        updateFovDiv(this);\n        // check whether a catalog has been parsed and\n        // is ready to be plot\n        let catReady = this.aladin.webglAPI.isCatalogLoaded();\n        if (catReady) {\n            var callbackFn = this.aladin.callbacksByEventName['catalogReady'];\n            (typeof callbackFn === 'function') && callbackFn();\n        }\n        this.aladin.webglAPI.render(this.needRedraw);\n\n        var imageCtx = this.imageCtx;\n        //////// 1. Draw images ////////\n        /*if (imageCtx.start2D) {\n            imageCtx.start2D();\n        }*/\n        //// clear canvas ////\n        // TODO : do not need to clear if fov small enough ?\n        /*imageCtx.clearRect(0, 0, this.imageCanvas.width, this.imageCanvas.height);\n        ////////////////////////\n    \n        var bkgdColor = this.getBackgroundColor();    \n        // fill with background of the same color than the first color map value (lowest intensity)\n        if (this.projectionMethod==ProjectionEnum.SIN) {\n            if (this.fov>=60) {\n                imageCtx.fillStyle = bkgdColor;\n                imageCtx.beginPath();\n                var maxCxCy = this.cx>this.cy ? this.cx : this.cy;\n                imageCtx.arc(this.cx, this.cy, maxCxCy * this.zoomFactor, 0, 2*Math.PI, true);\n                imageCtx.fill();\n            }\n            // pour eviter les losanges blancs qui apparaissent quand les tuiles sont en attente de chargement\n            else {\n                imageCtx.fillStyle = bkgdColor;\n                imageCtx.fillRect(0, 0, this.imageCanvas.width, this.imageCanvas.height);\n            }\n        }\n        else if (this.projectionMethod==ProjectionEnum.AITOFF) {\n            if (imageCtx.ellipse) {\n                imageCtx.fillStyle = bkgdColor;\n                imageCtx.beginPath();\n                imageCtx.ellipse(this.cx, this.cy, 2.828*this.cx*this.zoomFactor, this.cx*this.zoomFactor*1.414, 0, 0, 2*Math.PI);\n                imageCtx.fill();\n            }\n        }*/\n        /*if (imageCtx.finish2D) {\n            imageCtx.finish2D();\n        }*/\n\n        \n        this.projection.setCenter(this.viewCenter.lon, this.viewCenter.lat);\n        // do we have to redo that every time? Probably not\n        //this.projection.setProjection(this.projectionMethod);\n\n\n        // ************* Draw allsky tiles (low resolution) *****************\n\n        var cornersXYViewMapHighres = null;\n        // Pour traitement des DEFORMATIONS --> TEMPORAIRE, draw deviendra la methode utilisee systematiquement\n\n        /*if (this.imageSurvey && this.imageSurvey.isReady && this.displaySurvey) {\n                if (this.aladin.reduceDeformations==null) {\n                    this.imageSurvey.draw(imageCtx, this, !this.dragging, this.curNorder);\n                }\n\n                else {\n                    this.imageSurvey.draw(imageCtx, this, this.aladin.reduceDeformations, this.curNorder);\n                }\n        }*/\n        /*\n        else {\n            var cornersXYViewMapAllsky = this.getVisibleCells(3);\n            var cornersXYViewMapHighres = null;\n            if (this.curNorder>=3) {\n                if (this.curNorder==3) {\n                    cornersXYViewMapHighres = cornersXYViewMapAllsky;\n                }\n                else {\n                    cornersXYViewMapHighres = this.getVisibleCells(this.curNorder);\n                }\n            }\n\n            // redraw image survey\n            if (this.imageSurvey && this.imageSurvey.isReady && this.displaySurvey) {\n                // TODO : a t on besoin de dessiner le allsky si norder>=3 ?\n                // TODO refactoring : should be a method of HpxImageSurvey\n                this.imageSurvey.redrawAllsky(imageCtx, cornersXYViewMapAllsky, this.fov, this.curNorder);\n                if (this.curNorder>=3) {\n                    this.imageSurvey.redrawHighres(imageCtx, cornersXYViewMapHighres, this.curNorder);\n                }\n            }\n        }\n        */\n        \n\n        // redraw overlay image survey\n        // TODO : does not work if different frames \n        // TODO: use HpxImageSurvey.draw method !!\n        if (this.overlayImageSurvey && this.overlayImageSurvey.isReady) {\n            /*imageCtx.globalAlpha = this.overlayImageSurvey.getAlpha();\n\n            if (this.aladin.reduceDeformations==null) {\n                this.overlayImageSurvey.draw(imageCtx, this, !this.dragging, this.curOverlayNorder);\n            }\n\n            else {\n                this.overlayImageSurvey.draw(imageCtx, this, this.aladin.reduceDeformations, this.curOverlayNorder);\n            }*/\n            /*\n            if (this.fov>50) {\n                this.overlayImageSurvey.redrawAllsky(imageCtx, cornersXYViewMapAllsky, this.fov, this.curOverlayNorder);\n            }\n            if (this.curOverlayNorder>=3) {\n                var norderOverlay = Math.min(this.curOverlayNorder, this.overlayImageSurvey.maxOrder);\n                if ( cornersXYViewMapHighres==null || norderOverlay != this.curNorder ) {\n                    cornersXYViewMapHighres = this.getVisibleCells(norderOverlay);\n                }\n                this.overlayImageSurvey.redrawHighres(imageCtx, cornersXYViewMapHighres, norderOverlay);\n            }\n            */\n\n           //imageCtx.globalAlpha = 1.0;\n\n        }\n        \n        // redraw HEALPix grid\n        if( this.displayHpxGrid) {\n            var cornersXYViewMapAllsky = this.getVisibleCells(3);\n            var cornersXYViewMapHighres = null;\n            if (this.curNorder>=3) {\n                if (this.curNorder==3) {\n                    cornersXYViewMapHighres = cornersXYViewMapAllsky;\n                }\n                else {\n                    cornersXYViewMapHighres = this.getVisibleCells(this.curNorder);\n                }\n            }\n            this.gridCtx.clearRect(0, 0, this.imageCanvas.width, this.imageCanvas.height);\n            if (cornersXYViewMapHighres && this.curNorder>3) {\n                this.healpixGrid.redraw(this.gridCtx, cornersXYViewMapHighres, this.fov, this.curNorder);\n            }\n            else {\n                this.healpixGrid.redraw(this.gridCtx, cornersXYViewMapAllsky, this.fov, 3);\n            }\n        }\n        \n        // redraw coordinates grid\n        /*if (this.showGrid) {\n            if (this.cooGrid==null) {\n                this.cooGrid = new CooGrid();\n            }\n            \n            this.cooGrid.redraw(this.gridCtx, this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor, this.fov);\n        }*/\n         \n\n\n        ///*\n        ////// 2. Draw catalogues////////\n        var catalogCtx = this.catalogCtx;\n\n        var catalogCanvasCleared = false;\n        if (this.mustClearCatalog) {\n            catalogCtx.clearRect(0, 0, this.width, this.height);\n            catalogCanvasCleared = true;\n            this.mustClearCatalog = false;\n        }\n        if (this.catalogs && this.catalogs.length>0 && this.displayCatalog && (! this.dragging  || View.DRAW_SOURCES_WHILE_DRAGGING)) {\n              // TODO : do not clear every time\n            //// clear canvas ////\n            if (! catalogCanvasCleared) {\n                catalogCtx.clearRect(0, 0, this.width, this.height);\n                catalogCanvasCleared = true;\n            }\n            for (var i=0; i<this.catalogs.length; i++) {\n                var cat = this.catalogs[i];\n                //console.log( this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor);\n                cat.draw(catalogCtx, this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor);\n            }\n        }\n        // draw popup catalog\n        if (this.catalogForPopup.isShowing && this.catalogForPopup.sources.length>0) {\n            if (! catalogCanvasCleared) {\n                catalogCtx.clearRect(0, 0, this.width, this.height);\n                catalogCanvasCleared = true;\n            }\n            this.catalogForPopup.draw(catalogCtx, this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor);\n        }\n\n        ////// 3. Draw overlays////////\n        var overlayCtx = this.catalogCtx;\n        if (this.overlays && this.overlays.length>0 && (! this.dragging  || View.DRAW_SOURCES_WHILE_DRAGGING)) {\n            if (! catalogCanvasCleared) {\n                catalogCtx.clearRect(0, 0, this.width, this.height);\n                catalogCanvasCleared = true;\n            }\n            for (var i=0; i<this.overlays.length; i++) {\n                this.overlays[i].draw(overlayCtx, this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor);\n            }\n        }\n        \n\n        // draw MOCs\n        var mocCtx = this.catalogCtx;\n        if (this.mocs && this.mocs.length>0 && (! this.dragging  || View.DRAW_MOCS_WHILE_DRAGGING)) {\n            if (! catalogCanvasCleared) {\n                catalogCtx.clearRect(0, 0, this.width, this.height);\n                catalogCanvasCleared = true;\n            }\n            for (var i=0; i<this.mocs.length; i++) {\n                this.mocs[i].draw(mocCtx, this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor, this.fov);\n            }\n        }\n\n        //*/\n        if (this.mode==View.SELECT) {\n            mustRedrawReticle = true;\n        }\n        \n        ////// 4. Draw reticle ///////\n        // TODO: reticle should be placed in a static DIV, no need to waste a canvas\n        var reticleCtx = this.reticleCtx;\n        if (this.mustRedrawReticle || this.mode==View.SELECT) {\n            reticleCtx.clearRect(0, 0, this.width, this.height);\n        }\n        if (this.displayReticle) {\n            \n            if (! this.reticleCache) {\n                // build reticle image\n                var c = document.createElement('canvas');\n                var s = this.options.reticleSize;\n                c.width = s;\n                c.height = s;\n                var ctx = c.getContext('2d');\n                ctx.lineWidth = 2;\n                ctx.strokeStyle = this.options.reticleColor;\n                ctx.beginPath();\n                ctx.moveTo(s/2, s/2+(s/2-1));\n                ctx.lineTo(s/2, s/2+2);\n                ctx.moveTo(s/2, s/2-(s/2-1));\n                ctx.lineTo(s/2, s/2-2);\n                \n                ctx.moveTo(s/2+(s/2-1), s/2);\n                ctx.lineTo(s/2+2,  s/2);\n                ctx.moveTo(s/2-(s/2-1), s/2);\n                ctx.lineTo(s/2-2,  s/2);\n                \n                ctx.stroke();\n                \n                this.reticleCache = c;\n            }\n                \n            reticleCtx.drawImage(this.reticleCache, this.width/2 - this.reticleCache.width/2, this.height/2 - this.reticleCache.height/2);\n            \n            \n            this.mustRedrawReticle = false;\n        }\n        /*\n        ////// 5. Draw all-sky ring /////\n        if (this.projectionMethod==ProjectionEnum.SIN && this.fov>=60 && this.aladin.options['showAllskyRing'] === true) {\n                    imageCtx.strokeStyle = this.aladin.options['allskyRingColor'];\n                    var ringWidth = this.aladin.options['allskyRingWidth'];\n                    imageCtx.lineWidth = ringWidth;\n                    imageCtx.beginPath();\n                    var maxCxCy = this.cx>this.cy ? this.cx : this.cy;\n                    imageCtx.arc(this.cx, this.cy, (maxCxCy-(ringWidth/2.0)+1) * this.zoomFactor, 0, 2*Math.PI, true);\n                    imageCtx.stroke();\n        }\n\n        \n        // draw selection box\n        if (this.mode==View.SELECT && this.dragging) {\n            reticleCtx.fillStyle = \"rgba(100, 240, 110, 0.25)\";\n            var w = this.dragx - this.selectStartCoo.x;\n            var h =  this.dragy - this.selectStartCoo.y;\n            \n            reticleCtx.fillRect(this.selectStartCoo.x, this.selectStartCoo.y, w, h);\n        }\n        */\n        \n         // TODO : is this the right way?\n         if (saveNeedRedraw==this.needRedraw) {\n             this.needRedraw = false;\n         }\n\n\n        // objects lookup\n        if (!this.dragging) {\n            this.updateObjectsLookup();\n        } \n\n        // execute 'positionChanged' and 'zoomChanged' callbacks\n        //this.executeCallbacksThrottled();\n        this.prev = now;\n\n    };\n\n    /*View.prototype.drawGridLabels = function (text) {\n        //let ctx = this.imageCanvas.getContext(\"webgl2\");\n        //var c = document.getElementById(\"myCanvas\");\n        //var ctx = c.getContext(\"2d\");\n        \n        this.reticleCtx.font = \"30px Verdana\";\n        this.reticleCtx.fillText(text, 200, 50);\n        //ctx.font = \"30px Verdana\";\n    }*/\n\n    View.prototype.forceRedraw = function() {\n        this.flagForceRedraw = true;\n    };\n    \n    View.prototype.refreshProgressiveCats = function() {\n        if (! this.catalogs) {\n            return;\n        }\n\n        for (var i=0; i<this.catalogs.length; i++) {\n            if (this.catalogs[i].type=='progressivecat') {\n                this.catalogs[i].loadNeededTiles();\n            }\n        }\n    };\n\n    View.prototype.getVisiblePixList = function(norder, frameSurvey) {\n        var nside = Math.pow(2, norder);\n\n        var pixList;\n        var npix = HealpixIndex.nside2Npix(nside);\n        if (this.fov>80) {\n            pixList = [];\n            for (var ipix=0; ipix<npix; ipix++) {\n                pixList.push(ipix);\n            }\n        }\n        else {\n            var hpxIdx = new HealpixIndex(nside);\n            hpxIdx.init();\n            var spatialVector = new SpatialVector();\n            // if frame != frame image survey, we need to convert to survey frame system\n            //var xy = AladinUtils.viewToXy(this.cx, this.cy, this.width, this.height, this.largestDim, this.zoomFactor);\n            //var radec = this.projection.unproject(xy.x, xy.y);\n            let pos_world = this.aladin.webglAPI.screenToWorld(this.cx, this.cy);\n            let radec = {\n                ra: pos_world[0],\n                dec: pos_world[1]\n            };\n            var lonlat = [];\n            /*if (frameSurvey && frameSurvey.system != this.cooFrame.system) {\n                if (frameSurvey.system==CooFrameEnum.SYSTEMS.J2000) {\n                    lonlat = CooConversion.GalacticToJ2000([radec.ra, radec.dec]);\n                }\n                else if (frameSurvey.system==CooFrameEnum.SYSTEMS.GAL) {\n                    lonlat = CooConversion.J2000ToGalactic([radec.ra, radec.dec]);\n                }\n            }\n            else {\n                lonlat = [radec.ra, radec.dec];\n            }*/\n            lonlat = [radec.ra, radec.dec];\n            spatialVector.set(lonlat[0], lonlat[1]);\n\n            var radius = this.fov*0.5*this.ratio;\n            // we need to extend the radius\n            if (this.fov>60) {\n                radius *= 1.6;\n            }\n            else if (this.fov>12) {\n                radius *=1.45;\n            }\n            else {\n                radius *= 1.1;\n            }\n\n\n\n            pixList = hpxIdx.queryDisc(spatialVector, radius*Math.PI/180.0, true, true);\n            // add central pixel at index 0\n            var polar = HealpixIndex.utils.radecToPolar(lonlat[0], lonlat[1]);\n            var ipixCenter = hpxIdx.ang2pix_nest(polar.theta, polar.phi);\n            pixList.unshift(ipixCenter);\n\n        }\n\n        return pixList;\n    };\n    \n    View.prototype.setAngleRotation = function(theta) {\n\n    }\n\n    // TODO: optimize this method !!\n    View.prototype.getVisibleCells = function(norder, frameSurvey) {\n        if (! frameSurvey && this.imageSurvey) {\n            frameSurvey = this.imageSurvey.cooFrame;\n        }\n        var cells = []; // array to be returned\n        var cornersXY = [];\n        var spVec = new SpatialVector();\n        var nside = Math.pow(2, norder); // TODO : to be modified\n        var npix = HealpixIndex.nside2Npix(nside);\n        var ipixCenter = null;\n        \n        // build list of pixels\n        // TODO: pixList can be obtained from getVisiblePixList\n        var pixList;\n        if (this.fov>80) {\n            pixList = [];\n            for (var ipix=0; ipix<npix; ipix++) {\n                pixList.push(ipix);\n            }\n        }\n        else {\n            var hpxIdx = new HealpixIndex(nside);\n            hpxIdx.init();\n            var spatialVector = new SpatialVector();\n            // if frame != frame image survey, we need to convert to survey frame system\n            var xy = AladinUtils.viewToXy(this.cx, this.cy, this.width, this.height, this.largestDim, this.zoomFactor);\n            //var radec = this.projection.unproject(xy.x, xy.y);\n            var radec = this.aladin.webglAPI.screenToWorld(this.cx, this.cy);\n            var radec = {\n                ra: radec[0],\n                dec: radec[1],\n            };\n            var lonlat = [];\n            if (frameSurvey && frameSurvey.system != this.cooFrame.system) {\n                if (frameSurvey.system==CooFrameEnum.SYSTEMS.J2000) {\n                    lonlat = CooConversion.GalacticToJ2000([radec.ra, radec.dec]); \n                }\n                else if (frameSurvey.system==CooFrameEnum.SYSTEMS.GAL) {\n                    lonlat = CooConversion.J2000ToGalactic([radec.ra, radec.dec]);\n                }\n            }\n            else {\n                lonlat = [radec.ra, radec.dec];\n            }\n            spatialVector.set(lonlat[0], lonlat[1]);\n\n            var radius = this.fov*0.5*this.ratio;\n            // we need to extend the radius\n            if (this.fov>60) {\n                radius *= 1.6;\n            }\n            else if (this.fov>12) {\n                radius *=1.45;\n            }\n            else {\n                radius *= 1.1;\n            }\n            \n            \n                \n            pixList = hpxIdx.queryDisc(spatialVector, radius*Math.PI/180.0, true, true);\n            // add central pixel at index 0\n            var polar = HealpixIndex.utils.radecToPolar(lonlat[0], lonlat[1]);\n            ipixCenter = hpxIdx.ang2pix_nest(polar.theta, polar.phi);\n            pixList.unshift(ipixCenter);\n        }\n        \n        \n        var ipix;\n        var lon, lat;\n        var corners;\n        for (var ipixIdx=0, len=pixList.length; ipixIdx<len; ipixIdx++) {\n            ipix = pixList[ipixIdx];\n            if (ipix==ipixCenter && ipixIdx>0) { \n                continue;\n            }\n            var cornersXYView = [];\n            corners = HealpixCache.corners_nest(ipix, nside);\n\n            for (var k=0; k<4; k++) {\n                spVec.setXYZ(corners[k].x, corners[k].y, corners[k].z);\n                \n                // need for frame transformation ?\n                if (frameSurvey && frameSurvey.system != this.cooFrame.system) {\n                    if (frameSurvey.system == CooFrameEnum.SYSTEMS.J2000) {\n                        var radec = CooConversion.J2000ToGalactic([spVec.ra(), spVec.dec()]); \n                        lon = radec[0];\n                        lat = radec[1];\n                    }\n                    else if (frameSurvey.system == CooFrameEnum.SYSTEMS.GAL) {\n                        var radec = CooConversion.GalacticToJ2000([spVec.ra(), spVec.dec()]); \n                        lon = radec[0];\n                        lat = radec[1];\n                    }\n                }\n                else {\n                    lon = spVec.ra();\n                    lat = spVec.dec();\n                }\n                \n                //cornersXY[k] = this.projection.project(lon, lat);\n                cornersXY[k] = this.aladin.webglAPI.worldToScreen(lon, lat);\n            }\n\n\n            if (cornersXY[0] == null ||  cornersXY[1] == null  ||  cornersXY[2] == null ||  cornersXY[3] == null ) {\n                continue;\n            }\n\n\n\n            for (var k=0; k<4; k++) {\n                //cornersXYView[k] = AladinUtils.xyToView(cornersXY[k].X, cornersXY[k].Y, this.width, this.height, this.largestDim, this.zoomFactor);\n                cornersXYView[k] = {\n                    vx: cornersXY[k][0],\n                    vy: cornersXY[k][1],\n                };\n            }\n\n            var indulge = 10;\n            // detect pixels outside view. Could be improved !\n            // we minimize here the number of cells returned\n            if( cornersXYView[0].vx<0 && cornersXYView[1].vx<0 && cornersXYView[2].vx<0 &&cornersXYView[3].vx<0) {\n                continue;\n            }\n            if( cornersXYView[0].vy<0 && cornersXYView[1].vy<0 && cornersXYView[2].vy<0 &&cornersXYView[3].vy<0) {\n                continue;\n            }\n            if( cornersXYView[0].vx>=this.width && cornersXYView[1].vx>=this.width && cornersXYView[2].vx>=this.width &&cornersXYView[3].vx>=this.width) {\n                continue;\n            }\n            if( cornersXYView[0].vy>=this.height && cornersXYView[1].vy>=this.height && cornersXYView[2].vy>=this.height &&cornersXYView[3].vy>=this.height) {\n                continue;\n            }\n\n\n            // check if pixel is visible\n//            if (this.fov<160) { // don't bother checking if fov is large enough\n//                if ( ! AladinUtils.isHpxPixVisible(cornersXYView, this.width, this.height) ) {\n//                    continue;\n//                }\n//            }\n            // check if we have a pixel at the edge of the view in allsky projections\n            if (this.projection.PROJECTION!=ProjectionEnum.SIN && this.projection.PROJECTION!=ProjectionEnum.TAN) {\n               /* console.log(this.largestDim);\n                var xdiff = cornersXYView[0].vx-cornersXYView[2].vx;\n                var ydiff = cornersXYView[0].vy-cornersXYView[2].vy;\n                var distDiag = Math.sqrt(xdiff*xdiff + ydiff*ydiff);\n                if (distDiag>this.largestDim/5) {\n                    continue;\n                }\n                xdiff = cornersXYView[1].vx-cornersXYView[3].vx;\n                ydiff = cornersXYView[1].vy-cornersXYView[3].vy;\n                distDiag = Math.sqrt(xdiff*xdiff + ydiff*ydiff);\n                if (distDiag>this.largestDim/5) {\n                    continue;\n                }*/\n\n                // New faster approach: when a vertex from a cell gets to the other side of the projection\n                // its vertices order change from counter-clockwise to clockwise!\n                // So if the vertices describing a cell are given in clockwise order\n                // we know it crosses the projection, so we do not plot them!\n                if (!AladinUtils.counterClockwiseTriangle(cornersXYView[0].vx, cornersXYView[0].vy, cornersXYView[1].vx, cornersXYView[1].vy, cornersXYView[2].vx, cornersXYView[2].vy) ||\n                    !AladinUtils.counterClockwiseTriangle(cornersXYView[0].vx, cornersXYView[0].vy, cornersXYView[2].vx, cornersXYView[2].vy, cornersXYView[3].vx, cornersXYView[3].vy)) {\n                    continue;\n                }\n            }\n            \n            cornersXYView.ipix = ipix;\n            cells.push(cornersXYView);\n        }\n        \n        return cells;\n    };\n\n    // get position in view for a given HEALPix cell\n    View.prototype.getPositionsInView = function(ipix, norder) {\n        var cornersXY = [];\n        var lon, lat;\n        var spVec = new SpatialVector();\n        var nside = Math.pow(2, norder); // TODO : to be modified\n        \n        \n        var cornersXYView = [];  // will be returned\n        var corners = HealpixCache.corners_nest(ipix, nside);\n\n        for (var k=0; k<4; k++) {\n            spVec.setXYZ(corners[k].x, corners[k].y, corners[k].z);\n                \n            // need for frame transformation ?\n            if (this.imageSurvey && this.imageSurvey.cooFrame.system != this.cooFrame.system) {\n                if (this.imageSurvey.cooFrame.system == CooFrameEnum.SYSTEMS.J2000) {\n                    var radec = CooConversion.J2000ToGalactic([spVec.ra(), spVec.dec()]); \n                    lon = radec[0];\n                    lat = radec[1];\n                }\n                else if (this.imageSurvey.cooFrame.system == CooFrameEnum.SYSTEMS.GAL) {\n                    var radec = CooConversion.GalacticToJ2000([spVec.ra(), spVec.dec()]); \n                    lon = radec[0];\n                    lat = radec[1];\n                }\n            }\n            else {\n                lon = spVec.ra();\n                lat = spVec.dec();\n            }\n            //cornersXY[k] = this.projection.project(lon, lat);\n            let xy = this.aladin.webglAPI.worldToScreen(lon, lat);\n            cornersXYView[k] = {\n                vx: xy.x,\n                vy: xy.y\n            };\n        }\n        \n        if (cornersXYView[0] == null ||  cornersXYView[1] == null  ||  cornersXYView[2] == null ||  cornersXYView[3] == null ) {\n            return null;\n        }\n        /*if (cornersXY[0] == null ||  cornersXY[1] == null  ||  cornersXY[2] == null ||  cornersXY[3] == null ) {\n            return null;\n        }*/\n        /*for (var k=0; k<4; k++) {\n            cornersXYView[k] = AladinUtils.xyToView(cornersXY[k].X, cornersXY[k].Y, this.width, this.height, this.largestDim, this.zoomFactor);\n        }*/\n\n        return cornersXYView;\n    };\n    \n    \n    /*View.prototype.computeZoomFactor = function(level) {\n        if (level>0) {\n            return AladinUtils.getZoomFactorForAngle(180.0/Math.pow(1.35, level), this.projectionMethod);\n        }\n        else {\n            return 1 + 0.1*level;\n        }\n    };*/\n    /*View.prototype.computeZoomLevelFromFOV = function() {\n        if (level>0) {\n            return AladinUtils.getZoomFactorForAngle(180/Math.pow(1.15, level), this.projectionMethod);\n        }\n        else {\n            return 1 + 0.1*level;\n        }\n    };*/\n    \n    // Called for touchmove events\n    View.prototype.setZoom = function(fovDegrees) {\n        if (fovDegrees<0) {\n            return;\n        }\n        // Erase the field of view state of the backend by\n        this.aladin.webglAPI.setFieldOfView(fovDegrees);\n        //var zoomLevel = Math.log(180/fovDegrees)/Math.log(1.15);\n        //this.setZoomLevel(zoomLevel);\n        this.updateZoomState();\n    };\n\n    View.prototype.increaseZoom = function() {\n        for (let i = 0; i < 5; i++) {\n            this.aladin.webglAPI.registerWheelEvent(0.01);\n        }\n    }\n    View.prototype.decreaseZoom = function() {\n        for (let i = 0; i < 5; i++) {\n            this.aladin.webglAPI.registerWheelEvent(-0.01);\n        }\n    }\n    View.prototype.setShowGrid = function(showGrid) {\n        this.showGrid = showGrid;\n        if (showGrid) {\n            this.aladin.webglAPI.enableGrid();\n        } else {\n            this.aladin.webglAPI.disableGrid();\n        }\n        this.requestRedraw();\n    };\n\n    //View.prototype.setZoom = function(level) {\n    View.prototype.updateZoomState = function() {\n        /*let zoom = {\"action\": undefined};\n\n        if (this.zoomLevel > level) {\n            console.log(\"unzoom\")\n            zoom[\"action\"] = \"unzoom\";\n        } else if (this.zoomLevel < level) {\n            zoom[\"action\"] = \"zoom\";\n        }*/\n\n        /*if (this.minFOV || this.maxFOV) {\n            var newFov = doComputeFov(this, this.computeZoomFactor(Math.max(-2, level)));\n            if (this.maxFOV && newFov>this.maxFOV  ||  this.minFOV && newFov<this.minFOV)  {\n                return;\n            }\n        }*/\n\n        /*if (this.projectionMethod==ProjectionEnum.SIN) {\n            //this.zoomLevel = Math.max(-2, level); // TODO : canvas freezes in firefox when max level is small\n            this.zoomLevel = Math.max(-7, level); // TODO : canvas freezes in firefox when max level is small\n        } else {\n            this.zoomLevel = Math.max(-7, level); // TODO : canvas freezes in firefox when max level is small\n        }*/\n        //this.zoomLevel = Math.max(-7, level);\n        \n        /// Old\n        /*this.zoomFactor = this.computeZoomFactor(this.zoomLevel);\n        this.fov = computeFov(this);\n\n        if (this.zoomFactor >= 1.0) {\n            this.aladin.webglAPI.setFieldOfView(this.fov);\n        } else {\n            //console.log(\"FOV, \", this.fov / this.zoomFactor);\n\n            // zoom factor\n            this.aladin.webglAPI.setFieldOfView(this.fov / this.zoomFactor);\n        }*/\n        this.zoomFactor = this.aladin.webglAPI.getClipZoomFactor();\n        this.fov = this.aladin.webglAPI.getFieldOfView();\n\n        // TODO: event/listener should be better\n        //updateFovDiv(this);\n        \n        this.computeNorder();\n        \n        this.forceRedraw();\n        //this.requestRedraw();\n        // on avertit les catalogues progressifs\n\n    };\n    \n    /**\n     * compute and set the norder corresponding to the current view resolution\n     */\n    View.prototype.computeNorder = function() {\n        var resolution = this.fov / this.largestDim; // in degree/pixel\n        var tileSize = 512; // TODO : read info from HpxImageSurvey.tileSize\n        var nside = HealpixIndex.calculateNSide(3600*tileSize*resolution); // 512 = size of a \"tile\" image\n        var norder = Math.log(nside)/Math.log(2);\n        norder = Math.max(norder, 1);\n        this.realNorder = norder;\n\n            \n        // here, we force norder to 3 (otherwise, the display is \"blurry\" for too long when zooming in)\n        if (this.fov<=50 && norder<=2) {\n            norder = 3;\n        }\n           \n\n        // that happens if we do not wish to display tiles coming from Allsky.[jpg|png]\n        if (this.imageSurvey && norder<=2 && this.imageSurvey.minOrder>2) {\n            norder = this.imageSurvey.minOrder;\n        }\n\n        var overlayNorder  = norder;\n        if (this.imageSurvey && norder>this.imageSurvey.maxOrder) {\n            norder = this.imageSurvey.maxOrder;\n        }\n        if (this.overlayImageSurvey && overlayNorder>this.overlayImageSurvey.maxOrder) {\n            overlayNorder = this.overlayImageSurvey.maxOrder;\n        }\n        // should never happen, as calculateNSide will return something <=HealpixIndex.ORDER_MAX\n        if (norder>HealpixIndex.ORDER_MAX) {\n            norder = HealpixIndex.ORDER_MAX;\n        }\n        if (overlayNorder>HealpixIndex.ORDER_MAX) {\n            overlayNorder = HealpixIndex.ORDER_MAX;\n        }\n            \n        this.curNorder = norder;\n        this.curOverlayNorder = overlayNorder;\n    };\n    \n    View.prototype.untaintCanvases = function() {\n        this.createCanvases();\n        createListeners(this);\n        this.fixLayoutDimensions();\n    };\n    \n    View.prototype.setOverlayImageSurvey = async function(idOrUrl) {\n        /*if (! overlayImageSurvey) {\n            this.overlayImageSurvey = null;\n            this.requestRedraw();\n            return;\n        }\n        \n        // reset canvas to \"untaint\" canvas if needed\n        // we test if the previous base image layer was using CORS or not\n        if ($.support.cors && this.overlayImageSurvey && ! this.overlayImageSurvey.useCors) {\n            this.untaintCanvases();\n        }\n        \n        var newOverlayImageSurvey;\n        if (typeof overlayImageSurvey == \"string\") {\n            newOverlayImageSurvey = HpxImageSurvey.getSurveyFromId(overlayImageSurvey);\n            if ( ! newOverlayImageSurvey) {\n                newOverlayImageSurvey = HpxImageSurvey.getSurveyFromId(HpxImageSurvey.DEFAULT_SURVEY_ID);\n            }\n        }\n        else {\n            newOverlayImageSurvey = overlayImageSurvey;\n        }\n        newOverlayImageSurvey.isReady = false;\n        this.overlayImageSurvey = newOverlayImageSurvey;\n        \n        var self = this;\n        newOverlayImageSurvey.init(this, function() {\n            //self.imageSurvey = newImageSurvey;\n            self.computeNorder();\n            newOverlayImageSurvey.isReady = true;\n            self.requestRedraw();\n            self.updateObjectsLookup();\n            \n            if (callback) {\n                callback();\n            }\n        });*/\n        if (!idOrUrl) {\n            return;\n        }\n\n        let overlaySurvey = await new HpxImageSurvey(idOrUrl);\n        this.aladin.webglAPI.setOverlayHiPS(overlaySurvey);\n    };\n\n    View.prototype.setUnknownSurveyIfNeeded = function() {\n        if (unknownSurveyId) {\n            this.setImageSurvey(unknownSurveyId);\n            unknownSurveyId = undefined;\n        }\n    }\n\n    /*View.prototype.addImageSurveyLayer = function(layer) {\n        if (!(layer instanceof ImageSurveyLayer)) {\n            throw \"Except an ImageSurveyLayer object\";\n        }\n\n        let surveys = [];\n        for (let survey of layer.getSurveys()) {\n            surveys.push(survey);\n        }\n        console.log(\"set layer: \", layer);\n        this.aladin.webglAPI.addImageSurveyLayer(layer.name, surveys);\n    };*/\n\n    var unknownSurveyId = undefined;\n    // @param imageSurvey : HpxImageSurvey object or image survey identifier\n    View.prototype.addImageSurvey = function(survey, layer) {\n        // We wait for the HpxImageSurvey to complete\n        // Register to the view\n        const url = survey.properties.url;\n        survey.layer = layer;\n\n        this.imageSurveys.get(layer).set(url, survey);\n        // Then we send the current surveys to the backend\n        this.setHiPS();\n    };\n\n    View.prototype.setImageSurvey = function(survey, layer) {\n        const url = survey.properties.url;\n        survey.layer = layer;\n        \n        this.imageSurveys.set(layer, new Map());\n        this.imageSurveys.get(layer).set(url, survey);\n        // Then we send the current surveys to the backend\n        this.setHiPS();\n    };\n\n    View.prototype.setImageSurveysLayer = function(surveys, layer) {\n        this.imageSurveys.set(layer, new Map());\n\n        surveys.forEach(survey => {\n            const url = survey.properties.url;\n            survey.layer = layer;\n            \n            this.imageSurveys.get(layer).set(url, survey);\n        });\n\n        // Then we send the current surveys to the backend\n        this.setHiPS();\n    };\n\n    View.prototype.removeImageSurveysLayer = function (layer) {\n        this.imageSurveys.delete(layer);\n\n        this.setHiPS();\n    };\n\n    View.prototype.moveImageSurveysLayerForward = function(layer) {\n        this.aladin.webglAPI.moveImageSurveysLayerForward(layer);\n    }\n\n    View.prototype.setHiPS = function() {\n        let surveys = [];\n        for (let layer of this.imageSurveys.values()) {\n            for (let survey of layer.values()) {\n                surveys.push(survey);\n            }\n        }\n\n        this.imageSurveysToSet = surveys;\n\n        //this.aladin.webglAPI.setImageSurveys(surveys);\n    };\n\n    View.prototype.requestRedraw = function() {\n        this.needRedraw = true;\n    };\n    \n    View.prototype.changeProjection = function(projectionName) {\n        switch (projectionName) {\n            case \"aitoff\":\n                this.projectionMethod = ProjectionEnum.AITOFF;\n                break;\n            case \"tan\":\n                this.projectionMethod = ProjectionEnum.TAN;\n                break;\n            case \"arc\":\n                this.projectionMethod = ProjectionEnum.ARC;\n                break;\n            case \"mercator\":\n                this.projectionMethod = ProjectionEnum.MERCATOR;\n                break;\n            case \"mollweide\":\n                this.projectionMethod = ProjectionEnum.MOL;\n                break;\n            case \"sinus\":\n            default:\n                this.projectionMethod = ProjectionEnum.SIN;\n        }\n        // Change the projection here\n        this.projection.setProjection(this.projectionMethod);\n        this.aladin.webglAPI.setProjection(projectionName);\n\n        this.requestRedraw();\n    };\n\n    View.prototype.changeFrame = function(cooFrame) {\n        var oldCooFrame = this.cooFrame;\n        this.cooFrame = cooFrame;\n        // recompute viewCenter\n        console.log(\"change frame\")\n        if (this.cooFrame.system == CooFrameEnum.SYSTEMS.GAL && this.cooFrame.system != oldCooFrame.system) {\n            var lb = CooConversion.J2000ToGalactic([this.viewCenter.lon, this.viewCenter.lat]);\n            this.viewCenter.lon = lb[0];\n            this.viewCenter.lat = lb[1]; \n\n            const GAL = Aladin.wasmLibs.webgl.GALCooSys();\n            this.aladin.webglAPI.setCooSystem(GAL);\n        }\n        else if (this.cooFrame.system == CooFrameEnum.SYSTEMS.J2000 && this.cooFrame.system != oldCooFrame.system) {\n            var radec = CooConversion.GalacticToJ2000([this.viewCenter.lon, this.viewCenter.lat]);\n            this.viewCenter.lon = radec[0];\n            this.viewCenter.lat = radec[1];\n\n            const ICRSJ2000 = Aladin.wasmLibs.webgl.ICRSJ2000CooSys();\n            this.aladin.webglAPI.setCooSystem(ICRSJ2000);\n        }\n\n        this.location.update(this.viewCenter.lon, this.viewCenter.lat, this.cooFrame, true);\n\n        this.requestRedraw();\n    };\n\n    View.prototype.showHealpixGrid = function(show) {\n        // Clear the grid ctx when not showing it\n        if (!show) {\n            this.gridCtx.clearRect(0, 0, this.imageCanvas.width, this.imageCanvas.height);\n        }\n        this.displayHpxGrid = show;\n        this.requestRedraw();\n    };\n    \n    View.prototype.showSurvey = function(show) {\n        this.displaySurvey = show;\n\n        this.requestRedraw();\n    };\n    \n    View.prototype.showCatalog = function(show) {\n        this.displayCatalog = show;\n\n        if (!this.displayCatalog) {\n            this.mustClearCatalog = true;\n        }\n        this.requestRedraw();\n    };\n    \n    View.prototype.showReticle = function(show) {\n        this.displayReticle = show;\n\n        this.mustRedrawReticle = true;\n        this.requestRedraw();\n    };\n\n    View.prototype.pointTo = function(ra, dec, options) {\n        options = options || {};\n        ra = parseFloat(ra);\n        dec = parseFloat(dec);\n\n        if (isNaN(ra) || isNaN(dec)) {\n            return;\n        }\n        //if (this.cooFrame.system==CooFrameEnum.SYSTEMS.J2000) {\n            this.viewCenter.lon = ra;\n            this.viewCenter.lat = dec;\n        //}\n        /*else if (this.cooFrame.system==CooFrameEnum.SYSTEMS.GAL) {\n            var lb = CooConversion.J2000ToGalactic([ra, dec]);\n            this.viewCenter.lon = lb[0];\n            this.viewCenter.lat = lb[1];\n        }*/\n        this.location.update(this.viewCenter.lon, this.viewCenter.lat, this.cooFrame, true);\n\n        if (options && options.forceAnimation === false) {\n            this.aladin.webglAPI.setCenter(this.viewCenter.lon, this.viewCenter.lat);\n        } else if (options && options.forceAnimation === true) {\n            this.aladin.webglAPI.moveToLocation(this.viewCenter.lon, this.viewCenter.lat)\n        } else {\n            if (this.fov > 30.0) {\n                this.aladin.webglAPI.moveToLocation(this.viewCenter.lon, this.viewCenter.lat);\n            } else {\n                this.aladin.webglAPI.setCenter(this.viewCenter.lon, this.viewCenter.lat);\n            }\n        }\n        \n        this.forceRedraw();\n        this.requestRedraw();\n\n        var self = this;\n        setTimeout(function() {self.refreshProgressiveCats();}, 1000);\n    };\n    View.prototype.makeUniqLayerName = function(name) {\n        if (! this.layerNameExists(name)) {\n            return name;\n        }\n        for (var k=1;;++k) {\n            var newName = name + '_' + k;\n            if ( ! this.layerNameExists(newName)) {\n                return newName;\n            }\n        }\n    };\n    View.prototype.layerNameExists = function(name) {\n        var c = this.allOverlayLayers;\n        for (var k=0; k<c.length; k++) {\n            if (name==c[k].name) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    View.prototype.removeLayers = function() {\n        this.catalogs = [];\n        this.overlays = [];\n        this.mocs = [];\n        this.allOverlayLayers = [];\n        this.requestRedraw();\n    };\n\n    View.prototype.addCatalog = function(catalog) {\n        catalog.name = this.makeUniqLayerName(catalog.name);\n        this.allOverlayLayers.push(catalog);\n        this.catalogs.push(catalog);\n        if (catalog.type=='catalog') {\n            catalog.setView(this);\n        }\n        else if (catalog.type=='progressivecat') {\n            catalog.init(this);\n        }\n    };\n    View.prototype.addOverlay = function(overlay) {\n        overlay.name = this.makeUniqLayerName(overlay.name);\n        this.overlays.push(overlay);\n        this.allOverlayLayers.push(overlay);\n        overlay.setView(this);\n    };\n    \n    View.prototype.addMOC = function(moc) {\n        moc.name = this.makeUniqLayerName(moc.name);\n        this.mocs.push(moc);\n        this.allOverlayLayers.push(moc);\n        moc.setView(this);\n    };\n    \n    View.prototype.getObjectsInBBox = function(x, y, w, h) {\n        if (w<0) {\n            x = x+w;\n            w = -w;\n        }\n        if (h<0) {\n            y = y+h;\n            h = -h;\n        }\n        var objList = [];\n        var cat, sources, s;\n        if (this.catalogs) {\n            for (var k=0; k<this.catalogs.length; k++) {\n                cat = this.catalogs[k];\n                if (!cat.isShowing) {\n                    continue;\n                }\n                sources = cat.getSources();\n                for (var l=0; l<sources.length; l++) {\n                    s = sources[l];\n                    if (!s.isShowing || !s.x || !s.y) {\n                        continue;\n                    }\n                    if (s.x>=x && s.x<=x+w && s.y>=y && s.y<=y+h) {\n                        objList.push(s);\n                    }\n                }\n            }\n        }\n        return objList;\n        \n    };\n\n    // update objLookup, lookup table \n    View.prototype.updateObjectsLookup = function() {\n        this.objLookup = [];\n\n        var cat, sources, s, xRounded, yRounded;\n        if (this.catalogs) {\n            for (var k=0; k<this.catalogs.length; k++) {\n                cat = this.catalogs[k];\n                if (!cat.isShowing) {\n                    continue;\n                }\n                sources = cat.getSources();\n                for (var l=0; l<sources.length; l++) {\n                    s = sources[l];\n                    if (!s.isShowing || !s.x || !s.y) {\n                        continue;\n                    }\n\n                    xRounded = Math.round(s.x);\n                    yRounded = Math.round(s.y);\n\n                    if (typeof this.objLookup[xRounded] === 'undefined') {\n                        this.objLookup[xRounded] = [];\n                    }\n                    if (typeof this.objLookup[xRounded][yRounded] === 'undefined') {\n                        this.objLookup[xRounded][yRounded] = [];\n                    }\n                    this.objLookup[xRounded][yRounded].push(s);\n                }       \n            }           \n        }     \n    };\n\n    // return closest object within a radius of maxRadius pixels. maxRadius is an integer\n    View.prototype.closestObjects = function(x, y, maxRadius) {\n\n        // footprint selection code adapted from Fabrizio Giordano dev. from Serco for ESA/ESDC\n        var overlay;\n        var canvas=this.catalogCanvas;\n        var ctx = canvas.getContext(\"2d\");\n        // this makes footprint selection easier as the catch-zone is larger\n        ctx.lineWidth = 6;\n\n        if (this.overlays) {\n            for (var k=0; k<this.overlays.length; k++) {\n                overlay = this.overlays[k];\n                for (var i=0; i<overlay.overlays.length;i++){\n\n                    // test polygons first\n                    var footprint = overlay.overlays[i];\n                    var pointXY = [];\n                    for(var j=0;j<footprint.polygons.length;j++){\n\n                        /*var xy = AladinUtils.radecToViewXy(footprint.polygons[j][0], footprint.polygons[j][1],\n                                this.projection,\n                                this.cooFrame,\n                                this.width, this.height,\n                                this.largestDim,\n                                this.zoomFactor);*/\n                        var xy = AladinUtils.radecToViewXy(footprint.polygons[j][0], footprint.polygons[j][1], this);\n                        if (! xy) {\n                            continue;\n                        }\n                        pointXY.push({\n                            x: xy[0],\n                            y: xy[1]\n                        });\n                    }\n                    for(var l=0; l<pointXY.length-1;l++){\n\n                        ctx.beginPath();                        // new segment\n                        ctx.moveTo(pointXY[l].x, pointXY[l].y);     // start is current point\n                        ctx.lineTo(pointXY[l+1].x, pointXY[l+1].y); // end point is next\n                        if (ctx.isPointInStroke(x, y)) {        // x,y is on line?\n                            closest = footprint;\n                            return [closest];\n                        }\n                    }\n                }\n\n                // test Circles\n                for (var i=0; i<overlay.overlay_items.length; i++) {\n                    if (overlay.overlay_items[i] instanceof Circle) {\n                        overlay.overlay_items[i].draw(ctx, this, this.projection, this.cooFrame, this.width, this.height, this.largestDim, this.zoomFactor, true);\n\n                        if (ctx.isPointInStroke(x, y)) {\n                            closest = overlay.overlay_items[i];\n                            return [closest];\n                        }\n                    }\n                }\n            }\n        }\n\n\n\n\n\n\n        if (!this.objLookup) {\n            return null;\n        }\n        var closest, dist;\n        for (var r=0; r<=maxRadius; r++) {\n            closest = dist = null;\n            for (var dx=-maxRadius; dx<=maxRadius; dx++) {\n                if (! this.objLookup[x+dx]) {\n                    continue;\n                }\n                for (var dy=-maxRadius; dy<=maxRadius; dy++) {\n                    if (this.objLookup[x+dx][y+dy]) {\n                        var d = dx*dx + dy*dy;\n                        if (!closest) {\n                            closest = this.objLookup[x+dx][y+dy];\n                            dist = d;\n                        }\n                        else if (d<dist) {\n                            dist = d;\n                            closest = this.objLookup[x+dx][y+dy];\n                        }\n                    }\n                }\n            }\n            if (closest) {\n                return closest;\n            }\n        }\n        return null;\n    };\n    \n    return View;\n})();\n","// requestAnimationFrame() shim by Paul Irish\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n/*export let requestAnimFrame = (function() {\n\treturn  window.requestAnimationFrame       || \n\t\t\twindow.webkitRequestAnimationFrame || \n\t\t\twindow.mozRequestAnimationFrame    || \n\t\t\twindow.oRequestAnimationFrame      || \n\t\t\twindow.msRequestAnimationFrame     || \n\t\t\tfunction( callback, element){\n\t\t\t\twindow.setTimeout(callback, 1000 / 60);\n\t\t\t};\n})();\n*/\n\nexport let requestAnimFrame = (function() {\n\treturn  window.requestAnimationFrame       || \n\t\t\twindow.webkitRequestAnimationFrame || \n\t\t\twindow.mozRequestAnimationFrame    || \n\t\t\twindow.oRequestAnimationFrame      || \n\t\t\twindow.msRequestAnimationFrame;\n})();\n","// stats.js r6 - http://github.com/mrdoob/stats.js\nexport let Stats=function(){function s(a,g,d){var f,c,e;for(c=0;c<30;c++)for(f=0;f<73;f++)e=(f+c*74)*4,a[e]=a[e+4],a[e+1]=a[e+5],a[e+2]=a[e+6];for(c=0;c<30;c++)e=(73+c*74)*4,c<g?(a[e]=b[d].bg.r,a[e+1]=b[d].bg.g,a[e+2]=b[d].bg.b):(a[e]=b[d].fg.r,a[e+1]=b[d].fg.g,a[e+2]=b[d].fg.b)}var r=0,t=2,g,u=0,j=(new Date).getTime(),F=j,v=j,l=0,w=1E3,x=0,k,d,a,m,y,n=0,z=1E3,A=0,f,c,o,B,p=0,C=1E3,D=0,h,i,q,E,b={fps:{bg:{r:16,g:16,b:48},fg:{r:0,g:255,b:255}},ms:{bg:{r:16,g:48,b:16},fg:{r:0,g:255,b:0}},mb:{bg:{r:48,g:16,\nb:26},fg:{r:255,g:0,b:128}}};g=document.createElement(\"div\");g.style.cursor=\"pointer\";g.style.width=\"80px\";g.style.opacity=\"0.9\";g.style.zIndex=\"10001\";g.addEventListener(\"click\",function(){r++;r==t&&(r=0);k.style.display=\"none\";f.style.display=\"none\";h.style.display=\"none\";switch(r){case 0:k.style.display=\"block\";break;case 1:f.style.display=\"block\";break;case 2:h.style.display=\"block\"}},!1);k=document.createElement(\"div\");k.style.backgroundColor=\"rgb(\"+Math.floor(b.fps.bg.r/2)+\",\"+Math.floor(b.fps.bg.g/\n2)+\",\"+Math.floor(b.fps.bg.b/2)+\")\";k.style.padding=\"2px 0px 3px 0px\";g.appendChild(k);d=document.createElement(\"div\");d.style.fontFamily=\"Helvetica, Arial, sans-serif\";d.style.textAlign=\"left\";d.style.fontSize=\"9px\";d.style.color=\"rgb(\"+b.fps.fg.r+\",\"+b.fps.fg.g+\",\"+b.fps.fg.b+\")\";d.style.margin=\"0px 0px 1px 3px\";d.innerHTML='<span style=\"font-weight:bold\">FPS</span>';k.appendChild(d);a=document.createElement(\"canvas\");a.width=74;a.height=30;a.style.display=\"block\";a.style.marginLeft=\"3px\";k.appendChild(a);\nm=a.getContext(\"2d\");m.fillStyle=\"rgb(\"+b.fps.bg.r+\",\"+b.fps.bg.g+\",\"+b.fps.bg.b+\")\";m.fillRect(0,0,a.width,a.height);y=m.getImageData(0,0,a.width,a.height);f=document.createElement(\"div\");f.style.backgroundColor=\"rgb(\"+Math.floor(b.ms.bg.r/2)+\",\"+Math.floor(b.ms.bg.g/2)+\",\"+Math.floor(b.ms.bg.b/2)+\")\";f.style.padding=\"2px 0px 3px 0px\";f.style.display=\"none\";g.appendChild(f);c=document.createElement(\"div\");c.style.fontFamily=\"Helvetica, Arial, sans-serif\";c.style.textAlign=\"left\";c.style.fontSize=\n\"9px\";c.style.color=\"rgb(\"+b.ms.fg.r+\",\"+b.ms.fg.g+\",\"+b.ms.fg.b+\")\";c.style.margin=\"0px 0px 1px 3px\";c.innerHTML='<span style=\"font-weight:bold\">MS</span>';f.appendChild(c);a=document.createElement(\"canvas\");a.width=74;a.height=30;a.style.display=\"block\";a.style.marginLeft=\"3px\";f.appendChild(a);o=a.getContext(\"2d\");o.fillStyle=\"rgb(\"+b.ms.bg.r+\",\"+b.ms.bg.g+\",\"+b.ms.bg.b+\")\";o.fillRect(0,0,a.width,a.height);B=o.getImageData(0,0,a.width,a.height);try{performance&&performance.memory&&performance.memory.totalJSHeapSize&&\n(t=3)}catch(G){}h=document.createElement(\"div\");h.style.backgroundColor=\"rgb(\"+Math.floor(b.mb.bg.r/2)+\",\"+Math.floor(b.mb.bg.g/2)+\",\"+Math.floor(b.mb.bg.b/2)+\")\";h.style.padding=\"2px 0px 3px 0px\";h.style.display=\"none\";g.appendChild(h);i=document.createElement(\"div\");i.style.fontFamily=\"Helvetica, Arial, sans-serif\";i.style.textAlign=\"left\";i.style.fontSize=\"9px\";i.style.color=\"rgb(\"+b.mb.fg.r+\",\"+b.mb.fg.g+\",\"+b.mb.fg.b+\")\";i.style.margin=\"0px 0px 1px 3px\";i.innerHTML='<span style=\"font-weight:bold\">MB</span>';\nh.appendChild(i);a=document.createElement(\"canvas\");a.width=74;a.height=30;a.style.display=\"block\";a.style.marginLeft=\"3px\";h.appendChild(a);q=a.getContext(\"2d\");q.fillStyle=\"#301010\";q.fillRect(0,0,a.width,a.height);E=q.getImageData(0,0,a.width,a.height);return{domElement:g,update:function(){u++;j=(new Date).getTime();n=j-F;z=Math.min(z,n);A=Math.max(A,n);s(B.data,Math.min(30,30-n/200*30),\"ms\");c.innerHTML='<span style=\"font-weight:bold\">'+n+\" MS</span> (\"+z+\"-\"+A+\")\";o.putImageData(B,0,0);F=j;if(j>\nv+1E3){l=Math.round(u*1E3/(j-v));w=Math.min(w,l);x=Math.max(x,l);s(y.data,Math.min(30,30-l/100*30),\"fps\");d.innerHTML='<span style=\"font-weight:bold\">'+l+\" FPS</span> (\"+w+\"-\"+x+\")\";m.putImageData(y,0,0);if(t==3)p=performance.memory.usedJSHeapSize*9.54E-7,C=Math.min(C,p),D=Math.max(D,p),s(E.data,Math.min(30,30-p/2),\"mb\"),i.innerHTML='<span style=\"font-weight:bold\">'+Math.round(p)+\" MB</span> (\"+Math.round(C)+\"-\"+Math.round(D)+\")\",q.putImageData(E,0,0);v=j;u=0}}}};\n\n","//=================================\n//            AstroMath\n//=================================\n\n// Class AstroMath having 'static' methods\nexport let AstroMath = function() {};\n\n// Constant for conversion Degrees => Radians (rad = deg*AstroMath.D2R)\nAstroMath.D2R = Math.PI/180.0;\n// Constant for conversion Radians => Degrees (deg = rad*AstroMath.R2D)\nAstroMath.R2D = 180.0/Math.PI;\n/**\n * Function sign\n * @param x value for checking the sign\n * @return -1, 0, +1 respectively if x < 0, = 0, > 0\n */\nAstroMath.sign = function(x) { return x > 0 ? 1 : (x < 0 ? -1 : 0 ); };\n\n/**\n * Function cosd(degrees)\n * @param x angle in degrees\n * @returns the cosine of the angle\n */\nAstroMath.cosd = function(x) {\n\tif (x % 90 == 0) {\n\t\tvar i = Math.abs(Math.floor(x / 90 + 0.5)) % 4;\n\t\tswitch (i) {\n\t\t\tcase 0:\treturn 1;\n\t\t\tcase 1:\treturn 0;\n\t\t\tcase 2:\treturn -1;\n\t\t\tcase 3:\treturn 0;\n\t\t}\n\t}\n\treturn Math.cos(x*AstroMath.D2R);\n};\n\n/**\n * Function sind(degrees)\n * @param x angle in degrees\n * @returns the sine of the angle\n */\nAstroMath.sind = function(x) {\n\tif (x % 90 === 0) {\n\t\tvar i = Math.abs(Math.floor(x / 90 - 0.5)) % 4;\n\t\tswitch (i) {\n\t\t\tcase 0:\treturn 1;\n\t\t\tcase 1:\treturn 0;\n\t\t\tcase 2:\treturn -1;\n\t\t\tcase 3:\treturn 0;\n\t\t}\n\t}\n\n\treturn Math.sin(x*AstroMath.D2R);\n};\n\n/**\n * Function tand(degrees)\n * @param x angle in degrees\n * @returns the tangent of the angle\n */\nAstroMath.tand = function(x) {\n\tvar resid;\n\n\tresid = x % 360;\n\tif (resid == 0 || Math.abs(resid) == 180) {\n\t\treturn 0;\n\t} else if (resid == 45 || resid == 225) {\n\t\treturn 1;\n\t} else if (resid == -135 || resid == -315) {\n\t\treturn -1\n\t}\n\n\treturn Math.tan(x * AstroMath.D2R);\n};\n\n/**\n * Function asin(degrees)\n * @param sine value [0,1]\n * @return the angle in degrees\n */\nAstroMath.asind = function(x) { return Math.asin(x)*AstroMath.R2D; };\n\n/**\n * Function acos(degrees)\n * @param cosine value [0,1]\n * @return the angle in degrees\n */\nAstroMath.acosd = function(x) { return Math.acos(x)*AstroMath.R2D; };\n\n/**\n * Function atan(degrees)\n * @param tangent value\n * @return the angle in degrees\n */\nAstroMath.atand = function(x) { return Math.atan(x)*AstroMath.R2D; };\n\n/**\n * Function atan2(y,x)\n * @param y y component of the vector\n * @param x x component of the vector\n * @return the angle in radians\n */\nAstroMath.atan2 = function(y,x) {\n\tif (y != 0.0) {\n\t\tvar sgny = AstroMath.sign(y);\n\t\tif (x != 0.0) {\n\t\t\tvar phi = Math.atan(Math.abs(y/x));\n\t\t\tif (x > 0.0) return phi*sgny;\n\t\t\telse if (x < 0) return (Math.PI-phi)*sgny;\n\t\t} else return (Math.PI/2)*sgny;\n\t} else {\n\t\treturn x > 0.0 ? 0.0 : (x < 0 ? Math.PI : 0.0/0.0);\n\t}\n}  \n\n/**\n * Function atan2d(y,x)\n * @param y y component of the vector\n * @param x x component of the vector\n * @return the angle in degrees\n */\nAstroMath.atan2d = function(y,x) {\n\treturn AstroMath.atan2(y,x)*AstroMath.R2D;\n}\n\n/*=========================================================================*/\n/**\n * Computation of hyperbolic cosine\n * @param x argument\n */\nAstroMath.cosh = function(x) {\n\treturn (Math.exp(x)+Math.exp(-x))/2;\n}\n\n/**\n * Computation of hyperbolic sine\n * @param x argument\n */\nAstroMath.sinh = function(x) {\n\treturn (Math.exp(x)-Math.exp(-x))/2;\n}\n\n/**\n * Computation of hyperbolic tangent\n * @param x argument\n */\nAstroMath.tanh = function(x) {\n\treturn (Math.exp(x)-Math.exp(-x))/(Math.exp(x)+Math.exp(-x));\n}\n\n/**\n * Computation of Arg cosh\n * @param x argument in degrees. Must be in the range [ 1, +infinity ]\n */\nAstroMath.acosh = function(x) {\n\treturn(Math.log(x+Math.sqrt(x*x-1.0)));\n}\n\n/**\n * Computation of Arg sinh\n * @param x argument in degrees\n */\nAstroMath.asinh = function(x) {\n\treturn(Math.log(x+Math.sqrt(x*x+1.0)));\n}\n\n/**\n * Computation of Arg tanh\n * @param x argument in degrees. Must be in the range ] -1, +1 [\n */\nAstroMath.atanh = function(x) {\n\treturn(0.5*Math.log((1.0+x)/(1.0-x)));\n}\n\n//=============================================================================\n//      Special Functions using trigonometry\n//=============================================================================\n/**\n * Computation of sin(x)/x\n *\t@param x in degrees.\n * For small arguments x <= 0.001, use approximation \n */\nAstroMath.sinc = function(x) {\n\tvar ax = Math.abs(x);\n\tvar y;\n\n\tif (ax <= 0.001) {\n\t\tax *= ax;\n\t\ty = 1 - ax*(1.0-ax/20.0)/6.0;\n\t} else {\n\t\ty = Math.sin(ax)/ax;\n\t}\n\n\treturn y;\n}\n\n/**\n * Computes asin(x)/x\n * @param x in degrees.\n * For small arguments x <= 0.001, use an approximation\n */\nAstroMath.asinc = function(x) {\n\tvar ax = Math.abs(x);\n\tvar y;\n\n\tif (ax <= 0.001) {\n\t\tax *= ax; \n\t\ty = 1 + ax*(6.0 + ax*(9.0/20.0))/6.0;\n\t} else {\n\t\ty = Math.asin(ax)/ax;\t// ???? radians ???\n\t}\n\n\treturn (y);\n}\n\n\n//=============================================================================\n/**\n * Computes the hypotenuse of x and y\n * @param x value\n * @param y value\n * @return sqrt(x*x+y*y)\n */\nAstroMath.hypot = function(x,y) {\n\treturn Math.sqrt(x*x+y*y);\n}\n\n/** Generate the rotation matrix from the Euler angles\n * @param z\tEuler angle\n * @param theta\tEuler angle\n * @param zeta\tEuler angles\n * @return R [3][3]\t\tthe rotation matrix\n * The rotation matrix is defined by:<pre>\n *    R =      R_z(-z)      *        R_y(theta)     *     R_z(-zeta)\n *   |cos.z -sin.z  0|   |cos.the  0 -sin.the|   |cos.zet -sin.zet 0|\n * = |sin.z  cos.z  0| x |   0     1     0   | x |sin.zet  cos.zet 0|\n *   |   0      0   1|   |sin.the  0  cos.the|   |   0        0    1|\n * </pre>\n */\nAstroMath.eulerMatrix = function(z, theta, zeta) {\n\tvar R = new Array(3);\n\tR[0] = new Array(3);\n\tR[1] = new Array(3);\n\tR[2] = new Array(3);\n\tvar cosdZ = AstroMath.cosd(z);\n\tvar sindZ = AstroMath.sind(z);\n\tvar cosdTheta = AstroMath.cosd(theta);\n\tvar w = AstroMath.sind(theta) ;\n\tvar cosdZeta = AstroMath.cosd(zeta);\n\tvar sindZeta = AstroMath.sind(zeta);\n\n\tR[0][0] = cosdZeta*cosdTheta*cosdZ - sindZeta*sindZ;\n\tR[0][1] = -sindZeta*cosdTheta*cosdZ - cosdZeta*sindZ;\n\tR[0][2] = -w*cosdZ;\n\n\tR[1][0] = cosdZeta*cosdTheta*sindZ + sindZeta*cosdZ;\n\tR[1][1] = -sindZeta*cosdTheta*sindZ + cosdZeta*cosdZ;\n\tR[1][2] = -w*sindZ;\n\n\tR[2][0] = -w*cosdZeta;\n\tR[2][1] = -w*cosdZ;\n\tR[2][2] = cosdTheta;\n\treturn R ;\n};\n\n\nAstroMath.displayMatrix = function(m) {\n\t// Number of rows\n\tvar nbrows = m.length;\n\t// Max column count\n\tvar nbcols = 0\n\tfor (var i=0; i<nbrows; i++) {\n\t\tif (m[i].length > nbcols) nbcols = m[i].length;\n\t}\n\tvar str = '<table>\\n';\n\tfor (var i=0; i<nbrows; i++) {\n\t\tstr += '<tr>';\n\t\tfor (var j=0; j<nbrows; j++) {\n\t\t\tstr += '<td>';\n\t\t\tif (i < m[i].length)\n\t\t\t\tstr += (m[i][j]).toString();\n\t\t\tstr += '</td>';\n\t\t}\n\t\tstr += '</td>\\n';\n\t}\n\tstr += '</table>\\n';\n\n\treturn str;\n}\n","//=================================\n// Class Coo\n//=================================\n\nimport { AstroMath } from \"./astroMath.js\";\n\n/**\n * Constructor\n * @param longitude longitude (decimal degrees)\n * @param latitude latitude (decimal degrees)\n * @param prec precision\n * (8: 1/1000th sec, 7: 1/100th sec, 6: 1/10th sec, 5: sec, 4: 1/10th min, 3: min, 2: 1/10th deg, 1: deg\n */\nexport let Coo = function(longitude, latitude, prec) {\n\tthis.lon = longitude;\n\tthis.lat = latitude;\n\tthis.prec = prec;\n\tthis.frame = null;\n\n\tthis.computeDirCos();\n};\n\nCoo.factor = [ 3600.0, 60.0, 1.0 ];\nCoo.prototype = {\n\tsetFrame: function(astroframe) {\n\t\tthis.frame = astroframe;\n\t},\n\tcomputeDirCos: function() {\n\t\tvar coslat = AstroMath.cosd(this.lat);\n\n\t\tthis.x = coslat*AstroMath.cosd(this.lon);\n\t\tthis.y = coslat*AstroMath.sind(this.lon);\n\t\tthis.z = AstroMath.sind(this.lat);\t\n\t}, \n\tcomputeLonLat: function() {\n\t\tvar r2 = this.x*this.x+this.y*this.y;\n\t\tthis.lon = 0.0;\n\t\tif (r2 == 0.0) {\n\t\t\t// In case of poles\n\t\t\tif (this.z == 0.0) {\n\t\t\t\tthis.lon = 0.0/0.0;\n\t\t\t\tthis.lat = 0.0/0.0;\n\t\t\t} else {\n\t\t\t\tthis.lat = (this.z > 0.0) ? 90.0 : -90.0;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lon = AstroMath.atan2d(this.y, this.x);\n\t\t\tthis.lat = AstroMath.atan2d(this.z, Math.sqrt(r2));\n\t\t\tif (this.lon < 0) this.lon += 360.0;\n\t\t}\n\t},\n\n  /**\n    * Squared distance between 2 points (= 4.sin<sup>2</sup>(r/2))\n    * @param  pos      another position on the sphere\n    * @return ||pos-this||<sup>2</sup> = 4.sin<sup>2</sup>(r/2)\n   **/\n   dist2: function(pos) {\n//    \tif ((this.x==0)&&(this.y==0)&&(this.z==0)) return(0./0.);\n//    \tif ((pos.x==0)&&(pos.y==0)&&(pos.z==0)) return(0./0.);\n\tvar w = pos.x - this.x;\n\tvar r2 = w * w;\n\tw = pos.y - this.y; r2 += w * w;\n\tw = pos.z - this.z; r2 += w * w;\n\treturn r2;\n   },\n\n   /**\n    * Distance between 2 points on the sphere.\n    * @param  pos another position on the sphere\n    * @return distance in degrees in range [0, 180]\n   **/\n    distance: function(pos) {\n      // Take care of NaN:\n    \tif ((pos.x==0)&&(pos.y==0)&&(pos.z==0)) return(0./0.);\n    \tif ((this.x==0)&&(this.y==0)&&(this.z==0)) return(0./0.);\n      return (2. * AstroMath.asind(0.5 * Math.sqrt(this.dist2(pos))));\n    },\n\n   /**\n    * Transform the position into another frame.\n    * @param new_frame\tThe frame of the resulting position.\n   **/\n   convertTo: function(new_frame) {\n\t\t// Verify first if frames identical -- then nothing to do !\n\t\tif (this.frame.equals(new_frame)) {\n\t    \t\treturn;\n\t\t}\n\n\t\t// Move via ICRS\n\t\tthis.frame.toICRS(this.coo);\t// Position now in ICRS\n\t\tnew_frame.fromICRS(this.coo);\t// Position now in new_frame\n\t\tthis.frame = new_frame;\n\t\tthis.lon = this.lat = 0./0.;\t// Actual angles not recomputed\n   },\n\n    /**\n     * Rotate a coordinate (apply a rotation to the position).\n     * @param R [3][3] Rotation Matrix\n     */\n    rotate: function(R) {\n      var X, Y, Z;\n\t\tif (R == Umatrix3) return;\n\t\tX = R[0][0]*this.x + R[0][1]*this.y + R[0][2]*this.z;\n\t\tY = R[1][0]*this.x + R[1][1]*this.y + R[1][2]*this.z;\n\t\tZ = R[2][0]*this.x + R[2][1]*this.y + R[2][2]*this.z;\n    \t// this.set(X, Y, Z); Not necessary to compute positions each time.\n\t\tthis.x = X; this.y = Y; this.z = Z;\n\t\tthis.lon = this.lat = 0./0.;\n    },\n\n    /**\n     * Rotate a coordinate (apply a rotation to the position) in reverse direction.\n     * The method is the inverse of rotate.\n     * @param R [3][3] Rotation Matrix\n     */\n    rotate_1: function(R) {\n      var X, Y, Z;\n      if (R == Umatrix3) return;\n\t\tX = R[0][0]*this.x + R[1][0]*this.y + R[2][0]*this.z;\n\t\tY = R[0][1]*this.x + R[1][1]*this.y + R[2][1]*this.z;\n\t\tZ = R[0][2]*this.x + R[1][2]*this.y + R[2][2]*this.z;\n    \t// this.set(X, Y, Z); Not necessary to compute positions each time.\n\t\tthis.x = X; this.y = Y; this.z = Z;\n\t\tthis.lon = this.lat = 0./0.;\n    },\n\n\n    /**\n     * Test equality of Coo.\n     * @param coo Second coordinate to compare with\n     * @return  True if the two coordinates are equal\n     */\n    equals: function(coo) {\n\t\treturn this.x == coo.x && this.y == coo.y && this.z == coo.z;\n    },\n\n\t/**\n\t * parse a coordinate string. The coordinates can be in decimal or sexagesimal\n\t * @param str string to parse\n\t * @return true if the parsing succeded, false otherwise\n\t */\n\tparse: function(str) {\n\t\tvar p = str.indexOf('+');\n\t\tif (p < 0) p = str.indexOf('-');\n\t\tif (p < 0) p = str.indexOf(' ');\n\t\tif (p < 0) {\n\t\t\tthis.lon = 0.0/0.0;\n\t\t\tthis.lat = 0.0/0.0;\n\t\t\tthis.prec = 0;\n\t\t\treturn false;\n\t\t}\n\t\tvar strlon = str.substring(0,p);\n\t\tvar strlat = str.substring(p);\n\t\n\t\tthis.lon = this.parseLon(strlon);\t// sets the precision parameter\n\t\tthis.lat = this.parseLat(strlat);\t// sets the precision parameter\n\t\treturn true;\n\t},\n\n\tparseLon: function(str) {\n\t\tvar str = str.trim();\n        str = str.replace(/:/g, ' ');\n\n\t\tif (str.indexOf(' ') < 0) {\n\t\t\t// The longitude is a integer or decimal number\n\t\t\tvar p = str.indexOf('.');\n\t\t\tthis.prec = p < 0 ? 0 : str.length - p - 1;\n\t\t\treturn parseFloat(str);\n\t\t} else {\n\t\t\tvar stok = new Tokenizer(str,' ');\n\t\t\tvar i = 0;\n\t\t\tvar l = 0;\n\t\t\tvar pr = 0;\n\t\t\twhile (stok.hasMore()) {\n\t\t\t\tvar tok = stok.nextToken();\n\t\t\t\tvar dec = tok.indexOf('.');\n\t\t\t\tl += parseFloat(tok)*Coo.factor[i];\n//\t\t\t\tpr = dec < 0 ? 1 : 2;\n\t\t\t\tswitch (i) {\n\t\t\t\t\tcase 0: pr = dec < 0 ? 1 : 2; break;\n\t\t\t\t\tcase 1: pr = dec < 0 ? 3 : 4; break;\n\t\t\t\t\tcase 2: pr = dec < 0 ? 5 : 4+tok.length-dec;\n\t\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tthis.prec = pr;\n\t\t\treturn l*15/3600.0;\t\n\t\t}\n\t},\n\t\t\t\n\tparseLat: function(str) {\n\t\tvar str = str.trim();\n        str = str.replace(/:/g, ' ');\n\n\t\tvar sign;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tsign = -1;\n\t\t\tstr = str.substring(1);\n\t\t} else if (str.charAt(0) == '-') {\n\t\t\tsign = 1;\n\t\t\tstr = str.substring(1);\n\t\t} else {\n\t\t\t// No sign specified\n\t\t\tsign = 1;\n\t\t}\n\t\tif (str.indexOf(' ') < 0) {\n\t\t\t// The longitude is a integer or decimal number\n\t\t\tvar p = str.indexOf('.');\n\t\t\tthis.prec = p < 0 ? 0 : str.length - p - 1;\n\t\t\treturn parseFloat(str)*sign;\n\t\t} else {\n\t\t\tvar stok = new Tokenizer(str,' ');\n\t\t\tvar i = 0;\n\t\t\tvar l = 0;\n\t\t\tvar pr = 0;\n\t\t\twhile (stok.hasMore()) {\n\t\t\t\tvar tok = stok.nextToken();\n\t\t\t\tvar dec = tok.indexOf('.');\n\t\t\t\tl += parseFloat(tok)*Coo.factor[i];\n\t\t\t\tswitch (i) {\n\t\t\t\t\tcase 0: pr = dec < 0 ? 1 : 2; break;\n\t\t\t\t\tcase 1: pr = dec < 0 ? 3 : 4; break;\n\t\t\t\t\tcase 2: pr = dec < 0 ? 5 : 4+tok.length-dec;\n\t\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tthis.prec = pr;\n\t\t\treturn l*sign/3600.0;\t\n\t\t}\n\t},\n\n\t/**\n\t * Format coordinates according to the options\n\t * @param options 'd': decimal, 's': sexagsimal, '/': space separated, '2': return [ra,dec] in an array\n\t * @return the formatted coordinates\n\t */\n\tformat: function(options) {\n\t\tif (isNaN(this.lon)) this.computeLonLat();\n\t\tvar strlon = \"\", strlat = \"\";\n\t\tif (options.indexOf('d') >= 0) {\n\t\t\t// decimal display\n\t\t\tstrlon = Numbers.format(this.lon, this.prec);\n\t\t\tstrlat = Numbers.format(this.lat, this.prec);\n\t\t} else {\n\t\t\t// sexagesimal display\n\t\t\tvar hlon = this.lon/15.0;\n\t\t\tvar strlon = Numbers.toSexagesimal(hlon, this.prec+1, false);\n\t\t\tvar strlat = Numbers.toSexagesimal(this.lat, this.prec, false);\n\t\t}\n\t\tif (this.lat > 0) strlat = '+'+strlat;\n\n\t\tif (options.indexOf('/') >= 0) {\n\t\t\treturn strlon+' '+strlat;\n\t\t} else if (options.indexOf('2') >= 0) {\n\t\t\treturn [strlon, strlat];\n\t\t}\n\t\treturn strlon+strlat;\n\t}\n\t\t\n}\n\n/**\n * Distance between 2 points on the sphere.\n * @param coo1 firs\tvar coslat = AstroMath.cosd(this.lat);\n\n\tthis.x = coslat*AstroMath.cosd(this.lon);\n\tthis.y = coslat*AstroMath.sind(this.lon);\n\tthis.z = AstroMath.sind(this.lat);\nt coordinates point\n * @param coo2 second coordinates point\n * @return distance in degrees in range [0, 180]\n**/\n/*\nCoo.distance = function(Coo coo1, Coo coo2) {\n\treturn Coo.distance(coo1.lon, coo1.lat, coo2.lon, coo2.lat);\n}\n*/\n/**\n * Distance between 2 points on the sphere.\n * @param lon1 longitude of first point in degrees\n * @param lat1 latitude of first point in degrees\n * @param lon2 longitude of second point in degrees\n * @param lat2 latitude of second point in degrees\n * @return distance in degrees in range [0, 180]\n**/\n/*\nCoo.distance = function(lon1, lat1, lon2, lat2) {\n\tvar c1 = AstroMath.cosd(lat1);\n\tvar c2 = AstroMath.cosd(lat2);\n\n\tvar w, r2;\n\tw = c1 * AstroMath.cosd(lon1) - c2 * AstroMath.cosd(lon2);\n\tr2 = w*w;\n\tw = c1 * AstroMath.sind(lon1) - c2 * AstroMath.sind(lon2);\n\tr2 += w*w;\n\tw = AstroMath.sind(lat1) - AstroMath.sind(lat2);\n\tr2 += w*w;\n\n\treturn 2. * AstroMath.asind(0.5 * Math.sqrt(r2));\n}\n\n\n//===================================\n// Class Tokenizer (similar to Java)\n//===================================\n\n/**\n * Constructor\n * @param str String to tokenize\n * @param sep token separator char\n */\nfunction Tokenizer(str, sep) {\n\tthis.string = Strings.trim(str, sep);\n\tthis.sep = sep;\n\tthis.pos = 0;\n}\n\nTokenizer.prototype = {\n\t/**\n\t * Check if the string has more tokens\n\t * @return true if a token remains (read with nextToken())\n\t */\n\thasMore: function() {\n\t\treturn this.pos < this.string.length;\n\t},\n\n\t/**\n\t * Returns the next token (as long as hasMore() is true)\n\t * @return the token string\n\t */\n\tnextToken: function() {\n\t\t// skip all the separator chars\n\t\tvar p0 = this.pos;\n\t\twhile (p0 < this.string.length && this.string.charAt(p0) == this.sep) p0++;\n\t\tvar p1 = p0;\n\t\t// get the token\n\t\twhile (p1 < this.string.length && this.string.charAt(p1) != this.sep) p1++;\n\t\tthis.pos = p1;\n\t\treturn this.string.substring(p0, p1);\n\t},\n}\n\n//================================\n// Class Strings (static methods)\n//================================\nfunction Strings() {}\n\n/**\n * Removes a given char at the beginning and the end of a string\n * @param str string to trim\n * @param c char to remove\n * @return the trimmed string\n */\n\nStrings.trim = function(str, c) {\n\tvar p0=0, p1=str.length-1;\n\twhile (p0 < str.length && str.charAt(p0) == c) p0++;\n\tif (p0 == str.length) return \"\";\n\twhile (p1 > p0 && str.charAt(p1) == c) p1--;\n\treturn str.substring(p0, p1+1);\n}\n\n//================================\n// Class Numbers (static methods)\n//================================\nfunction Numbers() {}\n//                0  1   2    3     4      5       6        7         8          9\nNumbers.pow10 = [ 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000,\n//      10           11            12             13              14\n\t10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000 ];\n//                 0    1     2      3       4        5         6          7\nNumbers.rndval = [ 0.5, 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005,\n//      8            9             10             11              12\n\t0.000000005, 0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005,\n//      13                14\n\t0.00000000000005, 0.00000000000005 ];\n/**\n * Format a integer or decimal number, adjusting the value with 'prec' decimal digits\n * @param num number (integer or decimal)\n * @param prec precision (= number of decimal digit to keep or append)\n * @return a string with the formatted number\n */\nNumbers.format = function(num, prec) {\n\t\tif (prec <= 0) {\n\t\t\t// Return an integer number\n\t\t\treturn (Math.round(num)).toString();\n\t\t}\n\t\tvar str = num.toString();\n\t\tvar p = str.indexOf('.');\n\t\tvar nbdec = p >= 0 ? str.length-p-1 : 0;\n\t\tif (prec >= nbdec) {\n\t\t\tif (p < 0) str += '.';\n\t\t\tfor (var i=0; i<prec-nbdec; i++)\n\t\t\t\tstr += '0';\n\t\t\treturn str;\n\t\t}\n\t\t// HERE: prec > 0 and prec < nbdec\n\t\tstr = (num+Numbers.rndval[prec]).toString();\n\t\treturn str.substr(0, p+prec+1);\n}\n\n\n/**\n * Convert a decimal coordinate into sexagesimal string, according to the given precision<br>\n * 8: 1/1000th sec, 7: 1/100th sec, 6: 1/10th sec, 5: sec, 4: 1/10th min, 3: min, 2: 1/10th deg, 1: deg\n * @param num number (integer or decimal)\n * @param prec precision (= number of decimal digit to keep or append)\n * @param plus if true, the '+' sign is displayed\n * @return a string with the formatted sexagesimal number\n */\nNumbers.toSexagesimal = function(num, prec, plus) {\n\tvar resu = \"\";\n\tvar sign = num < 0 ? '-' : (plus ? '+' : '');\n\tvar n = Math.abs(num);\n\n\tswitch (prec) {\n\t\tcase 1:\t// deg\n\t\t\tvar n1 = Math.round(n);\n\t\t\treturn sign+n1.toString();\n\t\tcase 2:\t// deg.d\n\t\t\treturn sign+Numbers.format(n, 1);\n\t\tcase 3:\t// deg min\n\t\t\tvar n1 = Math.floor(n);\n\t\t\tvar n2 = Math.round((n-n1)*60);\n\t\t\treturn sign+n1+' '+n2;\n\t\tcase 4:\t// deg min.d\n\t\t\tvar n1 = Math.floor(n);\n\t\t\tvar n2 = (n-n1)*60;\n\t\t\treturn sign+n1+' '+Numbers.format(n2, 1);\n\t\tcase 5:\t// deg min sec\n\t\t\tvar n1 = Math.floor(n);\t// d\n\t\t\tvar n2 = (n-n1)*60;\t\t// M.d\n\t\t\tvar n3 = Math.floor(n2);// M\n\t\t\tvar n4 = Math.round((n2-n3)*60);\t// S\n\t\t\treturn sign+n1+' '+n3+' '+n4;\n\t\tcase 6:\t// deg min sec.d\n\t\tcase 7:\t// deg min sec.dd\n\t\tcase 8:\t// deg min sec.ddd\n\t\t\tvar n1 = Math.floor(n);\t// d\n\t\t\tif (n1<10) n1 = '0' + n1;\n\t\t\tvar n2 = (n-n1)*60;\t\t// M.d\n\t\t\tvar n3 = Math.floor(n2);// M\n\t\t\tif (n3<10) n3 = '0' + n3;\n\t\t\tvar n4 = (n2-n3)*60;\t\t// S.ddd\n\t\t\treturn sign+n1+' '+n3+' '+Numbers.format(n4, prec-5);\n\t\tdefault:\n\t\t\treturn sign+Numbers.format(n, 1);\n\t}\n}\n","\nimport { AstroMath } from \"./astroMath.js\";\n\nexport let Projection = function(lon0, lat0) {\n\tthis.PROJECTION = Projection.PROJ_TAN;\n\tthis.ROT = this.tr_oR(lon0, lat0);\n\n    this.longitudeIsReversed = false;\n}\n\n//var ROT;\n//var PROJECTION = Projection.PROJ_TAN;\t// Default projection\n\n\nProjection.PROJ_TAN = 1;\t/* Gnomonic projection*/\nProjection.PROJ_TAN2 = 2;\t/* Stereographic projection*/\nProjection.PROJ_STG = 2;\t\nProjection.PROJ_SIN = 3;\t/* Orthographic\t\t*/\nProjection.PROJ_SIN2 = 4;\t/* Equal-area \t\t*/\nProjection.PROJ_ZEA = 4;\t/* Zenithal Equal-area \t*/\nProjection.PROJ_ARC = 5;\t/* For Schmidt plates\t*/\nProjection.PROJ_SCHMIDT = 5;\t/* For Schmidt plates\t*/\nProjection.PROJ_AITOFF = 6;\t/* Aitoff Projection\t*/\nProjection.PROJ_AIT = 6;\t/* Aitoff Projection\t*/\nProjection.PROJ_GLS = 7;\t/* Global Sin (Sanson)\t*/\nProjection.PROJ_MERCATOR = 8;\nProjection.PROJ_MER = 8;\t\nProjection.PROJ_LAM = 9;\t/* Lambert Projection\t*/\nProjection.PROJ_LAMBERT = 9;\t\nProjection.PROJ_TSC = 10;\t/* Tangent Sph. Cube\t*/\nProjection.PROJ_QSC = 11;\t/* QuadCube Sph. Cube\t*/\nProjection.PROJ_MOLLWEIDE = 12;\nProjection.PROJ_LIST = [\n\t\"Mercator\",Projection.PROJ_MERCATOR,\n\t\"Gnomonic\",Projection.PROJ_TAN,\n\t\"Stereographic\",Projection.PROJ_TAN2,\n\t\"Orthographic\",Projection.PROJ_SIN,\n\t\"Zenithal\",Projection.PROJ_ZEA,\n\t\"Schmidt\",Projection.PROJ_SCHMIDT,\n\t\"Aitoff\",Projection.PROJ_AITOFF,\n\t\"Lambert\",Projection.PROJ_LAMBERT,\n//\t\"Tangential\",Projection.PROJ_TSC,\n//\t\"Quadrilaterized\",Projection.PROJ_QSC,\n];\nProjection.PROJ_NAME = [\n\t'-', 'Gnomonic', 'Stereographic', 'Orthographic', 'Equal-area', 'Schmidt plates',\n\t'Aitoff', 'Global sin', 'Mercator', 'Lambert'\n];\n\nProjection.prototype = { \n\t\n\t/** Set the center of the projection\n\t * \n\t * (ajout T. Boch, 19/02/2013)\n\t * \n\t * */\n\tsetCenter: function(lon0, lat0) {\n\t\tthis.ROT = this.tr_oR(lon0, lat0);\n\t},\n\n    /** Reverse the longitude\n      * If set to true, longitudes will increase from left to right\n      *\n      * */\n    reverseLongitude: function(b) {\n        this.longitudeIsReversed = b;\n    },\n\t\n\t/**\n\t * Set the projection to use\n\t * p = projection code\n\t */\n\tsetProjection: function(p) {\n\t\tthis.PROJECTION = p;\n\t},\n\n\n\t/**\n\t * Computes the projection of 1 point : ra,dec => X,Y\n\t * alpha, delta = longitude, lattitude\n\t */\n\tproject: function(alpha, delta) {\n        var u1 = this.tr_ou(alpha, delta);\t// u1[3]\n\t\tvar u2 = this.tr_uu(u1, this.ROT);\t// u2[3]\n\t\tvar P = this.tr_up(this.PROJECTION, u2);\t// P[2] = [X,Y]\n\t\tif (P == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif( this.longitudeIsReversed) {\n            return { X: P[0], Y: -P[1] };\n        }\n        else {\n\t\t    return { X: -P[0], Y: -P[1] };\n        }\n        //return { X: -P[0], Y: -P[1] };\n\t},\n\n\t/**\n\t * Computes the coordinates from a projection point : X,Y => ra,dec\n\t * return o = [ ra, dec ]\n\t */\n\tunproject: function(X,Y) {\n\t\tif ( ! this.longitudeIsReversed) {\n            X = -X;\n        }\n\t\tY = -Y;\n\t\tvar u1 = this.tr_pu(this.PROJECTION, X, Y);\t// u1[3]\n\t\tvar u2 = this.tr_uu1(u1, this.ROT);\t// u2[3]\n\t\tvar o = this.tr_uo(u2);\t// o[2]\n\n/*\n\t\tif (this.longitudeIsReversed) {\n            return { ra: 360-o[0], dec: o[1] };\n        }\n        else {\n\t\t    return { ra: o[0], dec: o[1] };\n        }\n*/\n        return { ra: o[0], dec: o[1] };\n\t},\n\n\t/**\n\t * Compute projections from unit vector\n\t * The center of the projection correspond to u = [1, 0, 0)\n\t * proj = projection system (integer code like _PROJ_MERCATOR_\n\t * u[3] = unit vector\n\t * return: an array [x,y] or null\n\t */\n\ttr_up: function(proj, u) {\n\t\tvar x = u[0]; var y = u[1]; var z = u[2];\n\t\tvar r, den;\n\t\tvar pp;\n\t\tvar X,Y;\n\n\t\tr = AstroMath.hypot(x,y);\t\t\t// r = cos b\n\t\tif (r == 0.0 && z == 0.0) return null;\n\n\t\tswitch(proj) {\n\t\t\tdefault:\n\t\t\t\tpp = null;\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_AITOFF:\n\t\t\t\tden = Math.sqrt(r*(r+x)/2.0); \t\t// cos b . cos l/2\n\t\t\t\tX = Math.sqrt(2.0*r*(r-x));\n\t\t\t\tden = Math.sqrt((1.0 + den)/2.0); \n\t\t\t\tX = X / den;\n\t\t\t\tY = z / den;\n\t\t\t\tif (y < 0.0) X = -X;\n\t\t\t\tpp = [ X, Y];\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_GLS:\n\t\t\t\tY = Math.asin(z);\t\t\t\t// sin b\n\t\t\t\tX = (r != 0) ? Math.atan2(y,x)*r : 0.0;\n\t\t\t\tpp = [ X, Y];\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_MERCATOR:\n\t\t\t\tif (r != 0) {\n\t\t\t\t\tX = Math.atan2(y,x);\n\t\t\t\t\tY = AstroMath.atanh(z);\n\t\t\t\t\tpp = [ X, Y];\n\t\t\t\t} else {\n\t\t\t\t\tpp = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_TAN:\n\t\t\t\tif (x > 0.0) {\n\t\t\t\t\tX = y/x;\n\t\t\t\t\tY = z/x;\n\t\t\t\t\tpp = [ X, Y ];\n\t\t\t\t} else {\n\t\t\t\t\tpp = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_TAN2:\n\t\t\t\tden = (1.0 + x)/2.0;\n\t\t\t\tif (den > 0.0)\t{\n\t\t\t\t\tX = y/den;\n\t\t\t\t\tY = z/den;\n\t\t\t\t\tpp = [ X, Y ];\n\t\t\t\t} else {\n\t\t\t\t\tpp = null;\n\t\t\t\t}\n\t\t\t \tbreak;\n\n\t\t\tcase Projection.PROJ_ARC:\n\t\t\t\tif (x <= -1.0) {\n\t\t\t\t\t// Distance of 180 degrees\n\t\t\t\t\tX = Math.PI\n\t\t\t\t\tY = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\t// Arccos(x) = Arcsin(r)\n\t\t\t\t\tr = AstroMath.hypot(y,z);\n\t\t\t\t\tif (x > 0.0) den = AstroMath.asinc(r);\n\t\t\t\t\telse den = Math.acos(x)/r;\n\t\t\t\t\tX = y * den;\n\t\t\t\t\tY = z * den;\n\t\t\t\t}\n\t\t\t\tpp = [ X, Y ];\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_SIN:\n\t\t\t\tif (x >= 0.0) {\n\t\t\t\t\tX = y;\n\t\t\t\t\tY = z;\n\t\t\t\t\tpp = [ X, Y ];\n\t\t\t\t} else {\n\t\t\t\t\tpp = null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_SIN2:\t// Always possible\n\t\t\t\tden = Math.sqrt((1.0 + x)/2.0);\n\t\t\t\tif (den != 0)\t{\n\t\t\t\t\tX = y / den;\n\t\t\t\t\tY = z / den;\n\t\t\t\t} else {\n\t\t\t\t\t// For x = -1\n\t\t\t\t\tX = 2.0;\n\t\t\t\t\tY = 0.0;\n\t\t\t\t}\n\t\t\t\tpp = [ X, Y ];\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_LAMBERT:\t// Always possible\n\t\t\t\tY = z;\n\t\t\t\tX = 0;\n\t\t\t\tif (r != 0)\tX = Math.atan2(y,x);\n\t\t\t\tpp = [ X, Y ];\n\t\t\t\tbreak;\n\t  }\n\t  return pp;\n\t},\n\n\t/**\n\t * Computes Unit vector from a position in projection centered at position (0,0).\n\t * proj = projection code\n\t * X,Y : coordinates of the point in the projection\n\t * returns : the unit vector u[3] or a face number for cube projection. \n\t *           null if the point is outside the limits, or if the projection is unknown.\n\t */\n\ttr_pu: function( proj, X, Y ) {\n\t\tvar r,s,x,y,z;\n\n\t\tswitch(proj) {\n\t\t\tdefault:\n\t\t\treturn null;\n\n\t\t\tcase Projection.PROJ_AITOFF:\n\t\t\t\t// Limit is ellipse with axises \n\t\t\t\t// a = 2 * sqrt(2) ,  b = sqrt(2)\n\t\t\t\t// Compute dir l/2, b\n\t\t\t\tr = X*X/8.e0 + Y*Y/2.e0; \t// 1 - cos b . cos l/2\n\t\t\t\tif (r > 1.0) {\n\t  \t\t\t\t// Test outside domain */\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tx = 1.0 - r ;\t// cos b . cos l/2\n\t\t\t\ts = Math.sqrt(1.0 - r/2.0) ;\t// sqrt(( 1 + cos b . cos l/2)/2)\n\t\t\t\ty = X * s / 2.0;\n\t\t\t\tz = Y * s ;\n\t\t\t\t// From (l/2,b) to (l,b)\n\t\t\t\tr = AstroMath.hypot( x, y ) ;\t// cos b\n\t\t\t\tif (r != 0.0) {\n\t\t\t\t\ts = x;\n\t\t\t\t\tx = (s*s - y*y) /r;\n\t\t\t\t\ty = 2.0 * s * y/r;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_GLS:\n\t\t\t\t// Limit is |Y| <= pi/2\n\t\t\t\tz = Math.sin(Y);\n\t\t\t\tr = 1 - z*z;\t\t// cos(b) ** 2\n\t\t\t\tif (r < 0.0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tr = Math.sqrt(r);\t\t// cos b\n\t\t\t\tif (r != 0.0) {\n\t\t\t\t\ts = X/r;\t// Longitude\n\t\t\t\t} else {\n\t\t\t\t\ts = 0.0;\t// For poles\n\t\t\t\t}\n\t\t\t\tx = r * Math.cos(s);\n\t\t\t\ty = r * Math.sin(s);\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_MERCATOR:\n\t\t\t\tz = AstroMath.tanh(Y);\n\t\t\t\tr = 1.0/AstroMath.cosh(Y);\n\t\t\t\tx = r * Math.cos(X);\n\t\t\t\ty = r * Math.sin(X);\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_LAMBERT:\n\t\t\t\t// Always possible\n\t\t\t\tz = Y;\n\t\t\t\tr = 1 - z*z;\t\t// cos(b) ** 2\n\t\t\t\tif (r < 0.0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tr = Math.sqrt(r);\t\t// cos b\n\t\t\t\tx = r * Math.cos(X);\n\t\t\t\ty = r * Math.sin(X);\n\t\t\t\tbreak;\n\t\n\t\t\tcase Projection.PROJ_TAN:\n\t\t\t\t// No limit\n\t\t\t\tx = 1.0 / Math.sqrt(1.0 + X*X + Y*Y);\n\t\t\t\ty = X * x;\n\t\t\t\tz = Y * x;\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_TAN2:\n\t\t\t\t// No limit\n\t\t\t\tr = (X*X + Y*Y)/4.0;\n\t\t\t\ts = 1.0 + r;\n\t\t\t\tx = (1.0 - r)/s;\n\t\t\t\ty = X / s;\n\t\t\t\tz = Y / s;\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_ARC:\n\t\t\t\t// Limit is circle, radius PI\n\t\t\t\tr = AstroMath.hypot(X, Y);\n\t\t\t\tif (r > Math.PI) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ts = AstroMath.sinc(r);\n\t\t\t\tx = Math.cos(r);\n\t\t\t\ty = s * X;\n\t\t\t\tz = s * Y;\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_SIN:\n\t\t\t\t// Limit is circle, radius 1\n\t\t\t\ts = 1.0 - X*X - Y*Y;\n\t\t\t\tif (s < 0.0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tx = Math.sqrt(s);\n\t\t\t\ty = X;\n\t\t\t\tz = Y;\n\t\t\t\tbreak;\n\n\t\t\tcase Projection.PROJ_SIN2:\n\t\t\t\t// Limit is circle, radius 2\t*/\n\t\t\t\tr = (X*X + Y*Y)/4.e0;\n\t\t\t\tif (r > 1.0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ts = Math.sqrt(1.0 - r);\n\t\t\t\tx = 1.0 - 2.0 * r;\n\t\t\t\ty = s * X;\n\t\t\t\tz = s * Y;\n\t\t\t\tbreak;\n\t  }\n\t  return [ x,y,z ];\n\t},\n\n\t/**\n\t * Creates the rotation matrix R[3][3] defined as\n\t * R[0] (first row) = unit vector towards Zenith\n\t * R[1] (second row) = unit vector towards East\n\t * R[2] (third row) = unit vector towards North\n\t * o[2] original angles\n\t * @return rotation matrix\n\t */\n\ttr_oR: function(lon, lat) {\n\t\tvar R = new Array(3);\n\t\tR[0] = new Array(3);\n\t\tR[1] = new Array(3);\n\t\tR[2] = new Array(3);\n\t\tR[2][2] =  AstroMath.cosd(lat);\n\t\tR[0][2] =  AstroMath.sind(lat);\n\t\tR[1][1] =  AstroMath.cosd(lon);\n\t\tR[1][0] =  -AstroMath.sind(lon);\n\t\tR[1][2] =  0.0;\n\t\tR[0][0] =  R[2][2] * R[1][1];  \n\t\tR[0][1] = -R[2][2] * R[1][0];\n\t\tR[2][0] = -R[0][2] * R[1][1];\n\t\tR[2][1] =  R[0][2] * R[1][0];\n\t\treturn R;\n\t},\n\n\t/**\n\t * Transformation from polar coordinates to Unit vector\n\t * @return U[3]\n\t */\n\ttr_ou: function(ra, dec) {\n\t\tvar u = new Array(3);\n\t\tvar cosdec = AstroMath.cosd(dec);\n\n\t\tu[0] = cosdec * AstroMath.cosd(ra);\n\t\tu[1] = cosdec * AstroMath.sind(ra);\n\t\tu[2] = AstroMath.sind(dec);\n\n\t\treturn u;\n\t},\n\n\t/**\n\t * Rotates the unit vector u1 using the rotation matrix\n\t * u1[3] unit vector\n\t * R[3][3] rotation matrix\n\t * return resulting unit vector u2[3]\n\t */\n\ttr_uu: function( u1, R ) {\n\t\tvar u2 = new Array(3);\n\t\tvar x = u1[0];\n\t\tvar y = u1[1];\n\t\tvar z = u1[2];\n\n\t\tu2[0] = R[0][0]*x + R[0][1]*y + R[0][2]*z ;\n\t\tu2[1] = R[1][0]*x + R[1][1]*y + R[1][2]*z ;\n\t\tu2[2] = R[2][0]*x + R[2][1]*y + R[2][2]*z ;\n\n\t\treturn u2;\n\t},\n\n\t/**\n\t * reverse rotation the unit vector u1 using the rotation matrix\n\t * u1[3] unit vector\n\t * R[3][3] rotation matrix\n\t * return resulting unit vector u2[3]\n\t */\n\ttr_uu1: function( u1 , R) {\n\t\tvar u2 = new Array(3);\n\t\tvar x = u1[0];\n\t\tvar y = u1[1];\n\t\tvar z = u1[2];\n\n\t\tu2[0] = R[0][0]*x + R[1][0]*y + R[2][0]*z;\n\t\tu2[1] = R[0][1]*x + R[1][1]*y + R[2][1]*z;\n\t\tu2[2] = R[0][2]*x + R[1][2]*y + R[2][2]*z;\n\n\t\treturn u2;\n\t},\n\n\t/**\n\t * Computes angles from direction cosines\n\t * u[3] = direction cosines vector\n\t * return o = [ ra, dec ]\n\t */\n\ttr_uo: function(u) {\n\t\tvar x = u[0]; var y = u[1]; var z = u[2];  \n\t\tvar r2 = x*x + y*y;\n\t\tvar ra, dec;\n\t\tif (r2  == 0.0) {\n\t \t\t// in case of poles\n\t\t\tif (z == 0.0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tra = 0.0;\n\t\t\tdec = z > 0.0 ? 90.0 : -90.0;\n\t\t} else {\n\t\t\tdec = AstroMath.atand( z / Math.sqrt(r2));\n\t\t\tra  = AstroMath.atan2d (y , x );\n\t\t\tif (ra < 0.0) ra += 360.0;\n\t\t}\n\n\t\treturn [ ra, dec ];\n\t}\n}\n","export let astro = (function () {\n\n  let astro = {};\n\n  var Base, BinaryTable, CompressedImage, DataUnit, Decompress, FITS, HDU, Header, HeaderVerify, Image, ImageUtils, Parser, Table, Tabular, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __slice = [].slice;\n\n\n  Base = (function() {\n    function Base() {}\n\n    Base.include = function(obj) {\n      var key, value;\n      for (key in obj) {\n        value = obj[key];\n        this.prototype[key] = value;\n      }\n      return this;\n    };\n\n    Base.extend = function(obj) {\n      var key, value;\n      for (key in obj) {\n        value = obj[key];\n        this[key] = value;\n      }\n      return this;\n    };\n\n    Base.prototype.proxy = function(func) {\n      var _this = this;\n      return function() {\n        return func.apply(_this, arguments);\n      };\n    };\n\n    Base.prototype.invoke = function(callback, opts, data) {\n      var context;\n      context = (opts != null ? opts.context : void 0) != null ? opts.context : this;\n      if (callback != null) {\n        return callback.call(context, data, opts);\n      }\n    };\n\n    return Base;\n\n  })();\n\n  Parser = (function(_super) {\n    __extends(Parser, _super);\n\n    Parser.prototype.LINEWIDTH = 80;\n\n    Parser.prototype.BLOCKLENGTH = 2880;\n\n    File.prototype.slice = File.prototype.slice || File.prototype.webkitSlice;\n\n    Blob.prototype.slice = Blob.prototype.slice || Blob.prototype.webkitSlice;\n\n    function Parser(arg, callback, opts) {\n      var xhr,\n        _this = this;\n      this.arg = arg;\n      this.callback = callback;\n      this.opts = opts;\n      this.hdus = [];\n      this.blockCount = 0;\n      this.begin = 0;\n      this.end = this.BLOCKLENGTH;\n      this.offset = 0;\n      this.headerStorage = new Uint8Array();\n      if (typeof this.arg === 'string') {\n        this.readNextBlock = this._readBlockFromBuffer;\n        xhr = new XMLHttpRequest();\n        xhr.open('GET', this.arg);\n        xhr.responseType = 'arraybuffer';\n\n        // the onerror handling has been added wrt the original fitsjs library as retrieved on the astrojs github repo\n        // if an error occurs, we return an empty object\n        xhr.onerror = function() {\n          _this.invoke(_this.callback, _this.opts);\n        }\n\n        xhr.onload = function() {\n          if (xhr.status !== 200) {\n            _this.invoke(_this.callback, _this.opts);\n            return;\n          }\n          _this.arg = xhr.response;\n          _this.length = _this.arg.byteLength;\n          return _this.readFromBuffer();\n        };\n        xhr.send();\n      } else {\n        this.length = this.arg.size;\n        this.readNextBlock = this._readBlockFromFile;\n        this.readFromFile();\n      }\n    }\n\n    Parser.prototype.readFromBuffer = function() {\n      var block;\n      block = this.arg.slice(this.begin + this.offset, this.end + this.offset);\n      return this.readBlock(block);\n    };\n\n    Parser.prototype.readFromFile = function() {\n      var block,\n        _this = this;\n      this.reader = new FileReader();\n      this.reader.onloadend = function(e) {\n        return _this.readBlock(e.target.result);\n      };\n      block = this.arg.slice(this.begin + this.offset, this.end + this.offset);\n      return this.reader.readAsArrayBuffer(block);\n    };\n\n    Parser.prototype.readBlock = function(block) {\n      var arr, dataLength, dataunit, header, rowIndex, rows, s, slice, tmp, value, _i, _len, _ref;\n      arr = new Uint8Array(block);\n      tmp = new Uint8Array(this.headerStorage);\n      this.headerStorage = new Uint8Array(this.end);\n      this.headerStorage.set(tmp, 0);\n      this.headerStorage.set(arr, this.begin);\n      rows = this.BLOCKLENGTH / this.LINEWIDTH;\n      while (rows--) {\n        rowIndex = rows * this.LINEWIDTH;\n        if (arr[rowIndex] === 32) {\n          continue;\n        }\n        if (arr[rowIndex] === 69 && arr[rowIndex + 1] === 78 && arr[rowIndex + 2] === 68 && arr[rowIndex + 3] === 32) {\n          s = '';\n          _ref = this.headerStorage;\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            value = _ref[_i];\n            s += String.fromCharCode(value);\n          }\n          header = new Header(s);\n          this.start = this.end + this.offset;\n          dataLength = header.getDataLength();\n          slice = this.arg.slice(this.start, this.start + dataLength);\n          if (header.hasDataUnit()) {\n            dataunit = this.createDataUnit(header, slice);\n          }\n          this.hdus.push(new HDU(header, dataunit));\n          this.offset += this.end + dataLength + this.excessBytes(dataLength);\n          if (this.offset === this.length) {\n            this.headerStorage = null;\n            this.invoke(this.callback, this.opts, this);\n            return;\n          }\n          this.blockCount = 0;\n          this.begin = this.blockCount * this.BLOCKLENGTH;\n          this.end = this.begin + this.BLOCKLENGTH;\n          this.headerStorage = new Uint8Array();\n          block = this.arg.slice(this.begin + this.offset, this.end + this.offset);\n          this.readNextBlock(block);\n          return;\n        }\n        break;\n      }\n      this.blockCount += 1;\n      this.begin = this.blockCount * this.BLOCKLENGTH;\n      this.end = this.begin + this.BLOCKLENGTH;\n      block = this.arg.slice(this.begin + this.offset, this.end + this.offset);\n      this.readNextBlock(block);\n    };\n\n    Parser.prototype._readBlockFromBuffer = function(block) {\n      return this.readBlock(block);\n    };\n\n    Parser.prototype._readBlockFromFile = function(block) {\n      return this.reader.readAsArrayBuffer(block);\n    };\n\n    Parser.prototype.createDataUnit = function(header, blob) {\n      var type;\n      type = header.getDataType();\n      return new astro.FITS[type](header, blob);\n    };\n\n    Parser.prototype.excessBytes = function(length) {\n      return (this.BLOCKLENGTH - (length % this.BLOCKLENGTH)) % this.BLOCKLENGTH;\n    };\n\n    Parser.prototype.isEOF = function() {\n      if (this.offset === this.length) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    return Parser;\n\n  })(Base);\n\n   FITS = (function(_super) {\n    __extends(FITS, _super);\n\n    function FITS(arg, callback, opts) {\n      var parser,\n        _this = this;\n      this.arg = arg;\n      parser = new Parser(this.arg, function(fits) {\n        _this.hdus = parser.hdus;\n        return _this.invoke(callback, opts, _this);\n      });\n    }\n\n    FITS.prototype.getHDU = function(index) {\n      var hdu, _i, _len, _ref;\n      if ((index != null) && (this.hdus[index] != null)) {\n        return this.hdus[index];\n      }\n      _ref = this.hdus;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        hdu = _ref[_i];\n        if (hdu.hasData()) {\n          return hdu;\n        }\n      }\n    };\n\n    FITS.prototype.getHeader = function(index) {\n      return this.getHDU(index).header;\n    };\n\n    FITS.prototype.getDataUnit = function(index) {\n      return this.getHDU(index).data;\n    };\n\n    return FITS;\n\n  })(Base);\n\n  FITS.version = '0.6.5';\n\n  astro.FITS = FITS;\n\n  DataUnit = (function(_super) {\n    __extends(DataUnit, _super);\n\n    DataUnit.swapEndian = {\n      B: function(value) {\n        return value;\n      },\n      I: function(value) {\n        return (value << 8) | (value >> 8);\n      },\n      J: function(value) {\n        return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);\n      }\n    };\n\n    DataUnit.swapEndian[8] = DataUnit.swapEndian['B'];\n\n    DataUnit.swapEndian[16] = DataUnit.swapEndian['I'];\n\n    DataUnit.swapEndian[32] = DataUnit.swapEndian['J'];\n\n    function DataUnit(header, data) {\n      if (data instanceof ArrayBuffer) {\n        this.buffer = data;\n      } else {\n        this.blob = data;\n      }\n    }\n\n    return DataUnit;\n\n  })(Base);\n\n  astro.FITS.DataUnit = DataUnit;\n\n  HeaderVerify = {\n    verifyOrder: function(keyword, order) {\n      if (order !== this.cardIndex) {\n        return console.warn(\"\" + keyword + \" should appear at index \" + this.cardIndex + \" in the FITS header\");\n      }\n    },\n    verifyBetween: function(keyword, value, lower, upper) {\n      if (!(value >= lower && value <= upper)) {\n        throw \"The \" + keyword + \" value of \" + value + \" is not between \" + lower + \" and \" + upper;\n      }\n    },\n    verifyBoolean: function(value) {\n      if (value === \"T\") {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    VerifyFns: {\n      SIMPLE: function() {\n        var args, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = arguments[0];\n        this.primary = true;\n        this.verifyOrder(\"SIMPLE\", 0);\n        return this.verifyBoolean(value);\n      },\n      XTENSION: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        this.extension = true;\n        this.extensionType = arguments[0];\n        this.verifyOrder(\"XTENSION\", 0);\n        return this.extensionType;\n      },\n      BITPIX: function() {\n        var args, key, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        key = \"BITPIX\";\n        value = parseInt(arguments[0]);\n        this.verifyOrder(key, 1);\n        if (value !== 8 && value !== 16 && value !== 32 && value !== (-32) && value !== (-64)) {\n          throw \"\" + key + \" value \" + value + \" is not permitted\";\n        }\n        return value;\n      },\n      NAXIS: function() {\n        var args, array, key, required, value, _ref;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        key = \"NAXIS\";\n        value = parseInt(arguments[0]);\n        array = arguments[1];\n        if (!array) {\n          this.verifyOrder(key, 2);\n          this.verifyBetween(key, value, 0, 999);\n          if (this.isExtension()) {\n            if ((_ref = this.extensionType) === \"TABLE\" || _ref === \"BINTABLE\") {\n              required = 2;\n              if (value !== required) {\n                throw \"\" + key + \" must be \" + required + \" for TABLE and BINTABLE extensions\";\n              }\n            }\n          }\n        }\n        return value;\n      },\n      PCOUNT: function() {\n        var args, key, order, required, value, _ref;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        key = \"PCOUNT\";\n        value = parseInt(arguments[0]);\n        order = 1 + 1 + 1 + this.get(\"NAXIS\");\n        this.verifyOrder(key, order);\n        if (this.isExtension()) {\n          if ((_ref = this.extensionType) === \"IMAGE\" || _ref === \"TABLE\") {\n            required = 0;\n            if (value !== required) {\n              throw \"\" + key + \" must be \" + required + \" for the \" + this.extensionType + \" extensions\";\n            }\n          }\n        }\n        return value;\n      },\n      GCOUNT: function() {\n        var args, key, order, required, value, _ref;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        key = \"GCOUNT\";\n        value = parseInt(arguments[0]);\n        order = 1 + 1 + 1 + this.get(\"NAXIS\") + 1;\n        this.verifyOrder(key, order);\n        if (this.isExtension()) {\n          if ((_ref = this.extensionType) === \"IMAGE\" || _ref === \"TABLE\" || _ref === \"BINTABLE\") {\n            required = 1;\n            if (value !== required) {\n              throw \"\" + key + \" must be \" + required + \" for the \" + this.extensionType + \" extensions\";\n            }\n          }\n        }\n        return value;\n      },\n      EXTEND: function() {\n        var args, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = arguments[0];\n        if (!this.isPrimary()) {\n          throw \"EXTEND must only appear in the primary header\";\n        }\n        return this.verifyBoolean(value);\n      },\n      BSCALE: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseFloat(arguments[0]);\n      },\n      BZERO: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseFloat(arguments[0]);\n      },\n      BLANK: function() {\n        var args, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = arguments[0];\n        if (!(this.get(\"BITPIX\") > 0)) {\n          console.warn(\"BLANK is not to be used for BITPIX = \" + (this.get('BITPIX')));\n        }\n        return parseInt(value);\n      },\n      DATAMIN: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseFloat(arguments[0]);\n      },\n      DATAMAX: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseFloat(arguments[0]);\n      },\n      EXTVER: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseInt(arguments[0]);\n      },\n      EXTLEVEL: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseInt(arguments[0]);\n      },\n      TFIELDS: function() {\n        var args, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = parseInt(arguments[0]);\n        this.verifyBetween(\"TFIELDS\", value, 0, 999);\n        return value;\n      },\n      TBCOL: function() {\n        var args, index, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = arguments[0];\n        index = arguments[2];\n        this.verifyBetween(\"TBCOL\", index, 0, this.get(\"TFIELDS\"));\n        return value;\n      },\n      ZIMAGE: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return this.verifyBoolean(arguments[0]);\n      },\n      ZCMPTYPE: function() {\n        var args, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = arguments[0];\n        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {\n          throw \"ZCMPTYPE value \" + value + \" is not permitted\";\n        }\n        if (value !== 'RICE_1') {\n          throw \"Compress type \" + value + \" is not yet implement\";\n        }\n        return value;\n      },\n      ZBITPIX: function() {\n        var args, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = parseInt(arguments[0]);\n        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {\n          throw \"ZBITPIX value \" + value + \" is not permitted\";\n        }\n        return value;\n      },\n      ZNAXIS: function() {\n        var args, array, value;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        value = parseInt(arguments[0]);\n        array = arguments[1];\n        value = value;\n        if (!array) {\n          this.verifyBetween(\"ZNAXIS\", value, 0, 999);\n        }\n        return value;\n      },\n      ZTILE: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseInt(arguments[0]);\n      },\n      ZSIMPLE: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        if (arguments[0] === \"T\") {\n          return true;\n        } else {\n          return false;\n        }\n      },\n      ZPCOUNT: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseInt(arguments[0]);\n      },\n      ZGCOUNT: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseInt(arguments[0]);\n      },\n      ZDITHER0: function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return parseInt(arguments[0]);\n      }\n    }\n  };\n\n  astro.FITS.HeaderVerify = HeaderVerify;\n\n  Header = (function(_super) {\n    __extends(Header, _super);\n\n    Header.include(HeaderVerify);\n\n    Header.prototype.arrayPattern = /(\\D+)(\\d+)/;\n\n    Header.prototype.maxLines = 600;\n\n    function Header(block) {\n      var method, name, _ref;\n      this.primary = false;\n      this.extension = false;\n      this.verifyCard = {};\n      _ref = this.VerifyFns;\n      for (name in _ref) {\n        method = _ref[name];\n        this.verifyCard[name] = this.proxy(method);\n      }\n      this.cards = {};\n      this.cards[\"COMMENT\"] = [];\n      this.cards[\"HISTORY\"] = [];\n      this.cardIndex = 0;\n      this.block = block;\n      this.readBlock(block);\n    }\n\n    Header.prototype.get = function(key) {\n      if (this.contains(key)) {\n        return this.cards[key].value;\n      } else {\n        return null;\n      }\n    };\n\n    Header.prototype.set = function(key, value, comment) {\n      comment = comment || '';\n      this.cards[key] = {\n        index: this.cardIndex,\n        value: value,\n        comment: comment\n      };\n      return this.cardIndex += 1;\n    };\n\n    Header.prototype.contains = function(key) {\n      return this.cards.hasOwnProperty(key);\n    };\n\n    Header.prototype.readLine = function(l) {\n      var blank, comment, firstByte, indicator, key, value, _ref;\n      key = l.slice(0, 8).trim();\n      blank = key === '';\n      if (blank) {\n        return;\n      }\n      indicator = l.slice(8, 10);\n      value = l.slice(10);\n      if (indicator !== \"= \") {\n        if (key === 'COMMENT' || key === 'HISTORY') {\n          this.cards[key].push(value.trim());\n        }\n        return;\n      }\n      _ref = value.split(' /'), value = _ref[0], comment = _ref[1];\n      value = value.trim();\n      firstByte = value[0];\n      if (firstByte === \"'\") {\n        value = value.slice(1, -1).trim();\n      } else {\n        if (value !== 'T' && value !== 'F') {\n          value = parseFloat(value);\n        }\n      }\n      value = this.validate(key, value);\n      return this.set(key, value, comment);\n    };\n\n    Header.prototype.validate = function(key, value) {\n      var baseKey, index, isArray, match, _ref;\n      index = null;\n      baseKey = key;\n      isArray = this.arrayPattern.test(key);\n      if (isArray) {\n        match = this.arrayPattern.exec(key);\n        _ref = match.slice(1), baseKey = _ref[0], index = _ref[1];\n      }\n      if (baseKey in this.verifyCard) {\n        value = this.verifyCard[baseKey](value, isArray, index);\n      }\n      return value;\n    };\n\n    Header.prototype.readBlock = function(block) {\n      var i, line, lineWidth, nLines, _i, _ref, _results;\n      lineWidth = 80;\n      nLines = block.length / lineWidth;\n      nLines = nLines < this.maxLines ? nLines : this.maxLines;\n      _results = [];\n      for (i = _i = 0, _ref = nLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n        line = block.slice(i * lineWidth, (i + 1) * lineWidth);\n        _results.push(this.readLine(line));\n      }\n      return _results;\n    };\n\n    Header.prototype.hasDataUnit = function() {\n      if (this.get(\"NAXIS\") === 0) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    Header.prototype.getDataLength = function() {\n      var i, length, naxis, _i, _ref;\n      if (!this.hasDataUnit()) {\n        return 0;\n      }\n      naxis = [];\n      for (i = _i = 1, _ref = this.get(\"NAXIS\"); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {\n        naxis.push(this.get(\"NAXIS\" + i));\n      }\n      length = naxis.reduce(function(a, b) {\n        return a * b;\n      }) * Math.abs(this.get(\"BITPIX\")) / 8;\n      length += this.get(\"PCOUNT\");\n      return length;\n    };\n\n    Header.prototype.getDataType = function() {\n      switch (this.extensionType) {\n        case 'BINTABLE':\n          if (this.contains('ZIMAGE')) {\n            return 'CompressedImage';\n          }\n          return 'BinaryTable';\n        case 'TABLE':\n          return 'Table';\n        default:\n          if (this.hasDataUnit()) {\n            return 'Image';\n          } else {\n            return null;\n          }\n      }\n    };\n\n    Header.prototype.isPrimary = function() {\n      return this.primary;\n    };\n\n    Header.prototype.isExtension = function() {\n      return this.extension;\n    };\n\n    return Header;\n\n  })(Base);\n\n  astro.FITS.Header = Header;\n\n  ImageUtils = {\n    getExtent: function(arr) {\n      var index, max, min, value;\n      index = arr.length;\n      while (index--) {\n        value = arr[index];\n        if (isNaN(value)) {\n          continue;\n        }\n        min = max = value;\n        break;\n      }\n      if (index === -1) {\n        return [NaN, NaN];\n      }\n      while (index--) {\n        value = arr[index];\n        if (isNaN(value)) {\n          continue;\n        }\n        if (value < min) {\n          min = value;\n        }\n        if (value > max) {\n          max = value;\n        }\n      }\n      return [min, max];\n    },\n    getPixel: function(arr, x, y) {\n      return arr[y * this.width + x];\n    }\n  };\n\n  astro.FITS.ImageUtils = ImageUtils;\n\n  Image = (function(_super) {\n    __extends(Image, _super);\n\n    Image.include(ImageUtils);\n\n    Image.prototype.allocationSize = 16777216;\n\n    function Image(header, data) {\n      var begin, frame, i, naxis, _i, _j, _ref;\n      Image.__super__.constructor.apply(this, arguments);\n      naxis = header.get(\"NAXIS\");\n      this.bitpix = header.get(\"BITPIX\");\n      this.naxis = [];\n      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {\n        this.naxis.push(header.get(\"NAXIS\" + i));\n      }\n      this.width = header.get(\"NAXIS1\");\n      this.height = header.get(\"NAXIS2\") || 1;\n      this.depth = header.get(\"NAXIS3\") || 1;\n      this.bzero = header.get(\"BZERO\") || 0;\n      this.bscale = header.get(\"BSCALE\") || 1;\n      this.bytes = Math.abs(this.bitpix) / 8;\n      this.length = this.naxis.reduce(function(a, b) {\n        return a * b;\n      }) * Math.abs(this.bitpix) / 8;\n      this.frame = 0;\n      this.frameOffsets = [];\n      this.frameLength = this.bytes * this.width * this.height;\n      this.nBuffers = this.buffer != null ? 1 : 2;\n      for (i = _j = 0, _ref = this.depth - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {\n        begin = i * this.frameLength;\n        frame = {\n          begin: begin\n        };\n        if (this.buffer != null) {\n          frame.buffers = [this.buffer.slice(begin, begin + this.frameLength)];\n        }\n        this.frameOffsets.push(frame);\n      }\n    }\n\n    Image.prototype._getFrame = function(buffer, bitpix, bzero, bscale) {\n      var arr, bytes, dataType, i, nPixels, swapEndian, tmp, value;\n      bytes = Math.abs(bitpix) / 8;\n      nPixels = i = buffer.byteLength / bytes;\n      dataType = Math.abs(bitpix);\n      if (bitpix > 0) {\n        switch (bitpix) {\n          case 8:\n            tmp = new Uint8Array(buffer);\n            tmp = new Uint16Array(tmp);\n            swapEndian = function(value) {\n              return value;\n            };\n            break;\n          case 16:\n            tmp = new Int16Array(buffer);\n            swapEndian = function(value) {\n              return ((value & 0xFF) << 8) | ((value >> 8) & 0xFF);\n            };\n            break;\n          case 32:\n            tmp = new Int32Array(buffer);\n            swapEndian = function(value) {\n              return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);\n            };\n        }\n        if (!(parseInt(bzero) === bzero && parseInt(bscale) === bscale)) {\n          arr = new Float32Array(tmp.length);\n        } else {\n          arr = tmp;\n        }\n        while (nPixels--) {\n          tmp[nPixels] = swapEndian(tmp[nPixels]);\n          arr[nPixels] = bzero + bscale * tmp[nPixels];\n        }\n      } else {\n        arr = new Uint32Array(buffer);\n        swapEndian = function(value) {\n          return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);\n        };\n        while (i--) {\n          value = arr[i];\n          arr[i] = swapEndian(value);\n        }\n        arr = new Float32Array(buffer);\n        while (nPixels--) {\n          arr[nPixels] = bzero + bscale * arr[nPixels];\n        }\n      }\n      return arr;\n    };\n\n    Image.prototype._getFrameAsync = function(buffers, callback, opts) {\n      var URL, blobGetFrame, blobOnMessage, fn1, fn2, i, mime, msg, onmessage, pixels, start, urlGetFrame, urlOnMessage, worker,\n        _this = this;\n      onmessage = function(e) {\n        var arr, bitpix, bscale, buffer, bzero, data, url;\n        data = e.data;\n        buffer = data.buffer;\n        bitpix = data.bitpix;\n        bzero = data.bzero;\n        bscale = data.bscale;\n        url = data.url;\n        importScripts(url);\n        arr = _getFrame(buffer, bitpix, bzero, bscale);\n        return postMessage(arr);\n      };\n      fn1 = onmessage.toString().replace('return postMessage', 'postMessage');\n      fn1 = \"onmessage = \" + fn1;\n      fn2 = this._getFrame.toString();\n      fn2 = fn2.replace('function', 'function _getFrame');\n      mime = \"application/javascript\";\n      blobOnMessage = new Blob([fn1], {\n        type: mime\n      });\n      blobGetFrame = new Blob([fn2], {\n        type: mime\n      });\n      URL = window.URL || window.webkitURL;\n      urlOnMessage = URL.createObjectURL(blobOnMessage);\n      urlGetFrame = URL.createObjectURL(blobGetFrame);\n      worker = new Worker(urlOnMessage);\n      msg = {\n        buffer: buffers[0],\n        bitpix: this.bitpix,\n        bzero: this.bzero,\n        bscale: this.bscale,\n        url: urlGetFrame\n      };\n      i = 0;\n      pixels = null;\n      start = 0;\n      worker.onmessage = function(e) {\n        var arr;\n        arr = e.data;\n        if (pixels == null) {\n          pixels = new arr.constructor(_this.width * _this.height);\n        }\n        pixels.set(arr, start);\n        start += arr.length;\n        i += 1;\n        if (i === _this.nBuffers) {\n          _this.invoke(callback, opts, pixels);\n          URL.revokeObjectURL(urlOnMessage);\n          URL.revokeObjectURL(urlGetFrame);\n          return worker.terminate();\n        } else {\n          msg.buffer = buffers[i];\n          return worker.postMessage(msg, [buffers[i]]);\n        }\n      };\n      worker.postMessage(msg, [buffers[0]]);\n    };\n\n    Image.prototype.getFrame = function(frame, callback, opts) {\n      var begin, blobFrame, blobs, buffers, bytesPerBuffer, frameInfo, i, nRowsPerBuffer, reader, start, _i, _ref,\n        _this = this;\n      this.frame = frame || this.frame;\n      frameInfo = this.frameOffsets[this.frame];\n      buffers = frameInfo.buffers;\n      if ((buffers != null ? buffers.length : void 0) === this.nBuffers) {\n        return this._getFrameAsync(buffers, callback, opts);\n      } else {\n        this.frameOffsets[this.frame].buffers = [];\n        begin = frameInfo.begin;\n        blobFrame = this.blob.slice(begin, begin + this.frameLength);\n        blobs = [];\n        nRowsPerBuffer = Math.floor(this.height / this.nBuffers);\n        bytesPerBuffer = nRowsPerBuffer * this.bytes * this.width;\n        for (i = _i = 0, _ref = this.nBuffers - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n          start = i * bytesPerBuffer;\n          if (i === this.nBuffers - 1) {\n            blobs.push(blobFrame.slice(start));\n          } else {\n            blobs.push(blobFrame.slice(start, start + bytesPerBuffer));\n          }\n        }\n        buffers = [];\n        reader = new FileReader();\n        reader.frame = this.frame;\n        i = 0;\n        reader.onloadend = function(e) {\n          var buffer;\n          frame = e.target.frame;\n          buffer = e.target.result;\n          _this.frameOffsets[frame].buffers.push(buffer);\n          i += 1;\n          if (i === _this.nBuffers) {\n            return _this.getFrame(frame, callback, opts);\n          } else {\n            return reader.readAsArrayBuffer(blobs[i]);\n          }\n        };\n        return reader.readAsArrayBuffer(blobs[0]);\n      }\n    };\n\n    Image.prototype.getFrames = function(frame, number, callback, opts) {\n      var cb,\n        _this = this;\n      cb = function(arr, opts) {\n        _this.invoke(callback, opts, arr);\n        number -= 1;\n        frame += 1;\n        if (!number) {\n          return;\n        }\n        return _this.getFrame(frame, cb, opts);\n      };\n      return this.getFrame(frame, cb, opts);\n    };\n\n    Image.prototype.isDataCube = function() {\n      if (this.naxis.length > 2) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    return Image;\n\n  })(DataUnit);\n\n  astro.FITS.Image = Image;\n\n  Tabular = (function(_super) {\n    __extends(Tabular, _super);\n\n    Tabular.prototype.maxMemory = 1048576;\n\n    function Tabular(header, data) {\n      Tabular.__super__.constructor.apply(this, arguments);\n      this.rowByteSize = header.get(\"NAXIS1\");\n      this.rows = header.get(\"NAXIS2\");\n      this.cols = header.get(\"TFIELDS\");\n      this.length = this.rowByteSize * this.rows;\n      this.heapLength = header.get(\"PCOUNT\");\n      this.columns = this.getColumns(header);\n      if (this.buffer != null) {\n        this.rowsInMemory = this._rowsInMemoryBuffer;\n        this.heap = this.buffer.slice(this.length, this.length + this.heapLength);\n      } else {\n        this.rowsInMemory = this._rowsInMemoryBlob;\n        this.firstRowInBuffer = this.lastRowInBuffer = 0;\n        this.nRowsInBuffer = Math.floor(this.maxMemory / this.rowByteSize);\n      }\n      this.accessors = [];\n      this.descriptors = [];\n      this.elementByteLengths = [];\n      this.setAccessors(header);\n    }\n\n    Tabular.prototype._rowsInMemoryBuffer = function() {\n      return true;\n    };\n\n    Tabular.prototype._rowsInMemoryBlob = function(firstRow, lastRow) {\n      if (firstRow < this.firstRowInBuffer) {\n        return false;\n      }\n      if (lastRow > this.lastRowInBuffer) {\n        return false;\n      }\n      return true;\n    };\n\n    Tabular.prototype.getColumns = function(header) {\n      var columns, i, key, _i, _ref;\n      columns = [];\n      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {\n        key = \"TTYPE\" + i;\n        if (!header.contains(key)) {\n          return null;\n        }\n        columns.push(header.get(key));\n      }\n      return columns;\n    };\n\n    Tabular.prototype.getColumn = function(name, callback, opts) {\n      var accessor, cb, column, descriptor, elementByteLength, elementByteOffset, factor, i, index, iterations, rowsPerIteration,\n        _this = this;\n      if (this.blob != null) {\n        index = this.columns.indexOf(name);\n        descriptor = this.descriptors[index];\n        accessor = this.accessors[index];\n        elementByteLength = this.elementByteLengths[index];\n        elementByteOffset = this.elementByteLengths.slice(0, index);\n        if (elementByteOffset.length === 0) {\n          elementByteOffset = 0;\n        } else {\n          elementByteOffset = elementByteOffset.reduce(function(a, b) {\n            return a + b;\n          });\n        }\n        column = this.typedArray[descriptor] != null ? new this.typedArray[descriptor](this.rows) : [];\n        rowsPerIteration = ~~(this.maxMemory / this.rowByteSize);\n        rowsPerIteration = Math.min(rowsPerIteration, this.rows);\n        factor = this.rows / rowsPerIteration;\n        iterations = Math.floor(factor) === factor ? factor : Math.floor(factor) + 1;\n        i = 0;\n        index = 0;\n        cb = function(buffer, opts) {\n          var nRows, offset, startRow, view;\n          nRows = buffer.byteLength / _this.rowByteSize;\n          view = new DataView(buffer);\n          offset = elementByteOffset;\n          while (nRows--) {\n            column[i] = accessor(view, offset)[0];\n            i += 1;\n            offset += _this.rowByteSize;\n          }\n          iterations -= 1;\n          index += 1;\n          if (iterations) {\n            startRow = index * rowsPerIteration;\n            return _this.getTableBuffer(startRow, rowsPerIteration, cb, opts);\n          } else {\n            _this.invoke(callback, opts, column);\n          }\n        };\n        return this.getTableBuffer(0, rowsPerIteration, cb, opts);\n      } else {\n        cb = function(rows, opts) {\n          column = rows.map(function(d) {\n            return d[name];\n          });\n          return _this.invoke(callback, opts, column);\n        };\n        return this.getRows(0, this.rows, cb, opts);\n      }\n    };\n\n    Tabular.prototype.getTableBuffer = function(row, number, callback, opts) {\n      var begin, blobRows, end, reader,\n        _this = this;\n      number = Math.min(this.rows - row, number);\n      begin = row * this.rowByteSize;\n      end = begin + number * this.rowByteSize;\n      blobRows = this.blob.slice(begin, end);\n      reader = new FileReader();\n      reader.row = row;\n      reader.number = number;\n      reader.onloadend = function(e) {\n        return _this.invoke(callback, opts, e.target.result);\n      };\n      return reader.readAsArrayBuffer(blobRows);\n    };\n\n    Tabular.prototype.getRows = function(row, number, callback, opts) {\n      var begin, blobRows, buffer, end, reader, rows,\n        _this = this;\n      if (this.rowsInMemory(row, row + number)) {\n        if (this.blob != null) {\n          buffer = this.buffer;\n        } else {\n          begin = row * this.rowByteSize;\n          end = begin + number * this.rowByteSize;\n          buffer = this.buffer.slice(begin, end);\n        }\n        rows = this._getRows(buffer, number);\n        this.invoke(callback, opts, rows);\n        return rows;\n      } else {\n        begin = row * this.rowByteSize;\n        end = begin + Math.max(this.nRowsInBuffer * this.rowByteSize, number * this.rowByteSize);\n        blobRows = this.blob.slice(begin, end);\n        reader = new FileReader();\n        reader.row = row;\n        reader.number = number;\n        reader.onloadend = function(e) {\n          var target;\n          target = e.target;\n          _this.buffer = target.result;\n          _this.firstRowInBuffer = _this.lastRowInBuffer = target.row;\n          _this.lastRowInBuffer += target.number;\n          return _this.getRows(row, number, callback, opts);\n        };\n        return reader.readAsArrayBuffer(blobRows);\n      }\n    };\n\n    return Tabular;\n\n  })(DataUnit);\n\n  astro.FITS.Tabular = Tabular;\n\n  Table = (function(_super) {\n    __extends(Table, _super);\n\n    function Table() {\n      _ref = Table.__super__.constructor.apply(this, arguments);\n      return _ref;\n    }\n\n    Table.prototype.dataAccessors = {\n      A: function(value) {\n        return value.trim();\n      },\n      I: function(value) {\n        return parseInt(value);\n      },\n      F: function(value) {\n        return parseFloat(value);\n      },\n      E: function(value) {\n        return parseFloat(value);\n      },\n      D: function(value) {\n        return parseFloat(value);\n      }\n    };\n\n    Table.prototype.setAccessors = function(header) {\n      var descriptor, form, i, match, pattern, type, _i, _ref1, _results,\n        _this = this;\n      pattern = /([AIFED])(\\d+)\\.*(\\d+)*/;\n      _results = [];\n      for (i = _i = 1, _ref1 = this.cols; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {\n        form = header.get(\"TFORM\" + i);\n        type = header.get(\"TTYPE\" + i);\n        match = pattern.exec(form);\n        descriptor = match[1];\n        _results.push((function(descriptor) {\n          var accessor;\n          accessor = function(value) {\n            return _this.dataAccessors[descriptor](value);\n          };\n          return _this.accessors.push(accessor);\n        })(descriptor));\n      }\n      return _results;\n    };\n\n    Table.prototype._getRows = function(buffer) {\n      var accessor, arr, begin, end, i, index, line, nRows, row, rows, subarray, value, _i, _j, _k, _len, _len1, _ref1, _ref2;\n      nRows = buffer.byteLength / this.rowByteSize;\n      arr = new Uint8Array(buffer);\n      rows = [];\n      for (i = _i = 0, _ref1 = nRows - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n        begin = i * this.rowByteSize;\n        end = begin + this.rowByteSize;\n        subarray = arr.subarray(begin, end);\n        line = '';\n        for (_j = 0, _len = subarray.length; _j < _len; _j++) {\n          value = subarray[_j];\n          line += String.fromCharCode(value);\n        }\n        line = line.trim().split(/\\s+/);\n        row = {};\n        _ref2 = this.accessors;\n        for (index = _k = 0, _len1 = _ref2.length; _k < _len1; index = ++_k) {\n          accessor = _ref2[index];\n          value = line[index];\n          row[this.columns[index]] = accessor(value);\n        }\n        rows.push(row);\n      }\n      return rows;\n    };\n\n    return Table;\n\n  })(Tabular);\n\n  astro.FITS.Table = Table;\n\n  BinaryTable = (function(_super) {\n    __extends(BinaryTable, _super);\n\n    function BinaryTable() {\n      _ref1 = BinaryTable.__super__.constructor.apply(this, arguments);\n      return _ref1;\n    }\n\n    BinaryTable.prototype.typedArray = {\n      B: Uint8Array,\n      I: Uint16Array,\n      J: Uint32Array,\n      E: Float32Array,\n      D: Float64Array,\n      1: Uint8Array,\n      2: Uint16Array,\n      4: Uint32Array\n    };\n\n    BinaryTable.offsets = {\n      L: 1,\n      B: 1,\n      I: 2,\n      J: 4,\n      K: 8,\n      A: 1,\n      E: 4,\n      D: 8,\n      C: 8,\n      M: 16\n    };\n\n    BinaryTable.prototype.dataAccessors = {\n      L: function(view, offset) {\n        var val, x;\n        x = view.getInt8(offset);\n        offset += 1;\n        val = x === 84 ? true : false;\n        return [val, offset];\n      },\n      B: function(view, offset) {\n        var val;\n        val = view.getUint8(offset);\n        offset += 1;\n        return [val, offset];\n      },\n      I: function(view, offset) {\n        var val;\n        val = view.getInt16(offset);\n        offset += 2;\n        return [val, offset];\n      },\n      J: function(view, offset) {\n        var val;\n        val = view.getInt32(offset);\n        offset += 4;\n        return [val, offset];\n      },\n      K: function(view, offset) {\n        var factor, highByte, lowByte, mod, val;\n        highByte = Math.abs(view.getInt32(offset));\n        offset += 4;\n        lowByte = Math.abs(view.getInt32(offset));\n        offset += 4;\n        mod = highByte % 10;\n        factor = mod ? -1 : 1;\n        highByte -= mod;\n        val = factor * ((highByte << 32) | lowByte);\n        return [val, offset];\n      },\n      A: function(view, offset) {\n        var val;\n        val = view.getUint8(offset);\n        val = String.fromCharCode(val);\n        offset += 1;\n        return [val, offset];\n      },\n      E: function(view, offset) {\n        var val;\n        val = view.getFloat32(offset);\n        offset += 4;\n        return [val, offset];\n      },\n      D: function(view, offset) {\n        var val;\n        val = view.getFloat64(offset);\n        offset += 8;\n        return [val, offset];\n      },\n      C: function(view, offset) {\n        var val, val1, val2;\n        val1 = view.getFloat32(offset);\n        offset += 4;\n        val2 = view.getFloat32(offset);\n        offset += 4;\n        val = [val1, val2];\n        return [val, offset];\n      },\n      M: function(view, offset) {\n        var val, val1, val2;\n        val1 = view.getFloat64(offset);\n        offset += 8;\n        val2 = view.getFloat64(offset);\n        offset += 8;\n        val = [val1, val2];\n        return [val, offset];\n      }\n    };\n\n    BinaryTable.prototype.toBits = function(byte) {\n      var arr, i;\n      arr = [];\n      i = 128;\n      while (i >= 1) {\n        arr.push((byte & i ? 1 : 0));\n        i /= 2;\n      }\n      return arr;\n    };\n\n    BinaryTable.prototype.getFromHeap = function(view, offset, descriptor) {\n      var arr, heapOffset, heapSlice, i, length;\n      length = view.getInt32(offset);\n      offset += 4;\n      heapOffset = view.getInt32(offset);\n      offset += 4;\n      heapSlice = this.heap.slice(heapOffset, heapOffset + length);\n      arr = new this.typedArray[descriptor](heapSlice);\n      i = arr.length;\n      while (i--) {\n        arr[i] = this.constructor.swapEndian[descriptor](arr[i]);\n      }\n      return [arr, offset];\n    };\n\n    BinaryTable.prototype.setAccessors = function(header) {\n      var count, descriptor, form, i, isArray, match, pattern, type, _i, _ref2, _results,\n        _this = this;\n      pattern = /(\\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/;\n      _results = [];\n      for (i = _i = 1, _ref2 = this.cols; 1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 1 <= _ref2 ? ++_i : --_i) {\n        form = header.get(\"TFORM\" + i);\n        type = header.get(\"TTYPE\" + i);\n        match = pattern.exec(form);\n        count = parseInt(match[1]) || 1;\n        isArray = match[2];\n        descriptor = match[3];\n        _results.push((function(descriptor, count) {\n          var accessor, nBytes;\n          _this.descriptors.push(descriptor);\n          _this.elementByteLengths.push(_this.constructor.offsets[descriptor] * count);\n          if (isArray) {\n            switch (type) {\n              case \"COMPRESSED_DATA\":\n                accessor = function(view, offset) {\n                  var arr, pixels, _ref3;\n                  _ref3 = _this.getFromHeap(view, offset, descriptor), arr = _ref3[0], offset = _ref3[1];\n                  pixels = new _this.typedArray[_this.algorithmParameters[\"BYTEPIX\"]](_this.ztile[0]);\n                  Decompress.Rice(arr, _this.algorithmParameters[\"BLOCKSIZE\"], _this.algorithmParameters[\"BYTEPIX\"], pixels, _this.ztile[0], Decompress.RiceSetup);\n                  return [pixels, offset];\n                };\n                break;\n              case \"GZIP_COMPRESSED_DATA\":\n                accessor = function(view, offset) {\n                  var arr;\n                  arr = new Float32Array(_this.width);\n                  i = arr.length;\n                  while (i--) {\n                    arr[i] = NaN;\n                  }\n                  return [arr, offset];\n                };\n                break;\n              default:\n                accessor = function(view, offset) {\n                  return _this.getFromHeap(view, offset, descriptor);\n                };\n            }\n          } else {\n            if (count === 1) {\n              accessor = function(view, offset) {\n                var value, _ref3;\n                _ref3 = _this.dataAccessors[descriptor](view, offset), value = _ref3[0], offset = _ref3[1];\n                return [value, offset];\n              };\n            } else {\n              if (descriptor === 'X') {\n                nBytes = Math.log(count) / Math.log(2);\n                accessor = function(view, offset) {\n                  var arr, bits, buffer, byte, bytes, _j, _len;\n                  buffer = view.buffer.slice(offset, offset + nBytes);\n                  bytes = new Uint8Array(buffer);\n                  bits = [];\n                  for (_j = 0, _len = bytes.length; _j < _len; _j++) {\n                    byte = bytes[_j];\n                    arr = _this.toBits(byte);\n                    bits = bits.concat(arr);\n                  }\n                  offset += nBytes;\n                  return [bits.slice(0, +(count - 1) + 1 || 9e9), offset];\n                };\n              } else if (descriptor === 'A') {\n                accessor = function(view, offset) {\n                  var arr, buffer, s, value, _j, _len;\n                  buffer = view.buffer.slice(offset, offset + count);\n                  arr = new Uint8Array(buffer);\n                  s = '';\n                  for (_j = 0, _len = arr.length; _j < _len; _j++) {\n                    value = arr[_j];\n                    s += String.fromCharCode(value);\n                  }\n                  s = s.trim();\n                  offset += count;\n                  return [s, offset];\n                };\n              } else {\n                accessor = function(view, offset) {\n                  var data, value, _ref3;\n                  i = count;\n                  data = [];\n                  while (i--) {\n                    _ref3 = _this.dataAccessors[descriptor](view, offset), value = _ref3[0], offset = _ref3[1];\n                    data.push(value);\n                  }\n                  return [data, offset];\n                };\n              }\n            }\n          }\n          return _this.accessors.push(accessor);\n        })(descriptor, count));\n      }\n      return _results;\n    };\n\n    BinaryTable.prototype._getRows = function(buffer, nRows) {\n      var accessor, index, offset, row, rows, value, view, _i, _len, _ref2, _ref3;\n      view = new DataView(buffer);\n      offset = 0;\n      rows = [];\n      while (nRows--) {\n        row = {};\n        _ref2 = this.accessors;\n        for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {\n          accessor = _ref2[index];\n          _ref3 = accessor(view, offset), value = _ref3[0], offset = _ref3[1];\n          row[this.columns[index]] = value;\n        }\n        rows.push(row);\n      }\n      return rows;\n    };\n\n    return BinaryTable;\n\n  })(Tabular);\n\n  astro.FITS.BinaryTable = BinaryTable;\n\n  Decompress = {\n    RiceSetup: {\n      1: function(array) {\n        var fsbits, fsmax, lastpix, pointer;\n        pointer = 1;\n        fsbits = 3;\n        fsmax = 6;\n        lastpix = array[0];\n        return [fsbits, fsmax, lastpix, pointer];\n      },\n      2: function(array) {\n        var bytevalue, fsbits, fsmax, lastpix, pointer;\n        pointer = 2;\n        fsbits = 4;\n        fsmax = 14;\n        lastpix = 0;\n        bytevalue = array[0];\n        lastpix = lastpix | (bytevalue << 8);\n        bytevalue = array[1];\n        lastpix = lastpix | bytevalue;\n        return [fsbits, fsmax, lastpix, pointer];\n      },\n      4: function(array) {\n        var bytevalue, fsbits, fsmax, lastpix, pointer;\n        pointer = 4;\n        fsbits = 5;\n        fsmax = 25;\n        lastpix = 0;\n        bytevalue = array[0];\n        lastpix = lastpix | (bytevalue << 24);\n        bytevalue = array[1];\n        lastpix = lastpix | (bytevalue << 16);\n        bytevalue = array[2];\n        lastpix = lastpix | (bytevalue << 8);\n        bytevalue = array[3];\n        lastpix = lastpix | bytevalue;\n        return [fsbits, fsmax, lastpix, pointer];\n      }\n    },\n    Rice: function(array, blocksize, bytepix, pixels, nx, setup) {\n      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref2, _ref3;\n      bbits = 1 << fsbits;\n      _ref2 = setup[bytepix](array), fsbits = _ref2[0], fsmax = _ref2[1], lastpix = _ref2[2], pointer = _ref2[3];\n      nonzeroCount = new Uint8Array(256);\n      nzero = 8;\n      _ref3 = [128, 255], k = _ref3[0], i = _ref3[1];\n      while (i >= 0) {\n        while (i >= k) {\n          nonzeroCount[i] = nzero;\n          i -= 1;\n        }\n        k = k / 2;\n        nzero -= 1;\n      }\n      nonzeroCount[0] = 0;\n      b = array[pointer++];\n      nbits = 8;\n      i = 0;\n      while (i < nx) {\n        nbits -= fsbits;\n        while (nbits < 0) {\n          b = (b << 8) | array[pointer++];\n          nbits += 8;\n        }\n        fs = (b >> nbits) - 1;\n        b &= (1 << nbits) - 1;\n        imax = i + blocksize;\n        if (imax > nx) {\n          imax = nx;\n        }\n        if (fs < 0) {\n          while (i < imax) {\n            pixels[i] = lastpix;\n            i += 1;\n          }\n        } else if (fs === fsmax) {\n          while (i < imax) {\n            k = bbits - nbits;\n            diff = b << k;\n            k -= 8;\n            while (k >= 0) {\n              b = array[pointer++];\n              diff |= b << k;\n              k -= 8;\n            }\n            if (nbits > 0) {\n              b = array[pointer++];\n              diff |= b >> (-k);\n              b &= (1 << nbits) - 1;\n            } else {\n              b = 0;\n            }\n            if ((diff & 1) === 0) {\n              diff = diff >> 1;\n            } else {\n              diff = ~(diff >> 1);\n            }\n            pixels[i] = diff + lastpix;\n            lastpix = pixels[i];\n            i++;\n          }\n        } else {\n          while (i < imax) {\n            while (b === 0) {\n              nbits += 8;\n              b = array[pointer++];\n            }\n            nzero = nbits - nonzeroCount[b];\n            nbits -= nzero + 1;\n            b ^= 1 << nbits;\n            nbits -= fs;\n            while (nbits < 0) {\n              b = (b << 8) | array[pointer++];\n              nbits += 8;\n            }\n            diff = (nzero << fs) | (b >> nbits);\n            b &= (1 << nbits) - 1;\n            if ((diff & 1) === 0) {\n              diff = diff >> 1;\n            } else {\n              diff = ~(diff >> 1);\n            }\n            pixels[i] = diff + lastpix;\n            lastpix = pixels[i];\n            i++;\n          }\n        }\n      }\n      return pixels;\n    }\n  };\n\n  astro.FITS.Decompress = Decompress;\n\n  CompressedImage = (function(_super) {\n    __extends(CompressedImage, _super);\n\n    CompressedImage.include(ImageUtils);\n\n    CompressedImage.extend(Decompress);\n\n    CompressedImage.randomGenerator = function() {\n      var a, i, m, random, seed, temp, _i;\n      a = 16807;\n      m = 2147483647;\n      seed = 1;\n      random = new Float32Array(10000);\n      for (i = _i = 0; _i <= 9999; i = ++_i) {\n        temp = a * seed;\n        seed = temp - m * parseInt(temp / m);\n        random[i] = seed / m;\n      }\n      return random;\n    };\n\n    CompressedImage.randomSequence = CompressedImage.randomGenerator();\n\n    function CompressedImage(header, data) {\n      var i, key, value, ztile, _i, _ref2;\n      CompressedImage.__super__.constructor.apply(this, arguments);\n      this.zcmptype = header.get(\"ZCMPTYPE\");\n      this.zbitpix = header.get(\"ZBITPIX\");\n      this.znaxis = header.get(\"ZNAXIS\");\n      this.zblank = header.get(\"ZBLANK\");\n      this.blank = header.get(\"BLANK\");\n      this.zdither = header.get('ZDITHER0') || 0;\n      this.ztile = [];\n      for (i = _i = 1, _ref2 = this.znaxis; 1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 1 <= _ref2 ? ++_i : --_i) {\n        ztile = header.contains(\"ZTILE\" + i) ? header.get(\"ZTILE\" + i) : i === 1 ? header.get(\"ZNAXIS1\") : 1;\n        this.ztile.push(ztile);\n      }\n      this.width = header.get(\"ZNAXIS1\");\n      this.height = header.get(\"ZNAXIS2\") || 1;\n      this.algorithmParameters = {};\n      if (this.zcmptype === 'RICE_1') {\n        this.algorithmParameters[\"BLOCKSIZE\"] = 32;\n        this.algorithmParameters[\"BYTEPIX\"] = 4;\n      }\n      i = 1;\n      while (true) {\n        key = \"ZNAME\" + i;\n        if (!header.contains(key)) {\n          break;\n        }\n        value = \"ZVAL\" + i;\n        this.algorithmParameters[header.get(key)] = header.get(value);\n        i += 1;\n      }\n      this.zmaskcmp = header.get(\"ZMASKCMP\");\n      this.zquantiz = header.get(\"ZQUANTIZ\") || \"LINEAR_SCALING\";\n      this.bzero = header.get(\"BZERO\") || 0;\n      this.bscale = header.get(\"BSCALE\") || 1;\n    }\n\n    CompressedImage.prototype._getRows = function(buffer, nRows) {\n      var accessor, arr, blank, data, i, index, nTile, offset, r, rIndex, row, scale, seed0, seed1, value, view, zero, _i, _j, _len, _len1, _ref2, _ref3;\n      view = new DataView(buffer);\n      offset = 0;\n      arr = new Float32Array(this.width * this.height);\n      while (nRows--) {\n        row = {};\n        _ref2 = this.accessors;\n        for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {\n          accessor = _ref2[index];\n          _ref3 = accessor(view, offset), value = _ref3[0], offset = _ref3[1];\n          row[this.columns[index]] = value;\n        }\n        data = row['COMPRESSED_DATA'] || row['UNCOMPRESSED_DATA'] || row['GZIP_COMPRESSED_DATA'];\n        blank = row['ZBLANK'] || this.zblank;\n        scale = row['ZSCALE'] || this.bscale;\n        zero = row['ZZERO'] || this.bzero;\n        nTile = this.height - nRows;\n        seed0 = nTile + this.zdither - 1;\n        seed1 = (seed0 - 1) % 10000;\n        rIndex = parseInt(this.constructor.randomSequence[seed1] * 500);\n        for (index = _j = 0, _len1 = data.length; _j < _len1; index = ++_j) {\n          value = data[index];\n          i = (nTile - 1) * this.width + index;\n          if (value === -2147483647) {\n            arr[i] = NaN;\n          } else if (value === -2147483646) {\n            arr[i] = 0;\n          } else {\n            r = this.constructor.randomSequence[rIndex];\n            arr[i] = (value - r + 0.5) * scale + zero;\n          }\n          rIndex += 1;\n          if (rIndex === 10000) {\n            seed1 = (seed1 + 1) % 10000;\n            rIndex = parseInt(this.randomSequence[seed1] * 500);\n          }\n        }\n      }\n      return arr;\n    };\n\n    CompressedImage.prototype.getFrame = function(nFrame, callback, opts) {\n      var heapBlob, reader,\n        _this = this;\n      if (this.heap) {\n        this.frame = nFrame || this.frame;\n        return this.getRows(0, this.rows, callback, opts);\n      } else {\n        heapBlob = this.blob.slice(this.length, this.length + this.heapLength);\n        reader = new FileReader();\n        reader.onloadend = function(e) {\n          _this.heap = e.target.result;\n          return _this.getFrame(nFrame, callback, opts);\n        };\n        return reader.readAsArrayBuffer(heapBlob);\n      }\n    };\n\n    return CompressedImage;\n\n  })(BinaryTable);\n\n  astro.FITS.CompressedImage = CompressedImage;\n\n  HDU = (function() {\n    function HDU(header, data) {\n      this.header = header;\n      this.data = data;\n    }\n\n    HDU.prototype.hasData = function() {\n      if (this.data != null) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    return HDU;\n\n  })();\n\n  astro.FITS.HDU = HDU;\n\n  return astro;\n\n})();\n","\t/**\n \t* HEALPix Javascript code derived from the jhealpix Java library\n \t* \n \t* Class Constants\n \t* \n \t* @author: Thomas Boch [CDS]\n \t*/\n\n\t export let Constants = {};\n\n\t /** The Constant PI. */\n\t Constants.PI = Math.PI;//3.141592653589793238462643383279502884197;\n \n\t /** The Constant C_PR. */\n\t Constants.C_PR = Math.PI / 180;\n \n\t /** The Constant VLEV. */\n\t Constants.VLEV = 2;\n \n\t /** The Constant EPS. */\n\t Constants.EPS = 0.0000001;\n \n\t /** The Constant C. */\n\t Constants.c = 0.105;\n \n\t /** The Constant LN10. */\n\t Constants.LN10 = Math.log(10);\n \n\t /** The Constant PIOVER2. */\n\t Constants.PIOVER2 = Math.PI / 2.;\n \n\t /** The Constant TWOPI. */\n\t Constants.TWOPI = 2 * Math.PI;//6.283185307179586476925286766559005768394;// 2 * PI\n \n\t /** The Constant TWOTHIRD. */\n\t Constants.TWOTHIRD = 2. / 3.;\n \n\t /** The Constant 1 arcsecond in units of radians. */\n\t Constants.ARCSECOND_RADIAN = 4.84813681109536e-6;\n\n/**\n * HEALPix Javascript code derived from the jhealpix Java library\n * \n * Class HealpixIndex\n * \n * Main methods :\n * - ang2pix_nest\n * - pix2ang_nest\n * - nest2ring\n * - corners_nest\n * - queryDisc\n * - calculateNSide\n * \n * @author: Thomas Boch [CDS]\n */\n\n\nexport let HealpixIndex = (function () {\n\t/**\n\t * Some utility functions\n\t *\n\t * @author Thomas Boch [CDS]\n\t *\n\t */\n\n\tlet Utils = function () { }\n\n\tUtils.radecToPolar = function (ra, dec) {\n\t\treturn {\n\t\t\ttheta: Math.PI / 2. - dec / 180. * Math.PI,\n\t\t\tphi: ra / 180. * Math.PI\n\t\t};\n\t}\n\n\tUtils.polarToRadec = function (theta, phi) {\n\t\treturn {\n\t\t\tra: phi * 180. / Math.PI,\n\t\t\tdec: (Math.PI / 2. - theta) * 180. / Math.PI\n\t\t};\n\t}\n\n\n\tUtils.castToInt = function (nb) {\n\t\tif (nb > 0) {\n\t\t\treturn Math.floor(nb);\n\t\t}\n\t\telse {\n\t\t\treturn Math.ceil(nb);\n\t\t}\n\t}\n\n\t/**\n * HEALPix Javascript code derived from the jhealpix Java library\n\t* \n * Class SpatialVector\n\t* \n * @author: Thomas Boch[CDS]\n\t* /\n\n\n\n\t/**\n * HEALPix Javascript code derived from the jhealpix Java library\n * \n * Class AngularPosition\n * \n * @author: Thomas Boch [CDS]\n */\n\n\n\tlet AngularPosition = (function () {\n\n\t\t/** Constructor\n\t\t * \n\t\t *  @theta theta in radians [0, 2*Pi] \n\t\t *  @phi phi in radians [0, Pi]\n\t\t */\n\t\tfunction AngularPosition(theta, phi) {\n\t\t\t\"use strict\";\n\t\t\tthis.theta = theta;\n\t\t\tthis.phi = phi;\n\t\t};\n\n\t\tAngularPosition.prototype.toString = function () {\n\t\t\t\"use strict\";\n\t\t\treturn \"theta: \" + this.theta + \", phi: \" + this.phi;\n\t\t};\n\n\t\treturn AngularPosition;\n\t})();\n\n\t/**\n * HEALPix Javascript code derived from the jhealpix Java library\n * \n * Class LongRangeSetBuilder\n * \n * @author: Thomas Boch [CDS]\n */\n\n\tlet LongRangeSetBuilder = (function () {\n\t\t/* Constructor */\n\t\tfunction LongRangeSetBuilder() {\n\t\t\tthis.items = [];\n\t\t}\n\n\t\tLongRangeSetBuilder.prototype.appendRange = function (lo, hi) {\n\t\t\tfor (var i = lo; i <= hi; i++) {\n\t\t\t\tif (i in this.items) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis.items.push(i);\n\t\t\t}\n\t\t};\n\t\treturn LongRangeSetBuilder;\n\t})();\n\n\n\n\t/** Constructor */\n\tfunction HealpixIndex(nside) {\n\t\t\"use strict\";\n\t\tthis.nside = nside;\n\t};\n\n\t/** Constants * */\n\tHealpixIndex.NS_MAX = 16384/*536870912*/;\n\n\tHealpixIndex.ORDER_MAX = 14/*29*/;\n\n\n\t/** Available nsides ..always power of 2 ..* */\n\tHealpixIndex.NSIDELIST = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048,\n\t\t4096, 8192, 16384/*, 32768, 65536, 131072, 262144, 524288,\n                               1048576, 2097152, 4194304, 8388608, 16777216, 33554432,\n                               67108864, 134217728,  268435456, 536870912*/ ];\n\n\t// coordinate of the lowest corner of each face\n\tHealpixIndex.JRLL = [2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4];\n\tHealpixIndex.JPLL = [1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7];\n\n\tHealpixIndex.XOFFSET = [-1, -1, 0, 1, 1, 1, 0, -1];\n\tHealpixIndex.YOFFSET = [0, 1, 1, 1, 0, -1, -1, -1];\n\tHealpixIndex.FACEARRAY =\n\t\t[[8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9],   // S\n\t\t[5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8],   // SE\n\t\t[-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1],   // E\n\t\t[4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10],   // SW\n\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],   // center\n\t\t[1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4],   // NE\n\t\t[-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1],   // W\n\t\t[3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7],   // NW\n\t\t[2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]]; // N\n\tHealpixIndex.SWAPARRAY =\n\t\t[[0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3],   // S\n\t\t[0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6],   // SE\n\t\t[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],   // E\n\t\t[0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5],   // SW\n\t\t[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],   // center\n\t\t[5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0],   // NE\n\t\t[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],   // W\n\t\t[6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0],   // NW\n\t\t[3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0]]; // N\n\t/** The Constant z0. */\n\tHealpixIndex.Z0 = Constants.TWOTHIRD; // 2/3\n\n\n\n\tHealpixIndex.prototype.init = function () {\n\t\t\"use strict\";\n\t\tvar tabmax = 0x100;\n\t\tthis.ctab = new Array(tabmax);\n\t\tthis.utab = new Array(tabmax);\n\t\tfor (var m = 0; m < 0x100; ++m) {\n\t\t\tthis.ctab[m] = ((m & 0x1) | ((m & 0x2) << 7) | ((m & 0x4) >> 1) | ((m & 0x8) << 6) |\n\t\t\t\t((m & 0x10) >> 2) | ((m & 0x20) << 5) | ((m & 0x40) >> 3) | ((m & 0x80) << 4));\n\t\t\tthis.utab[m] = ((m & 0x1) | ((m & 0x2) << 1) | ((m & 0x4) << 2) | ((m & 0x8) << 3) |\n\t\t\t\t((m & 0x10) << 4) | ((m & 0x20) << 5) | ((m & 0x40) << 6) | ((m & 0x80) << 7));\n\t\t}\n\n\t\t// end tablefiller\n\t\tthis.nl2 = 2 * this.nside;\n\t\tthis.nl3 = 3 * this.nside;\n\t\tthis.nl4 = 4 * this.nside;\n\t\tthis.npface = this.nside * this.nside;\n\t\tthis.ncap = 2 * this.nside * (this.nside - 1);// points in each polar cap,\n\t\t// =0 for\n\n\t\tthis.npix = 12 * this.npface;\n\t\tthis.fact2 = 4.0 / this.npix;\n\t\tthis.fact1 = (this.nside << 1) * this.fact2;\n\n\t\tthis.order = HealpixIndex.nside2order(this.nside);\n\t}\n\n    /**\n     * calculate required nside given pixel size in arcsec\n     *\n     * @param pixsize in arcsec\n     * @return long nside parameter\n     */\n\tHealpixIndex.calculateNSide = function (pixsize) {\n\t\tvar res = 0;\n\t\tvar pixelArea = pixsize * pixsize;\n\t\tvar degrad = 180. / Constants.PI;\n\t\tvar skyArea = 4. * Constants.PI * degrad * degrad * 3600. * 3600.;\n\t\tvar npixels = Utils.castToInt(skyArea / pixelArea);\n\t\tvar nsidesq = npixels / 12;\n\t\tvar nside_req = Math.sqrt(nsidesq);\n\t\tvar mindiff = HealpixIndex.NS_MAX;\n\t\tvar indmin = 0;\n\t\tfor (var i = 0; i < HealpixIndex.NSIDELIST.length; i++) {\n\t\t\tif (Math.abs(nside_req - HealpixIndex.NSIDELIST[i]) <= mindiff) {\n\t\t\t\tmindiff = Math.abs(nside_req - HealpixIndex.NSIDELIST[i]);\n\t\t\t\tres = HealpixIndex.NSIDELIST[i];\n\t\t\t\tindmin = i;\n\t\t\t}\n\t\t\tif ((nside_req > res) && (nside_req < HealpixIndex.NS_MAX))\n\t\t\t\tres = HealpixIndex.NSIDELIST[indmin + 1];\n\t\t\tif (nside_req > HealpixIndex.NS_MAX) {\n\t\t\t\tconsole.log(\"nside cannot be bigger than \" + HealpixIndex.NS_MAX);\n\t\t\t\treturn HealpixIndex.NS_MAX;\n\t\t\t}\n\n\t\t}\n\t\treturn res;\n\t}\n    /**\n     * static method to find order from nside\n     * \n     * @param nside\n     * @return order\n     */\n\tHealpixIndex.nside2order = function (nside) {\n\t\t\"use strict\";\n\t\tif ((nside & (nside - 1)) > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn Utils.castToInt(HealpixIndex.log2(nside));\n\t}\n\n    /**\n     * Log base two\n     * \n     * @param num\n     * @return log2\n     */\n\tHealpixIndex.log2 = function (num) {\n\t\t\"use strict\";\n\t\treturn (Math.log(num) / Math.log(2));\n\t}\n\n\n    /**\n     * TESTED. Works OK for nside<=8192\n     *\n     * renders the pixel number ipix ( scheme as defined for object) for a pixel\n     * which contains a point on a sphere at coordinates theta and phi, given the\n     * map resolution parameter nside\n     * \n     * @param theta\n     *            angle (along meridian), in [0,Pi], theta=0 : north pole\n     * @param phi\n     *            angle (along parallel), in [0,2*Pi]\n     * @return pixel index number\n     * @throws Exception\n     */\n\tHealpixIndex.prototype.ang2pix_nest = function (theta, phi) {\n\t\t\"use strict\";\n\n\t\tvar ipix;\n\t\tvar z, za, tt, tp;\n\t\tvar ifp, ifm;\n\t\tvar jp, jm;\n\t\tvar ntt, face_num, ix, iy;\n\n\t\tif (phi >= Constants.TWOPI)\n\t\t\tphi = phi - Constants.TWOPI;\n\t\tif (phi < 0.)\n\t\t\tphi = phi + Constants.TWOPI;\n\t\tif (theta > Constants.PI || theta < 0) {\n\t\t\tthrow { name: \"Illegal argument\", message: \"theta must be between 0 and \" + Constants.PI };\n\t\t}\n\t\tif (phi > Constants.TWOPI || phi < 0) {\n\t\t\tthrow { name: \"Illegal argument\", message: \"phi must be between 0 and \" + Constants.TWOPI };\n\t\t}\n\n\t\tz = Math.cos(theta);\n\t\tza = Math.abs(z);\n\t\ttt = phi / Constants.PIOVER2;// in [0,4]\n\n\n\t\tif (za <= HealpixIndex.Z0) { // Equatorial region\n\t\t\t// (the index of edge lines increase when the longitude=phi goes up)\n\t\t\tvar temp1 = this.nside * (0.5 + tt);\n\t\t\tvar temp2 = this.nside * (z * 0.75);\n\n\t\t\tvar jp = (temp1 - temp2);\n\t\t\t// ascending edge line index\n\t\t\tvar jm = (temp1 + temp2);\n\t\t\t// descending edge line index\n\n\t\t\t// finds the face\n\t\t\tifp = jp >> this.order; // in {0,4}\n\t\t\tifm = jm >> this.order;\n\t\t\tif (ifp == ifm) { // faces 4 to 7\n\t\t\t\tface_num = (ifp == 4 ? 4 : ifp + 4);\n\t\t\t} else {\n\t\t\t\tif (ifp < ifm) { // (half-)faces 0 to 3\n\t\t\t\t\tface_num = ifp;\n\t\t\t\t} else { // (half-)faces 8 to 11\n\t\t\t\t\tface_num = ifm + 8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tix = Utils.castToInt(jm & (this.nside - 1));\n\t\t\tiy = Utils.castToInt(this.nside - (jp & (this.nside - 1)) - 1);\n\t\t} else { // polar region, za > 2/3\n\t\t\tntt = Utils.castToInt(tt);\n\t\t\tif (ntt >= 4)\n\t\t\t\tntt = 3;\n\t\t\ttp = tt - ntt;\n\t\t\tvar tmp = this.nside * Math.sqrt(3.0 * (1.0 - za));\n\n\n\t\t\t// (the index of edge lines increase when distance from the closest\n\t\t\t// pole goes up)\n\t\t\tjp = Utils.castToInt(tp * tmp);// line going toward the\n\t\t\t// pole as phi increases\n\t\t\tjm = Utils.castToInt((1.0 - tp) * tmp); // that one goes\n\t\t\t// away of the closest pole\n\t\t\tjp = Math.min(HealpixIndex.NS_MAX - 1, jp);\n\t\t\t// for points too close to the boundary\n\t\t\tjm = Math.min(HealpixIndex.NS_MAX - 1, jm);\n\n\n\n\t\t\t// finds the face and pixel's (x,y)\n\t\t\tif (z >= 0) { // North Pole\n\t\t\t\t// System.out.println(\"Polar z>=0 ntt:\"+ntt+\" tt:\"+tt);\n\t\t\t\tface_num = ntt; // in {0,3}\n\t\t\t\tix = Utils.castToInt(this.nside - jm - 1);\n\t\t\t\tiy = Utils.castToInt(this.nside - jp - 1);\n\n\t\t\t} else {\n\t\t\t\t// System.out.println(\"Polar z<0 ntt:\"+ntt+\" tt:\"+tt);\n\t\t\t\tface_num = ntt + 8;// in {8,11}\n\t\t\t\tix = jp;\n\t\t\t\tiy = jm;\n\t\t\t}\n\t\t}\n\n\t\tipix = this.xyf2nest(ix, iy, face_num);\n\n\t\treturn ipix;\n\t}\n\n\tHealpixIndex.prototype.xyf2nest = function (ix, iy, face_num) {\n\t\t\"use strict\";\n\t\treturn ((face_num) << (2 * this.order)) +\n\t\t\t(((this.utab[ix & 0xff]))\n\t\t\t\t| ((this.utab[(ix >> 8) & 0xff]) << 16)\n\t\t\t\t| ((this.utab[(ix >> 16) & 0xff]) << 32)\n\t\t\t\t| ((this.utab[(ix >> 24) & 0xff]) << 48)\n\t\t\t\t| ((this.utab[iy & 0xff]) << 1)\n\t\t\t\t| ((this.utab[(iy >> 8) & 0xff]) << 17)\n\t\t\t\t| ((this.utab[(iy >> 16) & 0xff]) << 33)\n\t\t\t\t| ((this.utab[(iy >> 24) & 0xff]) << 49));\n\t}\n\n\tHealpixIndex.prototype.nest2xyf = function (ipix) {\n\t\t\"use strict\";\n\t\tvar ret = {};\n\t\tret.face_num = ipix >> (2 * this.order);\n\t\tvar pix = ipix & (this.npface - 1);\n\t\t// need o check the & here - they were unsigned in cpp ...\n\t\tvar raw = (((pix & 0x555500000000) >> 16)\n\t\t\t| ((pix & 0x5555000000000000) >> 31)\n\t\t\t| (pix & 0x5555)\n\t\t\t| ((pix & 0x55550000) >> 15));\n\t\tret.ix = this.ctab[raw & 0xff]\n\t\t\t| (this.ctab[(raw >> 8) & 0xff] << 4)\n\t\t\t| (this.ctab[(raw >> 16) & 0xff] << 16)\n\t\t\t| (this.ctab[(raw >> 24) & 0xff] << 20);\n\t\tpix >>= 1;\n\t\traw = (((pix & 0x555500000000) >> 16)\n\t\t\t| ((pix & 0x5555000000000000) >> 31)\n\t\t\t| (pix & 0x5555)\n\t\t\t| ((pix & 0x55550000) >> 15));\n\t\tret.iy = this.ctab[raw & 0xff]\n\t\t\t| (this.ctab[(raw >> 8) & 0xff] << 4)\n\t\t\t| (this.ctab[(raw >> 16) & 0xff] << 16)\n\t\t\t| (this.ctab[(raw >> 24) & 0xff] << 20);\n\n\t\treturn ret;\n\t}\n\n    /**\n     * TESTED. Works OK for nside<=8192\n     * \n     * Convert from pix number to angle renders theta and phi coordinates of the\n     * nominal pixel center for the pixel number ipix (NESTED scheme) given the\n     * map resolution parameter nside\n     *\n     * @param ipix\n     *            pixel index number\n     * @return double array of [theta, phi] angles in radians [0,Pi], [0,2*Pi]\n     * @throws Exception if ipix not in expected range for norder\n     */\n\tHealpixIndex.prototype.pix2ang_nest = function (ipix) {\n\t\t\"use strict\";\n\n\t\tif (ipix < 0 || ipix > this.npix - 1) {\n\t\t\tthrow { name: \"Illegal argument\", message: \"ipix out of range\" };\n\t\t}\n\n\t\tvar x = this.nest2xyf(ipix);\n\n\t\tvar ix = x.ix;\n\t\tvar iy = x.iy;\n\t\tvar face_num = x.face_num;\n\n\t\t// TODO this c++ bit shift givesa differnt jr to the Healpix Code - why ?\n\t\tvar jr = ((HealpixIndex.JRLL[face_num] << this.order)) - ix - iy - 1;\n\t\tvar nr, z, kshift;\n\n\t\t// ring number in {1,4*nside-1}\n\n\t\tif (jr < this.nside) { // north pole region\n\t\t\tnr = jr;\n\t\t\tz = 1.0 - nr * nr * this.fact2;\n\t\t\tkshift = 0;\n\t\t} else if (jr > this.nl3) { // south pole region\n\t\t\tnr = this.nl4 - jr;\n\t\t\tz = nr * nr * this.fact2 - 1.0;\n\t\t\tkshift = 0;\n\t\t} else {\n\t\t\tnr = this.nside;\n\t\t\tz = (this.nl2 - jr) * this.fact1;\n\t\t\tkshift = (jr - this.nside) & 1;\n\t\t}\n\t\tvar theta = Math.acos(z);\n\n\t\t// computes the phi coordinate on the sphere, in [0,2Pi]\n\t\tvar jp = (HealpixIndex.JPLL[face_num] * nr + ix - iy + 1 + kshift) / 2;\n\t\t// 'phi' number in the ring in {1,4*nr}\n\t\tif (jp > this.nl4) {\n\t\t\tjp = jp - this.nl4;\n\t\t}\n\t\tif (jp < 1) {\n\t\t\tjp = jp + this.nl4;\n\t\t}\n\n\t\tvar phi = (jp - (kshift + 1) * 0.50) * (Constants.PIOVER2 / nr);\n\n\t\t// if (phi < 0)\n\t\t// phi += 2.0 * Math.PI; // phi in [0, 2pi]\n\n\t\treturn { theta: theta, phi: phi };\n\t}\n\n\tHealpixIndex.nside2Npix = function (nside) {\n\t\t\"use strict\";\n\n\t\t// check if power of 2 and if nside<NS_MAX\n\t\tif (nside < 0 || (nside & -nside) != nside || nside > HealpixIndex.NS_MAX) {\n\t\t\tthrow { name: \"Illegal argument\", message: \"nside should be >0, power of 2, <\" + HealpixIndex.NS_MAX };\n\t\t}\n\t\tvar res = 12 * nside * nside;\n\t\treturn res;\n\t}\n\n\tHealpixIndex.prototype.xyf2ring = function (ix, iy, face_num) {\n\t\t\"use strict\";\n\n\t\tvar jr = HealpixIndex.JRLL[face_num] * this.nside - ix - iy - 1;\n\n\t\tvar nr, kshift, n_before;\n\t\tif (jr < this.nside) {\n\t\t\tnr = jr;\n\t\t\tn_before = 2 * nr * (nr - 1);\n\t\t\tkshift = 0;\n\t\t}\n\t\telse if (jr > 3 * this.nside) {\n\t\t\tnr = this.nl4 - jr;\n\t\t\tn_before = this.npix - 2 * (nr + 1) * nr;\n\t\t\tkshift = 0;\n\t\t}\n\t\telse {\n\t\t\tnr = this.nside;\n\t\t\tn_before = this.ncap + (jr - this.nside) * this.nl4;\n\t\t\tkshift = (jr - this.nside) & 1;\n\t\t}\n\n\t\tvar jp = (HealpixIndex.JPLL[face_num] * nr + ix - iy + 1 + kshift) / 2;\n\t\tif (jp > this.nl4) {\n\t\t\tjp -= this.nl4;\n\t\t}\n\t\telse {\n\t\t\tif (jp < 1) {\n\t\t\t\tjp += this.nl4;\n\t\t\t}\n\t\t}\n\n\t\treturn n_before + jp - 1;\n\t}\n\n    /**\n     * \n     * TESTED. Works OK for nside<=8192\n     * \n     * performs conversion from NESTED to RING pixel number\n     *\n     * @param ipnest\n     *            pixel NEST index number\n     * @return RING pixel index number\n     * @throws Exception\n     */\n\tHealpixIndex.prototype.nest2ring = function (ipnest) {\n\t\t\"use strict\";\n\t\tvar xyf = this.nest2xyf(ipnest);\n\t\tvar ipring = this.xyf2ring(xyf.ix, xyf.iy, xyf.face_num);\n\t\treturn ipring;\n\t}\n\n    /**\n     * \n     * TESTED. Works OK for nside<=8192\n     * \n     * Returns set of points along the boundary of the given pixel in NEST\n     * scheme. Step 1 gives 4 points on the corners.\n     *\n     * @param pix\n     *            pixel index number in nest scheme\n     * @param step\n     * @return {@link SpatialVector} for each points\n     * @throws Exception\n     */\n\tHealpixIndex.prototype.corners_nest = function (pix, step) {\n\t\t\"use strict\";\n\n\t\tvar pixr = this.nest2ring(pix);\n\t\treturn this.corners_ring(pixr, step);\n\t}\n\n\n    /**\n     * Convert from pix number to angle renders theta and phi coordinates of the\n     * nominal pixel center for the pixel number ipix (RING scheme) given the\n     * map resolution parameter nside\n     *\n     * @param ipix\n     *            pixel index number\n     * @return double array of [theta, phi] angles in radians [0,Pi], [0,2*Pi]\n     * @throws Exception\n     */\n\tHealpixIndex.prototype.pix2ang_ring = function (ipix) {\n\t\t\"use strict\";\n\n\t\tvar theta, phi;\n\t\tvar iring, iphi, ip, ipix1;\n\t\tvar fodd, hip, fihip;\n\t\t// -----------------------------------------------------------------------\n\t\tif (ipix < 0 || ipix > this.npix - 1) {\n\t\t\tthrow { name: \"Illegal argument\", message: \"ipix out of range\" };\n\t\t}\n\n\t\tipix1 = ipix + 1;// in {1, npix}\n\t\tif (ipix1 <= this.ncap) { // North Polar cap -------------\n\n\t\t\thip = ipix1 / 2.0;\n\t\t\tfihip = Utils.castToInt(hip);\n\t\t\tiring = Utils.castToInt(Math.sqrt(hip - Math.sqrt(fihip))) + 1;\n\t\t\t// counted from North pole\n\t\t\tiphi = ipix1 - 2 * iring * (iring - 1);\n\n\t\t\ttheta = Math.acos(1.0 - (iring * iring * this.fact2));\n\t\t\tphi = ((iphi) - 0.50) * Constants.PI / (2.0 * iring);\n\n\t\t} else {\n\t\t\tif (ipix < (this.npix - this.ncap)) { // Equatorial region\n\t\t\t\tip = ipix - this.ncap;\n\t\t\t\tiring = (ip / this.nl4) + this.nside;// counted from North pole\n\t\t\t\tiphi = ip % this.nl4 + 1;\n\n\t\t\t\tfodd = (((iring + this.nside) & 1) > 0) ? 1 : 0.5;\n\t\t\t\t// 1 if iring+nside is odd, 1/2 otherwise\n\t\t\t\ttheta = Math.acos((this.nl2 - iring) * this.fact1);\n\t\t\t\tphi = ((iphi) - fodd) * Constants.PI\n\t\t\t\t\t/ this.nl2;\n\t\t\t} else { // South Polar cap -----------------------------------\n\t\t\t\tip = this.npix - ipix;\n\t\t\t\tiring = Utils.castToInt(0.5 * (1 + Math.sqrt(2 * ip - 1)));\n\t\t\t\t// counted from South pole\n\t\t\t\tiphi = 4 * iring + 1 - (ip - 2 * iring * (iring - 1));\n\n\t\t\t\ttheta = Math.acos(-1.0 + Math.pow(iring, 2) * this.fact2);\n\t\t\t\tphi = ((iphi) - 0.50) * Constants.PI\n\t\t\t\t\t/ (2.0 * iring);\n\n\t\t\t}\n\t\t};\n\n\t\treturn [theta, phi];\n\t}\n\n    /**\n     * return ring number for given pix in ring scheme\n     *\n     * @param ipix\n     *            pixel index number in ring scheme\n     * @return ring number\n     * @throws Exception\n     */\n\tHealpixIndex.prototype.ring = function (ipix) {\n\t\t\"use strict\";\n\t\tvar iring = 0;\n\t\tvar ipix1 = ipix + 1;// in {1, npix}\n\t\tvar ip;\n\t\tvar hip, fihip = 0;\n\t\tif (ipix1 <= this.ncap) { // North Polar cap -------------\n\t\t\thip = (ipix1 / 2.0);\n\t\t\tfihip = Utils.castToInt(hip);\n\t\t\tiring = Utils.castToInt(Math.sqrt(hip - Math.sqrt(fihip))) + 1;// counted\n\t\t\t// from\n\t\t\t// North\n\t\t\t// pole\n\t\t} else {\n\t\t\tif (ipix1 <= this.nl2 * (5 * this.nside + 1)) { // Equatorial region\n\t\t\t\t// ------\n\t\t\t\tip = Utils.castToInt(ipix1 - this.ncap - 1);\n\t\t\t\tiring = Utils.castToInt((ip / this.nl4) + this.nside);// counted from North pole\n\t\t\t} else { // South Polar cap -----------------------------------\n\t\t\t\tip = (this.npix - ipix1 + 1);\n\t\t\t\thip = (ip / 2.0);\n\t\t\t\tfihip = Utils.castToInt(hip);\n\t\t\t\tiring = Utils.castToInt(Math.sqrt(hip - Math.sqrt(fihip))) + 1;// counted\n\t\t\t\t// from\n\t\t\t\t// South\n\t\t\t\t// pole\n\t\t\t\tiring = (this.nl4 - iring);\n\t\t\t}\n\t\t}\n\t\treturn iring;\n\t}\n\n    /**\n     * integration limits in cos(theta) for a given ring i_th, i_th > 0\n     *\n     * @param i_th\n     *            ith ring\n     * @return limits\n     */\n\tHealpixIndex.prototype.integration_limits_in_costh = function (i_th) {\n\t\t\"use strict\";\n\t\tvar a, ab, b, r_n_side;\n\t\t// integration limits in cos(theta) for a given ring i_th\n\t\t// i > 0 !!!\n\t\tr_n_side = 1.0 * this.nside;\n\t\tif (i_th <= this.nside) {\n\t\t\tab = 1.0 - (Math.pow(i_th, 2.0) / 3.0) / this.npface;\n\t\t\tb = 1.0 - (Math.pow((i_th - 1), 2.0) / 3.0) / this.npface;\n\t\t\tif (i_th == this.nside) {\n\t\t\t\ta = 2.0 * (this.nside - 1.0) / 3.0 / r_n_side;\n\t\t\t} else {\n\t\t\t\ta = 1.0 - Math.pow((i_th + 1), 2) / 3.0 / this.npface;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i_th < this.nl3) {\n\t\t\t\tab = 2.0 * (2 * this.nside - i_th) / 3.0 / r_n_side;\n\t\t\t\tb = 2.0 * (2 * this.nside - i_th + 1) / 3.0 / r_n_side;\n\t\t\t\ta = 2.0 * (2 * this.nside - i_th - 1) / 3.0 / r_n_side;\n\t\t\t} else {\n\t\t\t\tif (i_th == this.nl3) {\n\t\t\t\t\tb = 2.0 * (-this.nside + 1) / 3.0 / r_n_side;\n\t\t\t\t} else {\n\t\t\t\t\tb = -1.0 + Math.pow((4 * this.nside - i_th + 1), 2) / 3.0\n\t\t\t\t\t\t/ this.npface;\n\t\t\t\t}\n\n\t\t\t\ta = -1.0 + Math.pow((this.nl4 - i_th - 1), 2) / 3.0\n\t\t\t\t\t/ this.npface;\n\t\t\t\tab = -1.0 + Math.pow((this.nl4 - i_th), 2) / 3.0 / this.npface;\n\t\t\t}\n\n\t\t}\n\t\t// END integration limits in cos(theta)\n\t\treturn [b, ab, a];\n\t}\n\n    /**\n     * calculate the points of crossing for a given theata on the boundaries of\n     * the pixel - returns the left and right phi crossings\n     *\n     * @param i_th\n     *            ith pixel\n     * @param i_phi\n     *            phi angle\n     * @param i_zone\n     *            ith zone (0,...,3), a quarter of sphere\n     * @param cos_theta\n     *            theta cosinus\n     * @return the left and right phi crossings\n     */\n\tHealpixIndex.prototype.pixel_boundaries = function (i_th, i_phi, i_zone, cos_theta) {\n\t\tvar sq3th, factor, jd, ju, ku, kd, phi_l, phi_r;\n\t\tvar r_n_side = 1.0 * this.nside;\n\n\t\t// HALF a pixel away from both poles\n\t\tif (Math.abs(cos_theta) >= 1.0 - 1.0 / 3.0 / this.npface) {\n\t\t\tphi_l = i_zone * Constants.PIOVER2;\n\t\t\tphi_r = (i_zone + 1) * Constants.PIOVER2;\n\t\t\treturn [phi_l, phi_r];\n\t\t}\n\t\t// -------\n\t\t// NORTH POLAR CAP\n\t\tif (1.50 * cos_theta >= 1.0) {\n\t\t\tsq3th = Math.sqrt(3.0 * (1.0 - cos_theta));\n\t\t\tfactor = 1.0 / r_n_side / sq3th;\n\t\t\tjd = (i_phi);\n\t\t\tju = jd - 1;\n\t\t\tku = (i_th - i_phi);\n\t\t\tkd = ku + 1;\n\n\t\t\tphi_l = Constants.PIOVER2\n\t\t\t\t* (Math.max((ju * factor), (1.0 - (kd * factor))) + i_zone);\n\t\t\tphi_r = Constants.PIOVER2\n\t\t\t\t* (Math.min((1.0 - (ku * factor)), (jd * factor)) + i_zone);\n\n\t\t} else {\n\t\t\tif (-1.0 < 1.50 * cos_theta) {\n\t\t\t\t// -------\n\t\t\t\t// -------\n\t\t\t\t// EQUATORIAL ZONE\n\t\t\t\tvar cth34 = 0.50 * (1.0 - 1.50 * cos_theta);\n\t\t\t\tvar cth34_1 = cth34 + 1.0;\n\t\t\t\tvar modfactor = (this.nside + (i_th % 2));\n\n\t\t\t\tjd = i_phi - (modfactor - i_th) / 2.0;\n\t\t\t\tju = jd - 1;\n\t\t\t\tku = (modfactor + i_th) / 2.0 - i_phi;\n\t\t\t\tkd = ku + 1;\n\n\t\t\t\tphi_l = Constants.PIOVER2\n\t\t\t\t\t* (Math.max((cth34_1 - (kd / r_n_side)),\n\t\t\t\t\t\t(-cth34 + (ju / r_n_side))) + i_zone);\n\n\t\t\t\tphi_r = Constants.PIOVER2\n\t\t\t\t\t* (Math.min((cth34_1 - (ku / r_n_side)),\n\t\t\t\t\t\t(-cth34 + (jd / r_n_side))) + i_zone);\n\t\t\t\t// -------\n\t\t\t\t// -------\n\t\t\t\t// SOUTH POLAR CAP\n\n\t\t\t} else {\n\t\t\t\tsq3th = Math.sqrt(3.0 * (1.0 + cos_theta));\n\t\t\t\tfactor = 1.0 / r_n_side / sq3th;\n\t\t\t\tvar ns2 = 2 * this.nside;\n\n\t\t\t\tjd = i_th - ns2 + i_phi;\n\t\t\t\tju = jd - 1;\n\t\t\t\tku = ns2 - i_phi;\n\t\t\t\tkd = ku + 1;\n\n\t\t\t\tphi_l = Constants.PIOVER2\n\t\t\t\t\t* (Math.max((1.0 - (ns2 - ju) * factor),\n\t\t\t\t\t\t((ns2 - kd) * factor)) + i_zone);\n\n\t\t\t\tphi_r = Constants.PIOVER2\n\t\t\t\t\t* (Math.min((1.0 - (ns2 - jd) * factor),\n\t\t\t\t\t\t((ns2 - ku) * factor)) + i_zone);\n\t\t\t}// of SOUTH POLAR CAP\n\t\t}\n\t\t// and that's it\n\t\t// System.out.println(\" nside:\"+nside+\" i_th:\"+i_th+\" i_phi:\"+i_phi+\"\n\t\t// izone:\"+i_zone+\" cos_theta:\"+cos_theta+\" phi_l:\"+phi_l+\"\n\t\t// phi_r:\"+phi_r);\n\n\t\treturn [phi_l, phi_r];\n\t}\n\n    /**\n     * Construct a {@link SpatialVector} from the angle (theta,phi)\n     *\n     * @param theta\n     *            angle (along meridian), in [0,Pi], theta=0 : north pole\n     * @param phi\n     *            angle (along parallel), in [0,2*Pi]\n     * @return vector {@link SpatialVector}\n     */\n\tHealpixIndex.vector = function (theta, phi) {\n\t\t\"use strict\";\n\t\tvar x = 1 * Math.sin(theta) * Math.cos(phi);\n\t\tvar y = 1 * Math.sin(theta) * Math.sin(phi);\n\t\tvar z = 1 * Math.cos(theta);\n\t\treturn new SpatialVector(x, y, z);\n\t}\n\n    /**\n     * Returns set of points along the boundary of the given pixel in RING\n     * scheme. Step 1 gives 4 points on the corners.\n     * Mainly for graphics = you may not want to use LARGE NSIDEs..\n     *\n     * @param pix\n     *            pixel index number in ring scheme\n     * @param step\n     * @return {@link SpatialVector} for each points\n     * @throws Exception\n     */\n\tHealpixIndex.prototype.corners_ring = function (pix, step) {\n\t\t\"use strict\";\n\n\t\tvar nPoints = step * 2 + 2;\n\t\tvar points = new Array(nPoints);\n\t\tvar p0 = this.pix2ang_ring(pix);\n\t\tvar cos_theta = Math.cos(p0[0]);\n\t\tvar theta = p0[0];\n\t\tvar phi = p0[1];\n\n\t\tvar i_zone = Utils.castToInt(phi / Constants.PIOVER2);\n\t\tvar ringno = this.ring(pix);\n\t\tvar i_phi_count = Math.min(ringno, Math.min(this.nside, (this.nl4) - ringno));\n\t\tvar i_phi = 0;\n\t\tvar phifac = Constants.PIOVER2 / i_phi_count;\n\t\tif (ringno >= this.nside && ringno <= this.nl3) {\n\t\t\t// adjust by 0.5 for odd numbered rings in equatorial since\n\t\t\t// they start out of phase by half phifac.\n\t\t\ti_phi = Utils.castToInt(phi / phifac + ((ringno % 2) / 2.0)) + 1;\n\t\t} else {\n\t\t\ti_phi = Utils.castToInt(phi / phifac) + 1;\n\t\t}\n\t\t// adjust for zone offset\n\t\ti_phi = i_phi - (i_zone * i_phi_count);\n\t\tvar spoint = (nPoints / 2);\n\n\t\t// get north south middle - middle should match theta !\n\t\tvar nms = this.integration_limits_in_costh(ringno);\n\t\tvar ntheta = Math.acos(nms[0]);\n\t\tvar stheta = Math.acos(nms[2]);\n\t\tvar philr = this.pixel_boundaries(ringno, i_phi, i_zone, nms[0]);\n\n\t\tif (i_phi > (i_phi_count / 2)) {\n\t\t\tpoints[0] = HealpixIndex.vector(ntheta, philr[1]);\n\t\t} else {\n\t\t\tpoints[0] = HealpixIndex.vector(ntheta, philr[0]);\n\t\t}\n\t\tphilr = this.pixel_boundaries(ringno, i_phi, i_zone, nms[2]);\n\t\tif (i_phi > (i_phi_count / 2)) {\n\t\t\tpoints[spoint] = HealpixIndex.vector(stheta, philr[1]);\n\t\t} else {\n\t\t\tpoints[spoint] = HealpixIndex.vector(stheta, philr[0]);\n\t\t}\n\t\tif (step == 1) {\n\t\t\tvar mtheta = Math.acos(nms[1]);\n\t\t\tphilr = this.pixel_boundaries(ringno, i_phi, i_zone, nms[1]);\n\t\t\tpoints[1] = HealpixIndex.vector(mtheta, philr[0]);\n\t\t\tpoints[3] = HealpixIndex.vector(mtheta, philr[1]);\n\t\t} else {\n\t\t\tvar cosThetaLen = nms[2] - nms[0];\n\t\t\tvar cosThetaStep = (cosThetaLen / (step + 1)); // skip\n\t\t\t// North\n\t\t\t// and south\n\t\t\tfor (var p = 1; p <= step; p++) {\n\t\t\t\t/* Integrate points along the sides */\n\t\t\t\tcos_theta = nms[0] + (cosThetaStep * p);\n\t\t\t\ttheta = Math.acos(cos_theta);\n\t\t\t\tphilr = this.pixel_boundaries(ringno, i_phi, i_zone, cos_theta);\n\t\t\t\tpoints[p] = HealpixIndex.vector(theta, philr[0]);\n\t\t\t\tpoints[nPoints - p] = HealpixIndex.vector(theta, philr[1]);\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n    /**\n     * converts a SpatialVector in a tuple of angles tup[0] = theta co-latitude\n     * measured from North pole, in [0,PI] radians, tup[1] = phi longitude\n     * measured eastward, in [0,2PI] radians\n     *\n     * @param v\n     *            SpatialVector\n     * @return double[] out_tup out_tup[0] = theta out_tup[1] = phi\n     */\n\tHealpixIndex.vec2Ang = function (v) {\n\t\t\"use strict\";\n\n\t\tvar z = v.z / v.length();\n\t\tvar theta = Math.acos(z);\n\t\tvar phi = 0.;\n\t\tif ((v.x != 0.) || (v.y != 0)) {\n\t\t\tphi = Math.atan2(v.y, v.x); // phi in [-pi,pi]\n\t\t}\n\t\tif (phi < 0)\n\t\t\tphi += 2.0 * Math.PI; // phi in [0, 2pi]\n\t\treturn [theta, phi];\n\t}\n\n    /**\n     * generates in the RING or NESTED scheme all pixels that lies within an\n     * angular distance Radius of the center.\n     *\n     * TESTED. Works OK for nside<=8192\n     *\n     * @param nside\n     *            long map resolution\n     * @param vector\n     *            Vector3d pointing to the disc center\n     * @param radius\n     *            double angular radius of the disk (in RADIAN )\n     * @param do_nest\n     *            if true, output in NESTED scheme\n     *            if false, output in RING scheme\n     * @param do_inclusive\n     *            if set to false: only pixels whose center lie in the triangle\n     *            are listed, if set to true, all pixels overlapping the triangle\n     *            are listed\n     * @return ArrayList of pixel numbers calls: RingNum(nside, ir)\n     *         InRing(nside, iz, phi0, dphi,nest)\n     */\n\tHealpixIndex.prototype.queryDisc = function (vector, radius, do_nest, do_inclusive) {\n\t\t\"use strict\";\n\n\t\tif (radius < 0.0 || radius > Constants.PI) {\n\t\t\tthrow { \"name\": \"Illegal argument\", \"message\": \"angular radius is in RADIAN and should be in [0,pi]\" };\n\t\t}\n\n\t\tvar res = new LongRangeSetBuilder();\n\t\tvar irmin, irmax, iz;\n\t\tvar ang = null;\n\t\tvar z0, radius_eff, theta, phi, cosang, x, ysq;\n\t\tvar dth1, dth2, dphi;\n\t\tvar rlat1, rlat2, zmin, zmax, z, xa;\n\n\t\tvar radius_eff = radius;\n\t\tif (do_inclusive) {\n\t\t\tradius_eff += Constants.PI / (this.nl4); // increase radius by\n\t\t\t// half pixel: different in C++ version where a 'magic' number is used.\n\t\t}\n\n\t\t// this pix back abnf fourth is ok until you put in  precise vector like a pole .\n\t\t// then it shifts the whole elipse...\n\t\tang = HealpixIndex.vec2Ang(vector);\n\n\t\ttheta = ang[0];\n\t\tphi = ang[1];\n\t\tdth1 = this.fact2;\n\t\tdth2 = this.fact1;\n\t\tz0 = Math.cos(theta);\n\t\txa = 1. / Math.sqrt((1.0 - z0) * (1.0 + z0));\n\n\t\t/* coordinate z of highest and lowest points in the disc */\n\n\t\trlat1 = theta - radius_eff;\n\t\trlat2 = theta + radius_eff;\n\n\n\t\tcosang = Math.cos(radius_eff);\n\t\tzmax = Math.cos(rlat1);\n\t\tirmin = this.ringAbove(zmax) + 1;\n\t\tzmin = Math.cos(rlat2);\n\t\tirmax = this.ringAbove(zmin);\n\n\t\tif (irmax < irmin) {// in this case no pixels are returned - need irmax=irmin to loop\n\t\t\tif (irmax == 0) {\n\t\t\t\tirmax = irmin;\n\t\t\t}\n\t\t}\n\n\t\tif (rlat1 <= 0) {// north pole in the disc\n\t\t\tfor (var m = 1; m < irmin; ++m) {// rings completely in the disc\n\t\t\t\tthis.inRing(m, 0, Math.PI, res);\n\t\t\t}\n\t\t}\n\n\t\t/* loop on ring number */\n\t\tfor (iz = irmin; iz <= irmax; ++iz) {\n\t\t\tif (iz < this.nside) { // north polar cap\n\t\t\t\tz = 1.0 - iz * iz * dth1;\n\t\t\t} else if (iz <= (this.nl3)) { // tropical band + equator\n\t\t\t\tz = (this.nl2 - iz) * dth2;\n\t\t\t} else {\n\t\t\t\tz = -1.0 + (this.nl4 - iz) * (this.nl4 - iz) * dth1;\n\t\t\t}\n\t\t\t/* find phi range in the disc for each z */\n\t\t\tx = (cosang - z * z0) * xa;\n\t\t\tysq = 1.0 - z * z - x * x;\n\t\t\t// up north (and south ?) this atan does not work\n\t\t\t// dphi becomes NaN.\n\t\t\tdphi = Math.atan2(Math.sqrt(ysq), x);\n\t\t\tif (isNaN(dphi)) {\n\t\t\t\tdphi = radius_eff;\n\t\t\t}\n\t\t\tthis.inRing(iz, phi, dphi, res);\n\n\t\t}\n\t\tif (rlat2 >= Math.PI) {// south pole in the disc\n\t\t\tfor (var m = irmax + 1; m < (this.nl4); ++m) {\n\t\t\t\t// rings completely in the disc\n\t\t\t\tthis.inRing(m, 0, Math.PI, res, false);\n\t\t\t}\n\t\t}\n\n\t\tvar ret;\n\t\tif (do_nest) {\n\t\t\tvar items = res.items;\n\t\t\tvar items_nest = [];\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\tvar nestIdx = this.ring2nest(items[i]);\n\t\t\t\tif (items_nest.indexOf(nestIdx) >= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\titems_nest.push(nestIdx);\n\t\t\t}\n\t\t\tret = items_nest;\n\t\t}\n\t\telse {\n\t\t\tret = res.items;\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n    /**\n     * returns the list of pixels in RING scheme with latitude in [phi0 -\n     * dpi, phi0 + dphi] on the ring iz in [1, 4*nside -1 ] The pixel id numbers\n     * are in [0, 12*nside^2 - 1] the indexing is in RING, unless nest is set to\n     * 1\n     * NOTE: this is the f90 code 'in_ring' method ported to java with 'conservative' flag to false\n     *\n     * @param nside\n     *            long the map resolution\n     * @param iz\n     *            long ring number\n     * @param phi0\n     *            double\n     * @param dphi\n     *            double\n     * @param res result\n     */\n\tHealpixIndex.prototype.inRing = function (iz, phi0, dphi, res, conservative) {\n\t\t\"use strict\";\n\n\t\tvar take_all = false;\n\t\tvar to_top = false;\n\n\t\t//\tString SID = \"InRing:\";\n\t\tvar epsilon = 1e-12;//Double.MIN_VALUE; // the constant to eliminate\n\t\t// java calculation jitter\n\t\tvar shift = 0.;\n\t\tvar ir = 0;\n\t\tvar kshift, nr, ipix1, ipix2;//nir1, nir2,\n\t\tvar ip_low = 0, ip_hi = 0; //,in, nir;\n\t\t//\tlong inext;\n\n\t\tvar phi_low = ((phi0 - dphi) % Constants.TWOPI) - epsilon; // phi min,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // excluding\n\t\t// 2pi period\n\t\t//\tdouble phi_low = phi0 - dphi - epsilon; // phi min,\n\t\t// excluding\n\t\tvar phi_hi = phi0 + dphi + epsilon;\n\n\t\t// this was being moduloed but why ?? around the 2pi that casues a problem\n\t\tvar phi_hi_mod = ((phi0 + dphi) % Constants.TWOPI) + epsilon;\n\n\t\t//\n\t\tif (Math.abs(dphi - Constants.PI) < epsilon) {\n\t\t\ttake_all = true;\n\t\t}\n\t\t// what happens when phi_hi wraps round ??\n\n\t\t/* identifies ring number */\n\t\tif ((iz >= this.nside) && (iz <= this.nl3)) { // equatorial region\n\t\t\tir = iz - this.nside + 1; // in [1, 2*nside + 1]\n\t\t\tipix1 = this.ncap + this.nl4 * (ir - 1); // lowest pixel number in the\n\t\t\t// ring\n\t\t\tipix2 = ipix1 + this.nl4 - 1; // highest pixel number in the ring\n\t\t\tkshift = ir % 2;\n\n\t\t\tnr = this.nl4;\n\t\t}\n\t\telse {\n\t\t\tif (iz < this.nside) { // north pole\n\t\t\t\tir = iz;\n\t\t\t\tipix1 = 2 * ir * (ir - 1); // lowest pixel number\n\t\t\t\tipix2 = ipix1 + (4 * ir) - 1; // highest pixel number\n\t\t\t} else { // south pole\n\t\t\t\tir = 4 * this.nside - iz;\n\n\t\t\t\tipix1 = this.npix - 2 * ir * (ir + 1); // lowest pixel number\n\t\t\t\tipix2 = ipix1 + 4 * ir - 1;       // highest pixel number\n\t\t\t}\n\t\t\tnr = ir * 4;\n\t\t\tkshift = 1;\n\t\t}\n\n\t\t// Construct the pixel list\n\t\tif (take_all) {\n\t\t\tres.appendRange(ipix1, ipix2);\n\t\t\treturn;\n\t\t}\n\n\t\tshift = kshift / 2.0;\n\n\t\t// conservative : include every intersected pixel, even if the\n\t\t// pixel center is out of the [phi_low, phi_hi] region\n\t\tif (conservative) {\n\t\t\tip_low = Math.round((nr * phi_low) / Constants.TWOPI - shift);\n\t\t\tip_hi = Math.round((nr * phi_hi) / Constants.TWOPI - shift);\n\n\t\t\tip_low = (ip_low % nr); // in [0, nr - 1]\n\t\t\tif (ip_hi > nr) { // ifit is =nr then this sets it to zero - not good\n\t\t\t\tip_hi = (ip_hi % nr); // in [0, nr - 1]\n\t\t\t}\n\t\t\t//\t\tSystem.out.println(\"ip_low=\"+ip_low+\" ip_hi=\"+ip_hi);\n\t\t}\n\t\telse { // strict: includes only pixels whose center is in\n\t\t\t//                                                    [phi_low,phi_hi]\n\n\t\t\tip_low = Math.ceil((nr * phi_low) / Constants.TWOPI - shift);\n\t\t\tip_hi = Utils.castToInt((nr * phi_hi_mod) / Constants.TWOPI - shift);\n\t\t\tif (ip_hi < ip_low && iz == 1) {//this is not good - problem on pole with direction.\n\t\t\t\tip_hi = Utils.castToInt((nr * phi_hi) / Constants.TWOPI - shift);\n\t\t\t}\n\t\t\tif (ip_low == ip_hi + 1) {\n\t\t\t\tip_low = ip_hi;\n\t\t\t}\n\n\t\t\tif ((ip_low - ip_hi == 1) && (dphi * nr < Constants.PI)) {\n\t\t\t\t// the interval is too small ( and away from pixel center)\n\t\t\t\t// so no pixels is included in the list\n\n\t\t\t\tconsole.log(\"the interval is too small and avay from center\");\n\n\t\t\t\treturn; // return empty list\n\t\t\t}\n\n\t\t\tip_low = Math.min(ip_low, nr - 1);\n\t\t\tip_hi = Math.max(ip_hi, 0);\n\t\t}\n\n\t\t//\n\t\tif (ip_low > ip_hi) {\n\t\t\tto_top = true;\n\t\t}\n\n\t\tif (to_top) {\n\t\t\tip_low += ipix1;\n\t\t\tip_hi += ipix1;\n\n\t\t\tres.appendRange(ipix1, ip_hi);\n\t\t\tres.appendRange(ip_low, ipix2);\n\t\t} else {\n\t\t\tif (ip_low < 0) {\n\t\t\t\tip_low = Math.abs(ip_low);\n\n\t\t\t\tres.appendRange(ipix1, ipix1 + ip_hi);\n\t\t\t\tres.appendRange(ipix2 - ip_low + 1, ipix2);\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\tip_low += ipix1;\n\t\t\tip_hi += ipix1;\n\n\t\t\tres.appendRange(ip_low, ip_hi);\n\t\t}\n\t}\n\n\tHealpixIndex.prototype.ringAbove = function (z) {\n\t\t\"use strict\";\n\n\t\tvar az = Math.abs(z);\n\t\tif (az > Constants.TWOTHIRD) { // polar caps\n\t\t\tvar iring = Utils.castToInt(this.nside * Math.sqrt(3 * (1 - az)));\n\t\t\treturn (z > 0) ? iring : 4 * this.nside - iring - 1;\n\t\t}\n\t\telse { // ----- equatorial region ---------\n\t\t\treturn Utils.castToInt(this.nside * (2.0 - 1.5 * z));\n\t\t}\n\t}\n\n\tHealpixIndex.prototype.ring2nest = function (ipring) {\n\t\t\"use strict\";\n\n\t\tvar xyf = this.ring2xyf(ipring);\n\t\treturn this.xyf2nest(xyf.ix, xyf.iy, xyf.face_num);\n\t}\n\n\tHealpixIndex.prototype.ring2xyf = function (pix) {\n\t\t\"use strict\";\n\n\t\tvar ret = {};\n\t\tvar iring, iphi, kshift, nr;\n\n\t\tif (pix < this.ncap) { // North Polar cap\n\t\t\tiring = Utils.castToInt(0.5 * (1 + Math.sqrt(1 + 2 * pix))); //counted from North pole\n\t\t\tiphi = (pix + 1) - 2 * iring * (iring - 1);\n\t\t\tkshift = 0;\n\t\t\tnr = iring;\n\t\t\tret.face_num = 0;\n\t\t\tvar tmp = iphi - 1;\n\t\t\tif (tmp >= (2 * iring)) {\n\t\t\t\tret.face_num = 2;\n\t\t\t\ttmp -= 2 * iring;\n\t\t\t}\n\t\t\tif (tmp >= iring) {\n\t\t\t\t++ret.face_num;\n\t\t\t}\n\t\t}\n\t\telse if (pix < (this.npix - this.ncap)) { // Equatorial region\n\t\t\tvar ip = pix - this.ncap;\n\t\t\tif (this.order >= 0) {\n\t\t\t\tiring = (ip >> (this.order + 2)) + this.nside; // counted from North pole\n\t\t\t\tiphi = (ip & (this.nl4 - 1)) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiring = (ip / (this.nl4)) + this.nside; // counted from North pole\n\t\t\t\tiphi = (ip % (this.nl4)) + 1;\n\t\t\t}\n\t\t\tkshift = (iring + this.nside) & 1;\n\t\t\tnr = this.nside;\n\t\t\tvar ire = iring - this.nside + 1;\n\t\t\tvar irm = this.nl2 + 2 - ire;\n\t\t\tvar ifm, ifp;\n\t\t\tif (this.order >= 0) {\n\t\t\t\tifm = (iphi - Utils.castToInt(ire / 2) + this.nside - 1) >> this.order;\n\t\t\t\tifp = (iphi - Utils.castToInt(irm / 2) + this.nside - 1) >> this.order;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tifm = (iphi - Utils.castToInt(ire / 2) + this.nside - 1) / this.nside;\n\t\t\t\tifp = (iphi - Utils.castToInt(irm / 2) + this.nside - 1) / this.nside;\n\t\t\t}\n\t\t\tif (ifp == ifm) { // faces 4 to 7\n\t\t\t\tret.face_num = (ifp == 4) ? 4 : Utils.castToInt(ifp) + 4;\n\t\t\t}\n\t\t\telse if (ifp < ifm) { // (half-)faces 0 to 3\n\t\t\t\tret.face_num = Utils.castToInt(ifp);\n\t\t\t}\n\t\t\telse { // (half-)faces 8 to 11\n\t\t\t\tret.face_num = Utils.castToInt(ifm) + 8;\n\t\t\t}\n\t\t}\n\t\telse { // South Polar cap\n\t\t\tvar ip = this.npix - pix;\n\t\t\tiring = Utils.castToInt(0.5 * (1 + Math.sqrt(2 * ip - 1))); //counted from South pole\n\t\t\tiphi = 4 * iring + 1 - (ip - 2 * iring * (iring - 1));\n\t\t\tkshift = 0;\n\t\t\tnr = iring;\n\t\t\tiring = 2 * this.nl2 - iring;\n\t\t\tret.face_num = 8;\n\t\t\tvar tmp = iphi - 1;\n\t\t\tif (tmp >= (2 * nr)) {\n\t\t\t\tret.face_num = 10;\n\t\t\t\ttmp -= 2 * nr;\n\t\t\t}\n\t\t\tif (tmp >= nr) {\n\t\t\t\t++ret.face_num;\n\t\t\t}\n\t\t}\n\n\t\tvar irt = iring - (HealpixIndex.JRLL[ret.face_num] * this.nside) + 1;\n\t\tvar ipt = 2 * iphi - HealpixIndex.JPLL[ret.face_num] * nr - kshift - 1;\n\t\tif (ipt >= this.nl2) {\n\t\t\tipt -= 8 * this.nside;\n\t\t}\n\n\n\t\tret.ix = ((ipt - irt) >> 1);\n\t\tret.iy = ((-(ipt + irt)) >> 1);\n\n\t\treturn ret;\n\t};\n\n\tHealpixIndex.utils = Utils;\n\n\treturn HealpixIndex;\n})();\n\n\n/**\n * The SpatialVector contains standard 3D vector with the addition that each\n * coordinate (x,y,z) is also kept in ra,dec since we expect the vector to live\n * on the surface of the unit sphere, i.e.\n * \n * <pre>\n *  2   2   2\n *  x + y + z  = 1\n * </pre>\n * \n * This is not enforced, so you can specify a vector that has not unit length.\n * If you request the ra/dec of such a vector, it will be automatically\n * normalized to length 1 and you get the ra/dec of that vector (the\n * intersection of the vector's direction with the unit sphere.\n * \n * This code comes originally from the HTM library of Peter Kunst during his\n * time at JHU.\n */\n\n\nexport let SpatialVector = (function () {\n\n\t/**\n\t * Constructor from three coordinates\n\t * \n\t * @param x\n\t * @param y\n\t * @param z\n\t */\n\tfunction SpatialVector(x, y, z) {\n\t\t\"use strict\";\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.ra_ = 0;\n\t\tthis.dec_ = 0;\n\t\tthis.okRaDec_ = false;\n\t}\n\t;\n\tSpatialVector.prototype.setXYZ = function (x, y, z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.okRaDec_ = false;\n\t};\n\n\t/**\n\t * Returns the length of this vector.\n\t * \n\t * @return the length of this vector\n\t */\n\tSpatialVector.prototype.length = function () {\n\t\t\"use strict\";\n\t\treturn Math.sqrt(this.lengthSquared());\n\t};\n\n\t/**\n\t * Returns the squared length of this vector.\n\t * \n\t * @return the squared length of this vector\n\t */\n\tSpatialVector.prototype.lengthSquared = function () {\n\t\t\"use strict\";\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t};\n\n\t/**\n\t * Normalized this vector\n\t */\n\tSpatialVector.prototype.normalized = function () {\n\t\t\"use strict\";\n\t\tvar d = this.length();\n\t\t// zero-div may occur.\n\t\tthis.x /= d;\n\t\tthis.y /= d;\n\t\tthis.z /= d;\n\t};\n\n\t/**\n\t * Sets the ra and dec angles in degrees\n\t * \n\t * @param ra\n\t *            right ascension angle in degrees\n\t * @param dec\n\t *            declination angle in degrees\n\t * \n\t */\n\tSpatialVector.prototype.set = function (ra, dec) {\n\t\t\"use strict\";\n\t\tthis.ra_ = ra;\n\t\tthis.dec_ = dec;\n\t\tthis.okRaDec_ = true;\n\t\tthis.updateXYZ();\n\t};\n\n\t/**\n\t * Returns the angle in radians between this vector and the vector\n\t * parameter; the return value is constrained to the range [0,PI].\n\t * \n\t * @param v1\n\t *            the other vector\n\t * @return the angle in radians in the range [0,PI]\n\t */\n\tSpatialVector.prototype.angle = function (v1) {\n\t\t\"use strict\";\n\t\t// return (double)Math.acos(dot(v1)/v1.length()/v.length());\n\t\t// Numerically, near 0 and PI are very bad condition for acos.\n\t\t// In 3-space, |atan2(sin,cos)| is much stable.\n\t\tvar xx = this.y * v1.z - this.z * v1.y;\n\t\tvar yy = this.z * v1.x - this.x * v1.z;\n\t\tvar zz = this.x * v1.y - this.y * v1.x;\n\t\tvar cross = Math.sqrt(xx * xx + yy * yy + zz * zz);\n\t\treturn Math.abs(Math.atan2(cross, dot(v1)));\n\t};\n\n\t/**\n\t * Get the coordinates in a 3 elements 1D array\n\t * \n\t * @return coordinates [x,y,z]\n\t */\n\tSpatialVector.prototype.get = function () {\n\t\t\"use strict\";\n\t\treturn [x, y, z];\n\t};\n\n\tSpatialVector.prototype.toString = function () {\n\t\t\"use strict\";\n\t\treturn \"SpatialVector[\" + this.x + \", \" + this.y + \", \" + this.z + \"]\";\n\t};\n\n\t/**\n\t * vector cross product\n\t * \n\t * @param v\n\t *            the vector to cross\n\t * @return the vector cross product\n\t */\n\tSpatialVector.prototype.cross = function (v) {\n\t\t\"use strict\";\n\t\treturn new SpatialVector(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x() * this.y);\n\t};\n\n\t/**\n\t * Compare vectors if coordinates are equals\n\t * \n\t * @param v\n\t *            the vector to be compared with\n\t * @return true if both coordinates of vectors are equal\n\t */\n\tSpatialVector.prototype.equal = function (v) {\n\t\t\"use strict\";\n\t\treturn ((this.x == v.x && this.y == v.y && this.z == v.z()) ? true : false);\n\t};\n\n\n\t/**\n\t * multiply with a number\n\t * \n\t * @param n\n\t *            the scale number to be multiply to the coordinates x,y,z\n\t * @return the vector with coordinates multiplied by n\n\t */\n\tSpatialVector.prototype.mult = function (n) {\n\t\t\"use strict\";\n\t\treturn new SpatialVector((n * this.x), (n * this.y), (n * this.z));\n\t};\n\n\t/**\n\t * Computes the dot product of the this vector and vector v1.\n\t * \n\t * @param v1\n\t *            the other vector\n\t * @return dot product\n\t */\n\tSpatialVector.prototype.dot = function (v1) {\n\t\t\"use strict\";\n\t\treturn this.x * v1.x + this.y * v1.y + this.z * v1.z;\n\t};\n\n\t/**\n\t * vector addition\n\t * \n\t * @param v\n\t *            the vector to be added\n\t * @return vector result by addition\n\t */\n\tSpatialVector.prototype.add = function (v) {\n\t\t\"use strict\";\n\t\treturn new SpatialVector(this.x + v.x, this.y + v.y, this.z + v.z);\n\t};\n\n\t/**\n\t * vector subtraction\n\t * \n\t * @param v\n\t *            the vector to be substracted\n\t * @return vector result by substraction\n\t */\n\tSpatialVector.prototype.sub = function (v) {\n\t\t\"use strict\";\n\t\treturn new SpatialVector(this.x - v.x, this.y - v.y, this.z - v.z);\n\t};\n\n\t/**\n\t * Get the dec angle in degrees\n\t * \n\t * @return declination angle\n\t */\n\tSpatialVector.prototype.dec = function () {\n\t\t\"use strict\";\n\t\tif (!this.okRaDec_) {\n\t\t\tthis.normalized();\n\t\t\tthis.updateRaDec();\n\t\t}\n\t\treturn this.dec_;\n\t};\n\n\t/**\n\t * Get the ra angle in degrees\n\t * \n\t * @return right ascension\n\t */\n\tSpatialVector.prototype.ra = function () {\n\t\t\"use strict\";\n\t\tif (!this.okRaDec_) {\n\t\t\tthis.normalized();\n\t\t\tthis.updateRaDec();\n\t\t}\n\t\treturn this.ra_;\n\t};\n\n\t/**\n\t * Update x_ y_ z_ from ra_ and dec_ variables\n\t */\n\tSpatialVector.prototype.updateXYZ = function () {\n\t\t\"use strict\";\n\t\tvar cd = Math.cos(this.dec_ * Constants.C_PR);\n\t\tthis.x = Math.cos(this.ra_ * Constants.C_PR) * cd;\n\t\tthis.y = Math.sin(this.ra_ * Constants.C_PR) * cd;\n\t\tthis.z = Math.sin(this.dec_ * Constants.C_PR);\n\t};\n\n\t/**\n\t * Update ra_ and dec_ from x_ y_ z_ variables\n\t */\n\tSpatialVector.prototype.updateRaDec = function () {\n\t\t\"use strict\";\n\t\tthis.dec_ = Math.asin(this.z) / Constants.C_PR; // easy.\n\t\tvar cd = Math.cos(this.dec_ * Constants.C_PR);\n\t\tif (cd > Constants.EPS || cd < -Constants.EPS) {\n\t\t\tif (this.y > Constants.EPS || this.y < -Constants.EPS) {\n\t\t\t\tif (this.y < 0.0) {\n\t\t\t\t\tthis.ra_ = 360 - Math.acos(this.x / cd) / Constants.C_PR;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.ra_ = Math.acos(this.x / cd) / Constants.C_PR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.ra_ = (this.x < 0.0 ? 180 : 0.0);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.ra_ = 0.0;\n\t\t}\n\t\tthis.okRaDec_ = true;\n\t};\n\n\t/**\n\t * @return Right Ascension of this vector in radians\n\t */\n\tSpatialVector.prototype.toRaRadians = function () {\n\t\t\"use strict\";\n\t\tvar phi = 0.;\n\t\tif ((this.x != 0.) || (this.y != 0)) {\n\t\t\tphi = Math.atan2(this.y, this.x); // phi in [-pi,pi]\n\t\t}\n\n\t\tif (phi < 0) {\n\t\t\tphi += 2.0 * Math.PI; // phi in [0, 2pi]\n\t\t}\n\n\t\treturn phi;\n\t};\n\n\t/**\n\t * @return Declination of this vector in radians\n\t */\n\tSpatialVector.prototype.toDeRadians = function () {\n\t\tvar z2 = z / this.length();\n\t\tvar theta = Math.acos(z2);\n\t\treturn Math.PI / 2 - theta;\n\t};\n\n\treturn SpatialVector;\n})();"],"sourceRoot":""}