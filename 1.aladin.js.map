{"version":3,"sources":["webpack:///./node_modules/@fxpineau/healpix/healpix.js","webpack:///./node_modules/@fxpineau/healpix/healpix_bg.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;;;;;;;;;;;;;ACA1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;;AAE1C;;AAEA,mDAAmD,+BAA+B;;AAElF;;AAEA;AACA;AACA,yEAAyE,uDAAW;AACpF,8CAA8C,uDAAW;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACO;AACP,cAAc,4DAAgB;AAC9B;AACA;;AAEA;AACA;AACA,6EAA6E,uDAAW;AACxF,kDAAkD,uDAAW;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,uDAAW;AACpF,8CAA8C,uDAAW;AACzD;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,uDAAW;AACtF,gDAAgD,uDAAW;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP,cAAc,+DAAmB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,aAAa;AACvB,YAAY;AACZ;AACO;AACP,2CAA2C,kEAAsB;AACjE;AACA,IAAI,oEAAwB;AAC5B;AACA;AACA;AACA,IAAI,gEAAoB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP,IAAI,6DAAiB;AACrB;AACA;AACA;AACA,IAAI,gEAAoB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP,IAAI,+DAAmB;AACvB;AACA;AACA;AACA,IAAI,gEAAoB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP,cAAc,iEAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP,cAAc,oEAAwB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP,IAAI,gEAAoB;AACxB;AACA;AACA;AACA,IAAI,gEAAoB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,aAAa;AACvB,YAAY;AACZ;AACO;AACP,kDAAkD,kEAAsB;AACxE;AACA,cAAc,uEAA2B;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,aAAa;AACvB,YAAY;AACZ;AACO;AACP,kDAAkD,kEAAsB;AACxE;AACA,IAAI,mEAAuB;AAC3B;AACA;AACA;AACA,IAAI,gEAAoB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,gEAAoB;AAC5B;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,uEAA2B;AAC7C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,yEAA6B;AAC/C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,uEAA2B;AAC7C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,yEAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA,kBAAkB,6DAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA,kBAAkB,kEAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA,kBAAkB,iEAAqB;AACvC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA,kBAAkB,iEAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,gEAAoB;AAC5B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,qEAAyB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,qEAAyB;AAC3C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,sEAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,sEAA0B;AAClC;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,2EAA+B;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,+EAAmC;AACrD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,0EAA8B;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,+EAAmC;AACrD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,4EAAgC;AAClD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,+EAAmC;AACrD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,0EAA8B;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,+EAAmC;AACrD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,2EAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,sEAA0B;AAClC;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB,+DAAmB;AACrC;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B;AACA;AACA,sDAAsD,kEAAsB;AAC5E;AACA,QAAQ,sEAA0B;AAClC;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA,QAAQ,qEAAyB;AACjC;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA,QAAQ,6EAAiC;AACzC;AACA;AACA;AACA,QAAQ,gEAAoB;AAC5B;AACA;AACA;;AAEO;AACP;AACA","file":"1.aladin.js","sourcesContent":["import * as wasm from \"./healpix_bg.wasm\";\nexport * from \"./healpix_bg.js\";","import * as wasm from './healpix_bg.wasm';\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* Returns the max order one can use in Javascipts.\n* Equals 24 since we store ou HEALPix indices on a Javascript number which is a double.\n* A double has a mantissa of 52 bits = 24 * 2 (2 bits per level) + 4 (4 bits to code base cells).\n* @returns {number}\n*/\nexport function getOrderMax() {\n    var ret = wasm.getOrderMax();\n    return ret;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8);\n    getFloat64Memory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* Returns the cell number (hash value) in the NESTED scheme associated with the given position\n* on the unit sphere\n* # Inputs\n* - `order`: the order of the HEALPix hash we want in output\n* - `lon`: longitude in degrees, support reasonably large positive and negative values\n*          producing accurate results with a naive range reduction like modulo 360\n*          (i.e. without having to resort on Cody-Waite or Payne Hanek range reduction).\n* - `lat`: latitude in degrees, must be in `[-90, 90]`\n* # Output\n* - the cell number (hash value) associated with the given position on the unit sphere,\n*   in `[0, 12*nside^2[`\n* # Panics\n*   If `lat` **not in** `[-90, 90]`, this method panics.\n* @param {number} depth\n* @param {number} lon\n* @param {number} lat\n* @returns {number}\n*/\nexport function lonlatToNested(depth, lon, lat) {\n    var ret = wasm.lonlatToNested(depth, lon, lat);\n    return ret;\n}\n\nfunction getArrayF64FromWasm0(ptr, len) {\n    return getFloat64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n/**\n* Returns the cell numbers (hash value) in the NESTED scheme associated with the given positions\n* on the unit sphere\n* # Inputs\n* - `order`: the order of the HEALPix hashes we want in output\n* - `coords`: an array storing consecutively the coordinates of the positions we look for the\n*             cell numbers: `[lon_1, lat_1, lon_2, lat_2, ..., lon_n, lat_n]`\n*   - `lon`: longitude in degrees, support reasonably large positive and negative values\n*            producing accurate results with a naive range reduction like modulo 2*pi\n*            (i.e. without having to resort on Cody-Waite or Payne Hanek range reduction).\n*   - `lat`: latitude in degrees, must be in `[-90, 90]`\n* # Output\n* - the cell number (hash value) associated with the given position on the unit sphere,\n*   in `[0, 12*nside^2[`\n* # Panics\n*   If `lat` **not in** `[-90, 90]`, this method panics.\n* @param {number} depth\n* @param {Float64Array} coords\n* @returns {Float64Array}\n*/\nexport function multiLonlatToNested(depth, coords) {\n    var ptr0 = passArrayF64ToWasm0(coords, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.multiLonlatToNested(8, depth, ptr0, len0);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v1;\n}\n\n/**\n* Compute the position on the unit sphere of the center (in the Euclidean projection plane)\n* of the cell associated to the given cell number.\n* # Input\n* - `order`: the order of the cell\n* - `icell`: the cell number value of the cell we look for the unprojected center, in the NESTED scheme\n* # Output\n* - `[lon, lat]` in degrees, the unprojected position (on the unit sphere) of the center of\n*   the cell in the Euclidean plane\n*   - `lon`, longitude in `[0, 360]` degrees;\n*   - `lat`, latitude in `[-90, 90]` degrees.\n*\n* # Panics\n* If the given `hash` value is not in `[0, 12*nside^2[`, this method panics.\n* @param {number} depth\n* @param {number} hash\n* @returns {Float64Array}\n*/\nexport function nestedCenter(depth, hash) {\n    wasm.nestedCenter(8, depth, hash);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Computes the location on the unit sphere of the 4 vertices of the given HEALPix cell\n* (define by its depth and number).\n* # Inputs\n* - `order` the order of the cell we look for the vertices\n* - `icell`: the cell number value of the cell we look for the unprojected center, in the NESTED scheme\n* # Output\n* - array containing the longitudes and latitudes (in degrees) of the vertices in the following order:\n*   `[SouthLon, SouthLat, EastLon, EastLat, NoethLon, NorthLat, WestLon, WestLat]`\n* @param {number} depth\n* @param {number} hash\n* @returns {Float64Array}\n*/\nexport function nestedVertices(depth, hash) {\n    wasm.nestedVertices(8, depth, hash);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Returns the hash values of all the neighbour cells of the cell of given cell number.\n* The given cell itself is included.\n* # Inputs\n* - `order` the order of the cell we look for the neighbours\n* - `icell` the nested number of the cell we look for the neighbours\n* @param {number} depth\n* @param {number} hash\n* @returns {Neighbours}\n*/\nexport function nestedNeighbours(depth, hash) {\n    var ret = wasm.nestedNeighbours(depth, hash);\n    return Neighbours.__wrap(ret);\n}\n\n/**\n* Returns the BMOC covered by the given cone.\n* # Inputs\n* - `order`: the maximum order of the cell in the returned BMOC\n* - `cone_lon`: cone center longitude, in degrees\n* - `cone_lat`: cone center latitude in degrees, must be in `[-90, 90]`\n* - `cone_radius`: radius of the cone, in degrees\n* # Outputs\n* - the BMOC covered by the given cone\n* @param {number} depth\n* @param {number} cone_lon\n* @param {number} cone_lat\n* @param {number} cone_radius\n* @returns {BMOC}\n*/\nexport function nestedQueryConeBMOC(depth, cone_lon, cone_lat, cone_radius) {\n    var ret = wasm.nestedQueryConeBMOC(depth, cone_lon, cone_lat, cone_radius);\n    return BMOC.__wrap(ret);\n}\n\n/**\n* Returns the flat list of HEALPix cell of given order covered by the given cone.\n* # Inputs\n* - `order`: the order of the returned cells\n* - `cone_lon`: cone center longitude, in degrees\n* - `cone_lat`: cone center latitude in degrees, must be in `[-90, 90]`\n* - `cone_radius`: radius of the cone, in degrees\n* # Outputs\n* - the flat list of HEALPix cell of given order covered by the given cone\n* @param {number} depth\n* @param {number} cone_lon\n* @param {number} cone_lat\n* @param {number} cone_radius\n* @returns {Float64Array}\n*/\nexport function nestedQueryCone(depth, cone_lon, cone_lat, cone_radius) {\n    wasm.nestedQueryCone(8, depth, cone_lon, cone_lat, cone_radius);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Returns the BMOC covered by the given polygon.\n* # Inputs\n* - `order`: the maximum order of the cell in the returned BMOC\n* - `vertices_coos`: the flat list of polygon vertices coordinates, in radians\n*    `[v1.lon, v1.lat, v2.lon, v2.lat, ..., vN.lon, vN.lat]`\n* # Outputs\n* - the BMOC covered by the given polygon\n* @param {number} depth\n* @param {Float64Array} vertices_coos\n* @returns {BMOC}\n*/\nexport function nestedQueryPolygonBMOC(depth, vertices_coos) {\n    var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.nestedQueryPolygonBMOC(depth, ptr0, len0);\n    return BMOC.__wrap(ret);\n}\n\n/**\n* Returns the BMOC covered by the given polygon.\n* # Inputs\n* - `order`: the order of the returned cells\n* - `vertices_coos`: the flat list of polygon vertices coordinates, in radians\n*    `[v1.lon, v1.lat, v2.lon, v2.lat, ..., vN.lon, vN.lat]`\n* # Outputs\n* - the BMOC covered by the given polygon\n* @param {number} depth\n* @param {Float64Array} vertices_coos\n* @returns {Float64Array}\n*/\nexport function nestedQueryPolygon(depth, vertices_coos) {\n    var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.nestedQueryPolygon(8, depth, ptr0, len0);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v1;\n}\n\n/**\n* Represents a BMOC object resulting from a cone search or a polygon query.\n* For practical reasons of data exchange between Javascript and WebAssembly, each elements\n* of a cell (depth, hash, flag) are stored in separate arrays.\n* (I firs wanted to return an array of Cell, but so far it is not possible with wasm-bindgen)\n*/\nexport class BMOC {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BMOC.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_bmoc_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get n_cells() {\n        var ret = wasm.__wbg_get_bmoc_n_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get depth_max() {\n        var ret = wasm.__wbg_get_bmoc_depth_max(this.ptr);\n        return ret;\n    }\n    /**\n    * Returns the number of cells (of various depth) in the BMOC\n    * @returns {number}\n    */\n    getSize() {\n        var ret = wasm.__wbg_get_bmoc_n_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the maximal depth of the BMOC\n    * @returns {number}\n    */\n    getDepth() {\n        var ret = wasm.__wbg_get_bmoc_depth_max(this.ptr);\n        return ret;\n    }\n    /**\n    * Utility method replacing the calls to `getCellDepth`, `getCellHash` and `getCellFlag`\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {Cell}\n    */\n    getCell(icell) {\n        var ret = wasm.bmoc_getCell(this.ptr, icell);\n        return Cell.__wrap(ret);\n    }\n    /**\n    * Returns the depth of cell number `i` in the BMOC\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {number}\n    */\n    getCellDepth(icell) {\n        var ret = wasm.bmoc_getCellDepth(this.ptr, icell);\n        return ret;\n    }\n    /**\n    * Returns the hash value (or pixel number) of the cell number `i` in the BMOC\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {number}\n    */\n    getCellHash(icell) {\n        var ret = wasm.bmoc_getCellHash(this.ptr, icell);\n        return ret;\n    }\n    /**\n    * Returns the status flag of the cell number `i` in the BMOC\n    * (`true`: cell fully covered; `false`: cell partially covered)\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {boolean}\n    */\n    getCellFlag(icell) {\n        var ret = wasm.bmoc_getCellFlag(this.ptr, icell);\n        return ret !== 0;\n    }\n}\n/**\n* Represents a BMOC cell: its depth, number and flag telling if the cell is fully/partially covered.\n*/\nexport class Cell {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Cell.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_cell_free(ptr);\n    }\n    /**\n    * The order of the HEALPix cell\n    * @returns {number}\n    */\n    get order() {\n        var ret = wasm.__wbg_get_cell_order(this.ptr);\n        return ret;\n    }\n    /**\n    * The nested HEALPix cell number\n    * @returns {number}\n    */\n    get icell() {\n        var ret = wasm.__wbg_get_cell_icell(this.ptr);\n        return ret;\n    }\n    /**\n    * The flag telling if the cell if fully or partially covered\n    * @returns {boolean}\n    */\n    get isfull() {\n        var ret = wasm.__wbg_get_cell_isfull(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Contains the list of the neighbours of the `center` HEALPix cell.\n* In general, a cell has 8 neighbours.\n* But the top and bottom corners of equatorial base cells do not have\n* north and south neighbours respectively.\n* The left most and right most corners of the polar caps base cells do not have\n* west and east corners respectively.\n*/\nexport class Neighbours {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Neighbours.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_neighbours_free(ptr);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get south() {\n        wasm.__wbg_get_neighbours_south(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get southeast() {\n        var ret = wasm.__wbg_get_neighbours_southeast(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get east() {\n        wasm.__wbg_get_neighbours_east(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get southwest() {\n        var ret = wasm.__wbg_get_neighbours_southwest(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get center() {\n        var ret = wasm.__wbg_get_neighbours_center(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get norhteast() {\n        var ret = wasm.__wbg_get_neighbours_norhteast(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get west() {\n        wasm.__wbg_get_neighbours_west(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get norhtwest() {\n        var ret = wasm.__wbg_get_neighbours_norhtwest(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get north() {\n        wasm.__wbg_get_neighbours_north(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n}\n/**\n*/\nexport class PolygonMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PolygonMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_polygonmap_free(ptr);\n    }\n    /**\n    * @returns {PolygonMap}\n    */\n    static new() {\n        var ret = wasm.polygonmap_new();\n        return PolygonMap.__wrap(ret);\n    }\n    /**\n    * Add a polygon of given identifier to the map, the provided liste is:\n    * [ra_v1_deg, dec_v1_deg, ra_v2_deg, de_v2_deg, ..., ra_vn_deg, de_vn_deg]\n    * @param {number} id\n    * @param {Float64Array} vertices_coos\n    */\n    addPolygon(id, vertices_coos) {\n        var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.polygonmap_addPolygon(this.ptr, id, ptr0, len0);\n    }\n    /**\n    * Remove the polygon of given identifier to the map.\n    * @param {number} id\n    */\n    rmPolygon(id) {\n        wasm.polygonmap_rmPolygon(this.ptr, id);\n    }\n    /**\n    * Returns the list of the identifiers of the polygon containing the given point.\n    * @param {number} ra_deg\n    * @param {number} de_deg\n    * @returns {Uint32Array}\n    */\n    polygonContaining(ra_deg, de_deg) {\n        wasm.polygonmap_polygonContaining(8, this.ptr, ra_deg, de_deg);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        var v0 = getArrayU32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v0;\n    }\n}\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n"],"sourceRoot":""}