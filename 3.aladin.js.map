{"version":3,"sources":["webpack:///./node_modules/@fxpineau/healpix/healpix_bg.js","webpack:///./node_modules/@fxpineau/healpix/healpix.js"],"names":["cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getStringFromWasm0","ptr","len","buffer","Uint8Array","subarray","getOrderMax","cachegetFloat64Memory0","getFloat64Memory0","Float64Array","WASM_VECTOR_LEN","passArrayF64ToWasm0","arg","malloc","length","set","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachegetUint32Memory0","getArrayU32FromWasm0","Uint32Array","lonlatToNested","depth","lon","lat","getArrayF64FromWasm0","multiLonlatToNested","coords","ptr0","len0","r0","r1","v1","slice","nestedCenter","hash","v0","nestedVertices","nestedNeighbours","ret","Neighbours","__wrap","nestedQueryConeBMOC","cone_lon","cone_lat","cone_radius","BMOC","nestedQueryCone","nestedQueryPolygonBMOC","vertices_coos","nestedQueryPolygon","obj","Object","create","prototype","this","icell","Cell","undefined","PolygonMap","id","ra_deg","de_deg","__wbindgen_throw","arg0","arg1","Error"],"mappings":"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","file":"3.aladin.js","sourcesContent":["import * as wasm from './healpix_bg.wasm';\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* Returns the max order one can use in Javascipts.\n* Equals 24 since we store ou HEALPix indices on a Javascript number which is a double.\n* A double has a mantissa of 52 bits = 24 * 2 (2 bits per level) + 4 (4 bits to code base cells).\n* @returns {number}\n*/\nexport function getOrderMax() {\n    var ret = wasm.getOrderMax();\n    return ret;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8);\n    getFloat64Memory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* Returns the cell number (hash value) in the NESTED scheme associated with the given position\n* on the unit sphere\n* # Inputs\n* - `order`: the order of the HEALPix hash we want in output\n* - `lon`: longitude in degrees, support reasonably large positive and negative values\n*          producing accurate results with a naive range reduction like modulo 360\n*          (i.e. without having to resort on Cody-Waite or Payne Hanek range reduction).\n* - `lat`: latitude in degrees, must be in `[-90, 90]`\n* # Output\n* - the cell number (hash value) associated with the given position on the unit sphere,\n*   in `[0, 12*nside^2[`\n* # Panics\n*   If `lat` **not in** `[-90, 90]`, this method panics.\n* @param {number} depth\n* @param {number} lon\n* @param {number} lat\n* @returns {number}\n*/\nexport function lonlatToNested(depth, lon, lat) {\n    var ret = wasm.lonlatToNested(depth, lon, lat);\n    return ret;\n}\n\nfunction getArrayF64FromWasm0(ptr, len) {\n    return getFloat64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n/**\n* Returns the cell numbers (hash value) in the NESTED scheme associated with the given positions\n* on the unit sphere\n* # Inputs\n* - `order`: the order of the HEALPix hashes we want in output\n* - `coords`: an array storing consecutively the coordinates of the positions we look for the\n*             cell numbers: `[lon_1, lat_1, lon_2, lat_2, ..., lon_n, lat_n]`\n*   - `lon`: longitude in degrees, support reasonably large positive and negative values\n*            producing accurate results with a naive range reduction like modulo 2*pi\n*            (i.e. without having to resort on Cody-Waite or Payne Hanek range reduction).\n*   - `lat`: latitude in degrees, must be in `[-90, 90]`\n* # Output\n* - the cell number (hash value) associated with the given position on the unit sphere,\n*   in `[0, 12*nside^2[`\n* # Panics\n*   If `lat` **not in** `[-90, 90]`, this method panics.\n* @param {number} depth\n* @param {Float64Array} coords\n* @returns {Float64Array}\n*/\nexport function multiLonlatToNested(depth, coords) {\n    var ptr0 = passArrayF64ToWasm0(coords, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.multiLonlatToNested(8, depth, ptr0, len0);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v1;\n}\n\n/**\n* Compute the position on the unit sphere of the center (in the Euclidean projection plane)\n* of the cell associated to the given cell number.\n* # Input\n* - `order`: the order of the cell\n* - `icell`: the cell number value of the cell we look for the unprojected center, in the NESTED scheme\n* # Output\n* - `[lon, lat]` in degrees, the unprojected position (on the unit sphere) of the center of\n*   the cell in the Euclidean plane\n*   - `lon`, longitude in `[0, 360]` degrees;\n*   - `lat`, latitude in `[-90, 90]` degrees.\n*\n* # Panics\n* If the given `hash` value is not in `[0, 12*nside^2[`, this method panics.\n* @param {number} depth\n* @param {number} hash\n* @returns {Float64Array}\n*/\nexport function nestedCenter(depth, hash) {\n    wasm.nestedCenter(8, depth, hash);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Computes the location on the unit sphere of the 4 vertices of the given HEALPix cell\n* (define by its depth and number).\n* # Inputs\n* - `order` the order of the cell we look for the vertices\n* - `icell`: the cell number value of the cell we look for the unprojected center, in the NESTED scheme\n* # Output\n* - array containing the longitudes and latitudes (in degrees) of the vertices in the following order:\n*   `[SouthLon, SouthLat, EastLon, EastLat, NoethLon, NorthLat, WestLon, WestLat]`\n* @param {number} depth\n* @param {number} hash\n* @returns {Float64Array}\n*/\nexport function nestedVertices(depth, hash) {\n    wasm.nestedVertices(8, depth, hash);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Returns the hash values of all the neighbour cells of the cell of given cell number.\n* The given cell itself is included.\n* # Inputs\n* - `order` the order of the cell we look for the neighbours\n* - `icell` the nested number of the cell we look for the neighbours\n* @param {number} depth\n* @param {number} hash\n* @returns {Neighbours}\n*/\nexport function nestedNeighbours(depth, hash) {\n    var ret = wasm.nestedNeighbours(depth, hash);\n    return Neighbours.__wrap(ret);\n}\n\n/**\n* Returns the BMOC covered by the given cone.\n* # Inputs\n* - `order`: the maximum order of the cell in the returned BMOC\n* - `cone_lon`: cone center longitude, in degrees\n* - `cone_lat`: cone center latitude in degrees, must be in `[-90, 90]`\n* - `cone_radius`: radius of the cone, in degrees\n* # Outputs\n* - the BMOC covered by the given cone\n* @param {number} depth\n* @param {number} cone_lon\n* @param {number} cone_lat\n* @param {number} cone_radius\n* @returns {BMOC}\n*/\nexport function nestedQueryConeBMOC(depth, cone_lon, cone_lat, cone_radius) {\n    var ret = wasm.nestedQueryConeBMOC(depth, cone_lon, cone_lat, cone_radius);\n    return BMOC.__wrap(ret);\n}\n\n/**\n* Returns the flat list of HEALPix cell of given order covered by the given cone.\n* # Inputs\n* - `order`: the order of the returned cells\n* - `cone_lon`: cone center longitude, in degrees\n* - `cone_lat`: cone center latitude in degrees, must be in `[-90, 90]`\n* - `cone_radius`: radius of the cone, in degrees\n* # Outputs\n* - the flat list of HEALPix cell of given order covered by the given cone\n* @param {number} depth\n* @param {number} cone_lon\n* @param {number} cone_lat\n* @param {number} cone_radius\n* @returns {Float64Array}\n*/\nexport function nestedQueryCone(depth, cone_lon, cone_lat, cone_radius) {\n    wasm.nestedQueryCone(8, depth, cone_lon, cone_lat, cone_radius);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v0 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v0;\n}\n\n/**\n* Returns the BMOC covered by the given polygon.\n* # Inputs\n* - `order`: the maximum order of the cell in the returned BMOC\n* - `vertices_coos`: the flat list of polygon vertices coordinates, in radians\n*    `[v1.lon, v1.lat, v2.lon, v2.lat, ..., vN.lon, vN.lat]`\n* # Outputs\n* - the BMOC covered by the given polygon\n* @param {number} depth\n* @param {Float64Array} vertices_coos\n* @returns {BMOC}\n*/\nexport function nestedQueryPolygonBMOC(depth, vertices_coos) {\n    var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.nestedQueryPolygonBMOC(depth, ptr0, len0);\n    return BMOC.__wrap(ret);\n}\n\n/**\n* Returns the BMOC covered by the given polygon.\n* # Inputs\n* - `order`: the order of the returned cells\n* - `vertices_coos`: the flat list of polygon vertices coordinates, in radians\n*    `[v1.lon, v1.lat, v2.lon, v2.lat, ..., vN.lon, vN.lat]`\n* # Outputs\n* - the BMOC covered by the given polygon\n* @param {number} depth\n* @param {Float64Array} vertices_coos\n* @returns {Float64Array}\n*/\nexport function nestedQueryPolygon(depth, vertices_coos) {\n    var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.nestedQueryPolygon(8, depth, ptr0, len0);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayF64FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 8);\n    return v1;\n}\n\n/**\n* Represents a BMOC object resulting from a cone search or a polygon query.\n* For practical reasons of data exchange between Javascript and WebAssembly, each elements\n* of a cell (depth, hash, flag) are stored in separate arrays.\n* (I firs wanted to return an array of Cell, but so far it is not possible with wasm-bindgen)\n*/\nexport class BMOC {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BMOC.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_bmoc_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get n_cells() {\n        var ret = wasm.__wbg_get_bmoc_n_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get depth_max() {\n        var ret = wasm.__wbg_get_bmoc_depth_max(this.ptr);\n        return ret;\n    }\n    /**\n    * Returns the number of cells (of various depth) in the BMOC\n    * @returns {number}\n    */\n    getSize() {\n        var ret = wasm.__wbg_get_bmoc_n_cells(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the maximal depth of the BMOC\n    * @returns {number}\n    */\n    getDepth() {\n        var ret = wasm.__wbg_get_bmoc_depth_max(this.ptr);\n        return ret;\n    }\n    /**\n    * Utility method replacing the calls to `getCellDepth`, `getCellHash` and `getCellFlag`\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {Cell}\n    */\n    getCell(icell) {\n        var ret = wasm.bmoc_getCell(this.ptr, icell);\n        return Cell.__wrap(ret);\n    }\n    /**\n    * Returns the depth of cell number `i` in the BMOC\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {number}\n    */\n    getCellDepth(icell) {\n        var ret = wasm.bmoc_getCellDepth(this.ptr, icell);\n        return ret;\n    }\n    /**\n    * Returns the hash value (or pixel number) of the cell number `i` in the BMOC\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {number}\n    */\n    getCellHash(icell) {\n        var ret = wasm.bmoc_getCellHash(this.ptr, icell);\n        return ret;\n    }\n    /**\n    * Returns the status flag of the cell number `i` in the BMOC\n    * (`true`: cell fully covered; `false`: cell partially covered)\n    * # Inputs\n    * - `i` the index of the cell in the BMOC\n    * @param {number} icell\n    * @returns {boolean}\n    */\n    getCellFlag(icell) {\n        var ret = wasm.bmoc_getCellFlag(this.ptr, icell);\n        return ret !== 0;\n    }\n}\n/**\n* Represents a BMOC cell: its depth, number and flag telling if the cell is fully/partially covered.\n*/\nexport class Cell {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Cell.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_cell_free(ptr);\n    }\n    /**\n    * The order of the HEALPix cell\n    * @returns {number}\n    */\n    get order() {\n        var ret = wasm.__wbg_get_cell_order(this.ptr);\n        return ret;\n    }\n    /**\n    * The nested HEALPix cell number\n    * @returns {number}\n    */\n    get icell() {\n        var ret = wasm.__wbg_get_cell_icell(this.ptr);\n        return ret;\n    }\n    /**\n    * The flag telling if the cell if fully or partially covered\n    * @returns {boolean}\n    */\n    get isfull() {\n        var ret = wasm.__wbg_get_cell_isfull(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Contains the list of the neighbours of the `center` HEALPix cell.\n* In general, a cell has 8 neighbours.\n* But the top and bottom corners of equatorial base cells do not have\n* north and south neighbours respectively.\n* The left most and right most corners of the polar caps base cells do not have\n* west and east corners respectively.\n*/\nexport class Neighbours {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Neighbours.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_neighbours_free(ptr);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get south() {\n        wasm.__wbg_get_neighbours_south(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get southeast() {\n        var ret = wasm.__wbg_get_neighbours_southeast(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get east() {\n        wasm.__wbg_get_neighbours_east(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get southwest() {\n        var ret = wasm.__wbg_get_neighbours_southwest(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get center() {\n        var ret = wasm.__wbg_get_neighbours_center(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get norhteast() {\n        var ret = wasm.__wbg_get_neighbours_norhteast(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get west() {\n        wasm.__wbg_get_neighbours_west(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n    /**\n    * @returns {number}\n    */\n    get norhtwest() {\n        var ret = wasm.__wbg_get_neighbours_norhtwest(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    get north() {\n        wasm.__wbg_get_neighbours_north(8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getFloat64Memory0()[8 / 8 + 1];\n        return r0 === 0 ? undefined : r1;\n    }\n}\n/**\n*/\nexport class PolygonMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PolygonMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        wasm.__wbg_polygonmap_free(ptr);\n    }\n    /**\n    * @returns {PolygonMap}\n    */\n    static new() {\n        var ret = wasm.polygonmap_new();\n        return PolygonMap.__wrap(ret);\n    }\n    /**\n    * Add a polygon of given identifier to the map, the provided liste is:\n    * [ra_v1_deg, dec_v1_deg, ra_v2_deg, de_v2_deg, ..., ra_vn_deg, de_vn_deg]\n    * @param {number} id\n    * @param {Float64Array} vertices_coos\n    */\n    addPolygon(id, vertices_coos) {\n        var ptr0 = passArrayF64ToWasm0(vertices_coos, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.polygonmap_addPolygon(this.ptr, id, ptr0, len0);\n    }\n    /**\n    * Remove the polygon of given identifier to the map.\n    * @param {number} id\n    */\n    rmPolygon(id) {\n        wasm.polygonmap_rmPolygon(this.ptr, id);\n    }\n    /**\n    * Returns the list of the identifiers of the polygon containing the given point.\n    * @param {number} ra_deg\n    * @param {number} de_deg\n    * @returns {Uint32Array}\n    */\n    polygonContaining(ra_deg, de_deg) {\n        wasm.polygonmap_polygonContaining(8, this.ptr, ra_deg, de_deg);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        var v0 = getArrayU32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v0;\n    }\n}\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n","import * as wasm from \"./healpix_bg.wasm\";\nexport * from \"./healpix_bg.js\";"],"sourceRoot":""}