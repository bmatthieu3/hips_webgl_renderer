(()=>{var n,e,t,i,a,o,r,l,s,c,f,u,p,_,h,d,v,m,g,w,b,I,P,T,S,C,k,D,q,R,O,M,L,E,N,F,j,H,U,V,B,G,X,J,Y,Z,W,K,Q,nn,en,tn,an,on,rn,ln,sn,cn,fn,un,pn,_n,hn,dn,vn,mn,xn,gn,yn,wn,bn,In,Pn,zn,Tn,Sn,Cn,An,kn,Dn,qn,Rn,On,Mn,Ln,En,Nn,Fn,jn,Hn,Un,Vn,Bn,Gn,Xn,Jn,$n,Yn,Zn,Wn,Kn,Qn,ne,ee,te,ie,ae,oe,re,le,se,ce,fe,ue,pe,_e,he,de,ve,me,xe,ge,ye,we,be,Ie,Pe,ze,Te,Se,Ce,Ae,ke,De,qe,Re,Oe,Me,Le,Ee,Ne,Fe,je,He,Ue,Ve,Be,Ge,Xe,Je,$e,Ye,Ze,We,Ke,Qe,nt,et,tt,it,at,ot,rt,lt,st,ct,ft,ut,pt,_t,ht,dt,vt,mt,xt,gt,yt,wt,bt,It,Pt,zt,Tt,St,Ct,At,kt,Dt,qt,Rt,Ot,Mt,Lt,Et,Nt,Ft,jt,Ht,Ut,Vt,Bt,Gt,Xt,Jt,$t,Yt,Zt,Wt,Kt,Qt,ni,ei,ti,ii,ai,oi,ri,li,si,ci,fi,ui,pi,_i,hi,di,vi,mi,xi={6706:n=>{n.exports="precision lowp float;\n\nattribute vec2 offset;\nattribute vec2 uv;\nattribute vec3 center;\nattribute vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 model;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_aitoff(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.0, 1.0);\n\n    out_uv = uv;\n    out_p = p;\n}"},1682:n=>{n.exports="precision lowp float;\nattribute vec2 offset;\nattribute vec2 uv;\nattribute vec3 center;\nattribute vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_arc(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.0, 1.0);\n\n    out_uv = uv;\n    out_p = p;\n}"},7776:n=>{n.exports="precision lowp float;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nuniform sampler2D kernel_texture;\nuniform float fov;\nuniform float strength;\nvoid main() {\n    vec4 color = texture2D(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\n    color.r *= strength;\n\n    gl_FragColor = color;\n}"},7263:n=>{n.exports="precision lowp float;\n\nattribute vec2 offset;\nattribute in vec2 uv;\nattribute in vec3 center;\nattribute in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_mercator(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.0, 1.0);\n\n    out_uv = uv;\n    out_p = p;\n}"},2860:n=>{n.exports="precision lowp float;\nattribute vec2 offset;\nattribute vec2 uv;\nattribute vec3 center;\nattribute vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_mollweide(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.0, 1.0);\n\n    out_uv = uv;\n    out_p = p;\n}"},3380:n=>{n.exports="precision lowp float;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nuniform sampler2D kernel_texture;\nuniform float fov;\nuniform float strength;\nvoid main() {\n    if (out_p.z < 0.0) {\n        discard;\n    }\n\n    vec4 color = texture2D(kernel_texture, out_uv).rgba / max(log2(fov*100.0), 1.0);\n    color.r *= strength;\n\n    gl_FragColor = color;\n}"},6496:n=>{n.exports="precision lowp float;\nattribute vec2 offset;\nattribute vec2 uv;\nattribute vec3 center;\nattribute vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_orthographic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.0, 1.0);\n\n    out_uv = uv;\n    out_p = p;\n}"},5126:n=>{n.exports="precision lowp float;\n\nattribute vec2 offset;\nattribute vec2 uv;\nattribute vec3 center;\nattribute vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nvarying vec2 out_uv;\nvarying vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_gnomonic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.0, 1.0);\n\n    out_uv = uv;\n    out_p = p;\n}"},659:n=>{n.exports="precision lowp float;\nprecision lowp sampler2D;\n\nvarying vec2 out_uv;\n\nuniform sampler2D texture_fbo;\nuniform float alpha;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\n\nvoid main() {\n    float opacity = texture2D(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.0, 0.1, opacity);\n\n    vec4 color = colormap_f(opacity);\n    color.a = o * alpha;\n\n    gl_FragColor = color;\n}"},8686:n=>{n.exports="precision lowp float;\nprecision lowp sampler2D;\n\nattribute vec2 position;\nattribute vec2 uv;\n\nvarying vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n    out_uv = uv;\n}"},8010:n=>{n.exports="precision mediump float;\n\nvarying vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform mat4 inv_model;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_aitoff(vec2 pos_clip_space) {\n    if(!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    vec2 uv = vec2(pos_clip_space.x * PI * 0.5, pos_clip_space.y * PI);\n    //da uv a lat/lon\n    float c = length(uv);\n\n    float phi = asin(uv.y * sin(c) / c);\n    float theta = atan(uv.x * sin(c), c * cos(c)) * 2.0;\n\n    vec3 world = vec3(\n        sin(theta) * cos(phi),\n        sin(phi),\n        cos(theta) * cos(phi)\n    );\n    return world;\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 posmodel = pos_model;\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(posmodel, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, posmodel));\n\n    vec3 h_model = normalize(posmodel - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.0));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_aitoff(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    vec3 posmodel = pos_model;\n    float y = atan(posmodel.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < 20; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n        if(i == num_meridians - 1) {\n            break;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < 10; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n        if(i == num_parallels - 1) {\n            break;\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.0);\n\n    vec3 pos_world = clip2world_aitoff(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.0));\n\n    float alpha = grid_alpha(pos_model);\n    vec4 color = mix(color, transparency, alpha);\n    gl_FragColor = color;\n}"},3845:n=>{n.exports="precision mediump float;\n\nvarying vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nfloat sinc_positive(float x) {\n    if (x > 1.0e-4) {\n        return sin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        x = x*x;\n        return 1.0 - x * (1.0 - x / 20.0) / 6.0;\n    }\n}\n\nvec3 clip2world_arc(vec2 pos_clip_space) {\n    // r <= pi\n    float x = pos_clip_space.x * PI;\n    float y = pos_clip_space.y * PI;\n    float r = length(vec2(x, y));\n    if (r <= PI) {\n        float z = cos(r);\n        r = sinc_positive(r);\n\n        return vec3(x * r, y * r, z);\n    }\n    discard;\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.0));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    h_world = check_inversed_longitude(h_world);\n    vec2 h_clip = world2clip_arc(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < 20; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n        if(i == num_meridians - 1) {\n            break;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < 10; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n        if(i == num_parallels - 1) {\n            break;\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.0);\n\n    vec3 pos_world = clip2world_arc(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.0));\n    float alpha = grid_alpha(pos_model);\n    gl_FragColor = mix(color, transparency, alpha);\n}"},1403:n=>{n.exports="precision mediump float;\n\nattribute vec2 position;\n\nvarying vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * czf);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},6843:n=>{n.exports="precision lowp float;\n\nuniform vec4 color;\n\nvoid main() {\n    gl_FragColor = color;\n}"},5437:n=>{n.exports="precision lowp float;\n\nattribute vec2 ndc_pos;\n\nvoid main() {\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n}"},721:n=>{n.exports="precision mediump float;\n\nvarying vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nfloat sinh(float x) {\n    return 0.5*(exp(x) - exp(-x));\n}\n\nvec3 clip2world_mercator(vec2 p) {\n    float theta = p.x * PI;\n    float delta = atan(sinh(p.y)) * PI;\n\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.0));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mercator(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < 20; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n        if(i == num_meridians - 1) {\n            break;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < 10; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n        if(i == num_parallels - 1) {\n            break;\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.0);\n\n    vec3 pos_world = clip2world_mercator(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.0));\n\n    float alpha = grid_alpha(pos_model);\n    gl_FragColor = mix(color, transparency, alpha);\n}"},8428:n=>{n.exports="precision mediump float;\n\nvarying vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_mollweide(vec2 pos_clip_space) {\n    if (!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    float y2 = pos_clip_space.y * pos_clip_space.y;\n    float k = sqrt(1.0 - 4.0 * y2);\n\n    float theta = PI * pos_clip_space.x / k;\n    float delta = asin((2.0 * asin(2.0 * pos_clip_space.y) + 4.0 * pos_clip_space.y * k) / PI);\n    \n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.0));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mollweide(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < 20; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n        if(i == num_meridians - 1) {\n            break;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < 10; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n        if(i == num_parallels - 1) {\n            break;\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.0);\n\n    vec3 pos_world = clip2world_mollweide(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.0));\n\n    float alpha = grid_alpha(pos_model);\n    gl_FragColor = mix(color, transparency, alpha);\n}"},6175:n=>{n.exports="precision mediump float;\n\nvarying vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvec3 clip2world_orthographic(vec2 pos_clip_space) {\n    float z = 1.0 - dot(pos_clip_space, pos_clip_space);\n    if (z > 0.0) {\n        return vec3(pos_clip_space.x, pos_clip_space.y, sqrt(z));\n    } else {\n        discard;\n    }\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.0));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_orthographic(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d*2.0;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < 20; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n\n        if(i == num_meridians - 1) {\n            break;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < 10; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n\n        if(i == num_parallels - 1) {\n            break;\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.0);\n\n    vec3 pos_world = clip2world_orthographic(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.0));\n\n    float alpha = grid_alpha(pos_model);\n    gl_FragColor = mix(color, transparency, alpha);\n}"},1417:n=>{n.exports="precision mediump float;\n\nvarying vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_gnomonic(vec2 pos_clip_space) {\n    float x_2d = pos_clip_space.x * PI;\n    float y_2d = pos_clip_space.y * PI;\n    float r = x_2d * x_2d + y_2d * y_2d;\n\n    float z = sqrt(1.0 + r);\n    return vec3(z * x_2d, z * y_2d, z);\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.0));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_gnomonic(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < 20; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n        if(i == num_meridians - 1) {\n            break;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < 10; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n        \n        if(i == num_parallels - 1) {\n            break;\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.0);\n\n    vec3 pos_world = clip2world_gnomonic(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = normalize(vec3(to_galactic * model * vec4(pos_world, 1.0)));\n    float alpha = grid_alpha(pos_model);\n    gl_FragColor = mix(color, transparency, alpha);\n}"},7084:n=>{n.exports="precision mediump float;\nprecision mediump int;\n\nattribute vec2 ndc_pos;\nattribute vec3 uv_start;\nattribute vec3 uv_end;\nattribute float time_tile_received;\nattribute float m0;\nattribute float m1;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_aitoff(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.0, 1.0);\n    m_start = m0;\n    m_end = m1;\n}"},70:n=>{n.exports="precision mediump float;\nprecision mediump int;\n\nattribute vec2 ndc_pos;\nattribute vec3 uv_start;\nattribute vec3 uv_end;\nattribute float time_tile_received;\nattribute float m0;\nattribute float m1;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_arc(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.0, 1.0);\n    m_start = m0;\n    m_end = m1;\n}"},422:n=>{n.exports="precision mediump float;\nprecision mediump sampler2D;\nprecision mediump int;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform float opacity;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture2D(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture2D(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture2D(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nvoid main() {\n    vec4 color_start = get_color_from_texture(frag_uv_start);\n    vec4 color_end = get_color_from_texture(frag_uv_end);\n\n    vec4 out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = opacity * out_frag_color.a;\n\n    gl_FragColor = out_frag_color;\n}"},3241:n=>{n.exports="precision mediump float;\nprecision mediump int;\n\nattribute vec2 ndc_pos;\nattribute vec3 uv_start;\nattribute vec3 uv_end;\nattribute float time_tile_received;\nattribute float m0;\nattribute float m1;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_gnomonic(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.0, 1.0);\n    m_start = m0;\n    m_end = m1;\n}"},8462:n=>{n.exports="precision mediump float;\nprecision mediump sampler2D;\nprecision mediump int;\n\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture2D(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture2D(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture2D(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = mix(get_color_from_grayscale_texture(uv), vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    vec4 out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n\n    gl_FragColor = out_frag_color;\n}\n\n"},2609:n=>{n.exports="precision mediump float;\nprecision mediump sampler2D;\nprecision mediump int;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture2D(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture2D(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture2D(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 c = get_colormap_from_grayscale_texture(uv);\n    vec4 color = mix(c, vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    vec4 out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n\n    gl_FragColor = out_frag_color;\n}"},7884:n=>{n.exports="precision mediump float;\nprecision mediump int;\n\nattribute vec2 ndc_pos;\nattribute vec3 uv_start;\nattribute vec3 uv_end;\nattribute float time_tile_received;\nattribute float m0;\nattribute float m1;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_mercator(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.0, 1.0);\n    m_start = m0;\n    m_end = m1;\n}"},9336:n=>{n.exports="precision mediump float;\nprecision mediump int;\n\nattribute vec2 ndc_pos;\nattribute vec3 uv_start;\nattribute vec3 uv_end;\nattribute float time_tile_received;\nattribute float m0;\nattribute float m1;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_mollweide(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.0, 1.0);\n    m_start = m0;\n    m_end = m1;\n}"},3979:n=>{n.exports="precision mediump float;\nprecision mediump int;\n\nattribute vec2 ndc_pos;\nattribute vec3 uv_start;\nattribute vec3 uv_end;\nattribute float time_tile_received;\nattribute float m0;\nattribute float m1;\n\nvarying vec3 frag_uv_start;\nvarying vec3 frag_uv_end;\nvarying float frag_blending_factor;\nvarying float m_start;\nvarying float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.0;\n    if (alpha > 1e-3) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.0 * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nconst int max_iter = 10;\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    for (int k = 0; k < max_iter; k++) {\n        phi = phi - f / (1.0 + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        if (abs(f) <= 1e-6) {\n            break;\n        }\n    }\n\n    phi = phi * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5 * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_orthographic(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.0, 1.0);\n    m_start = m0;\n    m_end = m1;\n}"},8250:n=>{n.exports="precision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nvarying vec3 out_vert_pos;\nvarying vec2 out_clip_pos;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\nuniform Tile textures_tiles[192];\nuniform int num_tiles;\n\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture2D(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture2D(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture2D(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718;\nconst float PI = 3.141592653589793;\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D u_ang2pixd;\nHashDxDy hash_with_dxdy(vec2 radec) {\n    vec2 uv = vec2(radec.x/TWICE_PI, radec.y/PI) + 0.5;\n    vec3 v = texture2D(u_ang2pixd, uv).rgb;\n\n    return HashDxDy(\n        int(v.x),\n        v.y,\n        v.z\n    );\n}\n\nuniform float opacity;\n\nTile get_tile(int idx) {\n    for(int i = 0; i < 12; i++) {\n        if( i == idx ) {\n            return textures_tiles[i];\n        }\n    }\n}\n\nTile binary_search_tile(int uniq) {\n    int l = 0;\n    int r = 11;\n    for (int v = 0; v <= 5; v++) {\n        int mid = (l + r) / 2;\n\n        Tile tile = get_tile(mid);\n        if(tile.uniq == uniq) {\n            return tile;\n        } else if(tile.uniq < uniq) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n\n        // before exiting the loop\n        if (l >= r) {\n            return get_tile(l);\n        }\n    }\n}\n\nvec4 get_tile_color(vec3 pos) {\n    float delta = asin(pos.y);\n    float theta = atan(pos.x, pos.z);\n    HashDxDy result = hash_with_dxdy(vec2(theta, delta));\n\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n    //return vec4(uv, 1.0, 1.0);\n\n    int uniq = 16 + idx; \n    Tile tile = binary_search_tile(uniq);\n\n    int idx_texture = tile.texture_idx / 64;\n    int off = tile.texture_idx - idx_texture * 64;\n\n    int idx_row = off / 8; // in [0; 7]\n    int idx_col = off - idx_row * 8; // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv) * 0.125;\n    vec3 UV = vec3(offset.x, offset.y, 0.0);\n    \n    vec4 color = get_color_from_texture(UV);\n    color.a *= (1.0 - float(tile.empty));\n    return color;\n}\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    //if(current_depth < 2) {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture2D(position_tex, uv).rgb;\n    /*} else {\n        float x = out_clip_pos.x;\n        float y = out_clip_pos.y;\n        float x2 = x*x;\n        float y2 = y*y;\n        float x4 = x2*x2;\n        float y4 = y2*y2;\n\n        n = vec3(\n            -x,\n            y,\n            -0.5*x2 - 0.5*y2 + 1.0\n        );\n    }*/\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    // Get the HEALPix cell idx and the uv in the texture\n    vec4 c = get_tile_color(frag_pos);\n    gl_FragColor = vec4(c.rgb, c.a * opacity);\n}"},5866:n=>{n.exports="precision mediump float;\nprecision mediump sampler2D;\nprecision mediump int;\n\nvarying vec3 out_vert_pos;\nvarying vec2 out_clip_pos;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\nuniform Tile textures_tiles[192];\nuniform int num_tiles;\n\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture2D(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture2D(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture2D(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718;\nconst float PI = 3.141592653589793;\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D u_ang2pixd;\nHashDxDy hash_with_dxdy(vec2 radec) {\n    vec2 uv = vec2(radec.x/TWICE_PI, radec.y/PI) + 0.5;\n    vec3 v = texture2D(u_ang2pixd, uv).rgb;\n\n    return HashDxDy(\n        int(v.x),\n        v.y,\n        v.z\n    );\n}\n\nuniform float opacity;\n\nTile get_tile(int idx) {\n    for(int i = 0; i < 12; i++) {\n        if( i == idx ) {\n            return textures_tiles[i];\n        }\n    }\n}\n\nTile binary_search_tile(int uniq) {\n    int l = 0;\n    int r = 11;\n    for (int v = 0; v <= 5; v++) {\n        int mid = (l + r) / 2;\n\n        Tile tile = get_tile(mid);\n        if(tile.uniq == uniq) {\n            return tile;\n        } else if(tile.uniq < uniq) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n\n        // before exiting the loop\n        if (l >= r) {\n            return get_tile(l);\n        }\n    }\n}\n\nvec4 get_tile_color(vec3 pos) {\n    float delta = asin(pos.y);\n    float theta = atan(pos.x, pos.z);\n    HashDxDy result = hash_with_dxdy(vec2(theta, delta));\n\n    int idx = result.idx;\n    vec2 uv = vec2(clamp(result.dy, 0.0, 1.0), result.dx);\n    int uniq = 16 + idx; \n    Tile tile = binary_search_tile(uniq);\n\n    int idx_texture = tile.texture_idx / 64;\n    int off = tile.texture_idx - idx_texture * 64;\n\n    int idx_row = off / 8; // in [0; 7]\n    int idx_col = off - idx_row * 8; // in [0; 7]\n\n    vec2 offset = (vec2(float(idx_col), float(idx_row)) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_color_from_grayscale_texture(UV);\n    color.a *= (1.0 - float(tile.empty));\n    return color;\n}\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture2D(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    c.a = c.a * opacity;\n    gl_FragColor = c;\n}"},8623:n=>{n.exports="precision mediump float;\nprecision mediump sampler2D;\nprecision mediump int;\n\nvarying vec3 out_vert_pos;\nvarying vec2 out_clip_pos;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\nuniform Tile textures_tiles[192];\nuniform int num_tiles;\n\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture2D(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh(float x) {\n    return log(x + sqrt(x*x + 1.0));\n}\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture2D(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture2D(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture2D(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718;\nconst float PI = 3.141592653589793;\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D u_ang2pixd;\nHashDxDy hash_with_dxdy(vec2 radec) {\n    vec2 uv = vec2(radec.x/TWICE_PI, radec.y/PI) + 0.5;\n    vec3 v = texture2D(u_ang2pixd, uv).rgb;\n\n    return HashDxDy(\n        int(v.x),\n        v.y,\n        v.z\n    );\n}\n\nuniform float opacity;\n\nTile get_tile(int idx) {\n    for(int i = 0; i < 12; i++) {\n        if( i == idx ) {\n            return textures_tiles[i];\n        }\n    }\n}\n\nTile binary_search_tile(int uniq) {\n    int l = 0;\n    int r = 11;\n    for (int v = 0; v <= 5; v++) {\n        int mid = (l + r) / 2;\n\n        Tile tile = get_tile(mid);\n        if(tile.uniq == uniq) {\n            return tile;\n        } else if(tile.uniq < uniq) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n\n        // before exiting the loop\n        if (l >= r) {\n            return get_tile(l);\n        }\n    }\n}\n\nvec4 get_tile_color(vec3 pos) {\n    float delta = asin(pos.y);\n    float theta = atan(pos.x, pos.z);\n    HashDxDy result = hash_with_dxdy(vec2(theta, delta));\n\n    int idx = result.idx;\n    vec2 uv = vec2(clamp(result.dy, 0.0, 1.0), result.dx);\n    int uniq = 16 + idx; \n    Tile tile = binary_search_tile(uniq);\n\n    int idx_texture = tile.texture_idx / 64;\n    int off = tile.texture_idx - idx_texture * 64;\n\n    int idx_row = off / 8; // in [0; 7]\n    int idx_col = off - idx_row * 8; // in [0; 7]\n\n    vec2 offset = (vec2(float(idx_col), float(idx_row)) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 c = get_colormap_from_grayscale_texture(UV);\n    // handle empty tiles\n    vec4 color = mix(c, vec4(0.0), tile.empty);\n    return color;\n}\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture2D(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    c.a = c.a * opacity;\n\n    gl_FragColor = c;\n}"},9752:n=>{n.exports="precision highp float;\nprecision highp int;\n\nattribute vec2 pos_clip_space;\nvarying vec2 out_clip_pos;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\n\nvoid main() {\n    gl_Position = vec4(pos_clip_space / (ndc_to_clip * czf), 0.0, 1.0);\n    out_clip_pos = pos_clip_space;\n}"},6086:n=>{n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 model;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_aitoff(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},76:n=>{n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_arc(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},5856:n=>{n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nin vec3 out_p;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\nuniform float fov;\nuniform float strength;\nvoid main() {\n    color = texture(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\n    color.r *= strength;\n}"},7668:n=>{n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_mercator(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},4521:n=>{n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_mollweide(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},3014:n=>{n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nin vec3 out_p;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\nuniform float fov;\nuniform float strength;\nvoid main() {\n    if (out_p.z < 0.f) {\n        discard;\n    }\n\n    color = texture(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\n    color.r *= strength;\n}"},1997:n=>{n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_orthographic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},107:n=>{n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_gnomonic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},9570:n=>{n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2D;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform float alpha;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    color = colormap_f(opacity);\n    color.a = o * alpha;\n}"},8524:n=>{n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2D;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},2791:n=>{n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform mat4 inv_model;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_aitoff(vec2 pos_clip_space) {\n    if(!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    vec2 uv = vec2(pos_clip_space.x * PI * 0.5, pos_clip_space.y * PI);\n    //da uv a lat/lon\n    float c = length(uv);\n\n    float phi = asin(uv.y * sin(c) / c);\n    float theta = atan(uv.x * sin(c), c * cos(c)) * 2.0;\n\n    vec3 world = vec3(\n        sin(theta) * cos(phi),\n        sin(phi),\n        cos(theta) * cos(phi)\n    );\n    return world;\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 posmodel = pos_model;\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(posmodel, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, posmodel));\n\n    vec3 h_model = normalize(posmodel - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_aitoff(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    vec3 posmodel = pos_model;\n    float y = atan(posmodel.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_aitoff(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},8484:n=>{n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nfloat sinc_positive(float x) {\n    if (x > 1.0e-4) {\n        return sin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        x = x*x;\n        return 1.0 - x * (1.0 - x / 20.0) / 6.0;\n    }\n}\n\nvec3 clip2world_arc(vec2 pos_clip_space) {\n    // r <= pi\n    float x = pos_clip_space.x * PI;\n    float y = pos_clip_space.y * PI;\n    float r = length(vec2(x, y));\n    if (r <= PI) {\n        float z = cos(r);\n        r = sinc_positive(r);\n\n        return vec3(x * r, y * r, z);\n    }\n    discard;\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    h_world = check_inversed_longitude(h_world);\n    vec2 h_clip = world2clip_arc(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_arc(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.f));\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},926:n=>{n.exports="#version 300 es\nprecision highp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * czf);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},8808:n=>{n.exports="#version 300 es\nprecision lowp float;\n\nout vec4 frag_color;\n\nuniform vec4 color;\nuniform float opacity;\n\nconst float PI = 3.141592653589793f;\n\nvoid main() {\n    frag_color = color;\n}"},9709:n=>{n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 ndc_pos;\n\nvoid main() {\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n}"},2462:n=>{n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvec3 clip2world_mercator(vec2 p) {\n    float theta = p.x * PI;\n    float delta = atan(sinh(p.y)) * PI;\n\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mercator(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_mercator(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},538:n=>{n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_mollweide(vec2 pos_clip_space) {\n    if (!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    float y2 = pos_clip_space.y * pos_clip_space.y;\n    float k = sqrt(1.0 - 4.0 * y2);\n\n    float theta = PI * pos_clip_space.x / k;\n    float delta = asin((2.0 * asin(2.0 * pos_clip_space.y) + 4.0 * pos_clip_space.y * k) / PI);\n    \n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mollweide(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_mollweide(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},7677:n=>{n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvec3 clip2world_orthographic(vec2 pos_clip_space) {\n    float z = 1.f - dot(pos_clip_space, pos_clip_space);\n    if (z > 0.f) {\n        return vec3(pos_clip_space.x, pos_clip_space.y, sqrt(z));\n    } else {\n        discard;\n    }\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_orthographic(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d*2.0;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_orthographic(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(to_galactic * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},9648:n=>{n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform mat4 to_galactic;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_gnomonic(vec2 pos_clip_space) {\n    float x_2d = pos_clip_space.x * PI;\n    float y_2d = pos_clip_space.y * PI;\n    float r = x_2d * x_2d + y_2d * y_2d;\n\n    float z = sqrt(1.0 + r);\n    return vec3(z * x_2d, z * y_2d, z);\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_gnomonic(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_gnomonic(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = normalize(vec3(to_galactic * model * vec4(pos_world, 1.f)));\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},2502:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_aitoff(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},1137:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_arc(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},1232:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\nuniform float opacity;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nvoid main() {\n    vec4 color_start = get_color_from_texture(frag_uv_start);\n    color_start.a *= (1.0 - m_start);\n\n    vec4 color_end = get_color_from_texture(frag_uv_end);\n    color_end.a *= (1.0 - m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = opacity * out_frag_color.a;\n}"},9379:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_gnomonic(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},7291:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = mix(get_color_from_grayscale_texture(uv), vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n    /*vec4 color_start = get_color_from_grayscale_texture(frag_uv_start);\n    color_start.a *= (1.0 - m_start);\n    vec4 color_end = get_color_from_grayscale_texture(frag_uv_end);\n    color_end.a *= (1.0 - m_end);*/\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}\n\n"},7503:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex1;\nuniform isampler2D tex2;\nuniform isampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nivec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return ivec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = mix(get_color_from_grayscale_texture(uv), vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n    /*vec4 color_start = get_color_from_grayscale_texture(frag_uv_start);\n    color_start.a *= (1.0 - m_start);\n    vec4 color_end = get_color_from_grayscale_texture(frag_uv_end);\n    color_end.a *= (1.0 - m_end);*/\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},9074:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp usampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform usampler2D tex1;\nuniform usampler2D tex2;\nuniform usampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nuvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return uvec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = mix(get_color_from_grayscale_texture(uv), vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n    /*vec4 color_start = get_color_from_grayscale_texture(frag_uv_start);\n    color_start.a *= (1.0 - m_start);\n    vec4 color_end = get_color_from_grayscale_texture(frag_uv_end);\n    color_end.a *= (1.0 - m_end);*/\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},9328:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 c = get_colormap_from_grayscale_texture(uv);\n    vec4 color = mix(c, vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    //vec4 color_start = get_color(frag_uv_start, m_start);\n    //vec4 color_end = get_color(frag_uv_end, m_end);\n    vec4 color_start = get_colormap_from_grayscale_texture(frag_uv_start);\n    color_start.a *= (1.0 - m_start);\n    vec4 color_end = get_colormap_from_grayscale_texture(frag_uv_end);\n    color_end.a *= (1.0 - m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},6266:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex1;\nuniform isampler2D tex2;\nuniform isampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nivec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return ivec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 c = get_colormap_from_grayscale_texture(uv);\n    vec4 color = mix(c, vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},108:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp usampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform usampler2D tex1;\nuniform usampler2D tex2;\nuniform usampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nuvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return uvec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 c = get_colormap_from_grayscale_texture(uv);\n    vec4 color = mix(c, vec4(0.0), empty);\n    return color;\n}\n\nvoid main() {\n    //vec4 color_start = get_color(frag_uv_start, m_start);\n    //vec4 color_end = get_color(frag_uv_end, m_end);\n    vec4 color_start = get_colormap_from_grayscale_texture(frag_uv_start);\n    color_start.a *= (1.0 - m_start);\n    vec4 color_end = get_colormap_from_grayscale_texture(frag_uv_end);\n    color_end.a *= (1.0 - m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},8225:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_mercator(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},8876:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_mollweide(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},5939:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_orthographic(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},2743:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\nuniform Tile textures_tiles[192];\nuniform int num_tiles;\n\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nint binary_search_tile(int uniq) {\n    int l = 0;\n    int r = num_tiles - 1;\n\n    while (l < r) {\n        int a = (l + r) / 2;\n        Tile tile = textures_tiles[a];\n        if(tile.uniq == uniq) {\n            return a;\n        } else if(tile.uniq < uniq) {\n            l = a + 1;\n        } else {\n            r = a - 1;\n        }\n    }\n\n    return l;\n}\n\nvec4 get_tile_color(vec3 pos) {\n    int d = current_depth;\n\n    while (d >= 0) {\n        HashDxDy result = hash_with_dxdy(d, pos.zxy);\n        \n        int idx = result.idx;\n        vec2 uv = vec2(result.dy, result.dx);\n\n        int uniq = (16 << (d << 1)) | idx;\n        int tile_idx = binary_search_tile(uniq);\n        Tile tile = textures_tiles[tile_idx];\n\n        if(tile.uniq == uniq) {\n            int idx_texture = tile.texture_idx >> 6;\n            int off = tile.texture_idx & 0x3F;\n            float idx_row = float(off >> 3); // in [0; 7]\n            float idx_col = float(off & 0x7); // in [0; 7]\n\n            vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n            vec3 UV = vec3(offset, float(idx_texture));\n\n            vec4 color = get_color_from_texture(UV);\n            // For empty tiles we set the alpha of the pixel to 0.0\n            // so that what is behind will be plotted\n            color.a *= (1.0 - tile.empty);\n            \n            return color;\n        }\n\n        d = d - 1;\n    }\n}\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec3 n = vec3(0.0);\n    if(current_depth < 2) {\n        vec2 uv = out_clip_pos * 0.5 + 0.5;\n        n = texture(position_tex, uv).rgb;\n    } else {\n        float x = out_clip_pos.x;\n        float y = out_clip_pos.y;\n        float x2 = x*x;\n        float y2 = y*y;\n        float x4 = x2*x2;\n        float y4 = y2*y2;\n\n        n = vec3(\n            -x,\n            y,\n            -0.5*x2 - 0.5*y2 + 1.0\n        );\n    }\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    // Get the HEALPix cell idx and the uv in the texture\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = vec4(c.rgb, opacity * c.a);\n}"},2767:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nvec4 get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_color_from_grayscale_texture(UV);\n    // For empty tiles we set the alpha of the pixel to 0.0\n    // so that what is behind will be plotted\n    color.a *= (1.0 - tile.empty);\n    return color;\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = c;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},6645:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex1;\nuniform isampler2D tex2;\nuniform isampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nivec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return ivec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nvec4 get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_color_from_grayscale_texture(UV);\n    // For empty tiles we set the alpha of the pixel to 0.0\n    // so that what is behind will be plotted\n    color.a *= (1.0 - tile.empty);\n    return color;\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = c;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},7110:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform usampler2D tex1;\nuniform usampler2D tex2;\nuniform usampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nuvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return uvec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nvec4 get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_color_from_grayscale_texture(UV);\n    // For empty tiles we set the alpha of the pixel to 0.0\n    // so that what is behind will be plotted\n    color.a *= (1.0 - tile.empty);\n    return color;\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = c;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},9215:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float opacity;\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\nuniform sampler2D tex3;\n\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = get_pixels(uv).r;\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nvec4 get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_colormap_from_grayscale_texture(UV);\n    // handle empty tiles\n    //vec4 c1 = mix(c, blank_color, tile.empty);\n    //vec4 c2 = mix(c, colormap_f(0.0), tile.empty);\n    //vec4 color = mix(c1, c2, first_survey);\n    // For empty tiles we set the alpha of the pixel to 0.0\n    // so that what is behind will be plotted\n    color.a *= (1.0 - tile.empty);\n    return color;\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = c;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},8069:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float opacity;\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex1;\nuniform isampler2D tex2;\nuniform isampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nivec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return ivec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nvec4 get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n\n    int idx = result.idx;\n\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_colormap_from_grayscale_texture(UV);\n    // handle empty tiles\n    //vec4 c1 = mix(c, blank_color, tile.empty);\n    //vec4 c2 = mix(c, colormap_f(0.0), tile.empty);\n    //vec4 color = mix(c1, c2, first_survey);\n    \n    // For empty tiles we set the alpha of the pixel to 0.0\n    // so that what is behind will be plotted\n    color.a *= (1.0 - tile.empty);\n\n    return color;\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = c;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},1203:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec2 out_clip_pos;\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    float empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float opacity;\nuniform float current_time; // current time in ms\n\n//const int MAX_NUM_TEX = 3;\nuniform usampler2D tex1;\nuniform usampler2D tex2;\nuniform usampler2D tex3;\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform int tex_storing_fits;\n\nuniform sampler2D colormaps;\nuniform int num_colormaps;\nuniform int colormap_id;\n// can be either 0 or 1\nuniform int reversed;\n\nvec4 colormap_f(float x) {\n    x = mix(x, 1.0 - x, float(reversed));\n    float id = (float(colormap_id) + 0.5) / float(num_colormaps);\n\n    return texture(colormaps, vec2(x, id));\n}\n\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nuvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex1, uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex2, uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex3, uv.xy);\n    } else {\n        return uvec4(0, 0, 0, 1);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(colormap_f(alpha), vec4(0.0), float(alpha == 0.0));\n    //}\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    // FITS data pixels are reversed along the y axis\n    vec3 uv = mix(UV, reverse_uv(UV), float(tex_storing_fits == 1));\n\n    float x = float(get_pixels(uv).r);\n    //if (x == blank) {\n    //    return blank_color;\n    //} else {\n        float alpha = x * scale + offset;\n        alpha = transfer_func(H, alpha, min_value, max_value);\n\n        return mix(vec4(C * K * alpha, 1.0), vec4(0.0), float(alpha == 0.0));\n    //}\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nvec4 get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n\n    int idx = result.idx;\n\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_colormap_from_grayscale_texture(UV);\n    // handle empty tiles\n    //vec4 c1 = mix(c, blank_color, tile.empty);\n    //vec4 c2 = mix(c, colormap_f(0.0), tile.empty);\n    //vec4 color = mix(c1, c2, first_survey);\n\n    // For empty tiles we set the alpha of the pixel to 0.0\n    // so that what is behind will be plotted\n    color.a *= (1.0 - tile.empty);\n    return color;\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nuniform sampler2D position_tex;\nuniform mat4 model;\nvoid main() {\n    vec2 uv = out_clip_pos * 0.5 + 0.5;\n    vec3 n = texture(position_tex, uv).rgb;\n\n    vec3 frag_pos = vec3(model * vec4(n, 1.0));\n\n    vec4 c = get_tile_color(frag_pos);\n    out_frag_color = c;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},9116:n=>{n.exports="#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout (location = 0) in vec2 pos_clip_space;\nout vec2 out_clip_pos;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\n\nvoid main() {\n    gl_Position = vec4(pos_clip_space / (ndc_to_clip * czf), 0.0, 1.0);\n    out_clip_pos = pos_clip_space;\n}"},6630:(n,e,t)=>{"use strict";t.d(e,{k:()=>Gt});let i=function(){function n(n,e){this.domEl=$('<div class="aladin-popup-container"><div class="aladin-popup"><a class="aladin-closeBtn">&times;</a><div class="aladin-popupTitle"></div><div class="aladin-popupText"></div></div><div class="aladin-popup-arrow"></div></div>'),this.domEl.appendTo(n),this.view=e;var t=this;this.domEl.find(".aladin-closeBtn").click((function(){t.hide()}))}return n.prototype.hide=function(){this.domEl.hide(),this.view.mustClearCatalog=!0,this.view.catalogForPopup.hide()},n.prototype.show=function(){this.domEl.show()},n.prototype.setTitle=function(n){this.domEl.find(".aladin-popupTitle").html(n||"")},n.prototype.setText=function(n){this.domEl.find(".aladin-popupText").html(n||""),this.w=this.domEl.outerWidth(),this.h=this.domEl.outerHeight()},n.prototype.setSource=function(n){this.source&&(this.source.popup=null),n.popup=this,this.source=n,this.setPosition(n.x,n.y)},n.prototype.setPosition=function(n,e){var t=n-this.w/2,i=e-this.h;this.source&&(i+=this.source.catalog.sourceSize/2),this.domEl[0].style.left=t+"px",this.domEl[0].style.top=i+"px"},n}(),a=function(){function n(){}return n.prototype.redraw=function(n,e,t,i){var a,o;n.lineWidth=1,n.strokeStyle="rgb(150,150,220)",n.beginPath();for(var r=0,l=e.length;r<l;r++)o=(a=e[r]).ipix,n.moveTo(a[0].vx,a[0].vy),n.lineTo(a[1].vx,a[1].vy),n.lineTo(a[2].vx,a[2].vy);for(n.stroke(),n.strokeStyle="#FFDDDD",n.beginPath(),r=0,l=e.length;r<l;r++)o=(a=e[r]).ipix,n.strokeText(i+"/"+o,(a[0].vx+a[2].vx)/2,(a[0].vy+a[2].vy)/2);n.stroke()},n}();var o=t(8222);let r=function(){};r.D2R=Math.PI/180,r.R2D=180/Math.PI,r.sign=function(n){return n>0?1:n<0?-1:0},r.cosd=function(n){if(n%90==0)switch(Math.abs(Math.floor(n/90+.5))%4){case 0:return 1;case 1:return 0;case 2:return-1;case 3:return 0}return Math.cos(n*r.D2R)},r.sind=function(n){if(n%90==0)switch(Math.abs(Math.floor(n/90-.5))%4){case 0:return 1;case 1:return 0;case 2:return-1;case 3:return 0}return Math.sin(n*r.D2R)},r.tand=function(n){var e;return 0==(e=n%360)||180==Math.abs(e)?0:45==e||225==e?1:-135==e||-315==e?-1:Math.tan(n*r.D2R)},r.asind=function(n){return Math.asin(n)*r.R2D},r.acosd=function(n){return Math.acos(n)*r.R2D},r.atand=function(n){return Math.atan(n)*r.R2D},r.atan2=function(n,e){if(0==n)return e>0?0:e<0?Math.PI:NaN;var t=r.sign(n);if(0==e)return Math.PI/2*t;var i=Math.atan(Math.abs(n/e));return e>0?i*t:e<0?(Math.PI-i)*t:void 0},r.atan2d=function(n,e){return r.atan2(n,e)*r.R2D},r.cosh=function(n){return(Math.exp(n)+Math.exp(-n))/2},r.sinh=function(n){return(Math.exp(n)-Math.exp(-n))/2},r.tanh=function(n){return(Math.exp(n)-Math.exp(-n))/(Math.exp(n)+Math.exp(-n))},r.acosh=function(n){return Math.log(n+Math.sqrt(n*n-1))},r.asinh=function(n){return Math.log(n+Math.sqrt(n*n+1))},r.atanh=function(n){return.5*Math.log((1+n)/(1-n))},r.sinc=function(n){var e=Math.abs(n);return e<=.001?1-(e*=e)*(1-e/20)/6:Math.sin(e)/e},r.asinc=function(n){var e=Math.abs(n);return e<=.001?1+(e*=e)*(6+.45*e)/6:Math.asin(e)/e},r.hypot=function(n,e){return Math.sqrt(n*n+e*e)},r.eulerMatrix=function(n,e,t){var i=new Array(3);i[0]=new Array(3),i[1]=new Array(3),i[2]=new Array(3);var a=r.cosd(n),o=r.sind(n),l=r.cosd(e),s=r.sind(e),c=r.cosd(t),f=r.sind(t);return i[0][0]=c*l*a-f*o,i[0][1]=-f*l*a-c*o,i[0][2]=-s*a,i[1][0]=c*l*o+f*a,i[1][1]=-f*l*o+c*a,i[1][2]=-s*o,i[2][0]=-s*c,i[2][1]=-s*a,i[2][2]=l,i},r.displayMatrix=function(n){for(var e=n.length,t=0,i=0;i<e;i++)n[i].length>t&&(t=n[i].length);var a="<table>\n";for(i=0;i<e;i++){a+="<tr>";for(var o=0;o<e;o++)a+="<td>",i<n[i].length&&(a+=n[i][o].toString()),a+="</td>";a+="</td>\n"}return a+"</table>\n"};let l=function(n,e){this.PROJECTION=l.PROJ_TAN,this.ROT=this.tr_oR(n,e),this.longitudeIsReversed=!1};l.PROJ_TAN=1,l.PROJ_TAN2=2,l.PROJ_STG=2,l.PROJ_SIN=3,l.PROJ_SIN2=4,l.PROJ_ZEA=4,l.PROJ_ARC=5,l.PROJ_SCHMIDT=5,l.PROJ_AITOFF=6,l.PROJ_AIT=6,l.PROJ_GLS=7,l.PROJ_MERCATOR=8,l.PROJ_MER=8,l.PROJ_LAM=9,l.PROJ_LAMBERT=9,l.PROJ_TSC=10,l.PROJ_QSC=11,l.PROJ_MOLLWEIDE=12,l.PROJ_LIST=["Mercator",l.PROJ_MERCATOR,"Gnomonic",l.PROJ_TAN,"Stereographic",l.PROJ_TAN2,"Orthographic",l.PROJ_SIN,"Zenithal",l.PROJ_ZEA,"Schmidt",l.PROJ_SCHMIDT,"Aitoff",l.PROJ_AITOFF,"Lambert",l.PROJ_LAMBERT],l.PROJ_NAME=["-","Gnomonic","Stereographic","Orthographic","Equal-area","Schmidt plates","Aitoff","Global sin","Mercator","Lambert"],l.prototype={setCenter:function(n,e){this.ROT=this.tr_oR(n,e)},reverseLongitude:function(n){this.longitudeIsReversed=n},setProjection:function(n){this.PROJECTION=n},project:function(n,e){var t=this.tr_ou(n,e),i=this.tr_uu(t,this.ROT),a=this.tr_up(this.PROJECTION,i);return null==a?null:this.longitudeIsReversed?{X:a[0],Y:-a[1]}:{X:-a[0],Y:-a[1]}},unproject:function(n,e){this.longitudeIsReversed||(n=-n),e=-e;var t=this.tr_pu(this.PROJECTION,n,e),i=this.tr_uu1(t,this.ROT),a=this.tr_uo(i);return{ra:a[0],dec:a[1]}},tr_up:function(n,e){var t,i,a,o,s,c=e[0],f=e[1],u=e[2];if(0==(t=r.hypot(c,f))&&0==u)return null;switch(n){default:a=null;break;case l.PROJ_AITOFF:i=Math.sqrt(t*(t+c)/2),o=Math.sqrt(2*t*(t-c)),o/=i=Math.sqrt((1+i)/2),f<0&&(o=-o),a=[o,s=u/i];break;case l.PROJ_GLS:s=Math.asin(u),a=[o=0!=t?Math.atan2(f,c)*t:0,s];break;case l.PROJ_MERCATOR:a=0!=t?[o=Math.atan2(f,c),s=r.atanh(u)]:null;break;case l.PROJ_TAN:a=c>0?[o=f/c,s=u/c]:null;break;case l.PROJ_TAN2:a=(i=(1+c)/2)>0?[o=f/i,s=u/i]:null;break;case l.PROJ_ARC:c<=-1?(o=Math.PI,s=0):(t=r.hypot(f,u),o=f*(i=c>0?r.asinc(t):Math.acos(c)/t),s=u*i),a=[o,s];break;case l.PROJ_SIN:a=c>=0?[o=f,s=u]:null;break;case l.PROJ_SIN2:0!=(i=Math.sqrt((1+c)/2))?(o=f/i,s=u/i):(o=2,s=0),a=[o,s];break;case l.PROJ_LAMBERT:s=u,o=0,0!=t&&(o=Math.atan2(f,c)),a=[o,s]}return a},tr_pu:function(n,e,t){var i,a,o,s,c;switch(n){default:return null;case l.PROJ_AITOFF:if((i=e*e/8+t*t/2)>1)return null;o=1-i,c=t*(a=Math.sqrt(1-i/2)),0!=(i=r.hypot(o,s=e*a/2))&&(o=((a=o)*a-s*s)/i,s=2*a*s/i);break;case l.PROJ_GLS:if((i=1-(c=Math.sin(t))*c)<0)return null;a=0!=(i=Math.sqrt(i))?e/i:0,o=i*Math.cos(a),s=i*Math.sin(a);break;case l.PROJ_MERCATOR:c=r.tanh(t),o=(i=1/r.cosh(t))*Math.cos(e),s=i*Math.sin(e);break;case l.PROJ_LAMBERT:if((i=1-(c=t)*c)<0)return null;o=(i=Math.sqrt(i))*Math.cos(e),s=i*Math.sin(e);break;case l.PROJ_TAN:s=e*(o=1/Math.sqrt(1+e*e+t*t)),c=t*o;break;case l.PROJ_TAN2:o=(1-(i=(e*e+t*t)/4))/(a=1+i),s=e/a,c=t/a;break;case l.PROJ_ARC:if((i=r.hypot(e,t))>Math.PI)return null;a=r.sinc(i),o=Math.cos(i),s=a*e,c=a*t;break;case l.PROJ_SIN:if((a=1-e*e-t*t)<0)return null;o=Math.sqrt(a),s=e,c=t;break;case l.PROJ_SIN2:if((i=(e*e+t*t)/4)>1)return null;o=1-2*i,s=(a=Math.sqrt(1-i))*e,c=a*t}return[o,s,c]},tr_oR:function(n,e){var t=new Array(3);return t[0]=new Array(3),t[1]=new Array(3),t[2]=new Array(3),t[2][2]=r.cosd(e),t[0][2]=r.sind(e),t[1][1]=r.cosd(n),t[1][0]=-r.sind(n),t[1][2]=0,t[0][0]=t[2][2]*t[1][1],t[0][1]=-t[2][2]*t[1][0],t[2][0]=-t[0][2]*t[1][1],t[2][1]=t[0][2]*t[1][0],t},tr_ou:function(n,e){var t=new Array(3),i=r.cosd(e);return t[0]=i*r.cosd(n),t[1]=i*r.sind(n),t[2]=r.sind(e),t},tr_uu:function(n,e){var t=new Array(3),i=n[0],a=n[1],o=n[2];return t[0]=e[0][0]*i+e[0][1]*a+e[0][2]*o,t[1]=e[1][0]*i+e[1][1]*a+e[1][2]*o,t[2]=e[2][0]*i+e[2][1]*a+e[2][2]*o,t},tr_uu1:function(n,e){var t=new Array(3),i=n[0],a=n[1],o=n[2];return t[0]=e[0][0]*i+e[1][0]*a+e[2][0]*o,t[1]=e[0][1]*i+e[1][1]*a+e[2][1]*o,t[2]=e[0][2]*i+e[1][2]*a+e[2][2]*o,t},tr_uo:function(n){var e,t,i=n[0],a=n[1],o=n[2],l=i*i+a*a;if(0==l){if(0==o)return null;e=0,t=o>0?90:-90}else t=r.atand(o/Math.sqrt(l)),(e=r.atan2d(a,i))<0&&(e+=360);return[e,t]}};let s={SIN:l.PROJ_SIN,AITOFF:l.PROJ_AITOFF,MERCATOR:l.PROJ_MERCATOR,ARC:l.PROJ_ARC,TAN:l.PROJ_TAN,MOL:l.PROJ_MOLLWEIDE},c=function(n,e,t){this.lon=n,this.lat=e,this.prec=t,this.frame=null,this.computeDirCos()};function f(n,e){this.string=u.trim(n,e),this.sep=e,this.pos=0}function u(){}function p(){}c.factor=[3600,60,1],c.prototype={setFrame:function(n){this.frame=n},computeDirCos:function(){var n=r.cosd(this.lat);this.x=n*r.cosd(this.lon),this.y=n*r.sind(this.lon),this.z=r.sind(this.lat)},computeLonLat:function(){var n=this.x*this.x+this.y*this.y;this.lon=0,0==n?0==this.z?(this.lon=NaN,this.lat=NaN):this.lat=this.z>0?90:-90:(this.lon=r.atan2d(this.y,this.x),this.lat=r.atan2d(this.z,Math.sqrt(n)),this.lon<0&&(this.lon+=360))},dist2:function(n){var e=n.x-this.x,t=e*e;return(t+=(e=n.y-this.y)*e)+(e=n.z-this.z)*e},distance:function(n){return 0==n.x&&0==n.y&&0==n.z||0==this.x&&0==this.y&&0==this.z?NaN:2*r.asind(.5*Math.sqrt(this.dist2(n)))},convertTo:function(n){this.frame.equals(n)||(this.frame.toICRS(this.coo),n.fromICRS(this.coo),this.frame=n,this.lon=this.lat=NaN)},rotate:function(n){var e,t,i;n!=Umatrix3&&(e=n[0][0]*this.x+n[0][1]*this.y+n[0][2]*this.z,t=n[1][0]*this.x+n[1][1]*this.y+n[1][2]*this.z,i=n[2][0]*this.x+n[2][1]*this.y+n[2][2]*this.z,this.x=e,this.y=t,this.z=i,this.lon=this.lat=NaN)},rotate_1:function(n){var e,t,i;n!=Umatrix3&&(e=n[0][0]*this.x+n[1][0]*this.y+n[2][0]*this.z,t=n[0][1]*this.x+n[1][1]*this.y+n[2][1]*this.z,i=n[0][2]*this.x+n[1][2]*this.y+n[2][2]*this.z,this.x=e,this.y=t,this.z=i,this.lon=this.lat=NaN)},equals:function(n){return this.x==n.x&&this.y==n.y&&this.z==n.z},parse:function(n){var e=n.indexOf("+");if(e<0&&(e=n.indexOf("-")),e<0&&(e=n.indexOf(" ")),e<0)return this.lon=NaN,this.lat=NaN,this.prec=0,!1;var t=n.substring(0,e),i=n.substring(e);return this.lon=this.parseLon(t),this.lat=this.parseLat(i),!0},parseLon:function(n){if((n=(n=n.trim()).replace(/:/g," ")).indexOf(" ")<0){var e=n.indexOf(".");return this.prec=e<0?0:n.length-e-1,parseFloat(n)}for(var t=new f(n," "),i=0,a=0,o=0;t.hasMore();){var r=t.nextToken(),l=r.indexOf(".");switch(a+=parseFloat(r)*c.factor[i],i){case 0:o=l<0?1:2;break;case 1:o=l<0?3:4;break;case 2:o=l<0?5:4+r.length-l}i++}return this.prec=o,15*a/3600},parseLat:function(n){var e;if("-"==(n=(n=n.trim()).replace(/:/g," ")).charAt(0)?(e=-1,n=n.substring(1)):"-"==n.charAt(0)?(e=1,n=n.substring(1)):e=1,n.indexOf(" ")<0){var t=n.indexOf(".");return this.prec=t<0?0:n.length-t-1,parseFloat(n)*e}for(var i=new f(n," "),a=0,o=0,r=0;i.hasMore();){var l=i.nextToken(),s=l.indexOf(".");switch(o+=parseFloat(l)*c.factor[a],a){case 0:r=s<0?1:2;break;case 1:r=s<0?3:4;break;case 2:r=s<0?5:4+l.length-s}a++}return this.prec=r,o*e/3600},format:function(n){isNaN(this.lon)&&this.computeLonLat();var e="",t="";if(n.indexOf("d")>=0)e=p.format(this.lon,this.prec),t=p.format(this.lat,this.prec);else{var i=this.lon/15;e=p.toSexagesimal(i,this.prec+1,!1),t=p.toSexagesimal(this.lat,this.prec,!1)}return this.lat>0&&(t="+"+t),n.indexOf("/")>=0?e+" "+t:n.indexOf("2")>=0?[e,t]:e+t}},f.prototype={hasMore:function(){return this.pos<this.string.length},nextToken:function(){for(var n=this.pos;n<this.string.length&&this.string.charAt(n)==this.sep;)n++;for(var e=n;e<this.string.length&&this.string.charAt(e)!=this.sep;)e++;return this.pos=e,this.string.substring(n,e)}},u.trim=function(n,e){for(var t=0,i=n.length-1;t<n.length&&n.charAt(t)==e;)t++;if(t==n.length)return"";for(;i>t&&n.charAt(i)==e;)i--;return n.substring(t,i+1)},p.pow10=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13,1e14],p.rndval=[.5,.05,.005,5e-4,5e-5,5e-6,5e-7,5e-8,5e-9,5e-10,5e-11,5e-12,5e-13,5e-14,5e-14],p.format=function(n,e){if(e<=0)return Math.round(n).toString();var t=n.toString(),i=t.indexOf("."),a=i>=0?t.length-i-1:0;if(e>=a){i<0&&(t+=".");for(var o=0;o<e-a;o++)t+="0";return t}return(t=(n+p.rndval[e]).toString()).substr(0,i+e+1)},p.toSexagesimal=function(n,e,t){var i=n<0?"-":t?"+":"",a=Math.abs(n);switch(e){case 1:return i+(r=Math.round(a)).toString();case 2:return i+p.format(a,1);case 3:return i+(r=Math.floor(a))+" "+Math.round(60*(a-r));case 4:var o=60*(a-(r=Math.floor(a)));return i+r+" "+p.format(o,1);case 5:return o=60*(a-(r=Math.floor(a))),i+r+" "+(l=Math.floor(o))+" "+Math.round(60*(o-l));case 6:case 7:case 8:var r,l;(r=Math.floor(a))<10&&(r="0"+r),o=60*(a-r),(l=Math.floor(o))<10&&(l="0"+l);var s=60*(o-l);return i+r+" "+l+" "+p.format(s,e-5);default:return i+p.format(a,1)}};let _={SYSTEMS:h={J2000:"J2000",GAL:"Galactic"},J2000:{label:"J2000",system:h.J2000},J2000d:{label:"J2000d",system:h.J2000},GAL:{label:"Galactic",system:h.GAL},fromString:function(n,e){return n?0==(n=n.toLowerCase().replace(/^\s+|\s+$/g,"")).indexOf("j2000d")||0==n.indexOf("icrsd")?_.J2000d:0==n.indexOf("j2000")||0==n.indexOf("icrs")?_.J2000:0==n.indexOf("gal")?_.GAL:e||null:e||null}};var h;let d={xyToView:function(n,e,t,i,a,o,r){return null==r&&(r=!0),r?{vx:d.myRound(a/2*(1+o*n)-(a-t)/2),vy:d.myRound(a/2*(1+o*e)-(a-i)/2)}:{vx:a/2*(1+o*n)-(a-t)/2,vy:a/2*(1+o*e)-(a-i)/2}},viewToXy:function(n,e,t,i,a,o){return{x:((2*n+(a-t))/a-1)/o,y:((2*e+(a-i))/a-1)/o}},radecToViewXy:function(n,e,t){return t.aladin.webglAPI.worldToScreen(n,e)},myRound:function(n){return n<0?-1*(0|-n):0|n},isInsideViewXy:function(n,e,t,i){return n>=0&&n<t&&e>=0&&e<i},isHpxPixVisible:function(n,e,t){for(var i=0;i<n.length;i++)if(n[i].vx>=-20&&n[i].vx<e+20&&n[i].vy>=-20&&n[i].vy<t+20)return!0;return!1},ipixToIpix:function(n,e,t){},counterClockwiseTriangle:function(n,e,t,i,a,o){return n*i+e*a+t*o-a*i-o*n-t*e>=0},grow2:function(n,e){for(var t=0,i=0;i<4;i++)null==n[i]&&t++;if(t>1)return n;var a=[];for(i=0;i<4;i++)a.push({vx:n[i].vx,vy:n[i].vy});for(i=0;i<2;i++){var o,r,l=1==i?1:0,s=1==i?3:2;if(null==a[l]&&(0==l||3==l?(o=1,r=2):(o=0,r=3),a[l]={vx:(a[o].vx+a[r].vx)/2,vy:(a[o].vy+a[r].vy)/2}),null==a[s]&&(0==s||3==s?(o=1,r=2):(o=0,r=3),a[s]={vx:(a[o].vx+a[r].vx)/2,vy:(a[o].vy+a[r].vy)/2}),null!=a[l]&&null!=a[s]){var c=Math.atan2(a[s].vy-a[l].vy,a[s].vx-a[l].vx),f=e*Math.cos(c);a[l].vx-=f,a[s].vx+=f,f=e*Math.sin(c),a[l].vy-=f,a[s].vy+=f}}return a},SVG_ICONS:{CATALOG:'<svg xmlns="http://www.w3.org/2000/svg"><polygon points="1,0,5,0,5,3,1,3"  fill="FILLCOLOR" /><polygon points="7,0,9,0,9,3,7,3"  fill="FILLCOLOR" /><polygon points="10,0,12,0,12,3,10,3"  fill="FILLCOLOR" /><polygon points="13,0,15,0,15,3,13,3"  fill="FILLCOLOR" /><polyline points="1,5,5,9"  stroke="FILLCOLOR" /><polyline points="1,9,5,5" stroke="FILLCOLOR" /><line x1="7" y1="7" x2="15" y2="7" stroke="FILLCOLOR" stroke-width="2" /><polyline points="1,11,5,15"  stroke="FILLCOLOR" /><polyline points="1,15,5,11"  stroke="FILLCOLOR" /><line x1="7" y1="13" x2="15" y2="13" stroke="FILLCOLOR" stroke-width="2" /></svg>',MOC:'<svg xmlns="http://www.w3.org/2000/svg"><polyline points="0.5,7,2.5,7,2.5,5,7,5,7,3,10,3,10,5,13,5,13,7,15,7,15,9,13,9,13,12,10,12,10,14,7,14,7,12,2.5,12,2.5,10,0.5,10,0.5,7" stroke-width="1" stroke="FILLCOLOR" fill="transparent" /><line x1="1" y1="10" x2="6" y2="5" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="2" y1="12" x2="10" y2="4" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="5" y1="12" x2="12" y2="5" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="7" y1="13" x2="13" y2="7" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="10" y1="13" x2="13" y2="10" stroke="FILLCOLOR" stroke-width="0.5" /></svg>',OVERLAY:'<svg xmlns="http://www.w3.org/2000/svg"><polygon points="10,5,10,1,14,1,14,14,2,14,2,9,6,9,6,5" fill="transparent" stroke="FILLCOLOR" stroke-width="2"/></svg>'}},v={};v.PI=Math.PI,v.C_PR=Math.PI/180,v.VLEV=2,v.EPS=1e-7,v.c=.105,v.LN10=Math.log(10),v.PIOVER2=Math.PI/2,v.TWOPI=2*Math.PI,v.TWOTHIRD=2/3,v.ARCSECOND_RADIAN=484813681109536e-20;let m=function(){let n=function(){};n.radecToPolar=function(n,e){return{theta:Math.PI/2-e/180*Math.PI,phi:n/180*Math.PI}},n.polarToRadec=function(n,e){return{ra:180*e/Math.PI,dec:180*(Math.PI/2-n)/Math.PI}},n.castToInt=function(n){return n>0?Math.floor(n):Math.ceil(n)};let e=function(){function n(){this.items=[]}return n.prototype.appendRange=function(n,e){for(var t=n;t<=e;t++)t in this.items||this.items.push(t)},n}();function t(n){this.nside=n}return t.NS_MAX=16384,t.ORDER_MAX=14,t.NSIDELIST=[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384],t.JRLL=[2,2,2,2,3,3,3,3,4,4,4,4],t.JPLL=[1,3,5,7,0,2,4,6,1,3,5,7],t.XOFFSET=[-1,-1,0,1,1,1,0,-1],t.YOFFSET=[0,1,1,1,0,-1,-1,-1],t.FACEARRAY=[[8,9,10,11,-1,-1,-1,-1,10,11,8,9],[5,6,7,4,8,9,10,11,9,10,11,8],[-1,-1,-1,-1,5,6,7,4,-1,-1,-1,-1],[4,5,6,7,11,8,9,10,11,8,9,10],[0,1,2,3,4,5,6,7,8,9,10,11],[1,2,3,0,0,1,2,3,5,6,7,4],[-1,-1,-1,-1,7,4,5,6,-1,-1,-1,-1],[3,0,1,2,3,0,1,2,4,5,6,7],[2,3,0,1,-1,-1,-1,-1,0,1,2,3]],t.SWAPARRAY=[[0,0,0,0,0,0,0,0,3,3,3,3],[0,0,0,0,0,0,0,0,6,6,6,6],[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,5,5,5,5],[0,0,0,0,0,0,0,0,0,0,0,0],[5,5,5,5,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0],[6,6,6,6,0,0,0,0,0,0,0,0],[3,3,3,3,0,0,0,0,0,0,0,0]],t.Z0=v.TWOTHIRD,t.prototype.init=function(){this.ctab=new Array(256),this.utab=new Array(256);for(var n=0;n<256;++n)this.ctab[n]=1&n|(2&n)<<7|(4&n)>>1|(8&n)<<6|(16&n)>>2|(32&n)<<5|(64&n)>>3|(128&n)<<4,this.utab[n]=1&n|(2&n)<<1|(4&n)<<2|(8&n)<<3|(16&n)<<4|(32&n)<<5|(64&n)<<6|(128&n)<<7;this.nl2=2*this.nside,this.nl3=3*this.nside,this.nl4=4*this.nside,this.npface=this.nside*this.nside,this.ncap=2*this.nside*(this.nside-1),this.npix=12*this.npface,this.fact2=4/this.npix,this.fact1=(this.nside<<1)*this.fact2,this.order=t.nside2order(this.nside)},t.calculateNSide=function(e){for(var i=0,a=e*e,o=180/v.PI,r=4*v.PI*o*o*3600*3600,l=n.castToInt(r/a)/12,s=Math.sqrt(l),c=t.NS_MAX,f=0,u=0;u<t.NSIDELIST.length;u++)if(Math.abs(s-t.NSIDELIST[u])<=c&&(c=Math.abs(s-t.NSIDELIST[u]),i=t.NSIDELIST[u],f=u),s>i&&s<t.NS_MAX&&(i=t.NSIDELIST[f+1]),s>t.NS_MAX)return console.log("nside cannot be bigger than "+t.NS_MAX),t.NS_MAX;return i},t.nside2order=function(e){return(e&e-1)>0?-1:n.castToInt(t.log2(e))},t.log2=function(n){return Math.log(n)/Math.log(2)},t.prototype.ang2pix_nest=function(e,i){var a,o,r,l,s,c,f,u,p,_;if(i>=v.TWOPI&&(i-=v.TWOPI),i<0&&(i+=v.TWOPI),e>v.PI||e<0)throw{name:"Illegal argument",message:"theta must be between 0 and "+v.PI};if(i>v.TWOPI||i<0)throw{name:"Illegal argument",message:"phi must be between 0 and "+v.TWOPI};if(a=Math.cos(e),o=Math.abs(a),r=i/v.PIOVER2,o<=t.Z0){var h,d=this.nside*(.5+r),m=this.nside*(.75*a),x=d+m;u=(s=(h=d-m)>>this.order)==(c=x>>this.order)?4==s?4:s+4:s<c?s:c+8,p=n.castToInt(x&this.nside-1),_=n.castToInt(this.nside-(h&this.nside-1)-1)}else{(f=n.castToInt(r))>=4&&(f=3),l=r-f;var g=this.nside*Math.sqrt(3*(1-o));h=n.castToInt(l*g),x=n.castToInt((1-l)*g),h=Math.min(t.NS_MAX-1,h),x=Math.min(t.NS_MAX-1,x),a>=0?(u=f,p=n.castToInt(this.nside-x-1),_=n.castToInt(this.nside-h-1)):(u=f+8,p=h,_=x)}return this.xyf2nest(p,_,u)},t.prototype.xyf2nest=function(n,e,t){return(t<<2*this.order)+(this.utab[255&n]|this.utab[n>>8&255]<<16|this.utab[n>>16&255]<<32|this.utab[n>>24&255]<<48|this.utab[255&e]<<1|this.utab[e>>8&255]<<17|this.utab[e>>16&255]<<33|this.utab[e>>24&255]<<49)},t.prototype.nest2xyf=function(n){var e={};e.face_num=n>>2*this.order;var t=n&this.npface-1,i=(93823560581120&t)>>16|(614882086624428e4&t)>>31|21845&t|(1431633920&t)>>15;return e.ix=this.ctab[255&i]|this.ctab[i>>8&255]<<4|this.ctab[i>>16&255]<<16|this.ctab[i>>24&255]<<20,i=(93823560581120&(t>>=1))>>16|(614882086624428e4&t)>>31|21845&t|(1431633920&t)>>15,e.iy=this.ctab[255&i]|this.ctab[i>>8&255]<<4|this.ctab[i>>16&255]<<16|this.ctab[i>>24&255]<<20,e},t.prototype.pix2ang_nest=function(n){if(n<0||n>this.npix-1)throw{name:"Illegal argument",message:"ipix out of range"};var e,i,a,o=this.nest2xyf(n),r=o.ix,l=o.iy,s=o.face_num,c=(t.JRLL[s]<<this.order)-r-l-1;c<this.nside?(i=1-(e=c)*e*this.fact2,a=0):c>this.nl3?(i=(e=this.nl4-c)*e*this.fact2-1,a=0):(e=this.nside,i=(this.nl2-c)*this.fact1,a=c-this.nside&1);var f=Math.acos(i),u=(t.JPLL[s]*e+r-l+1+a)/2;return u>this.nl4&&(u-=this.nl4),u<1&&(u+=this.nl4),{theta:f,phi:(u-.5*(a+1))*(v.PIOVER2/e)}},t.nside2Npix=function(n){if(n<0||(n&-n)!=n||n>t.NS_MAX)throw{name:"Illegal argument",message:"nside should be >0, power of 2, <"+t.NS_MAX};return 12*n*n},t.prototype.xyf2ring=function(n,e,i){var a,o,r,l=t.JRLL[i]*this.nside-n-e-1;l<this.nside?(r=2*(a=l)*(a-1),o=0):l>3*this.nside?(a=this.nl4-l,r=this.npix-2*(a+1)*a,o=0):(a=this.nside,r=this.ncap+(l-this.nside)*this.nl4,o=l-this.nside&1);var s=(t.JPLL[i]*a+n-e+1+o)/2;return s>this.nl4?s-=this.nl4:s<1&&(s+=this.nl4),r+s-1},t.prototype.nest2ring=function(n){var e=this.nest2xyf(n);return this.xyf2ring(e.ix,e.iy,e.face_num)},t.prototype.corners_nest=function(n,e){var t=this.nest2ring(n);return this.corners_ring(t,e)},t.prototype.pix2ang_ring=function(e){var t,i,a,o,r,l,s,c,f;if(e<0||e>this.npix-1)throw{name:"Illegal argument",message:"ipix out of range"};return(l=e+1)<=this.ncap?(f=n.castToInt(c=l/2),o=l-2*(a=n.castToInt(Math.sqrt(c-Math.sqrt(f)))+1)*(a-1),t=Math.acos(1-a*a*this.fact2),i=(o-.5)*v.PI/(2*a)):e<this.npix-this.ncap?(a=(r=e-this.ncap)/this.nl4+this.nside,o=r%this.nl4+1,s=(a+this.nside&1)>0?1:.5,t=Math.acos((this.nl2-a)*this.fact1),i=(o-s)*v.PI/this.nl2):(r=this.npix-e,o=4*(a=n.castToInt(.5*(1+Math.sqrt(2*r-1))))+1-(r-2*a*(a-1)),t=Math.acos(Math.pow(a,2)*this.fact2-1),i=(o-.5)*v.PI/(2*a)),[t,i]},t.prototype.ring=function(e){var t,i,a=0,o=e+1,r=0;return o<=this.ncap?(r=n.castToInt(i=o/2),a=n.castToInt(Math.sqrt(i-Math.sqrt(r)))+1):o<=this.nl2*(5*this.nside+1)?(t=n.castToInt(o-this.ncap-1),a=n.castToInt(t/this.nl4+this.nside)):(t=this.npix-o+1,r=n.castToInt(i=t/2),a=n.castToInt(Math.sqrt(i-Math.sqrt(r)))+1,a=this.nl4-a),a},t.prototype.integration_limits_in_costh=function(n){var e,t,i,a;return a=1*this.nside,n<=this.nside?(t=1-Math.pow(n,2)/3/this.npface,i=1-Math.pow(n-1,2)/3/this.npface,e=n==this.nside?2*(this.nside-1)/3/a:1-Math.pow(n+1,2)/3/this.npface):n<this.nl3?(t=2*(2*this.nside-n)/3/a,i=2*(2*this.nside-n+1)/3/a,e=2*(2*this.nside-n-1)/3/a):(i=n==this.nl3?2*(1-this.nside)/3/a:Math.pow(4*this.nside-n+1,2)/3/this.npface-1,e=Math.pow(this.nl4-n-1,2)/3/this.npface-1,t=Math.pow(this.nl4-n,2)/3/this.npface-1),[i,t,e]},t.prototype.pixel_boundaries=function(n,e,t,i){var a,o,r,l,s,c,f,u=1*this.nside;if(Math.abs(i)>=1-1/3/this.npface)return[c=t*v.PIOVER2,f=(t+1)*v.PIOVER2];if(1.5*i>=1)a=1/u/Math.sqrt(3*(1-i)),r=(o=e)-1,s=1+(l=n-e),c=v.PIOVER2*(Math.max(r*a,1-s*a)+t),f=v.PIOVER2*(Math.min(1-l*a,o*a)+t);else if(-1<1.5*i){var p=.5*(1-1.5*i),_=p+1,h=this.nside+n%2;r=(o=e-(h-n)/2)-1,s=1+(l=(h+n)/2-e),c=v.PIOVER2*(Math.max(_-s/u,r/u-p)+t),f=v.PIOVER2*(Math.min(_-l/u,o/u-p)+t)}else{a=1/u/Math.sqrt(3*(1+i));var d=2*this.nside;r=(o=n-d+e)-1,s=1+(l=d-e),c=v.PIOVER2*(Math.max(1-(d-r)*a,(d-s)*a)+t),f=v.PIOVER2*(Math.min(1-(d-o)*a,(d-l)*a)+t)}return[c,f]},t.vector=function(n,e){var t=1*Math.sin(n)*Math.cos(e),i=1*Math.sin(n)*Math.sin(e),a=1*Math.cos(n);return new g(t,i,a)},t.prototype.corners_ring=function(e,i){var a=2*i+2,o=new Array(a),r=this.pix2ang_ring(e),l=Math.cos(r[0]),s=r[0],c=r[1],f=n.castToInt(c/v.PIOVER2),u=this.ring(e),p=Math.min(u,Math.min(this.nside,this.nl4-u)),_=0,h=v.PIOVER2/p;_=u>=this.nside&&u<=this.nl3?n.castToInt(c/h+u%2/2)+1:n.castToInt(c/h)+1,_-=f*p;var d=a/2,m=this.integration_limits_in_costh(u),x=Math.acos(m[0]),g=Math.acos(m[2]),y=this.pixel_boundaries(u,_,f,m[0]);if(o[0]=_>p/2?t.vector(x,y[1]):t.vector(x,y[0]),y=this.pixel_boundaries(u,_,f,m[2]),o[d]=_>p/2?t.vector(g,y[1]):t.vector(g,y[0]),1==i){var w=Math.acos(m[1]);y=this.pixel_boundaries(u,_,f,m[1]),o[1]=t.vector(w,y[0]),o[3]=t.vector(w,y[1])}else for(var b=(m[2]-m[0])/(i+1),I=1;I<=i;I++)l=m[0]+b*I,s=Math.acos(l),y=this.pixel_boundaries(u,_,f,l),o[I]=t.vector(s,y[0]),o[a-I]=t.vector(s,y[1]);return o},t.vec2Ang=function(n){var e=n.z/n.length(),t=Math.acos(e),i=0;return 0==n.x&&0==n.y||(i=Math.atan2(n.y,n.x)),i<0&&(i+=2*Math.PI),[t,i]},t.prototype.queryDisc=function(n,i,a,o){if(i<0||i>v.PI)throw{name:"Illegal argument",message:"angular radius is in RADIAN and should be in [0,pi]"};var r,l,s,c,f,u,p,_,h,d,m,x,g,y,w,b,I,P,z,T,S=new e,C=i;if(o&&(C+=v.PI/this.nl4),u=(c=t.vec2Ang(n))[0],p=c[1],m=this.fact2,x=this.fact1,f=Math.cos(u),z=1/Math.sqrt((1-f)*(1+f)),y=u-C,w=u+C,_=Math.cos(C),I=Math.cos(y),r=this.ringAbove(I)+1,b=Math.cos(w),(l=this.ringAbove(b))<r&&0==l&&(l=r),y<=0)for(var A=1;A<r;++A)this.inRing(A,0,Math.PI,S);for(s=r;s<=l;++s)d=1-(P=s<this.nside?1-s*s*m:s<=this.nl3?(this.nl2-s)*x:(this.nl4-s)*(this.nl4-s)*m-1)*P-(h=(_-P*f)*z)*h,g=Math.atan2(Math.sqrt(d),h),isNaN(g)&&(g=C),this.inRing(s,p,g,S);if(w>=Math.PI)for(A=l+1;A<this.nl4;++A)this.inRing(A,0,Math.PI,S,!1);if(a){for(var k=S.items,D=[],q=0;q<k.length;q++){var R=this.ring2nest(k[q]);D.indexOf(R)>=0||D.push(R)}T=D}else T=S.items;return T},t.prototype.inRing=function(e,t,i,a,o){var r,l,s,c,f,u=!1,p=!1,_=1e-12,h=0,d=0,m=0,x=(t-i)%v.TWOPI-_,g=t+i+_,y=(t+i)%v.TWOPI+_;if(Math.abs(i-v.PI)<_&&(u=!0),e>=this.nside&&e<=this.nl3?(h=e-this.nside+1,f=(c=this.ncap+this.nl4*(h-1))+this.nl4-1,l=h%2,s=this.nl4):(e<this.nside?f=(c=2*(h=e)*(h-1))+4*h-1:(h=4*this.nside-e,f=(c=this.npix-2*h*(h+1))+4*h-1),s=4*h,l=1),u)a.appendRange(c,f);else{if(r=l/2,o)d=Math.round(s*x/v.TWOPI-r),d%=s,(m=Math.round(s*g/v.TWOPI-r))>s&&(m%=s);else{if(d=Math.ceil(s*x/v.TWOPI-r),(m=n.castToInt(s*y/v.TWOPI-r))<d&&1==e&&(m=n.castToInt(s*g/v.TWOPI-r)),d==m+1&&(d=m),d-m==1&&i*s<v.PI)return void console.log("the interval is too small and avay from center");d=Math.min(d,s-1),m=Math.max(m,0)}if(d>m&&(p=!0),p)d+=c,m+=c,a.appendRange(c,m),a.appendRange(d,f);else{if(d<0)return d=Math.abs(d),a.appendRange(c,c+m),void a.appendRange(f-d+1,f);d+=c,m+=c,a.appendRange(d,m)}}},t.prototype.ringAbove=function(e){var t=Math.abs(e);if(t>v.TWOTHIRD){var i=n.castToInt(this.nside*Math.sqrt(3*(1-t)));return e>0?i:4*this.nside-i-1}return n.castToInt(this.nside*(2-1.5*e))},t.prototype.ring2nest=function(n){var e=this.ring2xyf(n);return this.xyf2nest(e.ix,e.iy,e.face_num)},t.prototype.ring2xyf=function(e){var i,a,o,r,l={};if(e<this.ncap)a=e+1-2*(i=n.castToInt(.5*(1+Math.sqrt(1+2*e))))*(i-1),o=0,r=i,l.face_num=0,(_=a-1)>=2*i&&(l.face_num=2,_-=2*i),_>=i&&++l.face_num;else if(e<this.npix-this.ncap){var s=e-this.ncap;this.order>=0?(i=(s>>this.order+2)+this.nside,a=1+(s&this.nl4-1)):(i=s/this.nl4+this.nside,a=s%this.nl4+1),o=i+this.nside&1,r=this.nside;var c,f,u=i-this.nside+1,p=this.nl2+2-u;this.order>=0?(c=a-n.castToInt(u/2)+this.nside-1>>this.order,f=a-n.castToInt(p/2)+this.nside-1>>this.order):(c=(a-n.castToInt(u/2)+this.nside-1)/this.nside,f=(a-n.castToInt(p/2)+this.nside-1)/this.nside),l.face_num=f==c?4==f?4:n.castToInt(f)+4:f<c?n.castToInt(f):n.castToInt(c)+8}else{var _;s=this.npix-e,a=4*(i=n.castToInt(.5*(1+Math.sqrt(2*s-1))))+1-(s-2*i*(i-1)),o=0,r=i,i=2*this.nl2-i,l.face_num=8,(_=a-1)>=2*r&&(l.face_num=10,_-=2*r),_>=r&&++l.face_num}var h=i-t.JRLL[l.face_num]*this.nside+1,d=2*a-t.JPLL[l.face_num]*r-o-1;return d>=this.nl2&&(d-=8*this.nside),l.ix=d-h>>1,l.iy=-(d+h)>>1,l},t.utils=n,t}(),g=function(){function n(n,e,t){this.x=n,this.y=e,this.z=t,this.ra_=0,this.dec_=0,this.okRaDec_=!1}return n.prototype.setXYZ=function(n,e,t){this.x=n,this.y=e,this.z=t,this.okRaDec_=!1},n.prototype.length=function(){return Math.sqrt(this.lengthSquared())},n.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y+this.z*this.z},n.prototype.normalized=function(){var n=this.length();this.x/=n,this.y/=n,this.z/=n},n.prototype.set=function(n,e){this.ra_=n,this.dec_=e,this.okRaDec_=!0,this.updateXYZ()},n.prototype.angle=function(n){var e=this.y*n.z-this.z*n.y,t=this.z*n.x-this.x*n.z,i=this.x*n.y-this.y*n.x,a=Math.sqrt(e*e+t*t+i*i);return Math.abs(Math.atan2(a,dot(n)))},n.prototype.get=function(){return[x,y,z]},n.prototype.toString=function(){return"SpatialVector["+this.x+", "+this.y+", "+this.z+"]"},n.prototype.cross=function(e){return new n(this.y*e.z-e.y*this.z,this.z*e.x-e.z*this.x,this.x*e.y-e.x()*this.y)},n.prototype.equal=function(n){return this.x==n.x&&this.y==n.y&&this.z==n.z()},n.prototype.mult=function(e){return new n(e*this.x,e*this.y,e*this.z)},n.prototype.dot=function(n){return this.x*n.x+this.y*n.y+this.z*n.z},n.prototype.add=function(e){return new n(this.x+e.x,this.y+e.y,this.z+e.z)},n.prototype.sub=function(e){return new n(this.x-e.x,this.y-e.y,this.z-e.z)},n.prototype.dec=function(){return this.okRaDec_||(this.normalized(),this.updateRaDec()),this.dec_},n.prototype.ra=function(){return this.okRaDec_||(this.normalized(),this.updateRaDec()),this.ra_},n.prototype.updateXYZ=function(){var n=Math.cos(this.dec_*v.C_PR);this.x=Math.cos(this.ra_*v.C_PR)*n,this.y=Math.sin(this.ra_*v.C_PR)*n,this.z=Math.sin(this.dec_*v.C_PR)},n.prototype.updateRaDec=function(){this.dec_=Math.asin(this.z)/v.C_PR;var n=Math.cos(this.dec_*v.C_PR);n>v.EPS||n<-v.EPS?this.y>v.EPS||this.y<-v.EPS?this.y<0?this.ra_=360-Math.acos(this.x/n)/v.C_PR:this.ra_=Math.acos(this.x/n)/v.C_PR:this.ra_=this.x<0?180:0:this.ra_=0,this.okRaDec_=!0},n.prototype.toRaRadians=function(){var n=0;return 0==this.x&&0==this.y||(n=Math.atan2(this.y,this.x)),n<0&&(n+=2*Math.PI),n},n.prototype.toDeRadians=function(){var n=z/this.length(),e=Math.acos(n);return Math.PI/2-e},n}(),w=function(){let n={staticCache:{corners:{nside8:[]}},dynamicCache:{},lastNside:8,hpxIdxCache:null,init:function(){var e=new m(8);e.init();var t=m.nside2Npix(8);let i;for(var a=0;a<t;a++)i=e.corners_nest(a,1),n.staticCache.corners.nside8.push(i);n.hpxIdxCache=e}};return n.init(),n.corners_nest=function(e,t){return 8==t?n.staticCache.corners.nside8[e]:(t!=n.lastNside&&(n.hpxIdxCache=new m(t),n.hpxIdxCache.init(),n.lastNside=t),n.hpxIdxCache.corners_nest(e,1))},n}();var b=t(6186),I=t(6818);let P=function(){function n(n,e){this.img=n,this.url=e}return n.isImageOk=function(n){return!!n.allSkyTexture||!!n.src&&!!n.complete&&(void 0===n.naturalWidth||0!=n.naturalWidth)},n}(),T=function(){function n(){this.pointer=0,this.tilesMap={},this.tilesArray=new Array(800);for(var n=0;n<800;n++)this.tilesArray[n]=new P(new Image,null)}return n.prototype.addTile=function(n){if(this.getTile(n))return null;var e=this.tilesArray[this.pointer];return null!=e.url&&(e.img.src=null,delete this.tilesMap[e.url]),this.tilesArray[this.pointer].url=n,this.tilesMap[n]=this.tilesArray[this.pointer],this.pointer++,this.pointer>=800&&(this.pointer=0),this.tilesMap[n]},n.prototype.getTile=function(n){return this.tilesMap[n]},n}(),S=function(){let n=function(n){this.view=n,this.nbDownloads=0,this.dlQueue=[],this.urlsInQueue={}};return n.prototype.emptyQueue=function(){this.dlQueue=[],this.urlsInQueue={}},n.prototype.requestDownload=function(n,e,t){e in this.urlsInQueue||(this.dlQueue.push({img:n,url:e,cors:t}),this.urlsInQueue[e]=1,this.tryDownload())},n.prototype.tryDownload=function(){for(;this.dlQueue.length>0&&this.nbDownloads<4;)this.startDownloadNext()},n.prototype.startDownloadNext=function(){var n=this.dlQueue.shift();if(n){this.nbDownloads++;var e=this;n.img.onload=function(){e.completeDownload(this,!0)},n.img.onerror=function(n){e.completeDownload(this,!1)},n.cors?n.img.crossOrigin="anonymous":void 0!==n.img.crossOrigin&&delete n.img.crossOrigin,n.img.src=n.url}},n.prototype.completeDownload=function(n,e){delete this.urlsInQueue[n.src],n.onerror=null,n.onload=null,this.nbDownloads--,e?this.view.requestRedraw():n.dlError=!0,this.tryDownload()},n}(),C=function(){function n(n,e,t){var i,a,o;for(a=0;a<30;a++)for(i=0;i<73;i++)n[o=4*(i+74*a)]=n[o+4],n[o+1]=n[o+5],n[o+2]=n[o+6];for(a=0;a<30;a++)o=4*(73+74*a),a<e?(n[o]=k[t].bg.r,n[o+1]=k[t].bg.g,n[o+2]=k[t].bg.b):(n[o]=k[t].fg.r,n[o+1]=k[t].fg.g,n[o+2]=k[t].fg.b)}var e,t,i,a,o,r,l,s,c,f,u,p,_,h,d=0,v=2,m=0,x=(new Date).getTime(),g=x,y=x,w=0,b=1e3,I=0,P=0,z=1e3,T=0,S=0,C=1e3,A=0,k={fps:{bg:{r:16,g:16,b:48},fg:{r:0,g:255,b:255}},ms:{bg:{r:16,g:48,b:16},fg:{r:0,g:255,b:0}},mb:{bg:{r:48,g:16,b:26},fg:{r:255,g:0,b:128}}};(e=document.createElement("div")).style.cursor="pointer",e.style.width="80px",e.style.opacity="0.9",e.style.zIndex="10001",e.addEventListener("click",(function(){switch(++d==v&&(d=0),t.style.display="none",l.style.display="none",u.style.display="none",d){case 0:t.style.display="block";break;case 1:l.style.display="block";break;case 2:u.style.display="block"}}),!1),(t=document.createElement("div")).style.backgroundColor="rgb("+Math.floor(k.fps.bg.r/2)+","+Math.floor(k.fps.bg.g/2)+","+Math.floor(k.fps.bg.b/2)+")",t.style.padding="2px 0px 3px 0px",e.appendChild(t),(i=document.createElement("div")).style.fontFamily="Helvetica, Arial, sans-serif",i.style.textAlign="left",i.style.fontSize="9px",i.style.color="rgb("+k.fps.fg.r+","+k.fps.fg.g+","+k.fps.fg.b+")",i.style.margin="0px 0px 1px 3px",i.innerHTML='<span style="font-weight:bold">FPS</span>',t.appendChild(i),(a=document.createElement("canvas")).width=74,a.height=30,a.style.display="block",a.style.marginLeft="3px",t.appendChild(a),(o=a.getContext("2d")).fillStyle="rgb("+k.fps.bg.r+","+k.fps.bg.g+","+k.fps.bg.b+")",o.fillRect(0,0,a.width,a.height),r=o.getImageData(0,0,a.width,a.height),(l=document.createElement("div")).style.backgroundColor="rgb("+Math.floor(k.ms.bg.r/2)+","+Math.floor(k.ms.bg.g/2)+","+Math.floor(k.ms.bg.b/2)+")",l.style.padding="2px 0px 3px 0px",l.style.display="none",e.appendChild(l),(s=document.createElement("div")).style.fontFamily="Helvetica, Arial, sans-serif",s.style.textAlign="left",s.style.fontSize="9px",s.style.color="rgb("+k.ms.fg.r+","+k.ms.fg.g+","+k.ms.fg.b+")",s.style.margin="0px 0px 1px 3px",s.innerHTML='<span style="font-weight:bold">MS</span>',l.appendChild(s),(a=document.createElement("canvas")).width=74,a.height=30,a.style.display="block",a.style.marginLeft="3px",l.appendChild(a),(c=a.getContext("2d")).fillStyle="rgb("+k.ms.bg.r+","+k.ms.bg.g+","+k.ms.bg.b+")",c.fillRect(0,0,a.width,a.height),f=c.getImageData(0,0,a.width,a.height);try{performance&&performance.memory&&performance.memory.totalJSHeapSize&&(v=3)}catch(n){}return(u=document.createElement("div")).style.backgroundColor="rgb("+Math.floor(k.mb.bg.r/2)+","+Math.floor(k.mb.bg.g/2)+","+Math.floor(k.mb.bg.b/2)+")",u.style.padding="2px 0px 3px 0px",u.style.display="none",e.appendChild(u),(p=document.createElement("div")).style.fontFamily="Helvetica, Arial, sans-serif",p.style.textAlign="left",p.style.fontSize="9px",p.style.color="rgb("+k.mb.fg.r+","+k.mb.fg.g+","+k.mb.fg.b+")",p.style.margin="0px 0px 1px 3px",p.innerHTML='<span style="font-weight:bold">MB</span>',u.appendChild(p),(a=document.createElement("canvas")).width=74,a.height=30,a.style.display="block",a.style.marginLeft="3px",u.appendChild(a),(_=a.getContext("2d")).fillStyle="#301010",_.fillRect(0,0,a.width,a.height),h=_.getImageData(0,0,a.width,a.height),{domElement:e,update:function(){m++,x=(new Date).getTime(),P=x-g,z=Math.min(z,P),T=Math.max(T,P),n(f.data,Math.min(30,30-P/200*30),"ms"),s.innerHTML='<span style="font-weight:bold">'+P+" MS</span> ("+z+"-"+T+")",c.putImageData(f,0,0),g=x,x>y+1e3&&(w=Math.round(1e3*m/(x-y)),b=Math.min(b,w),I=Math.max(I,w),n(r.data,Math.min(30,30-w/100*30),"fps"),i.innerHTML='<span style="font-weight:bold">'+w+" FPS</span> ("+b+"-"+I+")",o.putImageData(r,0,0),3==v&&(S=954e-9*performance.memory.usedJSHeapSize,C=Math.min(C,S),A=Math.max(A,S),n(h.data,Math.min(30,30-S/2),"mb"),p.innerHTML='<span style="font-weight:bold">'+Math.round(S)+" MB</span> ("+Math.round(C)+"-"+Math.round(A)+")",_.putImageData(h,0,0)),y=x,m=0)}}},k=function(){let n=function(n){this.view=n,this.reversed=!1,this.mapName="native",this.sig=this.signature()};return(n.MAPS={}).eosb={name:"Eos B",r:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,18,27,36,45,49,57,72,81,91,100,109,118,127,136,131,139,163,173,182,191,200,209,218,227,213,221,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,253,251,249,247,245,243,241,215,214,235,234,232,230,228,226,224,222,198,196,216,215,213,211,209,207,205,203,181,179,197,196,194,192,190,188,186,184,164,162,178,176,175,173,171,169,167,165,147,145,159,157,156,154,152,150,148,146,130,128,140,138,137,135,133,131,129,127,113,111,121,119,117,117],g:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,15,23,31,39,47,55,57,64,79,87,95,103,111,119,127,135,129,136,159,167,175,183,191,199,207,215,200,207,239,247,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,250,246,242,238,233,229,225,198,195,212,208,204,199,195,191,187,182,160,156,169,165,161,157,153,148,144,140,122,118,127,125,123,121,119,116,114,112,99,97,106,104,102,99,97,95,93,91,80,78,84,82,80,78,76,74,72,70,61,59,63,61,59,57,55,53,50,48,42,40,42,40,38,36,33,31,29,27,22,21,21,19,16,14,12,13,8,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],b:[116,121,127,131,136,140,144,148,153,157,145,149,170,174,178,182,187,191,195,199,183,187,212,216,221,225,229,233,238,242,221,225,255,247,239,231,223,215,207,199,172,164,175,167,159,151,143,135,127,119,100,93,95,87,79,71,63,55,47,39,28,21,15,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},n.MAPS.rainbow={name:"Rainbow",r:[0,4,9,13,18,22,27,31,36,40,45,50,54,58,61,64,68,69,72,74,77,79,80,82,83,85,84,86,87,88,86,87,87,87,85,84,84,84,83,79,78,77,76,71,70,68,66,60,58,55,53,46,43,40,36,33,25,21,16,12,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,21,25,29,33,42,46,51,55,63,67,72,76,80,89,93,97,101,110,114,119,123,131,135,140,144,153,157,161,165,169,178,182,187,191,199,203,208,212,221,225,229,233,242,246,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],g:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,16,21,25,29,38,42,46,51,55,63,67,72,76,84,89,93,97,106,110,114,119,127,131,135,140,144,152,157,161,165,174,178,182,187,195,199,203,208,216,220,225,229,233,242,246,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,242,238,233,229,221,216,212,208,199,195,191,187,178,174,170,165,161,153,148,144,140,131,127,123,119,110,106,102,97,89,85,80,76,72,63,59,55,51,42,38,34,29,21,17,12,8,0],b:[0,3,7,10,14,19,23,28,32,38,43,48,53,59,63,68,72,77,81,86,91,95,100,104,109,113,118,122,127,132,136,141,145,150,154,159,163,168,173,177,182,186,191,195,200,204,209,214,218,223,227,232,236,241,245,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,246,242,238,233,225,220,216,212,203,199,195,191,187,178,174,170,165,157,152,148,144,135,131,127,123,114,110,106,102,97,89,84,80,76,67,63,59,55,46,42,38,34,25,21,16,12,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},n.MAPS.cubehelix={name:"Cubehelix",r:[0,1,3,4,6,8,9,10,12,13,14,15,17,18,19,20,20,21,22,23,23,24,24,25,25,25,26,26,26,26,26,26,26,26,26,26,26,25,25,25,25,24,24,24,23,23,23,23,22,22,22,21,21,21,21,21,21,20,20,20,21,21,21,21,21,22,22,22,23,23,24,25,26,27,27,28,30,31,32,33,35,36,38,39,41,43,45,47,49,51,53,55,57,60,62,65,67,70,72,75,78,81,83,86,89,92,95,98,101,104,107,110,113,116,120,123,126,129,132,135,138,141,144,147,150,153,155,158,161,164,166,169,171,174,176,178,181,183,185,187,189,191,193,194,196,198,199,201,202,203,204,205,206,207,208,209,209,210,211,211,211,212,212,212,212,212,212,212,212,211,211,211,210,210,210,209,208,208,207,207,206,205,205,204,203,203,202,201,201,200,199,199,198,197,197,196,196,195,195,194,194,194,193,193,193,193,193,193,193,193,193,193,194,194,195,195,196,196,197,198,199,200,200,202,203,204,205,206,208,209,210,212,213,215,217,218,220,222,223,225,227,229,231,232,234,236,238,240,242,244,245,247,249,251,253,255],g:[0,0,1,1,2,2,3,4,4,5,6,6,7,8,9,10,11,11,12,13,14,15,17,18,19,20,21,22,24,25,26,28,29,31,32,34,35,37,38,40,41,43,45,46,48,50,52,53,55,57,58,60,62,64,66,67,69,71,73,74,76,78,79,81,83,84,86,88,89,91,92,94,95,97,98,99,101,102,103,104,106,107,108,109,110,111,112,113,114,114,115,116,116,117,118,118,119,119,120,120,120,121,121,121,121,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,121,121,121,121,121,121,121,121,121,120,120,120,120,120,120,120,120,120,120,121,121,121,121,121,122,122,122,123,123,124,124,125,125,126,127,127,128,129,130,131,131,132,133,135,136,137,138,139,140,142,143,144,146,147,149,150,152,154,155,157,158,160,162,164,165,167,169,171,172,174,176,178,180,182,183,185,187,189,191,193,194,196,198,200,202,203,205,207,208,210,212,213,215,216,218,219,221,222,224,225,226,228,229,230,231,232,233,235,236,237,238,239,240,240,241,242,243,244,244,245,246,247,247,248,248,249,250,250,251,251,252,252,253,253,254,255],b:[0,1,3,4,6,8,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,48,50,52,54,56,57,59,60,62,63,65,66,67,69,70,71,72,73,74,74,75,76,76,77,77,77,78,78,78,78,78,78,78,77,77,77,76,76,75,75,74,73,73,72,71,70,69,68,67,66,66,65,64,63,61,60,59,58,58,57,56,55,54,53,52,51,51,50,49,49,48,48,47,47,47,46,46,46,46,46,47,47,47,48,48,49,50,50,51,52,53,55,56,57,59,60,62,64,65,67,69,71,74,76,78,81,83,86,88,91,94,96,99,102,105,108,111,114,117,120,124,127,130,133,136,140,143,146,149,153,156,159,162,165,169,172,175,178,181,184,186,189,192,195,197,200,203,205,207,210,212,214,216,218,220,222,224,226,227,229,230,231,233,234,235,236,237,238,239,239,240,241,241,242,242,242,243,243,243,243,243,243,243,243,243,243,242,242,242,242,241,241,241,241,240,240,240,239,239,239,239,239,238,238,238,238,238,238,238,238,239,239,239,240,240,240,241,242,242,243,244,245,246,247,248,249,250,252,253,255]},n.MAPS_NAMES=["native","grayscale"].concat(n.MAPS_CUSTOM=["cubehelix","eosb","rainbow"]),n.prototype.reverse=function(n){this.reversed=n||!this.reversed,this.sig=this.signature(),this.view.requestRedraw()},n.prototype.signature=function(){var n=this.mapName;return this.reversed&&(n+=" reversed"),n},n.prototype.update=function(n){this.mapName=n,this.sig=this.signature(),this.view.requestRedraw()},n.prototype.apply=function(e){if("native"==this.sig)return e;if(e.cmSig==this.sig)return e.cmImg;var t=document.createElement("canvas");t.width=e.width,t.height=e.height;var i=t.getContext("2d");i.drawImage(e,0,0);var a,o,r,l=i.getImageData(0,0,t.width,t.height),s=l.data,c=s.length,f=3;"grayscale"==this.mapName?f=1:n.MAPS_CUSTOM.indexOf(this.mapName)>=0&&(f=2);for(var u=0;u<c;u+=4){switch(f){case 1:a=o=r=d.myRound((s[u]+s[u+1]+s[u+2])/3);break;case 2:this.reversed?(a=n.MAPS[this.mapName].r[255-s[u]],o=n.MAPS[this.mapName].g[255-s[u+1]],r=n.MAPS[this.mapName].b[255-s[u+2]]):(a=n.MAPS[this.mapName].r[s[u]],o=n.MAPS[this.mapName].g[s[u+1]],r=n.MAPS[this.mapName].b[s[u+2]]);break;default:a=s[u],o=s[u+1],r=s[u+2]}2!=f&&this.reversed&&(a=255-a,o=255-o,r=255-r),s[u]=a,s[u+1]=o,s[u+2]=r}return i.putImageData(l,0,0),e.cmSig=this.sig,e.cmImg=t,e.cmImg},n}(),D=function(){let n=function(n){this.polygons=n,this.overlay=null,this.id="footprint-"+b.c.uuidv4(),this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.dispatchClickEvent=function(){this.overlay&&this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent("footprintClicked",{detail:{footprintId:this.id,overlayName:this.overlay.name}}))},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n}(),q=function(){let n=function(n,e,t){t=t||{},this.color=t.color||void 0,this.id="circle-"+b.c.uuidv4(),this.setCenter(n),this.setRadius(e),this.overlay=null,this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.dispatchClickEvent=function(){this.overlay&&this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent("footprintClicked",{detail:{footprintId:this.id,overlayName:this.overlay.name}}))},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n.prototype.setCenter=function(n){this.centerRaDec=n,this.overlay&&this.overlay.reportChange()},n.prototype.setRadius=function(n){this.radiusDegrees=n,this.overlay&&this.overlay.reportChange()},n.prototype.draw=function(n,e,t,i,a,o,r,l,s){if(!this.isShowing)return;s=!0===s||!1;var c=d.radecToViewXy(this.centerRaDec[0],this.centerRaDec[1],e);if(!c)return;var f=this.centerRaDec[0],u=this.centerRaDec[1]+(f>0?-this.radiusDegrees:this.radiusDegrees);let p=d.radecToViewXy(f,u,e);if(p){var _=p[0]-c[0],h=p[1]-c[1],v=Math.sqrt(_*_+h*h),m=this.color;!m&&this.overlay&&(m=this.overlay.color),m||(m="#ff0000"),this.isSelected?n.strokeStyle=Overlay.increaseBrightness(m,50):n.strokeStyle=m,n.beginPath(),n.arc(c[0],c[1],v,0,2*Math.PI,!1),s||n.stroke()}},n}(),R=function(){let n={GALACTIC_TO_J2000:[-.0548755604024359,.4941094279435681,-.867666148981161,-.8734370902479237,-.4448296299195045,-.1980763734646737,-.4838350155267381,.7469822444763707,.4559837762325372],J2000_TO_GALACTIC:[-.0548755604024359,-.873437090247923,-.4838350155267381,.4941094279435681,-.4448296299195045,.7469822444763707,-.867666148981161,-.1980763734646737,.4559837762325372],Transform:function(n,e){n[0]=n[0]*Math.PI/180,n[1]=n[1]*Math.PI/180;var t=new Array(Math.cos(n[0])*Math.cos(n[1]),Math.sin(n[0])*Math.cos(n[1]),Math.sin(n[1])),i=new Array(t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8]),a=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]),o=new Array(0,0);o[1]=Math.asin(i[2]/a);var r=i[0]/a/Math.cos(o[1]),l=i[1]/a/Math.cos(o[1]);return o[0]=Math.atan2(l,r),o[0]<0&&(o[0]=o[0]+2*Math.PI),o[0]=180*o[0]/Math.PI,o[1]=180*o[1]/Math.PI,o},GalacticToJ2000:function(e){return n.Transform(e,n.GALACTIC_TO_J2000)},J2000ToGalactic:function(e){return n.Transform(e,n.J2000_TO_GALACTIC)}};return n}(),O=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;var M=t(6706),L=t.n(M),E=t(7263),N=t.n(E),F=t(1682),j=t.n(F),H=t(5126),U=t.n(H),V=t(2860),B=t.n(V),G=t(6496),X=t.n(G),J=t(3380),Y=t.n(J),Z=t(7776),W=t.n(Z),K=t(8686),Q=t.n(K),nn=t(659),en=t.n(nn),tn=t(1403),an=t.n(tn),on=t(8010),rn=t.n(on),ln=t(8428),sn=t.n(ln),cn=t(6175),fn=t.n(cn),un=t(721),pn=t.n(un),_n=t(3845),hn=t.n(_n),dn=t(1417),vn=t.n(dn),mn=t(5437),xn=t.n(mn),gn=t(6843),yn=t.n(gn),wn=t(9752),bn=t.n(wn),In=t(8250),Pn=t.n(In),zn=t(5866),Tn=t.n(zn),Sn=t(8623),Cn=t.n(Sn),An=t(3979),kn=t.n(An),Dn=t(7884),qn=t.n(Dn),Rn=t(7084),On=t.n(Rn),Mn=t(3241),Ln=t.n(Mn),En=t(70),Nn=t.n(En),Fn=t(9336),jn=t.n(Fn),Hn=t(422),Un=t.n(Hn),Vn=t(8462),Bn=t.n(Vn),Gn=t(2609),Xn=t.n(Gn);let Jn=[{id:"CatalogAitoffVS",content:L()},{id:"CatalogMercatVS",content:N()},{id:"CatalogArcVS",content:j()},{id:"CatalogTanVS",content:U()},{id:"CatalogMollVS",content:B()},{id:"CatalogOrthoVS",content:X()},{id:"CatalogOrthoFS",content:Y()},{id:"CatalogFS",content:W()},{id:"ColormapCatalogVS",content:Q()},{id:"ColormapCatalogFS",content:en()},{id:"GridVS",content:an()},{id:"GridAitoffFS",content:rn()},{id:"GridMollFS",content:sn()},{id:"GridOrthoFS",content:fn()},{id:"GridMercatorFS",content:pn()},{id:"GridArcFS",content:hn()},{id:"GridTanFS",content:vn()},{id:"GridFS_CPU",content:yn()},{id:"GridVS_CPU",content:xn()},{id:"RayTracerVS",content:bn()},{id:"RayTracerColorFS",content:Pn()},{id:"RayTracerGrayscale2ColorFS",content:Tn()},{id:"RayTracerGrayscale2ColormapFS",content:Cn()},{id:"RasterizerOrthoVS",content:kn()},{id:"RasterizerMercatorVS",content:qn()},{id:"RasterizerAitoffVS",content:On()},{id:"RasterizerArcVS",content:Nn()},{id:"RasterizerGnomonicVS",content:Ln()},{id:"RasterizerMollVS",content:jn()},{id:"RasterizerColorFS",content:Un()},{id:"RasterizerGrayscale2ColorFS",content:Bn()},{id:"RasterizerGrayscale2ColormapFS",content:Xn()}];function $n(){return Jn}var Yn=t(6086),Zn=t.n(Yn),Wn=t(7668),Kn=t.n(Wn),Qn=t(76),ne=t.n(Qn),ee=t(107),te=t.n(ee),ie=t(4521),ae=t.n(ie),oe=t(1997),re=t.n(oe),le=t(3014),se=t.n(le),ce=t(5856),fe=t.n(ce),ue=t(8524),pe=t.n(ue),_e=t(9570),he=t.n(_e),de=t(926),ve=t.n(de),me=t(2791),xe=t.n(me),ge=t(538),ye=t.n(ge),we=t(7677),be=t.n(we),Ie=t(2462),Pe=t.n(Ie),ze=t(8484),Te=t.n(ze),Se=t(9648),Ce=t.n(Se),Ae=t(9709),ke=t.n(Ae),De=t(8808),qe=t.n(De),Re=t(9116),Oe=t.n(Re),Me=t(2743),Le=t.n(Me),Ee=t(2767),Ne=t.n(Ee),Fe=t(9215),je=t.n(Fe),He=t(6645),Ue=t.n(He),Ve=t(8069),Be=t.n(Ve),Ge=t(7110),Xe=t.n(Ge),Je=t(1203),$e=t.n(Je),Ye=t(5939),Ze=t.n(Ye),We=t(8225),Ke=t.n(We),Qe=t(2502),nt=t.n(Qe),et=t(9379),tt=t.n(et),it=t(1137),at=t.n(it),ot=t(8876),rt=t.n(ot),lt=t(1232),st=t.n(lt),ct=t(7291),ft=t.n(ct),ut=t(9328),pt=t.n(ut),_t=t(7503),ht=t.n(_t),dt=t(6266),vt=t.n(dt),mt=t(9074),xt=t.n(mt),gt=t(108),yt=t.n(gt);Zn(),Kn(),ne(),te(),ae(),re(),se(),fe(),pe(),he(),ve(),xe(),ye(),be(),Pe(),Te(),Ce(),qe(),ke(),Oe(),Le(),Ne(),je(),Ue(),Be(),Xe(),$e(),Ze(),Ke(),nt(),at(),tt(),rt(),st(),ft(),pt(),ht(),vt(),xt(),yt();const wt=t.p+"ccdb93d24585bd08a4261722b95e9e3d.png",bt=t.p+"d51a99cc94312e8e9de793a5d67aa20e.png";let It=function(){let n=function(n){this.surveys=new Map,this.name=n};return n.prototype.addImageSurvey=async function(n){const e=await o.j.create(n);this.surveys.set(n,e)},n.prototype.removeImageSurvey=function(n){this.surveys.remove(n)},n.prototype.clear=function(){this.surveys.clear()},n.prototype.getSurveys=function(){return this.surveys.values()},n}(),Pt=function(){function n(e,t,o,c,f){this.aladin=e,this.options=e.options,this.aladinDiv=this.aladin.aladinDiv,this.popup=new i(this.aladinDiv,this),this.createCanvases(),this.webGL2Supported=!1;const u=$n();let p={kernel:wt,colormaps:bt};try{this.aladin.webglAPI=new Gt.wasmLibs.webgl.WebClient(this.aladinDiv.id,u,p)}catch(n){console.log(n),alert("Problem initializing Aladin Lite. Please contact the support by contacting Matthieu Baumann (baumannmatthieu0@gmail.com) or Thomas Boch (thomas.boch@astro.unistra.fr). You can also open an issue on the Aladin Lite github repository here: https://github.com/cds-astro/aladin-lite")}if(this.location=t,this.fovDiv=o,this.mustClearCatalog=!0,this.mustRedrawReticle=!0,this.imageSurveysToSet=[],this.mode=n.PAN,this.minFOV=this.maxFOV=null,this.fov_limit=180,this.healpixGrid=new a(this.imageCanvas),0,this.projectionMethod=s.SIN,this.projection=new l(0,0),this.projection.setProjection(this.projectionMethod),this.prev=0,this.zoomFactor=this.aladin.webglAPI.getClipZoomFactor(),this.viewCenter={lon:0,lat:0},this.cooFrame=c||_.GAL,c.system===_.SYSTEMS.GAL){console.log();const n=Gt.wasmLibs.webgl.GALCooSys();this.aladin.webglAPI.setCooSystem(n)}else{const n=Gt.wasmLibs.webgl.ICRSJ2000CooSys();this.aladin.webglAPI.setCooSystem(n)}f&&this.setZoom(f),this.imageSurveys=new Map,this.catalogs=[];var h=document.createElement("canvas");h.width=h.height=24;var d=h.getContext("2d");d.lineWidth=6,d.beginPath(),d.strokeStyle="#eee",d.arc(12,12,8,0,2*Math.PI,!0),d.stroke(),d.lineWidth=3,d.beginPath(),d.strokeStyle="#c38",d.arc(12,12,8,0,2*Math.PI,!0),d.stroke(),this.catalogForPopup=A.catalog({shape:h,sourceSize:24}),this.catalogForPopup.hide(),this.catalogForPopup.setView(this),this.overlays=[],this.mocs=[],this.allOverlayLayers=[],this.tileBuffer=new T,this.fixLayoutDimensions(),this.firstHiPS=!0,this.curNorder=1,this.realNorder=1,this.curOverlayNorder=1,this.dragging=!1,this.dragx=null,this.dragy=null,this.needRedraw=!0,this.pinchZoomParameters={isPinching:!1,initialFov:void 0,initialDistance:void 0},this.fingersRotationParameters={initialViewAngleFromCenter:void 0,initialFingerAngle:void 0,rotationInitiated:!1},this.downloader=new S(this),this.flagForceRedraw=!1,this.fadingLatestUpdate=null,this.dateRequestRedraw=null,this.showGrid=!1,r(this),this.resizeTimer=null;var v=this;$(window).resize((function(){clearTimeout(v.resizeTimer),v.resizeTimer=setTimeout((function(){v.fixLayoutDimensions(v)}),100)})),setTimeout((function(){var n=$(v.aladinDiv).width(),e=$(v.aladinDiv).height();v.width===n&&v.height!==e||(v.fixLayoutDimensions(),v.updateZoomState())}),1e3)}n.PAN=0,n.SELECT=1,n.TOOL_SIMBAD_POINTER=2,n.DRAW_SOURCES_WHILE_DRAGGING=!0,n.DRAW_MOCS_WHILE_DRAGGING=!0,n.CALLBACKS_THROTTLE_TIME_MS=100,n.prototype.createCanvases=function(){var n=$(this.aladinDiv);n.find(".aladin-imageCanvas").remove(),n.find(".aladin-catalogCanvas").remove(),n.find(".aladin-reticleCanvas").remove(),n.find(".aladin-gridCanvas").remove(),this.imageCanvas=$("<canvas class='aladin-imageCanvas'></canvas>").appendTo(this.aladinDiv)[0],this.gridCanvas=$("<canvas class='aladin-gridCanvas'></canvas>").appendTo(this.aladinDiv)[0],this.catalogCanvas=$("<canvas class='aladin-catalogCanvas'></canvas>").appendTo(this.aladinDiv)[0],this.reticleCanvas=$("<canvas class='aladin-reticleCanvas'></canvas>").appendTo(this.aladinDiv)[0]},n.prototype.fixLayoutDimensions=function(){b.c.cssScale=void 0;var n=$(this.aladinDiv).width(),t=$(this.aladinDiv).height();this.width=Math.max(n,1),this.height=Math.max(t,1),this.cx=this.width/2,this.cy=this.height/2,this.largestDim=Math.max(this.width,this.height),this.smallestDim=Math.min(this.width,this.height),this.ratio=this.largestDim/this.smallestDim,this.mouseMoveIncrement=160/this.largestDim,this.imageCtx=this.imageCanvas.getContext(this.webGL2Supported?"webgl2":"webgl"),this.aladin.webglAPI.resize(this.width,this.height),this.catalogCtx=this.catalogCanvas.getContext("2d"),this.reticleCtx=this.reticleCanvas.getContext("2d"),this.gridCtx=this.gridCanvas.getContext("2d"),this.catalogCtx.canvas.width=this.width,this.reticleCtx.canvas.width=this.width,this.gridCtx.canvas.width=this.width,this.catalogCtx.canvas.height=this.height,this.reticleCtx.canvas.height=this.height,this.gridCtx.canvas.height=this.height,e(this.imageCtx,this.aladin.options.pixelateCanvas),this.logoDiv||(this.logoDiv=$(this.aladinDiv).find(".aladin-logo")[0]),this.width>800?($(this.logoDiv).removeClass("aladin-logo-small"),$(this.logoDiv).addClass("aladin-logo-large"),$(this.logoDiv).css("width","90px")):($(this.logoDiv).addClass("aladin-logo-small"),$(this.logoDiv).removeClass("aladin-logo-large"),$(this.logoDiv).css("width","32px")),this.computeNorder()};var e=function(n,e){var t=!e;n.imageSmoothingEnabled=t,n.webkitImageSmoothingEnabled=t,n.mozImageSmoothingEnabled=t,n.msImageSmoothingEnabled=t,n.oImageSmoothingEnabled=t};n.prototype.setMode=function(e){this.mode=e,this.mode==n.SELECT?this.setCursor("crosshair"):this.mode==n.TOOL_SIMBAD_POINTER?(this.popup.hide(),this.reticleCanvas.style.cursor="",$(this.reticleCanvas).addClass("aladin-sp-cursor")):this.setCursor("default")},n.prototype.setCursor=function(e){this.reticleCanvas.style.cursor!=e&&this.mode!=n.TOOL_SIMBAD_POINTER&&(this.reticleCanvas.style.cursor=e)},n.prototype.getCanvasDataURL=function(n,e,t){n=n||"image/png";var i=document.createElement("canvas");e=e||this.width,t=t||this.height,i.width=e,i.height=t;var a=i.getContext("2d");const o=this.aladin.webglAPI.canvas();return a.drawImage(o,0,0,i.width,i.height),a.drawImage(this.catalogCanvas,0,0,i.width,i.height),a.drawImage(this.reticleCanvas,0,0,i.width,i.height),a.drawImage(this.gridCanvas,0,0,i.width,i.height),i.toDataURL(n)};var t=function(e){var t=!1;"ontouchstart"in window&&(t=!0);var i;t||$(e.reticleCanvas).dblclick((function(n){var t=e.imageCanvas.relMouseCoords(n);if(!e.aladin.webglAPI.posOnUi()){try{var i=e.aladin.webglAPI.screenToWorld(t.x,t.y)}catch(n){return}var a;a=i,e.pointTo(a[0],a[1],{forceAnimation:!0})}})),$(e.reticleCanvas).bind("mousedown touchstart",(function(t){var i=e.imageCanvas.relMouseCoords(t);if(!e.aladin.webglAPI.posOnUi()){if("touchstart"===t.type&&t.originalEvent&&t.originalEvent.targetTouches&&2==t.originalEvent.targetTouches.length){e.dragging=!1,e.pinchZoomParameters.isPinching=!0;var a=e.aladin.webglAPI.getFieldOfView();return e.pinchZoomParameters.initialFov=a,e.pinchZoomParameters.initialDistance=Math.sqrt(Math.pow(t.originalEvent.targetTouches[0].clientX-t.originalEvent.targetTouches[1].clientX,2)+Math.pow(t.originalEvent.targetTouches[0].clientY-t.originalEvent.targetTouches[1].clientY,2)),e.fingersRotationParameters.initialViewAngleFromCenter=e.aladin.webglAPI.getRotationAroundCenter(),void(e.fingersRotationParameters.initialFingerAngle=180*Math.atan2(t.originalEvent.targetTouches[1].clientY-t.originalEvent.targetTouches[0].clientY,t.originalEvent.targetTouches[1].clientX-t.originalEvent.targetTouches[0].clientX)/Math.PI)}return i=e.imageCanvas.relMouseCoords(t),t.originalEvent&&t.originalEvent.targetTouches?(e.dragx=t.originalEvent.targetTouches[0].clientX,e.dragy=t.originalEvent.targetTouches[0].clientY):(e.dragx=i.x,e.dragy=i.y),e.dragging=!0,e.mode==n.PAN?e.setCursor("move"):e.mode==n.SELECT&&(e.selectStartCoo={x:e.dragx,y:e.dragy}),e.aladin.webglAPI.pressLeftMouseButton(e.dragx,e.dragy),!1}})),$(e.reticleCanvas).bind("click mouseout touchend",(function(t){var i=e.imageCanvas.relMouseCoords(t);if("touchend"===t.type&&e.pinchZoomParameters.isPinching)return e.pinchZoomParameters.isPinching=!1,void(e.pinchZoomParameters.initialFov=e.pinchZoomParameters.initialDistance=void 0);if("touchend"===t.type&&e.fingersRotationParameters.rotationInitiated)return e.fingersRotationParameters.initialViewAngleFromCenter=void 0,e.fingersRotationParameters.initialFingerAngle=void 0,void(e.fingersRotationParameters.rotationInitiated=!1);var a=!0===e.realDragging,o=e.mode===n.SELECT&&e.dragging;if(e.dragging&&(e.setCursor("default"),e.dragging=!1,a)){e.realDragging=!1;var r=e.aladin.callbacksByEventName.positionChanged;"function"==typeof r&&void 0!==(p=e.aladin.pix2world(e.width/2,e.height/2))&&r({ra:p[0],dec:p[1],dragging:!1})}if(o)return e.aladin.fire("selectend",e.getObjectsInBBox(e.selectStartCoo.x,e.selectStartCoo.y,e.dragx-e.selectStartCoo.x,e.dragy-e.selectStartCoo.y)),e.mustRedrawReticle=!0,void e.requestRedraw();if(e.mustClearCatalog=!0,e.mustRedrawReticle=!0,e.dragx=e.dragy=null,"mouseout"!==t.type&&"touchend"!==t.type||(e.requestRedraw(!0),c(e,e.width/2,e.height/2,!0),"mouseout"!==t.type)){if(e.mode==n.TOOL_SIMBAD_POINTER){var l=e.aladin.pix2world(i.x,i.y);return e.setMode(n.PAN),e.setCursor("wait"),void I.SimbadPointer.query(l[0],l[1],Math.min(1,15*e.fov/e.largestDim),e.aladin)}var s=e.closestObjects(i.x,i.y,5);if(!a&&s){var f=s[0];f instanceof D||f instanceof q?f.dispatchClickEvent():f.marker?(e.popup.setTitle(f.popupTitle),e.popup.setText(f.popupDesc),e.popup.setSource(f),e.popup.show()):(e.lastClickedObject&&e.lastClickedObject.actionOtherObjectClicked&&e.lastClickedObject.actionOtherObjectClicked(),f.actionClicked()),e.lastClickedObject=f,"function"==typeof(u=e.aladin.callbacksByEventName.objectClicked)&&u(f)}else{var u;e.lastClickedObject&&!a&&(e.aladin.measurementTable.hide(),e.popup.hide(),e.lastClickedObject instanceof D||e.lastClickedObject.actionOtherObjectClicked(),e.lastClickedObject=null,"function"==typeof(u=e.aladin.callbacksByEventName.objectClicked)&&u(null))}var p,_=e.aladin.callbacksByEventName.click;"function"==typeof _&&void 0!==(p=e.aladin.pix2world(i.x,i.y))&&_({ra:p[0],dec:p[1],x:i.x,y:i.y,isDragging:a}),e.refreshProgressiveCats(),e.requestRedraw(!0),e.aladin.webglAPI.releaseLeftButtonMouse()}else e.mode===n.TOOL_SIMBAD_POINTER&&e.setMode(n.PAN)}));var a=null;let o=null;$(e.reticleCanvas).bind("mousemove touchmove",(function(r){r.preventDefault();var l,s,f=e.imageCanvas.relMouseCoords(r);if(o=f,e.aladin.webglAPI.posOnUi())return;if("touchmove"===r.type&&e.pinchZoomParameters.isPinching&&r.originalEvent&&r.originalEvent.touches&&2==r.originalEvent.touches.length){var u=180*Math.atan2(r.originalEvent.targetTouches[1].clientY-r.originalEvent.targetTouches[0].clientY,r.originalEvent.targetTouches[1].clientX-r.originalEvent.targetTouches[0].clientX)/Math.PI,p=e.fingersRotationParameters.initialFingerAngle-u;!e.fingersRotationParameters.rotationInitiated&&Math.abs(p)>=7&&(e.fingersRotationParameters.rotationInitiated=!0,e.fingersRotationParameters.initialFingerAngle=u,p=0),e.fingersRotationParameters.rotationInitiated&&e.aladin.webglAPI.setRotationAroundCenter(p+e.fingersRotationParameters.initialViewAngleFromCenter);var _=Math.sqrt(Math.pow(r.originalEvent.touches[0].clientX-r.originalEvent.touches[1].clientX,2)+Math.pow(r.originalEvent.touches[0].clientY-r.originalEvent.touches[1].clientY,2));return void e.setZoom(e.pinchZoomParameters.initialFov*e.pinchZoomParameters.initialDistance/_)}if(!e.dragging||t){c(e,f.x,f.y);var h=e.aladin.callbacksByEventName.mouseMove;if("function"==typeof h){var d=e.aladin.pix2world(f.x,f.y);void 0!==d?h({ra:d[0],dec:d[1],x:f.x,y:f.y}):null!=a&&h({ra:null,dec:null,x:f.x,y:f.y}),a=d}if(!e.dragging&&!e.mode==n.SELECT){var v,m=e.closestObjects(f.x,f.y,5);if(m)e.setCursor("pointer"),"function"==typeof(v=e.aladin.callbacksByEventName.objectHovered)&&m[0]!=i&&v(m[0]),i=m[0];else e.setCursor("default"),"function"==typeof(v=e.aladin.callbacksByEventName.objectHovered)&&i&&(i=null,v(null))}if(!t)return}if(!e.dragging)return;if(r.originalEvent&&r.originalEvent.targetTouches?(l={x:e.dragx,y:e.dragy},s={x:r.originalEvent.targetTouches[0].clientX,y:r.originalEvent.targetTouches[0].clientY}):(l={x:e.dragx,y:e.dragy},s={x:f.x,y:f.y}),r.originalEvent&&r.originalEvent.targetTouches?(e.dragx=r.originalEvent.targetTouches[0].clientX,e.dragy=r.originalEvent.targetTouches[0].clientY):(e.dragx=f.x,e.dragy=f.y),e.mode==n.SELECT)return void e.requestRedraw();e.viewCenter.lat>90?e.viewCenter.lat=90:e.viewCenter.lat<-90&&(e.viewCenter.lat=-90),e.viewCenter.lon<0?e.viewCenter.lon=360+e.viewCenter.lon:e.viewCenter.lon>360&&(e.viewCenter.lon=e.viewCenter.lon%360),e.realDragging=!0,e.aladin.webglAPI.goFromTo(l.x,l.y,s.x,s.y);let x=e.aladin.webglAPI.getCenter();e.viewCenter.lon=x[0],e.viewCenter.lat=x[1],e.requestRedraw()})),$(e.aladinDiv).onselectstart=function(){return!1},$(e.reticleCanvas).on("wheel",(function(n){if(n.preventDefault(),n.stopPropagation(),!e.aladin.webglAPI.posOnUi()){var t=n.deltaY;if(n.hasOwnProperty("originalEvent")&&(t=-n.originalEvent.deltaY),e.aladin.webglAPI.registerWheelEvent(t),e.updateZoomState(),!e.debounceProgCatOnZoom){var i=e;e.debounceProgCatOnZoom=b.c.debounce((function(){i.refreshProgressiveCats()}),300)}return e.debounceProgCatOnZoom(),!1}}))},r=function(e){var i=new C;i.domElement.style.top="50px",$("#aladin-statsDiv").length>0&&$("#aladin-statsDiv")[0].appendChild(i.domElement),e.stats=i,t(e),e.executeCallbacksThrottled=b.c.throttle((function(){var n=e.aladin.pix2world(e.width/2,e.height/2),t=e.fov;if(void 0!==n&&void 0!==t){var i=n[0],a=n[1];if(i!==this.ra||a!==this.dec){var o=e.aladin.callbacksByEventName.positionChanged;"function"==typeof o&&o({ra:i,dec:a,dragging:!0}),this.ra=i,this.dec=a}if(t!==this.old_fov){var r=e.aladin.callbacksByEventName.zoomChanged;"function"==typeof r&&r(t),this.old_fov=t}}}),n.CALLBACKS_THROTTLE_TIME_MS),e.displayHpxGrid=!1,e.displaySurvey=!0,e.displayCatalog=!1,e.displayReticle=!0};function c(n,e,t,i){if(n.projection){var a;try{a=n.aladin.webglAPI.screenToWorld(e,t)}catch(n){}a&&(n.aladin.webglAPI.cooSystem()===Gt.wasmLibs.webgl.GALCooSys()&&(a=n.aladin.webglAPI.J20002Gal(a[0],a[1])),n.location.update(a[0],a[1],n.cooFrame,i))}}n.prototype.requestRedrawAtDate=function(n){this.dateRequestDraw=n},n.prototype.getBackgroundColor=function(){var n="rgb(0, 0, 0)";if(!this.imageSurvey)return n;var e=this.imageSurvey.getColorMap();if(!e)return n;if("native"==e.mapName||"grayscale"==e.mapName)return e.reversed?"rgb(255, 255, 255)":n;var t=e.reversed?255:0;return"rgb("+k.MAPS[e.mapName].r[t]+","+k.MAPS[e.mapName].g[t]+","+k.MAPS[e.mapName].b[t]+")"},n.prototype.getViewParams=function(){var n=this.width>this.height?this.fov/this.width:this.fov/this.height;return{fov:[this.width*n,this.height*n],width:this.width,height:this.height}},n.prototype.setGridColor=function(n,e,t,i){this.aladin.webglAPI.setGridColor(n,e,t,i)},n.prototype.redraw=function(){var e,t,i=this.needRedraw,a=Date.now(),o=a-this.prev;if(this.ready=this.aladin.webglAPI.isReady(),null!==this.imageSurveysToSet&&(this.firstHiPS||this.ready)){try{console.log("sdfff ",this.imageSurveysToSet),this.aladin.webglAPI.setImageSurveys(this.imageSurveysToSet)}catch(n){console.warn(n)}this.imageSurveysToSet=null,this.firstHiPS=!1}try{this.aladin.webglAPI.update(o,this.needRedraw)}catch(n){console.error(n)}if(e=this,isNaN(e.fov)?e.fovDiv.html("FoV:"):(t=e.fov>1?Math.round(100*e.fov)/100+"°":60*e.fov>1?Math.round(60*e.fov*100)/100+"'":Math.round(3600*e.fov*100)/100+'"',e.fovDiv.html("FoV: "+t)),this.aladin.webglAPI.isCatalogLoaded()){var r=this.aladin.callbacksByEventName.catalogReady;"function"==typeof r&&r()}try{this.aladin.webglAPI.render(this.needRedraw)}catch(n){console.error("Error: ",n)}this.imageCtx,this.projection.setCenter(this.viewCenter.lon,this.viewCenter.lat);var l=null;if(this.overlayImageSurvey&&this.overlayImageSurvey.isReady,this.displayHpxGrid){var s=this.getVisibleCells(3);l=null,this.curNorder>=3&&(l=3==this.curNorder?s:this.getVisibleCells(this.curNorder)),this.gridCtx.clearRect(0,0,this.imageCanvas.width,this.imageCanvas.height),l&&this.curNorder>3?this.healpixGrid.redraw(this.gridCtx,l,this.fov,this.curNorder):this.healpixGrid.redraw(this.gridCtx,s,this.fov,3)}var c=this.catalogCtx,f=!1;if(this.mustClearCatalog&&(c.clearRect(0,0,this.width,this.height),f=!0,this.mustClearCatalog=!1),this.catalogs&&this.catalogs.length>0&&this.displayCatalog&&(!this.dragging||n.DRAW_SOURCES_WHILE_DRAGGING)){f||(c.clearRect(0,0,this.width,this.height),f=!0);for(var u=0;u<this.catalogs.length;u++)this.catalogs[u].draw(c,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor)}this.catalogForPopup.isShowing&&this.catalogForPopup.sources.length>0&&(f||(c.clearRect(0,0,this.width,this.height),f=!0),this.catalogForPopup.draw(c,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor));var p=this.catalogCtx;if(this.overlays&&this.overlays.length>0&&(!this.dragging||n.DRAW_SOURCES_WHILE_DRAGGING))for(f||(c.clearRect(0,0,this.width,this.height),f=!0),u=0;u<this.overlays.length;u++)this.overlays[u].draw(p,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor);var _=this.catalogCtx;if(this.mocs&&this.mocs.length>0&&(!this.dragging||n.DRAW_MOCS_WHILE_DRAGGING))for(f||(c.clearRect(0,0,this.width,this.height),f=!0),u=0;u<this.mocs.length;u++)this.mocs[u].draw(_,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor,this.fov);this.mode==n.SELECT&&(mustRedrawReticle=!0);var h=this.reticleCtx;if((this.mustRedrawReticle||this.mode==n.SELECT)&&h.clearRect(0,0,this.width,this.height),this.displayReticle){if(!this.reticleCache){var d=document.createElement("canvas"),v=this.options.reticleSize;d.width=v,d.height=v;var m=d.getContext("2d");m.lineWidth=2,m.strokeStyle=this.options.reticleColor,m.beginPath(),m.moveTo(v/2,v/2+(v/2-1)),m.lineTo(v/2,v/2+2),m.moveTo(v/2,v/2-(v/2-1)),m.lineTo(v/2,v/2-2),m.moveTo(v/2+(v/2-1),v/2),m.lineTo(v/2+2,v/2),m.moveTo(v/2-(v/2-1),v/2),m.lineTo(v/2-2,v/2),m.stroke(),this.reticleCache=d}h.drawImage(this.reticleCache,this.width/2-this.reticleCache.width/2,this.height/2-this.reticleCache.height/2),this.mustRedrawReticle=!1}i==this.needRedraw&&(this.needRedraw=!1),this.dragging||this.updateObjectsLookup(),this.prev=a,O(this.redraw.bind(this))},n.prototype.forceRedraw=function(){this.flagForceRedraw=!0},n.prototype.refreshProgressiveCats=function(){if(this.catalogs)for(var n=0;n<this.catalogs.length;n++)"progressivecat"==this.catalogs[n].type&&this.catalogs[n].loadNeededTiles()},n.prototype.getVisiblePixList=function(n,e){var t,i=Math.pow(2,n),a=m.nside2Npix(i);if(this.fov>80){t=[];for(var o=0;o<a;o++)t.push(o)}else{var r=new m(i);r.init();var l=new g;let n=this.aladin.webglAPI.screenToWorld(this.cx,this.cy),e={ra:n[0],dec:n[1]};var s;s=[e.ra,e.dec],l.set(s[0],s[1]);var c=.5*this.fov*this.ratio;this.fov>60?c*=1.6:this.fov>12?c*=1.45:c*=1.1,t=r.queryDisc(l,c*Math.PI/180,!0,!0);var f=m.utils.radecToPolar(s[0],s[1]),u=r.ang2pix_nest(f.theta,f.phi);t.unshift(u)}return t},n.prototype.setAngleRotation=function(n){},n.prototype.getVisibleCells=function(n,e){!e&&this.imageSurvey&&(e=this.imageSurvey.cooFrame);var t,i,a,o,r=[],l=[],c=new g,f=Math.pow(2,n),u=m.nside2Npix(f),p=null;if(this.fov>80){t=[];for(var h=0;h<u;h++)t.push(h)}else{var v=new m(f);v.init();var x=new g,y=(d.viewToXy(this.cx,this.cy,this.width,this.height,this.largestDim,this.zoomFactor),{ra:(y=this.aladin.webglAPI.screenToWorld(this.cx,this.cy))[0],dec:y[1]}),b=[];e&&e.system!=this.cooFrame.system?e.system==_.SYSTEMS.J2000?b=R.GalacticToJ2000([y.ra,y.dec]):e.system==_.SYSTEMS.GAL&&(b=R.J2000ToGalactic([y.ra,y.dec])):b=[y.ra,y.dec],x.set(b[0],b[1]);var I=.5*this.fov*this.ratio;this.fov>60?I*=1.6:this.fov>12?I*=1.45:I*=1.1,t=v.queryDisc(x,I*Math.PI/180,!0,!0);var P=m.utils.radecToPolar(b[0],b[1]);p=v.ang2pix_nest(P.theta,P.phi),t.unshift(p)}for(var z=0,T=t.length;z<T;z++)if(!((h=t[z])==p&&z>0)){var S=[];o=w.corners_nest(h,f);for(var C=0;C<4;C++)c.setXYZ(o[C].x,o[C].y,o[C].z),e&&e.system!=this.cooFrame.system?e.system==_.SYSTEMS.J2000?(i=(y=R.J2000ToGalactic([c.ra(),c.dec()]))[0],a=y[1]):e.system==_.SYSTEMS.GAL&&(i=(y=R.GalacticToJ2000([c.ra(),c.dec()]))[0],a=y[1]):(i=c.ra(),a=c.dec()),l[C]=this.aladin.webglAPI.worldToScreen(i,a);if(null!=l[0]&&null!=l[1]&&null!=l[2]&&null!=l[3]){for(C=0;C<4;C++)S[C]={vx:l[C][0],vy:l[C][1]};S[0].vx<0&&S[1].vx<0&&S[2].vx<0&&S[3].vx<0||S[0].vy<0&&S[1].vy<0&&S[2].vy<0&&S[3].vy<0||S[0].vx>=this.width&&S[1].vx>=this.width&&S[2].vx>=this.width&&S[3].vx>=this.width||S[0].vy>=this.height&&S[1].vy>=this.height&&S[2].vy>=this.height&&S[3].vy>=this.height||(this.projection.PROJECTION==s.SIN||this.projection.PROJECTION==s.TAN||d.counterClockwiseTriangle(S[0].vx,S[0].vy,S[1].vx,S[1].vy,S[2].vx,S[2].vy)&&d.counterClockwiseTriangle(S[0].vx,S[0].vy,S[2].vx,S[2].vy,S[3].vx,S[3].vy))&&(S.ipix=h,r.push(S))}}return r},n.prototype.getPositionsInView=function(n,e){for(var t,i,a=new g,o=Math.pow(2,e),r=[],l=w.corners_nest(n,o),s=0;s<4;s++){if(a.setXYZ(l[s].x,l[s].y,l[s].z),this.imageSurvey&&this.imageSurvey.cooFrame.system!=this.cooFrame.system){if(this.imageSurvey.cooFrame.system==_.SYSTEMS.J2000)t=(c=R.J2000ToGalactic([a.ra(),a.dec()]))[0],i=c[1];else if(this.imageSurvey.cooFrame.system==_.SYSTEMS.GAL){var c;t=(c=R.GalacticToJ2000([a.ra(),a.dec()]))[0],i=c[1]}}else t=a.ra(),i=a.dec();let n=this.aladin.webglAPI.worldToScreen(t,i);r[s]={vx:n.x,vy:n.y}}return null==r[0]||null==r[1]||null==r[2]||null==r[3]?null:r},n.prototype.setZoom=function(n){n<0||(this.aladin.webglAPI.setFieldOfView(n),this.updateZoomState())},n.prototype.increaseZoom=function(){for(let n=0;n<5;n++)this.aladin.webglAPI.registerWheelEvent(.01)},n.prototype.decreaseZoom=function(){for(let n=0;n<5;n++)this.aladin.webglAPI.registerWheelEvent(-.01)},n.prototype.setShowGrid=function(n){this.showGrid=n,n?this.aladin.webglAPI.enableGrid():this.aladin.webglAPI.disableGrid(),this.requestRedraw()},n.prototype.updateZoomState=function(){this.zoomFactor=this.aladin.webglAPI.getClipZoomFactor(),this.fov=this.aladin.webglAPI.getFieldOfView(),this.computeNorder(),this.forceRedraw()},n.prototype.computeNorder=function(){var n=this.fov/this.largestDim,e=m.calculateNSide(1843200*n),t=Math.log(e)/Math.log(2);t=Math.max(t,1),this.realNorder=t,this.fov<=50&&t<=2&&(t=3),this.imageSurvey&&t<=2&&this.imageSurvey.minOrder>2&&(t=this.imageSurvey.minOrder);var i=t;this.imageSurvey&&t>this.imageSurvey.maxOrder&&(t=this.imageSurvey.maxOrder),this.overlayImageSurvey&&i>this.overlayImageSurvey.maxOrder&&(i=this.overlayImageSurvey.maxOrder),t>m.ORDER_MAX&&(t=m.ORDER_MAX),i>m.ORDER_MAX&&(i=m.ORDER_MAX),this.curNorder=t,this.curOverlayNorder=i},n.prototype.untaintCanvases=function(){this.createCanvases(),t(this),this.fixLayoutDimensions()},n.prototype.setOverlayImageSurvey=async function(n){if(!n)return;let e=await new o.j(n);this.aladin.webglAPI.setOverlayHiPS(e)},n.prototype.setUnknownSurveyIfNeeded=function(){f&&(this.setImageSurvey(f),f=void 0)};var f=void 0;return n.prototype.addImageSurvey=function(n,e){const t=n.properties.url;n.layer=e,this.imageSurveys.get(e).set(t,n),this.setHiPS()},n.prototype.setImageSurvey=function(n,e){const t=n.properties.url;n.layer=e,this.imageSurveys.set(e,new Map),this.imageSurveys.get(e).set(t,n),this.setHiPS()},n.prototype.setImageSurveysLayer=function(n,e){this.imageSurveys.set(e,new Map),n.forEach((n=>{const t=n.properties.url;n.layer=e,this.imageSurveys.get(e).set(t,n)})),this.setHiPS()},n.prototype.removeImageSurveysLayer=function(n){this.imageSurveys.delete(n),this.setHiPS()},n.prototype.moveImageSurveysLayerForward=function(n){this.aladin.webglAPI.moveImageSurveysLayerForward(n)},n.prototype.setHiPS=function(){let n=[];for(let e of this.imageSurveys.values())for(let t of e.values())n.push(t);this.imageSurveysToSet=n},n.prototype.requestRedraw=function(){this.needRedraw=!0},n.prototype.changeProjection=function(n){switch(n){case"aitoff":this.projectionMethod=s.AITOFF;break;case"tan":this.projectionMethod=s.TAN;break;case"arc":this.projectionMethod=s.ARC;break;case"mercator":this.projectionMethod=s.MERCATOR;break;case"mollweide":this.projectionMethod=s.MOL;break;case"sinus":default:this.projectionMethod=s.SIN}this.projection.setProjection(this.projectionMethod),this.aladin.webglAPI=this.aladin.webglAPI.setProjection(n),this.requestRedraw()},n.prototype.changeFrame=function(n){var e=this.cooFrame;if(this.cooFrame=n,console.log("change frame"),this.cooFrame.system==_.SYSTEMS.GAL&&this.cooFrame.system!=e.system){var t=R.J2000ToGalactic([this.viewCenter.lon,this.viewCenter.lat]);this.viewCenter.lon=t[0],this.viewCenter.lat=t[1];const n=Gt.wasmLibs.webgl.GALCooSys();this.aladin.webglAPI.setCooSystem(n)}else if(this.cooFrame.system==_.SYSTEMS.J2000&&this.cooFrame.system!=e.system){var i=R.GalacticToJ2000([this.viewCenter.lon,this.viewCenter.lat]);this.viewCenter.lon=i[0],this.viewCenter.lat=i[1];const n=Gt.wasmLibs.webgl.ICRSJ2000CooSys();this.aladin.webglAPI.setCooSystem(n)}this.location.update(this.viewCenter.lon,this.viewCenter.lat,this.cooFrame,!0),this.requestRedraw()},n.prototype.showHealpixGrid=function(n){n||this.gridCtx.clearRect(0,0,this.imageCanvas.width,this.imageCanvas.height),this.displayHpxGrid=n,this.requestRedraw()},n.prototype.showSurvey=function(n){this.displaySurvey=n,this.requestRedraw()},n.prototype.showCatalog=function(n){this.displayCatalog=n,this.displayCatalog||(this.mustClearCatalog=!0),this.requestRedraw()},n.prototype.showReticle=function(n){this.displayReticle=n,this.mustRedrawReticle=!0,this.requestRedraw()},n.prototype.pointTo=function(n,e,t){if(t=t||{},n=parseFloat(n),e=parseFloat(e),!isNaN(n)&&!isNaN(e)){this.viewCenter.lon=n,this.viewCenter.lat=e,this.location.update(this.viewCenter.lon,this.viewCenter.lat,this.cooFrame,!0),t&&!1===t.forceAnimation?this.aladin.webglAPI.setCenter(this.viewCenter.lon,this.viewCenter.lat):t&&!0===t.forceAnimation||this.fov>30?this.aladin.webglAPI.moveToLocation(this.viewCenter.lon,this.viewCenter.lat):this.aladin.webglAPI.setCenter(this.viewCenter.lon,this.viewCenter.lat),this.forceRedraw(),this.requestRedraw();var i=this;setTimeout((function(){i.refreshProgressiveCats()}),1e3)}},n.prototype.makeUniqLayerName=function(n){if(!this.layerNameExists(n))return n;for(var e=1;;++e){var t=n+"_"+e;if(!this.layerNameExists(t))return t}},n.prototype.layerNameExists=function(n){for(var e=this.allOverlayLayers,t=0;t<e.length;t++)if(n==e[t].name)return!0;return!1},n.prototype.removeLayers=function(){this.catalogs=[],this.overlays=[],this.mocs=[],this.allOverlayLayers=[],this.requestRedraw()},n.prototype.addCatalog=function(n){n.name=this.makeUniqLayerName(n.name),this.allOverlayLayers.push(n),this.catalogs.push(n),"catalog"==n.type?n.setView(this):"progressivecat"==n.type&&n.init(this)},n.prototype.addOverlay=function(n){n.name=this.makeUniqLayerName(n.name),this.overlays.push(n),this.allOverlayLayers.push(n),n.setView(this)},n.prototype.addMOC=function(n){n.name=this.makeUniqLayerName(n.name),this.mocs.push(n),this.allOverlayLayers.push(n),n.setView(this)},n.prototype.getObjectsInBBox=function(n,e,t,i){t<0&&(n+=t,t=-t),i<0&&(e+=i,i=-i);var a,o,r,l=[];if(this.catalogs)for(var s=0;s<this.catalogs.length;s++)if((a=this.catalogs[s]).isShowing){o=a.getSources();for(var c=0;c<o.length;c++)(r=o[c]).isShowing&&r.x&&r.y&&r.x>=n&&r.x<=n+t&&r.y>=e&&r.y<=e+i&&l.push(r)}return l},n.prototype.updateObjectsLookup=function(){var n,e,t,i,a;if(this.objLookup=[],this.catalogs)for(var o=0;o<this.catalogs.length;o++)if((n=this.catalogs[o]).isShowing){e=n.getSources();for(var r=0;r<e.length;r++)(t=e[r]).isShowing&&t.x&&t.y&&(i=Math.round(t.x),a=Math.round(t.y),void 0===this.objLookup[i]&&(this.objLookup[i]=[]),void 0===this.objLookup[i][a]&&(this.objLookup[i][a]=[]),this.objLookup[i][a].push(t))}},n.prototype.closestObjects=function(n,e,t){var i,a,o,r=this.catalogCanvas.getContext("2d");if(r.lineWidth=6,this.overlays)for(var l=0;l<this.overlays.length;l++){i=this.overlays[l];for(var s=0;s<i.overlays.length;s++){for(var c=i.overlays[s],f=[],u=0;u<c.polygons.length;u++){var p=d.radecToViewXy(c.polygons[u][0],c.polygons[u][1],this);p&&f.push({x:p[0],y:p[1]})}for(var _=0;_<f.length-1;_++)if(r.beginPath(),r.moveTo(f[_].x,f[_].y),r.lineTo(f[_+1].x,f[_+1].y),r.isPointInStroke(n,e))return[a=c]}for(s=0;s<i.overlay_items.length;s++)if(i.overlay_items[s]instanceof q&&(i.overlay_items[s].draw(r,this,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor,!0),r.isPointInStroke(n,e)))return[a=i.overlay_items[s]]}if(!this.objLookup)return null;for(var h=0;h<=t;h++){a=o=null;for(var v=-t;v<=t;v++)if(this.objLookup[n+v])for(var m=-t;m<=t;m++)if(this.objLookup[n+v][e+m]){var x=v*v+m*m;a?x<o&&(o=x,a=this.objLookup[n+v][e+m]):(a=this.objLookup[n+v][e+m],o=x)}if(a)return a}return null},n}(),zt=function(){let n={};var e,t,i,a,o,r,l,s,c,f,u,p,_,h,d={}.hasOwnProperty,v=function(n,e){for(var t in e)d.call(e,t)&&(n[t]=e[t]);function i(){this.constructor=n}return i.prototype=e.prototype,n.prototype=new i,n.__super__=e.prototype,n},m=[].slice;return e=function(){function n(){}return n.include=function(n){var e,t;for(e in n)t=n[e],this.prototype[e]=t;return this},n.extend=function(n){var e,t;for(e in n)t=n[e],this[e]=t;return this},n.prototype.proxy=function(n){var e=this;return function(){return n.apply(e,arguments)}},n.prototype.invoke=function(n,e,t){var i;if(i=null!=(null!=e?e.context:void 0)?e.context:this,null!=n)return n.call(i,t,e)},n}(),p=function(e){function t(n,e,t){var i,a=this;this.arg=n,this.callback=e,this.opts=t,this.hdus=[],this.blockCount=0,this.begin=0,this.end=this.BLOCKLENGTH,this.offset=0,this.headerStorage=new Uint8Array,"string"==typeof this.arg?(this.readNextBlock=this._readBlockFromBuffer,(i=new XMLHttpRequest).open("GET",this.arg),i.responseType="arraybuffer",i.onerror=function(){a.invoke(a.callback,a.opts)},i.onload=function(){if(200===i.status)return a.arg=i.response,a.length=a.arg.byteLength,a.readFromBuffer();a.invoke(a.callback,a.opts)},i.send()):(this.length=this.arg.size,this.readNextBlock=this._readBlockFromFile,this.readFromFile())}return v(t,e),t.prototype.LINEWIDTH=80,t.prototype.BLOCKLENGTH=2880,File.prototype.slice=File.prototype.slice||File.prototype.webkitSlice,Blob.prototype.slice=Blob.prototype.slice||Blob.prototype.webkitSlice,t.prototype.readFromBuffer=function(){var n;return n=this.arg.slice(this.begin+this.offset,this.end+this.offset),this.readBlock(n)},t.prototype.readFromFile=function(){var n,e=this;return this.reader=new FileReader,this.reader.onloadend=function(n){return e.readBlock(n.target.result)},n=this.arg.slice(this.begin+this.offset,this.end+this.offset),this.reader.readAsArrayBuffer(n)},t.prototype.readBlock=function(n){var e,t,i,a,o,r,c,f,u,p,_,h,d;for(e=new Uint8Array(n),u=new Uint8Array(this.headerStorage),this.headerStorage=new Uint8Array(this.end),this.headerStorage.set(u,0),this.headerStorage.set(e,this.begin),r=this.BLOCKLENGTH/this.LINEWIDTH;r--;)if(32!==e[o=r*this.LINEWIDTH]){if(69===e[o]&&78===e[o+1]&&68===e[o+2]&&32===e[o+3]){for(c="",_=0,h=(d=this.headerStorage).length;_<h;_++)p=d[_],c+=String.fromCharCode(p);return a=new s(c),this.start=this.end+this.offset,t=a.getDataLength(),f=this.arg.slice(this.start,this.start+t),a.hasDataUnit()&&(i=this.createDataUnit(a,f)),this.hdus.push(new l(a,i)),this.offset+=this.end+t+this.excessBytes(t),this.offset===this.length?(this.headerStorage=null,void this.invoke(this.callback,this.opts,this)):(this.blockCount=0,this.begin=this.blockCount*this.BLOCKLENGTH,this.end=this.begin+this.BLOCKLENGTH,this.headerStorage=new Uint8Array,n=this.arg.slice(this.begin+this.offset,this.end+this.offset),void this.readNextBlock(n))}break}this.blockCount+=1,this.begin=this.blockCount*this.BLOCKLENGTH,this.end=this.begin+this.BLOCKLENGTH,n=this.arg.slice(this.begin+this.offset,this.end+this.offset),this.readNextBlock(n)},t.prototype._readBlockFromBuffer=function(n){return this.readBlock(n)},t.prototype._readBlockFromFile=function(n){return this.reader.readAsArrayBuffer(n)},t.prototype.createDataUnit=function(e,t){var i;return i=e.getDataType(),new n.FITS[i](e,t)},t.prototype.excessBytes=function(n){return(this.BLOCKLENGTH-n%this.BLOCKLENGTH)%this.BLOCKLENGTH},t.prototype.isEOF=function(){return this.offset===this.length},t}(e),(r=function(n){function e(n,e,t){var i,a=this;this.arg=n,i=new p(this.arg,(function(n){return a.hdus=i.hdus,a.invoke(e,t,a)}))}return v(e,n),e.prototype.getHDU=function(n){var e,t,i,a;if(null!=n&&null!=this.hdus[n])return this.hdus[n];for(t=0,i=(a=this.hdus).length;t<i;t++)if((e=a[t]).hasData())return e},e.prototype.getHeader=function(n){return this.getHDU(n).header},e.prototype.getDataUnit=function(n){return this.getHDU(n).data},e}(e)).version="0.6.5",n.FITS=r,a=function(n){function e(n,e){e instanceof ArrayBuffer?this.buffer=e:this.blob=e}return v(e,n),e.swapEndian={B:function(n){return n},I:function(n){return n<<8|n>>8},J:function(n){return(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255}},e.swapEndian[8]=e.swapEndian.B,e.swapEndian[16]=e.swapEndian.I,e.swapEndian[32]=e.swapEndian.J,e}(e),n.FITS.DataUnit=a,c={verifyOrder:function(n,e){if(e!==this.cardIndex)return console.warn(n+" should appear at index "+this.cardIndex+" in the FITS header")},verifyBetween:function(n,e,t,i){if(!(e>=t&&e<=i))throw"The "+n+" value of "+e+" is not between "+t+" and "+i},verifyBoolean:function(n){return"T"===n},VerifyFns:{SIMPLE:function(){var n;return 1<=arguments.length&&m.call(arguments,0),n=arguments[0],this.primary=!0,this.verifyOrder("SIMPLE",0),this.verifyBoolean(n)},XTENSION:function(){return 1<=arguments.length&&m.call(arguments,0),this.extension=!0,this.extensionType=arguments[0],this.verifyOrder("XTENSION",0),this.extensionType},BITPIX:function(){var n,e;if(1<=arguments.length&&m.call(arguments,0),n="BITPIX",e=parseInt(arguments[0]),this.verifyOrder(n,1),8!==e&&16!==e&&32!==e&&-32!==e&&-64!==e)throw n+" value "+e+" is not permitted";return e},NAXIS:function(){var n,e,t,i;if(1<=arguments.length&&m.call(arguments,0),n="NAXIS",t=parseInt(arguments[0]),!arguments[1]&&(this.verifyOrder(n,2),this.verifyBetween(n,t,0,999),this.isExtension()&&("TABLE"===(i=this.extensionType)||"BINTABLE"===i)&&t!==(e=2)))throw n+" must be "+e+" for TABLE and BINTABLE extensions";return t},PCOUNT:function(){var n,e,t,i,a;if(1<=arguments.length&&m.call(arguments,0),n="PCOUNT",i=parseInt(arguments[0]),e=3+this.get("NAXIS"),this.verifyOrder(n,e),this.isExtension()&&("IMAGE"===(a=this.extensionType)||"TABLE"===a)&&i!==(t=0))throw n+" must be "+t+" for the "+this.extensionType+" extensions";return i},GCOUNT:function(){var n,e,t,i,a;if(1<=arguments.length&&m.call(arguments,0),n="GCOUNT",i=parseInt(arguments[0]),e=3+this.get("NAXIS")+1,this.verifyOrder(n,e),this.isExtension()&&("IMAGE"===(a=this.extensionType)||"TABLE"===a||"BINTABLE"===a)&&i!==(t=1))throw n+" must be "+t+" for the "+this.extensionType+" extensions";return i},EXTEND:function(){var n;if(1<=arguments.length&&m.call(arguments,0),n=arguments[0],!this.isPrimary())throw"EXTEND must only appear in the primary header";return this.verifyBoolean(n)},BSCALE:function(){return 1<=arguments.length&&m.call(arguments,0),parseFloat(arguments[0])},BZERO:function(){return 1<=arguments.length&&m.call(arguments,0),parseFloat(arguments[0])},BLANK:function(){var n;return 1<=arguments.length&&m.call(arguments,0),n=arguments[0],this.get("BITPIX")>0||console.warn("BLANK is not to be used for BITPIX = "+this.get("BITPIX")),parseInt(n)},DATAMIN:function(){return 1<=arguments.length&&m.call(arguments,0),parseFloat(arguments[0])},DATAMAX:function(){return 1<=arguments.length&&m.call(arguments,0),parseFloat(arguments[0])},EXTVER:function(){return 1<=arguments.length&&m.call(arguments,0),parseInt(arguments[0])},EXTLEVEL:function(){return 1<=arguments.length&&m.call(arguments,0),parseInt(arguments[0])},TFIELDS:function(){var n;return 1<=arguments.length&&m.call(arguments,0),n=parseInt(arguments[0]),this.verifyBetween("TFIELDS",n,0,999),n},TBCOL:function(){var n,e;return 1<=arguments.length&&m.call(arguments,0),e=arguments[0],n=arguments[2],this.verifyBetween("TBCOL",n,0,this.get("TFIELDS")),e},ZIMAGE:function(){return 1<=arguments.length&&m.call(arguments,0),this.verifyBoolean(arguments[0])},ZCMPTYPE:function(){var n;if(1<=arguments.length&&m.call(arguments,0),"GZIP_1"!==(n=arguments[0])&&"RICE_1"!==n&&"PLIO_1"!==n&&"HCOMPRESS_1"!==n)throw"ZCMPTYPE value "+n+" is not permitted";if("RICE_1"!==n)throw"Compress type "+n+" is not yet implement";return n},ZBITPIX:function(){var n;if(1<=arguments.length&&m.call(arguments,0),8!==(n=parseInt(arguments[0]))&&16!==n&&32!==n&&64!==n&&-32!==n&&-64!==n)throw"ZBITPIX value "+n+" is not permitted";return n},ZNAXIS:function(){var n;return 1<=arguments.length&&m.call(arguments,0),n=n=parseInt(arguments[0]),arguments[1]||this.verifyBetween("ZNAXIS",n,0,999),n},ZTILE:function(){return 1<=arguments.length&&m.call(arguments,0),parseInt(arguments[0])},ZSIMPLE:function(){return 1<=arguments.length&&m.call(arguments,0),"T"===arguments[0]},ZPCOUNT:function(){return 1<=arguments.length&&m.call(arguments,0),parseInt(arguments[0])},ZGCOUNT:function(){return 1<=arguments.length&&m.call(arguments,0),parseInt(arguments[0])},ZDITHER0:function(){return 1<=arguments.length&&m.call(arguments,0),parseInt(arguments[0])}}},n.FITS.HeaderVerify=c,s=function(n){function e(n){var e,t,i;for(t in this.primary=!1,this.extension=!1,this.verifyCard={},i=this.VerifyFns)e=i[t],this.verifyCard[t]=this.proxy(e);this.cards={},this.cards.COMMENT=[],this.cards.HISTORY=[],this.cardIndex=0,this.block=n,this.readBlock(n)}return v(e,n),e.include(c),e.prototype.arrayPattern=/(\D+)(\d+)/,e.prototype.maxLines=600,e.prototype.get=function(n){return this.contains(n)?this.cards[n].value:null},e.prototype.set=function(n,e,t){return t=t||"",this.cards[n]={index:this.cardIndex,value:e,comment:t},this.cardIndex+=1},e.prototype.contains=function(n){return this.cards.hasOwnProperty(n)},e.prototype.readLine=function(n){var e,t,i,a,o;if(""!==(i=n.slice(0,8).trim())){if(t=n.slice(8,10),a=n.slice(10),"= "===t)return o=a.split(" /"),a=o[0],e=o[1],"'"===(a=a.trim())[0]?a=a.slice(1,-1).trim():"T"!==a&&"F"!==a&&(a=parseFloat(a)),a=this.validate(i,a),this.set(i,a,e);"COMMENT"!==i&&"HISTORY"!==i||this.cards[i].push(a.trim())}},e.prototype.validate=function(n,e){var t,i,a,o;return i=null,t=n,(a=this.arrayPattern.test(n))&&(t=(o=this.arrayPattern.exec(n).slice(1))[0],i=o[1]),t in this.verifyCard&&(e=this.verifyCard[t](e,a,i)),e},e.prototype.readBlock=function(n){var e,t,i,a,o,r;for(r=[],e=a=0,o=(i=(i=n.length/80)<this.maxLines?i:this.maxLines)-1;0<=o?a<=o:a>=o;e=0<=o?++a:--a)t=n.slice(80*e,80*(e+1)),r.push(this.readLine(t));return r},e.prototype.hasDataUnit=function(){return 0!==this.get("NAXIS")},e.prototype.getDataLength=function(){var n,e,t,i;if(!this.hasDataUnit())return 0;for(e=[],n=t=1,i=this.get("NAXIS");1<=i?t<=i:t>=i;n=1<=i?++t:--t)e.push(this.get("NAXIS"+n));return e.reduce((function(n,e){return n*e}))*Math.abs(this.get("BITPIX"))/8+this.get("PCOUNT")},e.prototype.getDataType=function(){switch(this.extensionType){case"BINTABLE":return this.contains("ZIMAGE")?"CompressedImage":"BinaryTable";case"TABLE":return"Table";default:return this.hasDataUnit()?"Image":null}},e.prototype.isPrimary=function(){return this.primary},e.prototype.isExtension=function(){return this.extension},e}(e),n.FITS.Header=s,u={getExtent:function(n){var e,t,i,a;for(e=n.length;e--;)if(a=n[e],!isNaN(a)){i=t=a;break}if(-1===e)return[NaN,NaN];for(;e--;)a=n[e],isNaN(a)||(a<i&&(i=a),a>t&&(t=a));return[i,t]},getPixel:function(n,e,t){return n[t*this.width+e]}},n.FITS.ImageUtils=u,f=function(n){function e(n,t){var i,a,o,r,l,s,c;for(e.__super__.constructor.apply(this,arguments),r=n.get("NAXIS"),this.bitpix=n.get("BITPIX"),this.naxis=[],o=l=1;1<=r?l<=r:l>=r;o=1<=r?++l:--l)this.naxis.push(n.get("NAXIS"+o));for(this.width=n.get("NAXIS1"),this.height=n.get("NAXIS2")||1,this.depth=n.get("NAXIS3")||1,this.bzero=n.get("BZERO")||0,this.bscale=n.get("BSCALE")||1,this.bytes=Math.abs(this.bitpix)/8,this.length=this.naxis.reduce((function(n,e){return n*e}))*Math.abs(this.bitpix)/8,this.frame=0,this.frameOffsets=[],this.frameLength=this.bytes*this.width*this.height,this.nBuffers=null!=this.buffer?1:2,o=s=0,c=this.depth-1;0<=c?s<=c:s>=c;o=0<=c?++s:--s)a={begin:i=o*this.frameLength},null!=this.buffer&&(a.buffers=[this.buffer.slice(i,i+this.frameLength)]),this.frameOffsets.push(a)}return v(e,n),e.include(u),e.prototype.allocationSize=16777216,e.prototype._getFrame=function(n,e,t,i){var a,o,r,l,s,c,f;if(o=Math.abs(e)/8,l=r=n.byteLength/o,Math.abs(e),e>0){switch(e){case 8:c=new Uint8Array(n),c=new Uint16Array(c),s=function(n){return n};break;case 16:c=new Int16Array(n),s=function(n){return(255&n)<<8|n>>8&255};break;case 32:c=new Int32Array(n),s=function(n){return(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255}}for(a=parseInt(t)!==t||parseInt(i)!==i?new Float32Array(c.length):c;l--;)c[l]=s(c[l]),a[l]=t+i*c[l]}else{for(a=new Uint32Array(n),s=function(n){return(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255};r--;)f=a[r],a[r]=s(f);for(a=new Float32Array(n);l--;)a[l]=t+i*a[l]}return a},e.prototype._getFrameAsync=function(n,e,t){var i,a,o,r,l,s,c,f,u,p,_,h,d,v=this;r="onmessage = "+(r=function(n){var e,t,i,a,o,r,l;return a=(r=n.data).buffer,t=r.bitpix,o=r.bzero,i=r.bscale,l=r.url,importScripts(l),e=_getFrame(a,t,o,i),postMessage(e)}.toString().replace("return postMessage","postMessage")),l=(l=this._getFrame.toString()).replace("function","function _getFrame"),c="application/javascript",o=new Blob([r],{type:c}),a=new Blob([l],{type:c}),i=window.URL||window.webkitURL,h=i.createObjectURL(o),_=i.createObjectURL(a),d=new Worker(h),f={buffer:n[0],bitpix:this.bitpix,bzero:this.bzero,bscale:this.bscale,url:_},s=0,u=null,p=0,d.onmessage=function(a){var o;return o=a.data,null==u&&(u=new o.constructor(v.width*v.height)),u.set(o,p),p+=o.length,(s+=1)===v.nBuffers?(v.invoke(e,t,u),i.revokeObjectURL(h),i.revokeObjectURL(_),d.terminate()):(f.buffer=n[s],d.postMessage(f,[n[s]]))},d.postMessage(f,[n[0]])},e.prototype.getFrame=function(n,e,t){var i,a,o,r,l,s,c,f,u,p,_,h=this;if(this.frame=n||this.frame,(null!=(r=(s=this.frameOffsets[this.frame]).buffers)?r.length:void 0)===this.nBuffers)return this._getFrameAsync(r,e,t);for(this.frameOffsets[this.frame].buffers=[],i=s.begin,a=this.blob.slice(i,i+this.frameLength),o=[],l=Math.floor(this.height/this.nBuffers)*this.bytes*this.width,c=p=0,_=this.nBuffers-1;0<=_?p<=_:p>=_;c=0<=_?++p:--p)u=c*l,c===this.nBuffers-1?o.push(a.slice(u)):o.push(a.slice(u,u+l));return r=[],(f=new FileReader).frame=this.frame,c=0,f.onloadend=function(i){var a;return n=i.target.frame,a=i.target.result,h.frameOffsets[n].buffers.push(a),(c+=1)===h.nBuffers?h.getFrame(n,e,t):f.readAsArrayBuffer(o[c])},f.readAsArrayBuffer(o[0])},e.prototype.getFrames=function(n,e,t,i){var a,o=this;return a=function(i,r){if(o.invoke(t,r,i),n+=1,e-=1)return o.getFrame(n,a,r)},this.getFrame(n,a,i)},e.prototype.isDataCube=function(){return this.naxis.length>2},e}(a),n.FITS.Image=f,h=function(n){function e(n,t){e.__super__.constructor.apply(this,arguments),this.rowByteSize=n.get("NAXIS1"),this.rows=n.get("NAXIS2"),this.cols=n.get("TFIELDS"),this.length=this.rowByteSize*this.rows,this.heapLength=n.get("PCOUNT"),this.columns=this.getColumns(n),null!=this.buffer?(this.rowsInMemory=this._rowsInMemoryBuffer,this.heap=this.buffer.slice(this.length,this.length+this.heapLength)):(this.rowsInMemory=this._rowsInMemoryBlob,this.firstRowInBuffer=this.lastRowInBuffer=0,this.nRowsInBuffer=Math.floor(this.maxMemory/this.rowByteSize)),this.accessors=[],this.descriptors=[],this.elementByteLengths=[],this.setAccessors(n)}return v(e,n),e.prototype.maxMemory=1048576,e.prototype._rowsInMemoryBuffer=function(){return!0},e.prototype._rowsInMemoryBlob=function(n,e){return!(n<this.firstRowInBuffer||e>this.lastRowInBuffer)},e.prototype.getColumns=function(n){var e,t,i,a,o;for(e=[],t=a=1,o=this.cols;1<=o?a<=o:a>=o;t=1<=o?++a:--a){if(i="TTYPE"+t,!n.contains(i))return null;e.push(n.get(i))}return e},e.prototype.getColumn=function(n,e,t){var i,a,o,r,l,s,c,f,u,p,_=this;return null!=this.blob?(f=this.columns.indexOf(n),r=this.descriptors[f],i=this.accessors[f],this.elementByteLengths[f],l=0===(l=this.elementByteLengths.slice(0,f)).length?0:l.reduce((function(n,e){return n+e})),o=null!=this.typedArray[r]?new this.typedArray[r](this.rows):[],p=~~(this.maxMemory/this.rowByteSize),p=Math.min(p,this.rows),s=this.rows/p,u=Math.floor(s)===s?s:Math.floor(s)+1,c=0,f=0,a=function(n,t){var r,s,h,d;for(r=n.byteLength/_.rowByteSize,d=new DataView(n),s=l;r--;)o[c]=i(d,s)[0],c+=1,s+=_.rowByteSize;if(f+=1,u-=1)return h=f*p,_.getTableBuffer(h,p,a,t);_.invoke(e,t,o)},this.getTableBuffer(0,p,a,t)):(a=function(t,i){return o=t.map((function(e){return e[n]})),_.invoke(e,i,o)},this.getRows(0,this.rows,a,t))},e.prototype.getTableBuffer=function(n,e,t,i){var a,o,r,l,s=this;return e=Math.min(this.rows-n,e),r=(a=n*this.rowByteSize)+e*this.rowByteSize,o=this.blob.slice(a,r),(l=new FileReader).row=n,l.number=e,l.onloadend=function(n){return s.invoke(t,i,n.target.result)},l.readAsArrayBuffer(o)},e.prototype.getRows=function(n,e,t,i){var a,o,r,l,s,c,f=this;return this.rowsInMemory(n,n+e)?(null!=this.blob?r=this.buffer:(l=(a=n*this.rowByteSize)+e*this.rowByteSize,r=this.buffer.slice(a,l)),c=this._getRows(r,e),this.invoke(t,i,c),c):(l=(a=n*this.rowByteSize)+Math.max(this.nRowsInBuffer*this.rowByteSize,e*this.rowByteSize),o=this.blob.slice(a,l),(s=new FileReader).row=n,s.number=e,s.onloadend=function(a){var o;return o=a.target,f.buffer=o.result,f.firstRowInBuffer=f.lastRowInBuffer=o.row,f.lastRowInBuffer+=o.number,f.getRows(n,e,t,i)},s.readAsArrayBuffer(o))},e}(a),n.FITS.Tabular=h,_=function(n){function e(){return e.__super__.constructor.apply(this,arguments)}return v(e,n),e.prototype.dataAccessors={A:function(n){return n.trim()},I:function(n){return parseInt(n)},F:function(n){return parseFloat(n)},E:function(n){return parseFloat(n)},D:function(n){return parseFloat(n)}},e.prototype.setAccessors=function(n){var e,t,i,a,o,r,l,s=this;for(a=/([AIFED])(\d+)\.*(\d+)*/,l=[],i=o=1,r=this.cols;1<=r?o<=r:o>=r;i=1<=r?++o:--o)t=n.get("TFORM"+i),n.get("TTYPE"+i),e=a.exec(t)[1],l.push(function(n){var e;return e=function(e){return s.dataAccessors[n](e)},s.accessors.push(e)}(e));return l},e.prototype._getRows=function(n){var e,t,i,a,o,r,l,s,c,f,u,p,_,h,d,v,m,x,g;for(s=n.byteLength/this.rowByteSize,t=new Uint8Array(n),f=[],o=_=0,x=s-1;0<=x?_<=x:_>=x;o=0<=x?++_:--_){for(a=(i=o*this.rowByteSize)+this.rowByteSize,l="",h=0,v=(u=t.subarray(i,a)).length;h<v;h++)p=u[h],l+=String.fromCharCode(p);for(l=l.trim().split(/\s+/),c={},r=d=0,m=(g=this.accessors).length;d<m;r=++d)e=g[r],p=l[r],c[this.columns[r]]=e(p);f.push(c)}return f},e}(h),n.FITS.Table=_,t=function(n){function e(){return e.__super__.constructor.apply(this,arguments)}return v(e,n),e.prototype.typedArray={B:Uint8Array,I:Uint16Array,J:Uint32Array,E:Float32Array,D:Float64Array,1:Uint8Array,2:Uint16Array,4:Uint32Array},e.offsets={L:1,B:1,I:2,J:4,K:8,A:1,E:4,D:8,C:8,M:16},e.prototype.dataAccessors={L:function(n,e){return[84===n.getInt8(e),e+=1]},B:function(n,e){return[n.getUint8(e),e+=1]},I:function(n,e){return[n.getInt16(e),e+=2]},J:function(n,e){return[n.getInt32(e),e+=4]},K:function(n,e){var t,i;return t=Math.abs(n.getInt32(e)),e+=4,[((i=t%10)?-1:1)*((t-=i)<<32|Math.abs(n.getInt32(e))),e+=4]},A:function(n,e){var t;return t=n.getUint8(e),[t=String.fromCharCode(t),e+=1]},E:function(n,e){return[n.getFloat32(e),e+=4]},D:function(n,e){return[n.getFloat64(e),e+=8]},C:function(n,e){var t;return t=n.getFloat32(e),e+=4,[[t,n.getFloat32(e)],e+=4]},M:function(n,e){var t;return t=n.getFloat64(e),e+=8,[[t,n.getFloat64(e)],e+=8]}},e.prototype.toBits=function(n){var e,t;for(e=[],t=128;t>=1;)e.push(n&t?1:0),t/=2;return e},e.prototype.getFromHeap=function(n,e,t){var i,a,o,r,l;for(l=n.getInt32(e),e+=4,a=n.getInt32(e),e+=4,o=this.heap.slice(a,a+l),r=(i=new this.typedArray[t](o)).length;r--;)i[r]=this.constructor.swapEndian[t](i[r]);return[i,e]},e.prototype.setAccessors=function(n){var e,t,i,a,r,l,s,c,f,u,p,_=this;for(s=/(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/,p=[],a=f=1,u=this.cols;1<=u?f<=u:f>=u;a=1<=u?++f:--f)i=n.get("TFORM"+a),c=n.get("TTYPE"+a),l=s.exec(i),e=parseInt(l[1])||1,r=l[2],t=l[3],p.push(function(n,e){var t,i;if(_.descriptors.push(n),_.elementByteLengths.push(_.constructor.offsets[n]*e),r)switch(c){case"COMPRESSED_DATA":t=function(e,t){var i,a,r;return i=(r=_.getFromHeap(e,t,n))[0],t=r[1],a=new _.typedArray[_.algorithmParameters.BYTEPIX](_.ztile[0]),o.Rice(i,_.algorithmParameters.BLOCKSIZE,_.algorithmParameters.BYTEPIX,a,_.ztile[0],o.RiceSetup),[a,t]};break;case"GZIP_COMPRESSED_DATA":t=function(n,e){var t;for(t=new Float32Array(_.width),a=t.length;a--;)t[a]=NaN;return[t,e]};break;default:t=function(e,t){return _.getFromHeap(e,t,n)}}else 1===e?t=function(e,t){var i;return[(i=_.dataAccessors[n](e,t))[0],t=i[1]]}:"X"===n?(i=Math.log(e)/Math.log(2),t=function(n,t){var a,o,r,l,s,c,f;for(r=n.buffer.slice(t,t+i),o=[],c=0,f=(s=new Uint8Array(r)).length;c<f;c++)l=s[c],a=_.toBits(l),o=o.concat(a);return t+=i,[o.slice(0,+(e-1)+1||9e9),t]}):t="A"===n?function(n,t){var i,a,o,r,l,s;for(a=n.buffer.slice(t,t+e),o="",l=0,s=(i=new Uint8Array(a)).length;l<s;l++)r=i[l],o+=String.fromCharCode(r);return[o=o.trim(),t+=e]}:function(t,i){var o,r,l;for(a=e,o=[];a--;)r=(l=_.dataAccessors[n](t,i))[0],i=l[1],o.push(r);return[o,i]};return _.accessors.push(t)}(t,e));return p},e.prototype._getRows=function(n,e){var t,i,a,o,r,l,s,c,f,u;for(l=new DataView(n),i=0,o=[];e--;){for(a={},t=s=0,c=(f=this.accessors).length;s<c;t=++s)r=(u=(0,f[t])(l,i))[0],i=u[1],a[this.columns[t]]=r;o.push(a)}return o},e}(h),n.FITS.BinaryTable=t,o={RiceSetup:{1:function(n){return[3,6,n[0],1]},2:function(n){var e;return e=0,e|=n[0]<<8,[4,14,e|=n[1],2]},4:function(n){var e;return e=0,e|=n[0]<<24,e|=n[1]<<16,e|=n[2]<<8,[5,25,e|=n[3],4]}},Rice:function(n,e,t,i,a,o){var r,l,s,c,f,u,p,_,h,d,v,m,x,g,y,w;for(l=1<<f,f=(y=o[t](n))[0],u=y[1],d=y[2],g=y[3],m=new Uint8Array(256),x=8,h=(w=[128,255])[0],p=w[1];p>=0;){for(;p>=h;)m[p]=x,p-=1;h/=2,x-=1}for(m[0]=0,r=n[g++],v=8,p=0;p<a;){for(v-=f;v<0;)r=r<<8|n[g++],v+=8;if(c=(r>>v)-1,r&=(1<<v)-1,(_=p+e)>a&&(_=a),c<0)for(;p<_;)i[p]=d,p+=1;else if(c===u)for(;p<_;){for(s=r<<(h=l-v),h-=8;h>=0;)s|=(r=n[g++])<<h,h-=8;v>0?(s|=(r=n[g++])>>-h,r&=(1<<v)-1):r=0,0==(1&s)?s>>=1:s=~(s>>1),i[p]=s+d,d=i[p],p++}else for(;p<_;){for(;0===r;)v+=8,r=n[g++];for(r^=1<<(v-=1+(x=v-m[r])),v-=c;v<0;)r=r<<8|n[g++],v+=8;s=x<<c|r>>v,r&=(1<<v)-1,0==(1&s)?s>>=1:s=~(s>>1),i[p]=s+d,d=i[p],p++}}return i}},n.FITS.Decompress=o,i=function(n){function e(n,t){var i,a,o,r,l,s;for(e.__super__.constructor.apply(this,arguments),this.zcmptype=n.get("ZCMPTYPE"),this.zbitpix=n.get("ZBITPIX"),this.znaxis=n.get("ZNAXIS"),this.zblank=n.get("ZBLANK"),this.blank=n.get("BLANK"),this.zdither=n.get("ZDITHER0")||0,this.ztile=[],i=l=1,s=this.znaxis;1<=s?l<=s:l>=s;i=1<=s?++l:--l)r=n.contains("ZTILE"+i)?n.get("ZTILE"+i):1===i?n.get("ZNAXIS1"):1,this.ztile.push(r);for(this.width=n.get("ZNAXIS1"),this.height=n.get("ZNAXIS2")||1,this.algorithmParameters={},"RICE_1"===this.zcmptype&&(this.algorithmParameters.BLOCKSIZE=32,this.algorithmParameters.BYTEPIX=4),i=1;a="ZNAME"+i,n.contains(a);)o="ZVAL"+i,this.algorithmParameters[n.get(a)]=n.get(o),i+=1;this.zmaskcmp=n.get("ZMASKCMP"),this.zquantiz=n.get("ZQUANTIZ")||"LINEAR_SCALING",this.bzero=n.get("BZERO")||0,this.bscale=n.get("BSCALE")||1}return v(e,n),e.include(u),e.extend(o),e.randomGenerator=function(){var n,e,t,i,a,o;for(e=2147483647,i=1,t=new Float32Array(1e4),n=o=0;o<=9999;n=++o)i=(a=16807*i)-e*parseInt(a/e),t[n]=i/e;return t},e.randomSequence=e.randomGenerator(),e.prototype._getRows=function(n,e){var t,i,a,o,r,l,s,c,f,u,p,_,h,d,v,m,x,g,y,w;for(h=new DataView(n),l=0,t=new Float32Array(this.width*this.height);e--;){for(f={},o=v=0,x=(y=this.accessors).length;v<x;o=++v)_=(w=(0,y[o])(h,l))[0],l=w[1],f[this.columns[o]]=_;for(i=f.COMPRESSED_DATA||f.UNCOMPRESSED_DATA||f.GZIP_COMPRESSED_DATA,f.ZBLANK||this.zblank,u=f.ZSCALE||this.bscale,d=f.ZZERO||this.bzero,p=((r=this.height-e)+this.zdither-1-1)%1e4,c=parseInt(500*this.constructor.randomSequence[p]),o=m=0,g=i.length;m<g;o=++m)_=i[o],a=(r-1)*this.width+o,-2147483647===_?t[a]=NaN:-2147483646===_?t[a]=0:(s=this.constructor.randomSequence[c],t[a]=(_-s+.5)*u+d),1e4===(c+=1)&&(p=(p+1)%1e4,c=parseInt(500*this.randomSequence[p]))}return t},e.prototype.getFrame=function(n,e,t){var i,a,o=this;return this.heap?(this.frame=n||this.frame,this.getRows(0,this.rows,e,t)):(i=this.blob.slice(this.length,this.length+this.heapLength),(a=new FileReader).onloadend=function(i){return o.heap=i.target.result,o.getFrame(n,e,t)},a.readAsArrayBuffer(i))},e}(t),n.FITS.CompressedImage=i,l=function(){function n(n,e){this.header=n,this.data=e}return n.prototype.hasData=function(){return null!=this.data},n}(),n.FITS.HDU=l,n}(),Tt=function(){let n=function(n){this.order=void 0,this.type="moc",n=n||{},this.name=n.name||"MOC",this.color=n.color||Color.getNextColor(),this.opacity=n.opacity||1,this.opacity=Math.max(0,Math.min(1,this.opacity)),this.lineWidth=n.lineWidth||1,this.adaptativeDisplay=!1!==n.adaptativeDisplay,this.proxyCalled=!1,this._highResIndexOrder3=new Array(768),this._lowResIndexOrder3=new Array(768);for(var e=0;e<768;e++)this._highResIndexOrder3[e]={},this._lowResIndexOrder3[e]={};this.nbCellsDeepestLevel=0,this.isShowing=!0,this.ready=!1};n.MAX_NORDER=13,n.LOWRES_MAXORDER=6,n.HIGHRES_MAXORDER=11,n.PIVOT_FOV=30,n.prototype._removeDuplicatesFromIndexes=function(){for(var n,e,i=0;i<768;i++){for(var a in this._highResIndexOrder3[i])n=this._highResIndexOrder3[i][a],e=t(n),this._highResIndexOrder3[i][a]=e;for(var a in this._lowResIndexOrder3[i])n=this._lowResIndexOrder3[i][a],e=t(n),this._lowResIndexOrder3[i][a]=e}},n.prototype._addPix=function(e,t){var i=Math.floor(t*Math.pow(4,3-e));if(e<=n.LOWRES_MAXORDER)e in this._lowResIndexOrder3[i]||(this._lowResIndexOrder3[i][e]=[],this._highResIndexOrder3[i][e]=[]),this._lowResIndexOrder3[i][e].push(t),this._highResIndexOrder3[i][e].push(t);else if(e<=n.HIGHRES_MAXORDER){e in this._highResIndexOrder3[i]||(this._highResIndexOrder3[i][e]=[]),this._highResIndexOrder3[i][e].push(t);var a=n.LOWRES_MAXORDER,o=Math.floor(t/Math.pow(4,e-a)),r=Math.floor(o*Math.pow(4,3-a));a in this._lowResIndexOrder3[r]||(this._lowResIndexOrder3[r][a]=[]),this._lowResIndexOrder3[r][a].push(o)}else a=n.LOWRES_MAXORDER,o=Math.floor(t/Math.pow(4,e-a)),r=Math.floor(o*Math.pow(4,3-a)),a in this._lowResIndexOrder3[r]||(this._lowResIndexOrder3[r][a]=[]),this._lowResIndexOrder3[r][a].push(o),a=n.HIGHRES_MAXORDER,o=Math.floor(t/Math.pow(4,e-a)),r=Math.floor(o*Math.pow(4,3-a)),a in this._highResIndexOrder3[r]||(this._highResIndexOrder3[r][a]=[]),this._highResIndexOrder3[r][a].push(o);this.nbCellsDeepestLevel+=Math.pow(4,this.order-e)},n.prototype.skyFraction=function(){return this.nbCellsDeepestLevel/(12*Math.pow(4,this.order))},n.prototype.dataFromJSON=function(n){var e,t;for(var i in n)if(n.hasOwnProperty(i)){e=parseInt(i),(void 0===this.order||e>this.order)&&(this.order=e);for(var a=0;a<n[i].length;a++)t=n[i][a],this._addPix(e,t)}this.reportChange(),this.ready=!0},n.prototype.dataFromFITSURL=function(n,e){var t=this,i=function(){var n;try{if(0==this.hdus.length){if(!0!==t.proxyCalled){t.proxyCalled=!0;var a=Gt.JSONP_PROXY+"?url="+encodeURIComponent(t.dataURL);new zt.FITS(a,i)}return}n=this.getHeader(0)}catch(n){return void console.error("Could not get header of extension #0")}var o=this.getHeader(1);if(n.contains("HPXMOC"))t.order=n.get("HPXMOC");else if(n.contains("MOCORDER"))t.order=n.get("MOCORDER");else if(o.contains("HPXMOC"))t.order=o.get("HPXMOC");else{if(!o.contains("MOCORDER"))return void console.error("Can not find MOC order in FITS file");t.order=o.get("MOCORDER")}var r=this.getDataUnit(1),l=r.columns[0];r.getRows(0,r.rows,(function(n){for(var e=0;e<n.length;e++){var i=n[e][l],a=Math.floor(Math.floor((r=Math.floor(i/4),Math.log(r)/Math.LN2))/2),o=i-4*Math.pow(4,a);t._addPix(a,o)}var r})),r=null,t._removeDuplicatesFromIndexes(),e&&e(),t.reportChange(),t.ready=!0};this.dataURL=n,new zt.FITS(this.dataURL,i)},n.prototype.setView=function(n){this.view=n,this.reportChange()},n.prototype.draw=function(e,t,i,a,o,r,l,s){if(this.isShowing&&this.ready){var c=s>n.PIVOT_FOV&&this.adaptativeDisplay?this._lowResIndexOrder3:this._highResIndexOrder3;this._drawCells(e,c,s,t,i,_.J2000,a,o,r,l)}},n.prototype._drawCells=function(n,t,a,o,r,l,s,c,f,u){n.lineWidth=this.lineWidth,1==this.opacity?n.strokeStyle=this.color:(n.fillStyle=this.color,n.globalAlpha=this.opacity),n.beginPath();for(var p=[],h=0;h<768;h++){var d=t[h];for(var v in d)p.push(parseInt(v))}p.sort((function(n,e){return n-e}));var m,x,g=p[p.length-1],y=this.view.getVisiblePixList(3,_.J2000),w=[];for(h=0;h<y.length;h++){var b=y[h];(x=i(8,b,r,l,s,c,f,u,o,this.view))&&w.push(b)}for(var I=0;I<=g;I++){m=1<<I;for(var P=0;P<w.length;P++)if(void 0!==(d=t[w[P]])[I])if(I<=3)for(var z=0;z<d[I].length;z++){b=d[I][z];var T=Math.pow(4,3-I),S=b*T;for(h=0;h<T;h++)(x=i(8,S+h,r,l,s,c,f,u,o,this.view))&&e(n,x)}else for(z=0;z<d[I].length;z++)b=d[I][z],Math.floor(b/Math.pow(4,I-3)),(x=i(m,b,r,l,s,c,f,u,o,this.view))&&e(n,x)}1==this.opacity?n.stroke():(n.fill(),n.globalAlpha=1)};var e=function(n,e){n.moveTo(e[0].vx,e[0].vy),n.lineTo(e[1].vx,e[1].vy),n.lineTo(e[2].vx,e[2].vy),n.lineTo(e[3].vx,e[3].vy),n.lineTo(e[0].vx,e[0].vy)},t=function(n){for(var e={},t=[],i=n.length,a=0,o=0;o<i;o++){var r=n[o];1!==e[r]&&(e[r]=1,t[a++]=r)}return t},i=function(n,e,t,i,a,o,r,l,c,f){for(var u,p,_=[],h=Gt.wasmLibs.hpx.nestedVertices(Math.log2(n),e),v=0;v<4;v++){if(u=h[2*v],p=h[2*v+1],_[v]=f.aladin.webglAPI.worldToScreen(u,p),!_[v])return null;_[v]={vx:_[v][0],vy:_[v][1]}}return _[0].vx<0&&_[1].vx<0&&_[2].vx<0&&_[3].vx<0||_[0].vy<0&&_[1].vy<0&&_[2].vy<0&&_[3].vy<0||_[0].vx>=a&&_[1].vx>=a&&_[2].vx>=a&&_[3].vx>=a||_[0].vy>=o&&_[1].vy>=o&&_[2].vy>=o&&_[3].vy>=o?null:c.PROJECTION==s.SIN||c.PROJECTION==s.TAN||d.counterClockwiseTriangle(_[0].vx,_[0].vy,_[1].vx,_[1].vy,_[2].vx,_[2].vy)&&d.counterClockwiseTriangle(_[0].vx,_[0].vy,_[2].vx,_[2].vy,_[3].vx,_[3].vy)?_:null};return n.prototype.reportChange=function(){this.view&&this.view.requestRedraw()},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.reportChange())},n.prototype.contains=function(n,e){var t=new HealpixIndex(Math.pow(2,this.order));t.init();for(var i=HealpixIndex.utils.radecToPolar(n,e),a=t.ang2pix_nest(i.theta,i.phi),o={},r=0;r<=this.order;r++)o[r]=Math.floor(a/Math.pow(4,this.order-r));for(var l=0;l<768;l++){var s=this._highResIndexOrder3[l];for(var c in s)if(c<3)for(var f=s[c].length;f>=0;f--)if(o[c]==s[c][f])return!0}for(var c in l=o[3],s=this._highResIndexOrder3[l])for(f=s[c].length;f>=0;f--)if(o[c]==s[c][f])return!0;return!1},n}(),St=function(){let n=function(n,e,t,i){this.x1=n,this.y1=e,this.x2=t,this.y2=i};return n.prototype.isInsideView=function(e,t){if(this.x1>=0&&this.x1<=e&&this.y1>=0&&this.y1<=t)return!0;if(this.x2>=0&&this.x2<=e&&this.y2>=0&&this.y2<=t)return!0;let i=n.intersectLine(this.x1,this.y1,this.x2,this.y2,0,0,0,t),a=n.intersectLine(this.x1,this.y1,this.x2,this.y2,e,0,e,t),o=n.intersectLine(this.x1,this.y1,this.x2,this.y2,0,0,e,0),r=n.intersectLine(this.x1,this.y1,this.x2,this.y2,0,t,e,t);return!!(i||a||o||r)},n.prototype.draw=function(n){n.moveTo(this.x1,this.y1),n.lineTo(this.x2,this.y2)},n.intersectLine=function(n,e,t,i,a,o,r,l){let s=((r-a)*(e-o)-(l-o)*(n-a))/((l-o)*(t-n)-(r-a)*(i-e)),c=((t-n)*(e-o)-(i-e)*(n-a))/((l-o)*(t-n)-(r-a)*(i-e));return s>=0&&s<=1&&c>=0&&c<=1},n}(),Ct=function(){let n=function(n){n=n||{},this.type="overlay",this.name=n.name||"overlay",this.color=n.color||Color.getNextColor(),this.lineWidth=n.lineWidth||2,this.overlays=[],this.overlay_items=[],this.isShowing=!0};return n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.reportChange())},n.parseSTCS=function(n){for(var e=[],t=n.match(/\S+/g),i=0,a=t.length;i<a;){var o=t[i].toLowerCase();if("polygon"==o){var r=[];if("icrs"==(c=t[++i].toLowerCase())||"j2000"==c||"fk5"==c){for(;i+2<a;){var l=parseFloat(t[i+1]);if(isNaN(l))break;var s=parseFloat(t[i+2]);r.push([l,s]),i+=2}r.push(r[0]),e.push(new D(r))}}else if("circle"==o){var c,f;"icrs"!=(c=t[++i].toLowerCase())&&"j2000"!=c&&"fk5"!=c||(l=parseFloat(t[i+1]),s=parseFloat(t[i+2]),f=parseFloat(t[i+3]),e.push(A.circle(l,s,f)),i+=3)}i++}return e},n.prototype.addFootprints=function(n){for(var e=0,t=n.length;e<t;e++)this.add(n[e],!1);this.view.requestRedraw()},n.prototype.add=function(n,e){e=void 0===e||e,n instanceof D?this.overlays.push(n):this.overlay_items.push(n),n.setOverlay(this),e&&this.view.requestRedraw()},n.prototype.getFootprint=function(n){return n<this.footprints.length?this.footprints[n]:null},n.prototype.setView=function(n){this.view=n},n.prototype.removeAll=function(){this.overlays=[],this.overlay_items=[]},n.prototype.draw=function(e,t,i,a,o,r,l){if(this.isShowing){e.strokeStyle=this.color,e.lineWidth=this.lineWidth,e.beginPath();for(var s=[],c=0,f=this.overlays.length;c<f;c++)s.push(this.drawFootprint(this.overlays[c],e,t,i,a,o,r,l));for(e.stroke(),e.strokeStyle=n.increaseBrightness(this.color,50),e.beginPath(),c=0,f=this.overlays.length;c<f;c++)this.overlays[c].isSelected&&this.drawFootprintSelected(e,s[c]);for(e.stroke(),c=0;c<this.overlay_items.length;c++)this.overlay_items[c].draw(e,this.view,t,i,a,o,r,l)}},n.increaseBrightness=function(n,e){3==(n=n.replace(/^\s*#|\s*$/g,"")).length&&(n=n.replace(/(.)/g,"$1$1"));var t=parseInt(n.substr(0,2),16),i=parseInt(n.substr(2,2),16),a=parseInt(n.substr(4,2),16);return"#"+(0|256+t+(256-t)*e/100).toString(16).substr(1)+(0|256+i+(256-i)*e/100).toString(16).substr(1)+(0|256+a+(256-a)*e/100).toString(16).substr(1)},n.prototype.drawFootprint=function(n,e,t,i,a,o,r,l){if(!n.isShowing)return null;for(var s=n.polygons,c=0;c<s.length-1;c++){let n=this.view.aladin.webglAPI.projectLine(s[c][0],s[c][1],s[c+1][0],s[c+1][1]);for(var f=0;f<n.length;f+=4){let t=new St(n[f],n[f+1],n[f+2],n[f+3]);t.isInsideView(a,o)&&t.draw(e)}}return[]},n.prototype.drawFootprintSelected=function(n,e){if(e){var t=e;n.moveTo(t[0].vx,t[0].vy);for(var i=1,a=t.length;i<a;i++)n.lineTo(t[i].vx,t[i].vy)}},n.prototype.reportChange=function(){this.view.requestRedraw()},n}(),At=function(){let n=function(n,e,t,i,a){a=a||{},this.color=a.color||void 0,this.id="ellipse-"+b.c.uuidv4(),this.setCenter(n),this.setRadiuses(e,t),this.setRotation(i),this.overlay=null,this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.dispatchClickEvent=function(){this.overlay&&this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent("footprintClicked",{detail:{footprintId:this.id,overlayName:this.overlay.name}}))},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n.prototype.setCenter=function(n){this.centerRaDec=n,this.overlay&&this.overlay.reportChange()},n.prototype.setRotation=function(n){let e=n*Math.PI/180;this.rotation=e,this.overlay&&this.overlay.reportChange()},n.prototype.setRadiuses=function(n,e){this.radiusXDegrees=n,this.radiusYDegrees=e,this.overlay&&this.overlay.reportChange()},n.prototype.draw=function(n,e,t,i,a,o,r,l,s){if(!this.isShowing)return;s=!0===s||!1;var c=d.radecToViewXy(this.centerRaDec[0],this.centerRaDec[1],e);if(!c)return;let f=d.radecToViewXy(this.centerRaDec[0]+this.radiusXDegrees,this.centerRaDec[1],e),u=d.radecToViewXy(this.centerRaDec[0],this.centerRaDec[1]+this.radiusYDegrees,e);if(!f||!u)return;var p=f[0]-c[0],_=f[1]-c[1],h=Math.sqrt(p*p+_*_),v=u[0]-c[0],m=u[1]-c[1],x=Math.sqrt(v*v+m*m);if(p*m-v*_<=0)return;var g=this.color;!g&&this.overlay&&(g=this.overlay.color),g||(g="#ff0000"),this.isSelected?n.strokeStyle=Overlay.increaseBrightness(g,50):n.strokeStyle=g;let y=this.centerRaDec,w=[this.centerRaDec[0],this.centerRaDec[1]+.001],b=this.overlay.view.aladin.webglAPI.worldToScreen(y[0],y[1]),I=this.overlay.view.aladin.webglAPI.worldToScreen(w[0],w[1]),P=[I[0]-b[0],I[1]-b[1]],z=Math.sqrt(P[0]*P[0]+P[1]*P[1]);P=[P[0]/z,P[1]/z];let T=[1,0],S=T[0],C=T[1],A=P[0],k=P[1],D=Math.atan2(S*k-C*A,S*A+C*k),q=-this.rotation+D;n.beginPath(),n.ellipse(c[0],c[1],h,x,q,0,2*Math.PI,!1),s||n.stroke()},n}(),kt=function(){let n=function(n,e){e=e||{},this.color=e.color||void 0,this.radecArray=n,this.overlay=null,this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n.prototype.draw=function(n,e,t,i,a,o,r,l){if(this.isShowing&&this.radecArray&&!(this.radecArray.length<2)){this.color&&(n.strokeStyle=this.color),n.beginPath();for(var s=0;s<this.radecArray.length-1;s++){let t=e.aladin.webglAPI.projectLine(this.radecArray[s][0],this.radecArray[s][1],this.radecArray[s+1][0],this.radecArray[s+1][1]);for(var c=0;c<t.length;c+=4){let e=new St(t[c],t[c+1],t[c+2],t[c+3]);e.isInsideView(a,o)&&e.draw(n)}}n.stroke()}},n}(),Dt=function(n,e){try{var t="";e&&(t=JSON.stringify(e)),$.ajax({url:"//alasky.unistra.fr/cgi/AladinLiteLogger/log.py",data:{action:n,params:t,pageUrl:window.location.href,referer:document.referrer?document.referrer:""},method:"GET",dataType:"json"})}catch(n){window.console&&console.log("Exception: "+n)}},qt=function(){let n=function(n,e,t,i){this.ra=n,this.dec=e,this.data=t,this.catalog=null,this.marker=i&&i.marker||!1,this.marker&&(this.popupTitle=i&&i.popupTitle?i.popupTitle:"",this.popupDesc=i&&i.popupDesc?i.popupDesc:"",this.useMarkerDefaultIcon=!i||void 0===i.useMarkerDefaultIcon||i.useMarkerDefaultIcon),this.isShowing=!0,this.isSelected=!1};return n.prototype.setCatalog=function(n){this.catalog=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.catalog&&this.catalog.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.catalog&&this.catalog.reportChange())},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.catalog&&this.catalog.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.catalog&&this.catalog.reportChange())},n.prototype.actionClicked=function(){if(this.catalog&&this.catalog.onClick){var n=this.catalog.view;if("showTable"==this.catalog.onClick)n.aladin.measurementTable.showMeasurement(this),this.select();else if("showPopup"==this.catalog.onClick){n.popup.setTitle("<br><br>");var e='<div class="aladin-marker-measurement">';for(var t in e+="<table>",this.data)e+="<tr><td>"+t+"</td><td>"+this.data[t]+"</td></tr>";e+="</table>",e+="</div>",n.popup.setText(e),n.popup.setSource(this),n.popup.show()}else"function"==typeof this.catalog.onClick&&(this.catalog.onClick(this),n.lastClickedObject=this)}},n.prototype.actionOtherObjectClicked=function(){this.catalog&&this.catalog.onClick&&this.deselect()},n}(),Rt=function(){let n={curIdx:0,colors:["#ff0000","#0000ff","#99cc00","#ffff00","#000066","#00ffff","#9900cc","#0099cc","#cc9900","#cc0099","#00cc99","#663333","#ffcc9a","#ff9acc","#ccff33","#660000","#ffcc33","#ff00ff","#00ff00","#ffffff"],getNextColor:function(){var e=n.colors[n.curIdx%n.colors.length];return n.curIdx++,e},getLabelColorForBackground:function(n){var e="#111",t=n.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);return null==t||1-(.299*parseInt(t[1])+.587*parseInt(t[2])+.114*parseInt(t[3]))/255<.5?e:"#eee"}};return n}(),Ot=function(){function n(n){n=n||{},this.type="catalog",this.name=n.name||"catalog",this.color=n.color||Rt.getNextColor(),this.sourceSize=n.sourceSize||8,this.markerSize=n.sourceSize||12,this.shape=n.shape||"square",this.maxNbSources=n.limit||void 0,this.onClick=n.onClick||void 0,this.raField=n.raField||void 0,this.decField=n.decField||void 0,this.indexationNorder=5,this.sources=[],this.hpxIdx=new m(this.indexationNorder),this.hpxIdx.init(),this.displayLabel=n.displayLabel||!1,this.labelColor=n.labelColor||this.color,this.labelFont=n.labelFont||"10px sans-serif",this.displayLabel&&(this.labelColumn=n.labelColumn,this.labelColumn||(this.displayLabel=!1)),(this.shape instanceof Image||this.shape instanceof HTMLCanvasElement)&&(this.sourceSize=this.shape.width),this._shapeIsFunction=!1,$.isFunction(this.shape)&&(this._shapeIsFunction=!0),this.selectionColor="#00ff00",this.updateShape(n),this.cacheMarkerCanvas=document.createElement("canvas"),this.cacheMarkerCanvas.width=this.markerSize,this.cacheMarkerCanvas.height=this.markerSize;var e=this.cacheMarkerCanvas.getContext("2d");e.fillStyle=this.color,e.beginPath();var t=this.markerSize/2;e.arc(t,t,t-2,0,2*Math.PI,!1),e.fill(),e.lineWidth=2,e.strokeStyle="#ccc",e.stroke(),this.isShowing=!0}function e(n,e,t){var i,a;if(i=a=null,e)for(var o=0,r=n.length;o<r;o++){var l=n[o];if(b.c.isInt(e)&&e<n.length){i=e;break}if(l.ID&&l.ID===e||l.name&&l.name===e){i=o;break}}if(t)for(o=0,r=n.length;o<r;o++){if(l=n[o],b.c.isInt(t)&&t<n.length){a=t;break}if(l.ID&&l.ID===t||l.name&&l.name===t){a=o;break}}for(o=0,r=n.length;o<r&&(null==i||null==a);o++){var s;l=n[o],i||!l.ucd||0!=(s=$.trim(l.ucd.toLowerCase())).indexOf("pos.eq.ra")&&0!=s.indexOf("pos_eq_ra")?a||!l.ucd||0!=(s=$.trim(l.ucd.toLowerCase())).indexOf("pos.eq.dec")&&0!=s.indexOf("pos_eq_dec")||(a=o):i=o}if(null==i&&null==a)for(o=0,r=n.length;o<r;o++){var c=(l=n[o]).name||l.ID||"";c=c.toLowerCase(),i||0!=c.indexOf("ra")&&0!=c.indexOf("_ra")&&0!=c.indexOf("ra(icrs)")&&0!=c.indexOf("_ra")&&0!=c.indexOf("alpha")?a||0!=c.indexOf("dej2000")&&0!=c.indexOf("_dej2000")&&0!=c.indexOf("de")&&0!=c.indexOf("de(icrs)")&&0!=c.indexOf("_de")&&0!=c.indexOf("delta")||(a=o):i=o}return null!=i&&null!=a||(i=0,a=1),[i,a]}return n.createShape=function(n,e,t){if(n instanceof Image||n instanceof HTMLCanvasElement)return n;var i=document.createElement("canvas");i.width=i.height=t;var a=i.getContext("2d");return a.beginPath(),a.strokeStyle=e,a.lineWidth=2,"plus"==n?(a.moveTo(t/2,0),a.lineTo(t/2,t),a.stroke(),a.moveTo(0,t/2),a.lineTo(t,t/2),a.stroke()):"cross"==n?(a.moveTo(0,0),a.lineTo(t-1,t-1),a.stroke(),a.moveTo(t-1,0),a.lineTo(0,t-1),a.stroke()):"rhomb"==n?(a.moveTo(t/2,0),a.lineTo(0,t/2),a.lineTo(t/2,t),a.lineTo(t,t/2),a.lineTo(t/2,0),a.stroke()):"triangle"==n?(a.moveTo(t/2,0),a.lineTo(0,t-1),a.lineTo(t-1,t-1),a.lineTo(t/2,0),a.stroke()):"circle"==n?(a.arc(t/2,t/2,t/2-1,0,2*Math.PI,!0),a.stroke()):(a.moveTo(1,0),a.lineTo(1,t-1),a.lineTo(t-1,t-1),a.lineTo(t-1,1),a.lineTo(1,1),a.stroke()),i},n.parseVOTable=function(n,t,i,a,o,r){b.c.getAjaxObject(n,"GET","text",a).done((function(n){!function(n,t){n=n.replace(/^\s+/g,"");var a=["name","ID","ucd","utype","unit","datatype","arraysize","width","precision"],l=[],s=0,f=$($.parseXML(n)),u=function(n){var e;if(n.find("RESOURCE").length>0)e="";else{if(0==(e=n.find("*").first()).length)return"";var t=(e=e.prop("tagName")).indexOf(":");e=e.substring(0,t)+"\\:"}return e}(f);f.find(u+"FIELD").each((function(){for(var n={},e=0;e<a.length;e++){var t=a[e];$(this).attr(t)&&(n[t]=$(this).attr(t))}n.ID||(n.ID="col_"+s),l.push(n),s++}));var p,_,h=e(l,o,r);p=h[0],_=h[1];var d,v,m=[],x=new c;f.find(u+"TR").each((function(){var n={},e=0;$(this).find(u+"TD").each((function(){var t=l[e].name?l[e].name:l[e].id;n[t]=$(this).text(),e++}));var t=l[p].name?l[p].name:l[p].id,a=l[_].name?l[_].name:l[_].id;if(b.c.isNumber(n[t])&&b.c.isNumber(n[a])?(d=parseFloat(n[t]),v=parseFloat(n[a])):(x.parse(n[t]+" "+n[a]),d=x.lon,v=x.lat),m.push(new qt(d,v,n)),i&&m.length==i)return!1})),t&&t(m)}(n,t)}))},n.prototype.updateShape=function(e){e=e||{},this.color=e.color||this.color||Rt.getNextColor(),this.sourceSize=e.sourceSize||this.sourceSize||6,this.shape=e.shape||this.shape||"square",this.selectSize=this.sourceSize+2,this.cacheCanvas=n.createShape(this.shape,this.color,this.sourceSize),this.cacheSelectCanvas=n.createShape("square",this.selectionColor,this.selectSize),this.reportChange()},n.prototype.addSources=function(n){n=[].concat(n),this.sources=this.sources.concat(n);for(var e=0,t=n.length;e<t;e++)n[e].setCatalog(this);this.reportChange()},n.prototype.addSourcesAsArray=function(n,t){for(var i=[],a=0;a<n.length;a++)i.push({name:n[a]});var o,r,l=e(i,this.raField,this.decField);o=l[0],r=l[1];for(var s,f,u,p,_=[],h=new c,d=0;d<t.length;d++){for(u=t[d],b.c.isNumber(u[o])&&b.c.isNumber(u[r])?(s=parseFloat(u[o]),f=parseFloat(u[r])):(h.parse(u[o]+" "+u[r]),s=h.lon,f=h.lat),p={},a=0;a<n.length;a++)p[n[a]]=u[a];_.push(A.source(s,f,p))}this.addSources(_)},n.prototype.getSources=function(){return this.sources},n.prototype.selectAll=function(){if(this.sources)for(var n=0;n<this.sources.length;n++)this.sources[n].select()},n.prototype.deselectAll=function(){if(this.sources)for(var n=0;n<this.sources.length;n++)this.sources[n].deselect()},n.prototype.getSource=function(n){return n<this.sources.length?this.sources[n]:null},n.prototype.setView=function(n){this.view=n,this.reportChange()},n.prototype.remove=function(n){var e=this.sources.indexOf(n);e<0||(this.sources[e].deselect(),this.sources.splice(e,1),this.reportChange())},n.prototype.removeAll=n.prototype.clear=function(){this.sources=[]},n.prototype.draw=function(e,t,i,a,o,r,l){if(this.isShowing){this._shapeIsFunction&&e.save();for(var s,c=[],f=0,u=this.sources.length;f<u;f++)n.drawSource(this,this.sources[f],e,t,i,a,o,r,l)&&c.push(this.sources[f]);for(this._shapeIsFunction&&e.restore(),e.strokeStyle=this.selectionColor,f=0,u=c.length;f<u;f++)(s=c[f]).isSelected&&n.drawSourceSelection(this,s,e);if(this.displayLabel)for(e.fillStyle=this.labelColor,e.font=this.labelFont,f=0,u=c.length;f<u;f++)n.drawSourceLabel(this,c[f],e)}},n.drawSource=function(n,e,t,i,a,o,r,l,s){if(!e.isShowing)return!1;var c=n.sourceSize,f=n.view.aladin.webglAPI.worldToScreen(e.ra,e.dec);if(f){var u={vx:f[0],vy:f[1]},p=e.popup?100:e.sourceSize;if(u){if(u.vx>o+p||u.vx<0-p||u.vy>r+p||u.vy<0-p)return e.x=e.y=void 0,!1;e.x=u.vx,e.y=u.vy,n._shapeIsFunction?n.shape(e,t,n.view.getViewParams()):e.marker&&e.useMarkerDefaultIcon?t.drawImage(n.cacheMarkerCanvas,e.x-c/2,e.y-c/2):t.drawImage(n.cacheCanvas,e.x-n.cacheCanvas.width/2,e.y-n.cacheCanvas.height/2),e.popup&&e.popup.setPosition(e.x,e.y)}return!0}return!1},n.drawSourceSelection=function(n,e,t){if(e&&e.isShowing&&e.x&&e.y){var i=n.selectSize;t.drawImage(n.cacheSelectCanvas,e.x-i/2,e.y-i/2)}},n.drawSourceLabel=function(n,e,t){if(e&&e.isShowing&&e.x&&e.y){var i=e.data[n.labelColumn];i&&t.fillText(i,e.x,e.y)}},n.prototype.reportChange=function(){this.view&&this.view.requestRedraw()},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.view&&this.view.popup&&this.view.popup.source&&this.view.popup.source.catalog==this&&this.view.popup.hide(),this.reportChange())},n}(),Mt=function(){let n=function(n,e,t,i){i=i||{},this.type="progressivecat",this.rootUrl=n,b.c.isHttpsContext()&&(/u-strasbg.fr/i.test(this.rootUrl)||/unistra.fr/i.test(this.rootUrl))&&(this.rootUrl=this.rootUrl.replace("http://","https://")),this.frameStr=e,this.frame=_.fromString(e)||_.J2000,this.maxOrder=t,this.isShowing=!0,this.name=i.name||"progressive-cat",this.color=i.color||Rt.getNextColor(),this.shape=i.shape||"square",this.sourceSize=i.sourceSize||6,this.selectSize=this.sourceSize+2,this.selectionColor="#00ff00",this.filterFn=i.filter||void 0,this.onClick=i.onClick||void 0,this.sourcesCache=new b.c.LRUCache(100),this.updateShape(i),this.maxOrderAllsky=2,this.isReady=!1};function e(n,e){var t=["name","ID","ucd","utype","unit","datatype","arraysize","width","precision"],i=[],a=0;return n.keyRa=n.keyDec=null,$(e).find("FIELD").each((function(){for(var e={},o=0;o<t.length;o++){var r=t[o];$(this).attr(r)&&(e[r]=$(this).attr(r))}e.ID||(e.ID="col_"+a),n.keyRa||!e.ucd||0!=e.ucd.indexOf("pos.eq.ra")&&0!=e.ucd.indexOf("POS_EQ_RA")||(e.name?n.keyRa=e.name:n.keyRa=e.ID),n.keyDec||!e.ucd||0!=e.ucd.indexOf("pos.eq.dec")&&0!=e.ucd.indexOf("POS_EQ_DEC")||(e.name?n.keyDec=e.name:n.keyDec=e.ID),i.push(e),a++})),i}function t(n,e,t){if(!n.keyRa||!n.keyDec)return[];for(var i=e.split("\n"),a=[],o=0;o<t.length;o++)t[o].name?a.push(t[o].name):a.push(t[o].ID);for(var r,l=[],s=new c,f=2;f<i.length;f++){var u={},p=i[f].split("\t");if(!(p.length<a.length)){for(var _=0;_<a.length;_++)u[a[_]]=p[_];var h,d;b.c.isNumber(u[n.keyRa])&&b.c.isNumber(u[n.keyDec])?(h=parseFloat(u[n.keyRa]),d=parseFloat(u[n.keyDec])):(s.parse(u[n.keyRa]+" "+u[n.keyDec]),h=s.lon,d=s.lat),r=new qt(h,d,u),l.push(r),r.setCatalog(n)}}return l}return n.readProperties=function(n,e,t){if(e){var i=n+"/properties";$.ajax({url:i,method:"GET",dataType:"text",success:function(n){for(var t={},i=n.split("\n"),a=0;a<i.length;a++){var o=i[a],r=o.indexOf("="),l=$.trim(o.substring(0,r)),s=$.trim(o.substring(r+1));t[l]=s}e(t)},error:function(n){t&&t(n)}})}},n.prototype={init:function(e){var t=this;this.view=e,this.maxOrder&&this.frameStr?this._loadMetadata():n.readProperties(t.rootUrl,(function(n){t.properties=n,t.maxOrder=t.properties.hips_order,t.frame=_.fromString(t.properties.hips_frame),t._loadMetadata()}),(function(n){console.log("Could not find properties for HiPS "+t.rootUrl)}))},updateShape:Ot.prototype.updateShape,_loadMetadata:function(){var n=this;$.ajax({url:n.rootUrl+"/Metadata.xml",method:"GET",success:function(t){n.fields=e(n,t),n._loadAllskyNewMethod()},error:function(e){n._loadAllskyOldMethod()}})},_loadAllskyNewMethod:function(){var n=this;$.ajax({url:n.rootUrl+"/Norder1/Allsky.tsv",method:"GET",success:function(e){n.order1Sources=t(n,e,n.fields),n.order2Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}}),$.ajax({url:n.rootUrl+"/Norder2/Allsky.tsv",method:"GET",success:function(e){n.order2Sources=t(n,e,n.fields),n.order1Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}})},_loadAllskyOldMethod:function(){this.maxOrderAllsky=3,this._loadLevel2Sources(),this._loadLevel3Sources()},_loadLevel2Sources:function(){var n=this;$.ajax({url:n.rootUrl+"/Norder2/Allsky.xml",method:"GET",success:function(i){n.fields=e(n,i),n.order2Sources=t(n,$(i).find("CSV").text(),n.fields),n.order3Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}})},_loadLevel3Sources:function(){var n=this;$.ajax({url:n.rootUrl+"/Norder3/Allsky.xml",method:"GET",success:function(e){n.order3Sources=t(n,$(e).find("CSV").text(),n.fields),n.order2Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}})},_finishInitWhenReady:function(){this.view.requestRedraw(),this.loadNeededTiles()},draw:function(n,e,t,i,a,o,r){if(this.isShowing&&this.isReady&&(this.drawSources(this.order1Sources,n,e,t,i,a,o,r),this.drawSources(this.order2Sources,n,e,t,i,a,o,r),this.drawSources(this.order3Sources,n,e,t,i,a,o,r),this.tilesInView))for(var l,s,c,f=0;f<this.tilesInView.length;f++)s=(c=this.tilesInView[f])[0]+"-"+c[1],(l=this.sourcesCache.get(s))&&this.drawSources(l,n,e,t,i,a,o,r)},drawSources:function(n,e,t,i,a,o,r,l){if(n){for(var s,c=0,f=n.length;c<f;c++)s=n[c],this.filterFn&&!this.filterFn(s)||Ot.drawSource(this,s,e,t,i,a,o,r,l);for(c=0,f=n.length;c<f;c++)(s=n[c]).isSelected&&(this.filterFn&&!this.filterFn(s)||Ot.drawSourceSelection(this,s,e))}},getSources:function(){var n=[];if(this.order1Sources&&(n=n.concat(this.order1Sources)),this.order2Sources&&(n=n.concat(this.order2Sources)),this.order3Sources&&(n=n.concat(this.order3Sources)),this.tilesInView)for(var e,t,i,a=0;a<this.tilesInView.length;a++)t=(i=this.tilesInView[a])[0]+"-"+i[1],(e=this.sourcesCache.get(t))&&(n=n.concat(e));return n},deselectAll:function(){if(this.order1Sources)for(var n=0;n<this.order1Sources.length;n++)this.order1Sources[n].deselect();if(this.order2Sources)for(n=0;n<this.order2Sources.length;n++)this.order2Sources[n].deselect();if(this.order3Sources)for(n=0;n<this.order3Sources.length;n++)this.order3Sources[n].deselect();var e=this.sourcesCache.keys();for(key in e)if(this.sourcesCache[key]){var t=this.sourcesCache[key];for(n=0;n<t.length;n++)t[n].deselect()}},show:function(){this.isShowing||(this.isShowing=!0,this.loadNeededTiles(),this.reportChange())},hide:function(){this.isShowing&&(this.isShowing=!1,this.reportChange())},reportChange:function(){this.view.requestRedraw()},getTileURL:function(n,e){var t=1e4*Math.floor(e/1e4);return this.rootUrl+"/Norder"+n+"/Dir"+t+"/Npix"+e+".tsv"},loadNeededTiles:function(){if(this.isShowing){this.tilesInView=[];var n=this.view.realNorder;if(n>this.maxOrder&&(n=this.maxOrder),!(n<=this.maxOrderAllsky)){for(var e,i,a,o,r=this.view.getVisibleCells(n,this.frame),l=3;l<=n;l++){e=[];for(var s=0;s<r.length;s++)i=Math.floor(r[s].ipix/Math.pow(4,n-l)),e.indexOf(i)<0&&e.push(i);for(var c=0;c<e.length;c++)this.tilesInView.push([l,e[c]])}for(s=0;s<this.tilesInView.length;s++)o=(a=this.tilesInView[s])[0]+"-"+a[1],this.sourcesCache.get(o)||function(n,e,i){var a=e+"-"+i;$.ajax({url:n.getTileURL(e,i),method:"GET",success:function(e){n.sourcesCache.set(a,t(n,e,n.fields))},error:function(){n.sourcesCache.set(a,[])}})}(this,a[0],a[1])}}},reportChange:function(){this.view&&this.view.requestRedraw()}},n}(),Lt=function(){let n={cache:{},SESAME_URL:"http://cds.u-strasbg.fr/cgi-bin/nph-sesame.jsonp",getTargetRADec:function(e,t,i){if(t)if(/[a-zA-Z]/.test(e))n.resolve(e,(function(n){t({ra:n.Target.Resolver.jradeg,dec:n.Target.Resolver.jdedeg})}),(function(n){i&&i()}));else{var a=new Coo;a.parse(e),t&&t({ra:a.lon,dec:a.lat})}},resolve:function(e,t,i){var a=n.SESAME_URL;b.c.isHttpsContext()&&(a=a.replace("http://","https://")),$.ajax({url:a,data:{object:e},method:"GET",dataType:"jsonp",success:function(n){n.Target&&n.Target.Resolver&&n.Target.Resolver?t(n):i(n)},error:i})}};return n}(),Et=function(){function n(n){this.isShowing=!1,this.divEl=$('<div class="aladin-measurement-div"></div>'),$(n).append(this.divEl)}return n.prototype.showMeasurement=function(n){this.divEl.empty();var e="<thead><tr>",t="<tr>";for(let i in n.data)e+="<th>"+i+"</th>",t+="<td>"+n.data[i]+"</td>";e+="</tr></thead>",t+="</tr>",this.divEl.append("<table>"+e+t+"</table>"),this.show()},n.prototype.show=function(){this.divEl.show()},n.prototype.hide=function(){this.divEl.hide()},n}(),Nt=function(){function n(n){this.$div=$(n)}return n.prototype.update=function(n,e,t,i){i=i&&!0===i||!1;var a=new c(n,e,7);t==_.J2000?this.$div.html(a.format("s/")):(_.J2000d,this.$div.html(a.format("d/"))),this.$div.toggleClass("aladin-reticleColor",i)},n}(),Ft=function(n,e){return n&&"object"==typeof n&&"ra"in n&&"dec"in n&&(n=new c(n.ra,n.dec,7).format("s")),"https://alasky.unistra.fr/cgi/simbad-flat/simbad-cs.py?target="+encodeURIComponent(n)+"&SR="+e+"&format=votable&SRUNIT=deg&SORTBY=nbref"},jt=function(n,e,t){return"https://ned.ipac.caltech.edu/cgi-bin/nph-objsearch?search_type=Near+Position+Search&of=xml_main&RA="+n+"&DEC="+e+"&SR="+t},Ht=function(n,e){return"https://ned.ipac.caltech.edu/cgi-bin/nph-objsearch?search_type=Near+Name+Search&radius="+60*e+"&of=xml_main&objname="+n},Ut=function(n,e,t,i){console.log(e),e&&"object"==typeof e&&"ra"in e&&"dec"in e&&(e=new c(e.ra,e.dec,7).format("s"));var a=1e5;return i&&i.hasOwnProperty("limit")&&b.c.isNumber(i.limit)&&(a=parseInt(i.limit)),"https://vizier.unistra.fr/viz-bin/votable?-source="+n+"&-c="+encodeURIComponent(e)+"&-out.max="+a+"&-c.rd="+t},Vt=function(n,e,t,i,a){var o="http://vo.imcce.fr/webservices/skybot/skybotconesearch_query.php?-from=AladinLite";if(o+="&RA="+encodeURIComponent(n),o+="&DEC="+encodeURIComponent(e),o+="&SR="+encodeURIComponent(t),o+="&EPOCH="+encodeURIComponent(i),a)for(var r in a)a.hasOwnProperty(r)&&(o+="&"+r+"="+encodeURIComponent(a[r]));return o};var Bt=t(6990);let Gt=function(){var n=function(e,t){if(0!=$(e).length){this.webglAPI=null;var i=this;if(void 0===t&&(t=this.getOptionsFromQueryString()),"zoom"in(t=t||{})){var a=t.zoom;delete t.zoom,t.fov=a}var o={};for(var r in n.DEFAULT_OPTIONS)void 0!==t[r]?o[r]=t[r]:o[r]=n.DEFAULT_OPTIONS[r];for(var r in t)void 0===n.DEFAULT_OPTIONS[r]&&(o[r]=t[r]);this.options=o,$("<style type='text/css'> .aladin-reticleColor { color: "+this.options.reticleColor+"; font-weight:bold;} </style>").appendTo(e),this.aladinDiv=e,this.reduceDeformations=!0,$(e).addClass("aladin-container");var l=_.fromString(o.cooFrame,_.J2000),s=$('<div class="aladin-location">'+(o.showFrame?'<select class="aladin-frameChoice"><option value="'+_.J2000.label+'" '+(l==_.J2000?'selected="selected"':"")+'>J2000</option><option value="'+_.J2000d.label+'" '+(l==_.J2000d?'selected="selected"':"")+'>J2000d</option><option value="'+_.GAL.label+'" '+(l==_.GAL?'selected="selected"':"")+">GAL</option></select>":"")+'<span class="aladin-location-text"></span></div>').appendTo(e),c=$('<div class="aladin-fov"></div>').appendTo(e);o.showZoomControl&&$('<div class="aladin-zoomControl"><a href="#" class="zoomPlus" title="Zoom in">+</a><a href="#" class="zoomMinus" title="Zoom out">&ndash;</a></div>').appendTo(e),o.showFullscreenControl&&$('<div class="aladin-fullscreenControl aladin-maximize" title="Full screen"></div>').appendTo(e),this.fullScreenBtn=$(e).find(".aladin-fullscreenControl"),this.fullScreenBtn.click((function(){i.toggleFullscreen(i.options.realFullscreen)})),$(document).on("fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange",(function(n){if(null==(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement)){i.fullScreenBtn.removeClass("aladin-restore"),i.fullScreenBtn.addClass("aladin-maximize"),i.fullScreenBtn.attr("title","Full screen"),$(i.aladinDiv).removeClass("aladin-fullscreen");var e=i.callbacksByEventName.fullScreenToggled,t=i.fullScreenBtn.hasClass("aladin-restore");"function"==typeof e&&e(t)}})),$("<div class='aladin-logo-container'><a href='https://aladin.unistra.fr/' title='Powered by Aladin Lite' target='_blank'><div class='aladin-logo'></div></a></div>").appendTo(e),this.boxes=[],this.measurementTable=new Et(e);var f=new Nt(s.find(".aladin-location-text"));if(this.view=new Pt(this,f,c,l,o.fov),this.view.setShowGrid(o.showCooGrid),o.showLayersControl){(d=$('<div class="aladin-layersControl-container" title="Manage layers"><div class="aladin-layersControl"></div></div>')).appendTo(e);var u=$('<div class="aladin-box aladin-layerBox aladin-cb-list"></div>');u.appendTo(e),this.boxes.push(u),d.click((function(){return i.hideBoxes(),i.showLayerBox(),!1}))}if(o.showGotoControl){(d=$('<div class="aladin-gotoControl-container" title="Go to position"><div class="aladin-gotoControl"></div></div>')).appendTo(e);var p=$('<div class="aladin-box aladin-gotoBox"><a class="aladin-closeBtn">&times;</a><div style="clear: both;"></div><form class="aladin-target-form">Go to: <input type="text" placeholder="Object name/position" /></form></div>');p.appendTo(e),this.boxes.push(p);var h=p.find(".aladin-target-form input");h.on("paste keydown",(function(){$(this).removeClass("aladin-unknownObject")})),d.click((function(){return i.hideBoxes(),h.val(""),h.removeClass("aladin-unknownObject"),p.show(),h.focus(),!1})),p.find(".aladin-closeBtn").click((function(){return i.hideBoxes(),!1}))}if(o.showSimbadPointerControl&&((d=$('<div class="aladin-simbadPointerControl-container" title="SIMBAD pointer"><div class="aladin-simbadPointerControl"></div></div>')).appendTo(e),d.click((function(){i.view.setMode(Pt.TOOL_SIMBAD_POINTER)}))),o.showShareControl){var d;(d=$('<div class="aladin-shareControl-container" title="Get link for current view"><div class="aladin-shareControl"></div></div>')).appendTo(e);var v=$('<div class="aladin-box aladin-shareBox"><a class="aladin-closeBtn">&times;</a><div style="clear: both;"></div>Link to previewer: <span class="info"></span><input type="text" class="aladin-shareInput" /></div>');v.appendTo(e),this.boxes.push(v),d.click((function(){i.hideBoxes(),v.show();var n=i.getShareURL();return v.find(".aladin-shareInput").val(n).select(),document.execCommand("copy"),!1})),v.find(".aladin-closeBtn").click((function(){return i.hideBoxes(),!1}))}if(this.gotoObject(o.target,void 0,{forceAnimation:!1}),o.log){var m=t;m.version=n.VERSION,Dt("startup",m)}if(this.showReticle(o.showReticle),o.catalogUrls)for(var x=0,g=o.catalogUrls.length;x<g;x++)this.createCatalogFromVOTable(o.catalogUrls[x]);o.survey&&(async()=>{if(typeof o.survey===Array){let e=0;o.survey.forEach((async t=>{const i=await n.createImageSurvey(t);0==e?this.setImageSurvey(i,"base"):this.addImageSurvey(i,"base"),e++}))}else{const e=await n.createImageSurvey(o.survey,"base");this.setImageSurvey(e,"base")}})(),this.view.showCatalog(o.showCatalog);var y=this;$(e).find(".aladin-frameChoice").change((function(){y.setFrame($(this).val())})),$(e).find(".aladin-target-form").submit((function(){return y.gotoObject($(this).find("input").val(),(function(){$(e).find(".aladin-target-form input").addClass("aladin-unknownObject")})),!1}));var w=$(e).find(".zoomPlus");w.click((function(){return y.increaseZoom(),!1})),w.bind("mousedown",(function(n){n.preventDefault()}));var b=$(e).find(".zoomMinus");b.click((function(){return y.decreaseZoom(),!1})),b.bind("mousedown",(function(n){n.preventDefault()})),this.callbacksByEventName={},this.view.redraw(),o.fullScreen&&window.setTimeout((function(){i.toggleFullscreen(i.options.realFullscreen)}),10)}};n.VERSION="{ALADIN-LITE-VERSION-NUMBER}",n.JSONP_PROXY="https://alasky.unistra.fr/cgi/JSONProxy",n.wasmLibs={},n.webglAPI=[],n.DEFAULT_OPTIONS={target:"0 +0",cooFrame:"J2000",survey:"P/DSS2/color",fov:60,showReticle:!0,showZoomControl:!0,showFullscreenControl:!0,showLayersControl:!0,showGotoControl:!0,showSimbadPointerControl:!1,showShareControl:!1,showCatalog:!0,showFrame:!0,showCooGrid:!1,fullScreen:!1,reticleColor:"rgb(178, 50, 178)",reticleSize:22,log:!0,allowFullZoomout:!1,realFullscreen:!1,showAllskyRing:!1,allskyRingColor:"#c8c8ff",allskyRingWidth:8,pixelateCanvas:!0},n.prototype.toggleFullscreen=function(n){n=Boolean(n),this.fullScreenBtn.toggleClass("aladin-maximize aladin-restore");var e=this.fullScreenBtn.hasClass("aladin-restore");if(this.fullScreenBtn.attr("title",e?"Restore original size":"Full screen"),$(this.aladinDiv).toggleClass("aladin-fullscreen"),n)if(e){var t=this.aladinDiv;t.requestFullscreen?t.requestFullscreen():t.webkitRequestFullscreen?t.webkitRequestFullscreen():t.mozRequestFullScreen?t.mozRequestFullScreen():t.msRequestFullscreen&&t.msRequestFullscreen()}else document.exitFullscreen?document.exitFullscreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen();this.view.fixLayoutDimensions();var i=this.callbacksByEventName.zoomChanged;"function"==typeof i&&i(this.view.fov);var a=this.callbacksByEventName.fullScreenToggled;"function"==typeof a&&a(e)},n.prototype.updateSurveysDropdownList=function(n){n=n.sort((function(n,e){return n.order?n.order&&n.order>e.order?1:-1:n.id>e.id}));var e=$(this.aladinDiv).find(".aladin-surveySelection");e.empty();for(var t=0;t<n.length;t++){var i=this.view.imageSurvey.id==n[t].id;e.append($("<option />").attr("selected",i).val(n[t].id).text(n[t].name))}},n.prototype.setAngleRotation=function(n){this.view.setAngleRotation(n)},n.prototype.getOptionsFromQueryString=function(){var n={},e=$.urlParam("target");e&&(n.target=e);var t=$.urlParam("frame");t&&_[t]&&(n.frame=t);var i=$.urlParam("survey");i&&o.j.getSurveyInfoFromId(i)&&(n.survey=i);var a=$.urlParam("zoom");a&&a>0&&a<180&&(n.zoom=a);var r=$.urlParam("showReticle");r&&(n.showReticle="true"==r.toLowerCase());var l=$.urlParam("cooFrame");l&&(n.cooFrame=l);var s=$.urlParam("fullScreen");return void 0!==s&&(n.fullScreen=s),n},n.prototype.setFoV=n.prototype.setFov=function(n){this.view.setZoom(n)},n.prototype.adjustFovForObject=function(n){var e=this;this.getFovForObject(n,(function(n){e.setFoV(n)}))},n.prototype.getFovForObject=function(n,e){var t="//simbad.u-strasbg.fr/simbad/sim-tap/sync?query="+encodeURIComponent("SELECT galdim_majaxis, V FROM basic JOIN ident ON oid=ident.oidref JOIN allfluxes ON oid=allfluxes.oidref WHERE id='"+n+"'")+"&request=doQuery&lang=adql&format=json&phase=run";b.c.getAjaxObject(t,"GET","json",!1).done((function(n){var t=4/60;if("data"in n&&n.data.length>0){var i=b.c.isNumber(n.data[0][0])?n.data[0][0]/60:null,a=b.c.isNumber(n.data[0][1])?n.data[0][1]:null;null!==i?t=2*i:null!==a&&a<10&&(t=2*Math.pow(2,6-a/2)/60)}"function"==typeof e&&e(t)}))},n.prototype.setFrame=function(n){if(n){var e=_.fromString(n,_.J2000);e!=this.view.cooFrame&&(this.view.changeFrame(e),$(this.aladinDiv).find(".aladin-frameChoice").val(e.label))}},n.prototype.setProjection=function(n){n&&(n=n.toLowerCase(),this.view.changeProjection(n))},n.prototype.gotoObject=function(e,t,i){let a,o;if("object"==typeof t?(t.hasOwnProperty("success")&&(a=t.success),t.hasOwnProperty("error")&&(o=t.error)):"function"==typeof t&&(o=t),/[a-zA-Z]/.test(e)){var r=this;Lt.resolve(e,(function(n){var e=n.Target.Resolver.jradeg,t=n.Target.Resolver.jdedeg;r.view.pointTo(e,t,i),"function"==typeof a&&a(r.getRaDec())}),(function(n){console&&(console.log("Could not resolve object name "+e),console.log(n)),"function"==typeof o&&o()}))}else{var l=new c;l.parse(e);var s=[l.lon,l.lat];this.view.aladin.webglAPI.cooSystem()===n.wasmLibs.webgl.GALCooSys()&&(s=this.view.aladin.webglAPI.Gal2J2000(l.lon,l.lat)),this.view.pointTo(s[0],s[1],i),"function"==typeof a&&a(this.getRaDec())}},n.prototype.gotoPosition=function(n,e){var t;t=this.view.cooFrame==_.GAL?R.GalacticToJ2000([n,e]):[n,e],this.view.pointTo(t[0],t[1])};var e=function(n){var t=n.animationParams;if(null!=t&&t.running){var i=(new Date).getTime();if(i>t.end)return n.gotoRaDec(t.raEnd,t.decEnd),void(t.complete&&t.complete());var a=(i-t.start)/(t.end-t.start),o=function(n,e,t,i,a){function o(n){return n*Math.PI/180}function r(n){return 180*n/Math.PI}e=o(e),n=o(n),i=o(i),t=o(t);var l=2*Math.asin(Math.sqrt(Math.pow(Math.sin((e-i)/2),2)+Math.cos(e)*Math.cos(i)*Math.pow(Math.sin((n-t)/2),2))),s=Math.sin((1-a)*l)/Math.sin(l),c=Math.sin(a*l)/Math.sin(l),f=s*Math.cos(e)*Math.cos(n)+c*Math.cos(i)*Math.cos(t),u=s*Math.cos(e)*Math.sin(n)+c*Math.cos(i)*Math.sin(t),p=s*Math.sin(e)+c*Math.sin(i),_=Math.atan2(u,f),h=Math.atan2(p,Math.sqrt(Math.pow(f,2)+Math.pow(u,2)));return[r(_),r(h)]}(t.raStart,t.decStart,t.raEnd,t.decEnd,a),r=o[0],l=o[1];n.gotoRaDec(r,l),setTimeout((function(){e(n)}),50)}};n.prototype.stopAnimation=function(){this.zoomAnimationParams&&(this.zoomAnimationParams.running=!1),this.animationParams&&(this.animationParams.running=!1)},n.prototype.animateToRaDec=function(n,t,i,a){i=i||5,this.animationParams=null;var o={};o.start=(new Date).getTime(),o.end=(new Date).getTime()+1e3*i;var r=this.getRaDec();o.raStart=r[0],o.decStart=r[1],o.raEnd=n,o.decEnd=t,o.complete=a,o.running=!0,this.animationParams=o,e(this)};var t=function(n){var e=n.zoomAnimationParams;if(null!=e&&e.running){var i=(new Date).getTime();if(i>e.end)return n.setFoV(e.fovEnd),void(e.complete&&e.complete());var a=(i-e.start)/(e.end-e.start),o=e.fovStart+(e.fovEnd-e.fovStart)*Math.sqrt(a);n.setFoV(o),setTimeout((function(){t(n)}),50)}};return n.prototype.zoomToFoV=function(n,e,i){e=e||5,this.zoomAnimationParams=null;var a={};a.start=(new Date).getTime(),a.end=(new Date).getTime()+1e3*e;var o=this.getFov();a.fovStart=Math.max(o[0],o[1]),a.fovEnd=n,a.complete=i,a.running=!0,this.zoomAnimationParams=a,t(this)},n.prototype.getRaDec=function(){return this.webglAPI.getCenter()},n.prototype.gotoRaDec=function(n,e){this.view.pointTo(n,e)},n.prototype.showHealpixGrid=function(n){this.view.showHealpixGrid(n)},n.prototype.showSurvey=function(n){this.view.showSurvey(n)},n.prototype.showCatalog=function(n){this.view.showCatalog(n)},n.prototype.showReticle=function(n){this.view.showReticle(n),$("#displayReticle").attr("checked",n)},n.prototype.removeLayers=function(){this.view.removeLayers()},n.prototype.addCatalog=function(n){this.view.addCatalog(n)},n.prototype.addOverlay=function(n){this.view.addOverlay(n)},n.prototype.addMOC=function(n){this.view.addMOC(n)},n.createImageSurvey=async function(n){return await o.j.create(n)},n.prototype.setImageSurvey=function(n,e){let t;t=e||"base",this.view.setImageSurvey(n,t)},n.prototype.setImageSurveysLayer=function(n,e){let t;t=e||"base",this.view.setImageSurveysLayer(n,t)},n.prototype.removeImageSurveysLayer=function(n){let e;e=n||"base",this.view.removeImageSurveysLayer(e)},n.prototype.moveImageSurveysLayerForward=function(n){this.view.moveImageSurveysLayerForward(surveys,layerName)},n.prototype.addImageSurvey=function(n,e){let t;t=e||"base",this.view.addImageSurvey(n,t)},n.prototype.setOpacityLayer=function(n,e){let t;t=e||"base",this.webglAPI.setOpacityLayer(n,e)},n.prototype.setBaseImageSurveysLayer=function(n){this.view.setImageSurveysLayer(n,"base")},n.prototype.setBaseImageSurvey=function(n){this.view.setImageSurvey(n,"base")},n.prototype.increaseZoom=function(n){this.view.increaseZoom()},n.prototype.decreaseZoom=function(n){this.view.decreaseZoom()},n.prototype.createProgressiveCatalog=function(n,e,t,i){return new Mt(n,e,t,i)},n.prototype.createOverlay=function(n){return new Ct(n)},n.AVAILABLE_CALLBACKS=["select","objectClicked","objectHovered","footprintClicked","footprintHovered","positionChanged","zoomChanged","click","mouseMove","fullScreenToggled","catalogReady"],n.prototype.on=function(e,t){n.AVAILABLE_CALLBACKS.indexOf(e)<0||(this.callbacksByEventName[e]=t)},n.prototype.select=function(){this.fire("selectstart")},n.prototype.fire=function(n,e){if("selectstart"===n)this.view.setMode(Pt.SELECT);else if("selectend"===n){this.view.setMode(Pt.PAN);var t=this.callbacksByEventName.select;"function"==typeof t&&t(e)}},n.prototype.hideBoxes=function(){if(this.boxes)for(var n=0;n<this.boxes.length;n++)this.boxes[n].hide()},n.prototype.updateCM=function(){},n.prototype.showLayerBox=function(){var n=this,e=$(this.aladinDiv).find(".aladin-layerBox");e.empty(),e.append('<a class="aladin-closeBtn">&times;</a><div style="clear: both;"></div></div>'),e.append('<div class="aladin-label">Projection</div>');let t=$('<select id="projectionChoice"><option id="sinus" value="sinus">SINUS</option><option id="aitoff" value="aitoff">AITOFF</option><option id="mollweide" value="mollweide">MOLLWEIDE</option><option id="mercator" value="mercator">MERCATOR</option><option id="arc" value="arc">ARC</option><option id="tan" value="tan">TAN</option></select>');e.append(t).append("<br />"),t.change((function(){n.setProjection($(this).val())})),e.append('<div class="aladin-box-separator"></div><div class="aladin-label">Overlay layers</div>');for(var i=this.view.allOverlayLayers,a="<ul>",o=i.length-1;o>=0;o--){var r=i[o],l=r.name,s="";r.isShowing&&(s='checked="checked"');var c="",f="";if("catalog"==r.type||"progressivecat"==r.type){var u=r.getSources().length;c=u+" source"+(u>1?"s":""),f=d.SVG_ICONS.CATALOG}else"moc"==r.type?(c="Coverage: "+(100*r.skyFraction()).toFixed(3)+" % of sky",f=d.SVG_ICONS.MOC):"overlay"==r.type&&(f=d.SVG_ICONS.OVERLAY);var p=$("<div></div>").css("color",r.color).css("color"),_=Rt.getLabelColorForBackground(p);a+='<li><div class="aladin-stack-icon" style=\'background-image: url("data:image/svg+xml;base64,'+window.btoa(f.replace(/FILLCOLOR/g,r.color))+"\");'></div>",a+='<input type="checkbox" '+s+' id="aladin_lite_'+l+'"></input><label for="aladin_lite_'+l+'" class="aladin-layer-label" style="background: '+r.color+"; color:"+_+';" title="'+c+'">'+l+"</label></li>"}a+="</ul>",e.append(a),e.append('<div class="aladin-blank-separator"></div>'),s="",this.view.displayReticle&&(s='checked="checked"');var h=$('<input type="checkbox" '+s+' id="displayReticle" />');e.append(h).append('<label for="displayReticle">Reticle</label><br/>'),h.change((function(){n.showReticle($(this).is(":checked"))})),s="",this.view.displayHpxGrid&&(s='checked="checked"');var v=$('<input type="checkbox" '+s+' id="displayHpxGrid"/>');e.append(v).append('<label for="displayHpxGrid">HEALPix grid</label><br/>'),v.change((function(){n.showHealpixGrid($(this).is(":checked"))})),s="",this.view.showGrid&&(s='checked="checked"');var m=$('<input type="checkbox" '+s+' id="displayEquatorialGrid"/>');e.append(m).append('<label for="displayEquatorialGrid">Equatorial grid</label><br/>'),m.change((function(){let e=$(this).is(":checked");n.view.setShowGrid(e)})),e.append('<div class="aladin-box-separator"></div><div class="aladin-label">Tools</div>');var x=$('<button class="aladin-btn" type="button">Export view as PNG</button>');e.append(x),x.click((function(){n.exportAsPNG()})),e.find(".aladin-closeBtn").click((function(){return n.hideBoxes(),!1})),$(this.aladinDiv).find(".aladin-layerBox ul input").change((function(){var e=$(this).attr("id").substr(12),t=n.layerByName(e);$(this).is(":checked")?t.show():t.hide()})),e.show()},n.prototype.layerByName=function(n){for(var e=this.view.allOverlayLayers,t=0;t<e.length;t++)if(n==e[t].name)return e[t];return null},n.prototype.exportAsPNG=function(n){var e=window.open();e.document.write('<img src="'+this.getViewDataURL()+'">'),e.document.title="Aladin Lite snapshot"},n.prototype.getViewDataURL=function(n){return"object"!=typeof(n=n||{})&&(n={format:n}),this.view.getCanvasDataURL(n.format,n.width,n.height)},n.prototype.getViewWCS=function(n){var e=this.getRaDec(),t=this.getFov();return{NAXIS:2,NAXIS1:this.view.width,NAXIS2:this.view.height,RADECSYS:"ICRS",CRPIX1:this.view.width/2,CRPIX2:this.view.height/2,CRVAL1:e[0],CRVAL2:e[1],CTYPE1:"RA---SIN",CTYPE2:"DEC--SIN",CD1_1:t[0]/this.view.width,CD1_2:0,CD2_1:0,CD2_2:t[1]/this.view.height}},n.prototype.setFovRange=n.prototype.setFOVRange=function(n,e){if(n>e){var t=n;n=e,e=t}this.view.minFOV=n,this.view.maxFOV=e},n.prototype.pix2world=function(e,t){if(this.view){var i,a;try{i=this.view.aladin.webglAPI.screenToWorld(e,t)}catch(n){return}return this.view.aladin.webglAPI.cooSystem()===n.wasmLibs.webgl.GALCooSys()&&(a=this.view.aladin.webglAPI.Gal2J2000(i[0],i[1])),a}},n.prototype.world2pix=function(n,e){if(this.view){var t;if(this.view.cooFrame==_.GAL){var i=R.J2000ToGalactic([n,e]);t=this.view.projection.project(i[0],i[1])}else t=this.view.projection.project(n,e);if(t){var a=d.xyToView(t.X,t.Y,this.view.width,this.view.height,this.view.largestDim,this.view.zoomFactor);return[a.vx,a.vy]}return null}},n.prototype.getFovCorners=function(n){(!n||n<1)&&(n=1);for(var e,t,i,a,o=[],r=0;r<4;r++){e=0==r||3==r?0:this.view.width-1,t=r<2?0:this.view.height-1,i=r<2?this.view.width-1:0,a=1==r||2==r?this.view.height-1:0;for(var l=0;l<n;l++){let r=this.webglAPI.screenToWorld(e+l/n*(i-e),t+l/n*(a-t));o.push(r)}}return o},n.prototype.getFov=function(){var n=this.view.fov,e=this.getSize(),t=e[1]/e[0]*n;return[n=Math.min(n,180),t=Math.min(t,180)]},n.prototype.getSize=function(){return[this.view.width,this.view.height]},n.prototype.getParentDiv=function(){return $(this.aladinDiv)},n}(),Xt={aladin:function(n,e){return new Gt($(n)[0],e)},source:function(n,e,t,i){return new qt(n,e,t,i)},marker:function(n,e,t,i){return(t=t||{}).marker=!0,Xt.source(n,e,i,t)},createImageSurvey:async function(n){return await o.j.create(n)},polygon:function(n){var e=n.length;return e>0&&(n[0][0]==n[e-1][0]&&n[0][1]==n[e-1][1]||n.push([n[0][0],n[0][1]])),new D(n)},polyline:function(n,e){return new kt(n,e)},circle:function(n,e,t,i){return new q([n,e],t,i)},ellipse:function(n,e,t,i,a,o){return new At([n,e],t,i,a,o)},graphicOverlay:function(n){return new Ct(n)},imageSurveyLayer:function(n){return new It(n)},catalog:function(n){return new Ot(n)},catalogHiPS:function(n,e){return new Mt(n,null,null,e)}};Gt.prototype.box=function(n){var e=new Box(n);return e.$parentDiv.appendTo(this.aladinDiv),e},Gt.prototype.showPopup=function(n,e,t,i){this.view.catalogForPopup.removeAll();var a=Xt.marker(n,e,{popupTitle:t,popupDesc:i,useMarkerDefaultIcon:!1});this.view.catalogForPopup.addSources(a),this.view.catalogForPopup.show(),this.view.popup.setTitle(t),this.view.popup.setText(i),this.view.popup.setSource(a),this.view.popup.show()},Gt.prototype.hidePopup=function(){this.view.popup.hide()},Gt.prototype.getShareURL=function(){var n=this.getRaDec(),e=new c;return e.prec=7,e.lon=n[0],e.lat=n[1],"https://aladin.unistra.fr/AladinLite/?target="+encodeURIComponent(e.format("s"))+"&fov="+this.getFov()[0].toFixed(2)+"&survey="+encodeURIComponent(this.getBaseImageLayer().id||this.getBaseImageLayer().rootUrl)},Gt.prototype.getEmbedCode=function(){var n=this.getRaDec(),e=new c;e.prec=7,e.lon=n[0],e.lat=n[1];var t="";return t+='<link rel="stylesheet" href="https://aladin.unistra.fr/AladinLite/api/v2/latest/aladin.min.css" />\n',t+='<script type="text/javascript" src="https://code.jquery.com/jquery-1.9.1.min.js" charset="utf-8"><\/script>\n',t+='<div id="aladin-lite-div" style="width:400px;height:400px;"></div>\n',t+='<script type="text/javascript" src="https://aladin.unistra.fr/AladinLite/api/v2/latest/aladin.min.js" charset="utf-8"><\/script>\n',t+='<script type="text/javascript">\n',(t+='var aladin = A.aladin("#aladin-lite-div", {survey: "'+this.getBaseImageLayer().id+'P/DSS2/color", fov: '+this.getFov()[0].toFixed(2)+', target: "'+e.format("s")+'"});\n')+"<\/script>"},Gt.prototype.displayFITS=function(n,e,t,i,a){var o={url:n};(t=t||{}).color&&(o.color=!0),t.outputFormat&&(o.format=t.outputFormat),t.order&&(o.order=t.order),t.nocache&&(o.nocache=t.nocache);let r=this;$.ajax({url:"https://alasky.unistra.fr/cgi/fits2HiPS",data:o,method:"GET",dataType:"json",success:function(n){if("success"!=n.status)return console.error("An error occured: "+n.message),void(a&&a(n.message));t.label;var o=n.data.meta;(async()=>{let a=await Gt.createImageSurvey(n.data.url);var l=t&&t.transparency||1,s=!0;i&&(s=i(o.ra,o.dec,o.fov)),!0===s&&(r.webglAPI.setCenter(o.ra,o.dec),r.setFoV(o.fov)),r.setImageSurvey(a,e),r.setOpacityLayer(l,e)})()}})},Gt.prototype.displayJPG=Gt.prototype.displayPNG=function(n,e,t,i,a){(t=t||{}).color=!0,t.label="JPG/PNG image",t.outputFormat="png",this.displayFITS(n,e,t,i,a)},Gt.prototype.setReduceDeformations=function(n){this.reduceDeformations=n,this.view.requestRedraw()},Xt.footprintsFromSTCS=function(n){return Ct.parseSTCS(n)},Xt.MOCFromURL=function(n,e,t){var i=new Tt(e);return i.dataFromFITSURL(n,t),i},Xt.MOCFromJSON=function(n,e){var t=new Tt(e);return t.dataFromJSON(n),t},Xt.catalogFromURL=function(n,e,t,i){var a=Xt.catalog(e);return Ot.parseVOTable(n,(function(n){a.addSources(n),t&&t(n)}),a.maxNbSources,i,a.raField,a.decField),a},Xt.catalogFromSimbad=function(n,e,t,i){"name"in(t=t||{})||(t.name="Simbad");var a=Ft(n,e);return Xt.catalogFromURL(a,t,i,!1)},Xt.catalogFromNED=function(n,e,t,i){var a;if("name"in(t=t||{})||(t.name="NED"),n&&"object"==typeof n)"ra"in n&&"dec"in n&&(a=jt(n.ra,n.dec,e));else if(/[a-zA-Z]/.test(n))a=Ht(n,e);else{var o=new c;o.parse(n),a=jt(o.lon,o.lat,e)}return Xt.catalogFromURL(a,t,i)},Xt.catalogFromVizieR=function(n,e,t,i,a){"name"in(i=i||{})||(i.name="VizieR:"+n);var o=Ut(n,e,t,i);return console.log(o),Xt.catalogFromURL(o,i,a,!1)},Xt.catalogFromSkyBot=function(n,e,t,i,a,o,r){a=a||{},"name"in(o=o||{})||(o.name="SkyBot");var l=Vt(n,e,t,i,a);return Xt.catalogFromURL(l,o,r,!1)},Xt.hipsDefinitionFromURL=function(n,e){Bt.z.fromURL(n,e)},Xt.init=Promise.all([Promise.all([t.e(731),t.e(995)]).then(t.bind(t,1995)),Promise.all([t.e(731),t.e(846)]).then(t.bind(t,2846))]).then((async n=>{let[e,t]=n;Gt.wasmLibs.hpx=e,Gt.wasmLibs.webgl=t})),window.A=Xt},6990:(n,e,t)=>{"use strict";t.d(e,{z:()=>a});var i=t(6186);let a=function(){function n(n){this.properties=n,this.id=this.getID(),this.obsTitle=n.obs_title,this.frame=n.hips_frame,this.order=parseInt(n.hips_order),this.clientSortKey=n.client_sort_key,this.tileFormats=n.hasOwnProperty("hips_tile_format")&&n.hips_tile_format.split(" "),this.urls=[],this.urls.push(n.hips_service_url);for(var e=1;n.hasOwnProperty("hips_service_url_"+e);)this.urls.push(n["hips_service_url_"+e]),e++;this.clientApplications=n.client_application}n.prototype={getServiceURLs:function(n){n=!0===n},getID:function(){if(this.properties.hasOwnProperty("ID"))return this.properties.ID;var n=null;return this.properties.hasOwnProperty("creator_did")&&(n=this.properties.creator_did),null==n&&this.properties.hasOwnProperty("publisher_did")&&(n=this.properties.publisher_did),null!=n&&("ivo://"===n.slice(0,6)&&(n=n.slice(6)),n=n.replace(/\?/g,"/")),n}};var e=[],t=[];n.LOCAL_STORAGE_KEY="aladin:hips-list";var a="_last_used_url";n.getLocalStorageDefinitions=function(){try{var e=window.localStorage.getItem(n.LOCAL_STORAGE_KEY);return null===e?[]:window.JSON.parse(e)}catch(n){return[]}},n.storeInLocalStorage=function(e){try{window.localStorage.setItem(n.LOCAL_STORAGE_KEY,window.JSON.stringify(e))}catch(n){return!1}return!0};var o=["http://alasky.u-strasbg.fr/MocServer/query","http://alaskybis.u-strasbg.fr/MocServer/query"],r=["https://alasky.u-strasbg.fr/MocServer/query","https://alaskybis.unistra.fr/MocServer/query"];n.getRemoteDefinitions=function(n,e,t){(n=n||{client_application:"AladinLite"}).fmt="json",n.fields="ID,obs_title,client_sort_key,client_application,hips_service_url*,hips_order,hips_tile_format,hips_frame";var a=i.c.isHttpsContext()?r:o;i.c.loadFromMirrors(a,{data:n,onSuccess:function(n){"function"==typeof e&&e(n)},onFailure:function(){console.error("Could not load HiPS definitions from urls "+a),"function"==typeof t&&t()},timeout:5})};var l=function(n,e){for(var t=[],i={},o=0;o<e.length;o++)i[(r=e[o]).ID]=r;for(o=0;o<n.length;o++){var r,l=(r=n[o]).ID;if(i.hasOwnProperty(l)){var s=i[l];r.hasOwnProperty(a)&&!s.hasOwnProperty(a)&&(s[a]=r[a]),t.push(s)}else t.push(r)}return t};return n.CACHE_RETENTION_TIME_SECONDS=604800,n.init=function(){t=e;for(var i=n.getLocalStorageDefinitions(),a=(new Date).getTime(),o=[],r=0;r<i.length;r++){var s=i[r];s.hasOwnProperty("_timestamp_retrieved")&&a-s._timestamp_retrieved>1e3*n.CACHE_RETENTION_TIME_SECONDS&&o.push(r)}for(r=o.length-1;r>=0;r--)i.splice(o[r],1);t=l(t,i),n.getRemoteDefinitions({dataproduct_type:"image",client_application:"AladinLite"},(function(e){for(var i=(new Date).getTime(),a=0;a<e.length;a++)e[a]._timestamp_retrieved=i;t=l(t,e),n.storeInLocalStorage(t)}))},n.getALDefaultHiPSDefinitions=function(){for(var e=[],i=0;i<t.length;i++){var a=t[i];!a.hasOwnProperty("client_application")||a.client_application.indexOf("AladinLite")<0||e.push(new n(a))}return e},n.getDefinitions=function(){for(var e=[],i=0;i<t.length;i++){var a=t[i];e.push(new n(a))}return e},n.parseHiPSProperties=function(n){if(null==n)return null;for(var e={},t=(n=n.replace(/[\r]/g,"")).split("\n"),i=0;i<t.length;i++){var a=$.trim(t[i]);if("#"!==a.slice(0,1)){var o=a.indexOf("=");if(!(o<0)){var r=$.trim(a.slice(0,o)),l=$.trim(a.slice(o+1));e[r]=l}}}return e},n.findByID=function(n,e){var t=findByIDLocal(n);t.length>0?"function"==typeof e&&e(t):findByIDRemote(n,e)},n.findByIDLocal=function(e,i){for(var a=[],o=0;o<t.length;o++){var r=t[o];null!=r.ID.match(e)&&a.push(new n(r))}return a},n.findByIDRemote=function(e,t){n.findHiPSRemote({ID:"*"+e+"*"},t)},n.findHiPSRemote=function(e,t){(e=e||{}).hasOwnProperty("dataproduct_type")||(e.dataproduct_type="image"),n.getRemoteDefinitions(e,(function(e){for(var i=[],a=0;a<e.length;a++)i.push(new n(e[a]));"function"==typeof t&&t(i)}))},n.fromURL=function(e,t){var a,o;"properties"===e.slice(-10)?a=(o=e).slice(0,-11):("/"===e.slice(-1)&&(e=e.slice(0,-1)),o=(a=e)+"/properties");var r=function(e){var i=n.parseHiPSProperties(e);i.hasOwnProperty("hips_service_url")||(i.hips_service_url=a),"function"==typeof t&&t(new n(i))};i.c.getAjaxObject(o,"GET","text",!1).done((function(n){r(n)})).fail((function(){i.c.getAjaxObject(o,"GET","text",!0).done((function(n){r(n)})).fail((function(){"function"==typeof t&&t(null)}))}))},n.fromProperties=function(e){return new n(e)},n.init(),n}()},8222:(n,e,t)=>{"use strict";t.d(e,{j:()=>o});var i=t(6186),a=t(6990);let o=function(){let n=function(e){if(!e)throw"An hosting survey URL or an ID (i.e. DSS2/red) must be given";let t=!1;console.log("root url",e),e.includes("http")&&(t=!0);let o=null;if(t){let t=e;return"/"===t.slice(-1)&&(t=t.substr(0,t.length-1)),t=i.c.getAbsoluteURL(t),i.c.isHttpsContext()&&(/u-strasbg.fr/i.test(t)||/unistra.fr/i.test(t))&&(t=t.replace("http://","https://")),console.log("ROOT URL",t),o=t+"/properties",(async()=>{console.log("properties url",o);let e=await fetch(o).then((n=>n.text()));if(e=a.z.parseHiPSProperties(e),console.log("metadata",e),!e)throw"no surveys matching";const t=n.parseSurveyProperties(e);return console.log("survey ",t),t})()}{const t="https://alasky.unistra.fr/MocServer/query?ID=*"+encodeURIComponent(e)+"*&get=record&fmt=json";return(async()=>{let e=await(async n=>{const e=await fetch(n);return await e.json()})(t);if(!e)throw"no surveys matching";if(e.length>1){let n=[];throw e.forEach((e=>{n.push(e.ID)})),n+" surveys are matching. Please use one from this list."}if(0===e.length)throw"no surveys matching";return e=e[0],n.parseSurveyProperties(e)})()}};return n.parseSurveyProperties=function(n){n.hips_order;const e=n.hips_tile_format.split(" ");let t,i;e.indexOf("fits")>=0?(t={FITSImage:{bitpix:parseInt(n.hips_pixel_bitpix)}},i={Grayscale2Color:{color:[1,1,1],k:1,transfer:"asinh"}}):(i="Color",t=e.indexOf("png")>=0?{Image:{format:"png"}}:{Image:{format:"jpeg"}});let a=[void 0,void 0];n.hips_pixel_cut&&(a=n.hips_pixel_cut.split(" "));let o=512;if(n.hips_tile_width){let e=parseInt(n.hips_tile_width);!0===(e&&!(e&e-1))&&(o=e)}let r=n.hips_service_url;if(!r)throw"no valid service URL for retrieving the tiles";return r=r.startsWith("http://alasky")?r.replace("http","https"):"https://alasky.u-strasbg.fr/cgi/JSONProxy?url="+r,{properties:{url:r,maxOrder:parseInt(n.hips_order),frame:{label:"J2000",system:"J2000"},tileSize:o,format:t,minCutout:parseFloat(a[0]),maxCutout:parseFloat(a[1])},color:i}},n.create=async function(e,t){if(e)return await new n(e)},n}()},6818:()=>{SimbadPointer=(SimbadPointer={},SimbadPointer.MIRRORS=["https://alasky.u-strasbg.fr/cgi/simbad-flat/simbad-quick.py","https://alaskybis.u-strasbg.fr/cgi/simbad-flat/simbad-quick.py"],SimbadPointer.query=function(n,e,t,i){var a={Ident:new Coo(n,e,7).format("s/"),SR:t};Utils.loadFromMirrors(SimbadPointer.MIRRORS,{data:a,onSuccess:function(n){i.view.setCursor("pointer");var e=/(.*?)\/(.*?)\((.*?),(.*?)\)/g.exec(n);if(e){var t=new Coo;t.parse(e[1]);var a=e[2],o='<div class="aladin-sp-title"><a target="_blank" href="http://simbad.u-strasbg.fr/simbad/sim-id?Ident='+encodeURIComponent(a)+'">'+a+"</a></div>",r='<div class="aladin-sp-content">';r+="<em>Type: </em>"+e[4]+"<br>";var l=e[3];Utils.isNumber(l)&&(r+="<em>Mag: </em>"+l+"<br>"),r+='<br><a target="_blank" href="http://cdsportal.u-strasbg.fr/?target='+encodeURIComponent(a)+'">Query in CDS portal</a>',r+="</div>",i.showPopup(t.lon,t.lat,o,r)}else i.hidePopup()},onFailure:function(){i.view.setCursor("pointer"),i.hidePopup()},timeout:5})},SimbadPointer)},6186:(n,e,t)=>{"use strict";t.d(e,{c:()=>a});var i=t(6630);let a={cssScale:void 0};HTMLCanvasElement.prototype.relMouseCoords=function(n){if(n.offsetX)return{x:n.offsetX,y:n.offsetY};if(!a.cssScale){var e=window.getComputedStyle(document.body,null),t=(e.getPropertyValue("-webkit-transform")||e.getPropertyValue("-moz-transform")||e.getPropertyValue("-ms-transform")||e.getPropertyValue("-o-transform")||e.getPropertyValue("transform")).match(/matrix\((-?\d*\.?\d+),\s*0,\s*0,\s*(-?\d*\.?\d+),\s*0,\s*0\)/);a.cssScale=t?parseFloat(t[1]):1}var i=n,o=(i.target,i.target||i.srcElement),r=o.currentStyle||window.getComputedStyle(o,null),l=parseInt(r.borderLeftWidth,10),s=parseInt(r.borderTopWidth,10),c=o.getBoundingClientRect(),f=i.clientX,u=i.clientY;i.clientX?(f=i.clientX,u=i.clientY):(f=i.originalEvent.changedTouches[0].clientX,u=i.originalEvent.changedTouches[0].clientY);var p=f-l-c.left,_=u-s-c.top;return{x:parseInt(p/a.cssScale),y:parseInt(_/a.cssScale)}},Function.prototype.bind||(Function.prototype.bind=function(n){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=[].slice,t=e.call(arguments,1),i=this,a=function(){},o=function(){return i.apply(this instanceof a?this:n||{},t.concat(e.call(arguments)))};return o.prototype=this.prototype,o}),$.urlParam=function(n,e){return void 0===e&&(e=location.search),decodeURIComponent((new RegExp("[?|&]"+n+"=([^&;]+?)(&|#|;|$)").exec(e)||[,""])[1].replace(/\+/g,"%20"))||null},a.isNumber=function(n){return!isNaN(parseFloat(n))&&isFinite(n)},a.isInt=function(n){return a.isNumber(n)&&Math.floor(n)==n},a.debounce=function(n,e){var t=null;return function(){var i=this,a=arguments;clearTimeout(t),t=setTimeout((function(){n.apply(i,a)}),e)}},a.throttle=function(n,e,t){var i,a;return e||(e=250),function(){var o=t||this,r=+new Date,l=arguments;i&&r<i+e?(clearTimeout(a),a=setTimeout((function(){i=r,n.apply(o,l)}),e)):(i=r,n.apply(o,l))}},a.LRUCache=function(n){this._keys=[],this._items={},this._expires={},this._size=0,this._maxsize=n||1024},a.LRUCache.prototype={set:function(n,e){var t=this._keys,i=this._items,a=this._expires,o=this._size;o>=this._maxsize&&(t.sort((function(n,e){return a[n]>a[e]?-1:a[n]<a[e]?1:0})),o--,delete a[t[o]],delete i[t[o]]),t[o]=n,i[n]=e,a[n]=Date.now(),o++,this._keys=t,this._items=i,this._expires=a,this._size=o},get:function(n){var e=this._items[n];return e&&(this._expires[n]=Date.now()),e},keys:function(){return this._keys}},a.loadFromMirrors=function(n,e){var t=e&&e.data||null,i=(e&&e.method,e&&e.dataType||null),o=(e&&e.timeout,e&&e.onSuccess||null),r=e&&e.onFailure||null;if(0===n.length)"function"==typeof r&&r();else{var l={url:n[0],data:t};i&&(l.dataType=i),$.ajax(l).done((function(n){"function"==typeof o&&o(n)})).fail((function(){a.loadFromMirrors(n.slice(1),e)}))}},a.getAjaxObject=function(n,e,t,a){if(!1!==a&&(a=!0),!0===a)var o=i.k.JSONP_PROXY+"?url="+encodeURIComponent(n);else o=n;return e=e||"GET",t=t||null,$.ajax({url:o,method:e,dataType:t})},a.isHttpsContext=function(){return"https:"===window.location.protocol},a.getAbsoluteURL=function(n){var e=document.createElement("a");return e.href=n,e.href},a.uuidv4=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(n){var e=16*Math.random()|0;return("x"==n?e:3&e|8).toString(16)}))}}},gi={};function yi(n){var e=gi[n];if(void 0!==e)return e.exports;var t=gi[n]={id:n,loaded:!1,exports:{}};return xi[n].call(t.exports,t,t.exports,yi),t.loaded=!0,t.exports}yi.m=xi,yi.c=gi,yi.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return yi.d(e,{a:e}),e},yi.d=(n,e)=>{for(var t in e)yi.o(e,t)&&!yi.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},yi.f={},yi.e=n=>Promise.all(Object.keys(yi.f).reduce(((e,t)=>(yi.f[t](n,e),e)),[])),yi.u=n=>n+".aladin.js",yi.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),yi.hmd=n=>((n=Object.create(n)).children||(n.children=[]),Object.defineProperty(n,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+n.id)}}),n),yi.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),n={},e="hips_webgl_renderer:",yi.l=(t,i,a,o)=>{if(n[t])n[t].push(i);else{var r,l;if(void 0!==a)for(var s=document.getElementsByTagName("script"),c=0;c<s.length;c++){var f=s[c];if(f.getAttribute("src")==t||f.getAttribute("data-webpack")==e+a){r=f;break}}r||(l=!0,(r=document.createElement("script")).charset="utf-8",r.timeout=120,yi.nc&&r.setAttribute("nonce",yi.nc),r.setAttribute("data-webpack",e+a),r.src=t),n[t]=[i];var u=(e,i)=>{r.onerror=r.onload=null,clearTimeout(p);var a=n[t];if(delete n[t],r.parentNode&&r.parentNode.removeChild(r),a&&a.forEach((n=>n(i))),e)return e(i)},p=setTimeout(u.bind(null,void 0,{type:"timeout",target:r}),12e4);r.onerror=u.bind(null,r.onerror),r.onload=u.bind(null,r.onload),l&&document.head.appendChild(r)}},yi.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{var n;yi.g.importScripts&&(n=yi.g.location+"");var e=yi.g.document;if(!n&&e&&(e.currentScript&&(n=e.currentScript.src),!n)){var t=e.getElementsByTagName("script");t.length&&(n=t[t.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),yi.p=n})(),(()=>{var n={179:0};yi.f.j=(e,t)=>{var i=yi.o(n,e)?n[e]:void 0;if(0!==i)if(i)t.push(i[2]);else{var a=new Promise(((t,a)=>i=n[e]=[t,a]));t.push(i[2]=a);var o=yi.p+yi.u(e),r=new Error;yi.l(o,(t=>{if(yi.o(n,e)&&(0!==(i=n[e])&&(n[e]=void 0),i)){var a=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;r.message="Loading chunk "+e+" failed.\n("+a+": "+o+")",r.name="ChunkLoadError",r.type=a,r.request=o,i[1](r)}}),"chunk-"+e,e)}};var e=(e,t)=>{var i,a,[o,r,l]=t,s=0;for(i in r)yi.o(r,i)&&(yi.m[i]=r[i]);for(l&&l(yi),e&&e(t);s<o.length;s++)a=o[s],yi.o(n,a)&&n[a]&&n[a][0](),n[o[s]]=0},t=self.webpackChunkhips_webgl_renderer=self.webpackChunkhips_webgl_renderer||[];t.forEach(e.bind(null,0)),t.push=e.bind(null,t.push.bind(t))})(),di={},vi={6516:function(){return{"./healpix_bg.js":{__wbindgen_throw:function(n,e){return void 0===t&&(t=yi.c[821].exports),t.Or(n,e)}}}},182:function(){return{"./index_bg.js":{__wbindgen_object_drop_ref:function(n){return void 0===i&&(i=yi.c[2333].exports),i.ug$(n)},__wbindgen_object_clone_ref:function(n){return void 0===a&&(a=yi.c[2333].exports),a.m_1(n)},__wbindgen_string_new:function(n,e){return void 0===o&&(o=yi.c[2333].exports),o.h4u(n,e)},__wbindgen_number_get:function(n,e){return void 0===r&&(r=yi.c[2333].exports),r.M19(n,e)},__wbindgen_json_parse:function(n,e){return void 0===l&&(l=yi.c[2333].exports),l.t$0(n,e)},__wbindgen_json_serialize:function(n,e){return void 0===s&&(s=yi.c[2333].exports),s.r1T(n,e)},__wbindgen_cb_drop:function(n){return void 0===c&&(c=yi.c[2333].exports),c.G6U(n)},__wbg_fetchSurveyMetadata_3d518f6be78ba7d4:function(n,e){return void 0===f&&(f=yi.c[2333].exports),f.N6q(n,e)},__wbindgen_boolean_get:function(n){return void 0===u&&(u=yi.c[2333].exports),u.HT5(n)},__wbg_log_a39f164b49616cb0:function(n,e){return void 0===p&&(p=yi.c[2333].exports),p.TkU(n,e)},__wbg_instanceof_Window_434ce1849eb4e0fc:function(n){return void 0===_&&(_=yi.c[2333].exports),_.xAF(n)},__wbg_document_5edd43643d1060d9:function(n){return void 0===h&&(h=yi.c[2333].exports),h.p$7(n)},__wbg_navigator_0e0588c949560476:function(n){return void 0===d&&(d=yi.c[2333].exports),d.NMF(n)},__wbg_innerWidth_405786923c1d2641:function(n){return void 0===v&&(v=yi.c[2333].exports),v.Z5l(n)},__wbg_innerHeight_25d3be0d129329c3:function(n){return void 0===m&&(m=yi.c[2333].exports),m.jPO(n)},__wbg_devicePixelRatio_9632545370d525ae:function(n){return void 0===g&&(g=yi.c[2333].exports),g.$Ur(n)},__wbg_performance_bbca4ccfaef860b2:function(n){return void 0===w&&(w=yi.c[2333].exports),w.uVe(n)},__wbg_open_67fbcd7373a90ddc:function(n,e,t,i,a){return void 0===b&&(b=yi.c[2333].exports),b.c1U(n,e,t,i,a)},__wbg_requestAnimationFrame_0c71cd3c6779a371:function(n,e){return void 0===I&&(I=yi.c[2333].exports),I.VQB(n,e)},__wbg_setTimeout_1c75092906446b91:function(n,e,t){return void 0===P&&(P=yi.c[2333].exports),P.tZN(n,e,t)},__wbg_size_20c167ba9040b895:function(n){return void 0===T&&(T=yi.c[2333].exports),T.VeP(n)},__wbg_arrayBuffer_8b5364ee9b393098:function(n){return void 0===S&&(S=yi.c[2333].exports),S.JD0(n)},__wbg_appendChild_3fe5090c665d3bb4:function(n,e){return void 0===C&&(C=yi.c[2333].exports),C.Azg(n,e)},__wbg_setonerror_d665b35adb3552fb:function(n,e){return void 0===k&&(k=yi.c[2333].exports),k.wBc(n,e)},__wbg_setonload_18033df8ec5db791:function(n,e){return void 0===D&&(D=yi.c[2333].exports),D.vsC(n,e)},__wbg_data_9562112603a9aa89:function(n,e){return void 0===q&&(q=yi.c[2333].exports),q.RL2(n,e)},__wbg_getPropertyValue_fd6ae3726bda9d7f:function(n,e,t,i){return void 0===R&&(R=yi.c[2333].exports),R.CB1(n,e,t,i)},__wbg_setProperty_ebb06e7fa941d6a8:function(n,e,t,i,a){return void 0===O&&(O=yi.c[2333].exports),O.IYe(n,e,t,i,a)},__wbg_clientX_849ccdf456d662ac:function(n){return void 0===M&&(M=yi.c[2333].exports),M.bZ0(n)},__wbg_clientY_1aaff30fe0cd0876:function(n){return void 0===L&&(L=yi.c[2333].exports),L.aKY(n)},__wbg_ctrlKey_4e536bedb069129f:function(n){return void 0===E&&(E=yi.c[2333].exports),E.CX(n)},__wbg_metaKey_0b396e35a4941247:function(n){return void 0===N&&(N=yi.c[2333].exports),N.DO3(n)},__wbg_button_a18f33eb55774d89:function(n){return void 0===F&&(F=yi.c[2333].exports),F.HIE(n)},__wbg_type_8bc3e57acd2158c9:function(n,e){return void 0===j&&(j=yi.c[2333].exports),j.wF(n,e)},__wbg_addEventListener_6bdba88519fdc1c9:function(n,e,t,i){return void 0===H&&(H=yi.c[2333].exports),H.jGd(n,e,t,i)},__wbg_getwithindex_5caaba1b5b3e6e18:function(n,e){return void 0===U&&(U=yi.c[2333].exports),U.KUf(n,e)},__wbg_deltaX_df228181f4d1a561:function(n){return void 0===V&&(V=yi.c[2333].exports),V.$Ov(n)},__wbg_deltaY_afa6edde136e1500:function(n){return void 0===B&&(B=yi.c[2333].exports),B.XP1(n)},__wbg_deltaMode_ed9d7974a0c11323:function(n){return void 0===G&&(G=yi.c[2333].exports),G.uhW(n)},__wbg_dataTransfer_bc4c0501385a0c8e:function(n){return void 0===X&&(X=yi.c[2333].exports),X.T3e(n)},__wbg_now_5fa0ca001e042f8a:function(n){return void 0===J&&(J=yi.c[2333].exports),J.xbI(n)},__wbg_instanceof_HtmlInputElement_8969541a2a0bded0:function(n){return void 0===Y&&(Y=yi.c[2333].exports),Y.K5C(n)},__wbg_setautofocus_a2ae37091dfbe4af:function(n,e){return void 0===Z&&(Z=yi.c[2333].exports),Z.hhb(n,e)},__wbg_setsize_90d1034a7a757a50:function(n,e){return void 0===W&&(W=yi.c[2333].exports),W.VNV(n,e)},__wbg_value_fc1c354d1a0e9714:function(n,e){return void 0===K&&(K=yi.c[2333].exports),K.ZDS(n,e)},__wbg_setvalue_ce4a23f487065c07:function(n,e,t){return void 0===Q&&(Q=yi.c[2333].exports),Q.XgU(n,e,t)},__wbg_items_d571f433ef73ee49:function(n){return void 0===nn&&(nn=yi.c[2333].exports),nn.gDA(n)},__wbg_files_a4192b4f5967317b:function(n){return void 0===en&&(en=yi.c[2333].exports),en.ALE(n)},__wbg_length_41b205f6892bf9d9:function(n){return void 0===tn&&(tn=yi.c[2333].exports),tn.va1(n)},__wbg_get_bdec89fd60d07530:function(n,e){return void 0===an&&(an=yi.c[2333].exports),an.W8f(n,e)},__wbg_length_a2882c668bdf6488:function(n){return void 0===on&&(on=yi.c[2333].exports),on.pv_(n)},__wbg_get_1c01a7682a9775bb:function(n,e){return void 0===rn&&(rn=yi.c[2333].exports),rn.xq6(n,e)},__wbg_identifier_afa8b01d4d901685:function(n){return void 0===ln&&(ln=yi.c[2333].exports),ln.gvr(n)},__wbg_pageX_e0c8221ecfdb73d0:function(n){return void 0===sn&&(sn=yi.c[2333].exports),sn.vb7(n)},__wbg_pageY_32100ad7039a744e:function(n){return void 0===cn&&(cn=yi.c[2333].exports),cn.P01(n)},__wbg_force_8e51e1fec066aade:function(n){return void 0===fn&&(fn=yi.c[2333].exports),fn.Auf(n)},__wbg_length_01a613025b5ffd74:function(n){return void 0===un&&(un=yi.c[2333].exports),un.Lxw(n)},__wbg_item_b192ab411bbfbb09:function(n,e){return void 0===pn&&(pn=yi.c[2333].exports),pn.PzC(n,e)},__wbg_get_a765dab923455e0d:function(n,e){return void 0===_n&&(_n=yi.c[2333].exports),_n.A2l(n,e)},__wbg_responseURL_a3e549a88db1c1f7:function(n,e){return void 0===hn&&(hn=yi.c[2333].exports),hn.nwD(n,e)},__wbg_setresponseType_e5326d926ee8e787:function(n,e){return void 0===dn&&(dn=yi.c[2333].exports),dn.Ugc(n,e)},__wbg_response_8b12ac238727ae0e:function(n){return void 0===vn&&(vn=yi.c[2333].exports),vn.yB0(n)},__wbg_new_08dfde0f90155eb7:function(){return void 0===mn&&(mn=yi.c[2333].exports),mn.wae()},__wbg_open_7190f43b39e7f488:function(n,e,t,i,a,o){return void 0===xn&&(xn=yi.c[2333].exports),xn.tAG(n,e,t,i,a,o)},__wbg_send_84c8dd943b775f78:function(n){return void 0===gn&&(gn=yi.c[2333].exports),gn.iTe(n)},__wbg_body_7538539844356c1c:function(n){return void 0===yn&&(yn=yi.c[2333].exports),yn.Gnz(n)},__wbg_createElement_d017b8d2af99bab9:function(n,e,t){return void 0===wn&&(wn=yi.c[2333].exports),wn.cMj(n,e,t)},__wbg_getElementById_b30e88aff96f66a1:function(n,e,t){return void 0===bn&&(bn=yi.c[2333].exports),bn.zGh(n,e,t)},__wbg_id_79dca31d8297faf1:function(n,e){return void 0===In&&(In=yi.c[2333].exports),In.JN4(n,e)},__wbg_setid_73be37238eaa05be:function(n,e,t){return void 0===Pn&&(Pn=yi.c[2333].exports),Pn.epO(n,e,t)},__wbg_scrollLeft_e8aba47a94d12290:function(n){return void 0===zn&&(zn=yi.c[2333].exports),zn.TS(n)},__wbg_getBoundingClientRect_534c1b96b6e612d3:function(n){return void 0===Tn&&(Tn=yi.c[2333].exports),Tn.AJd(n)},__wbg_getElementsByClassName_8a7d00ed3eaf1522:function(n,e,t){return void 0===Sn&&(Sn=yi.c[2333].exports),Sn.GzJ(n,e,t)},__wbg_instanceof_WebGlRenderingContext_2be4c068bf5f8362:function(n){return void 0===Cn&&(Cn=yi.c[2333].exports),Cn.I76(n)},__wbg_canvas_d0b58be124e596e3:function(n){return void 0===An&&(An=yi.c[2333].exports),An.vg1(n)},__wbg_bufferData_85d635f32a990208:function(n,e,t,i){return void 0===kn&&(kn=yi.c[2333].exports),kn.$Vr(n,e,t,i)},__wbg_bufferSubData_3a944e1fdad0cd9a:function(n,e,t,i){return void 0===Dn&&(Dn=yi.c[2333].exports),Dn.I5w(n,e,t,i)},__wbg_readPixels_3692eaca9dfc7c0c:function(n,e,t,i,a,o,r,l){return void 0===qn&&(qn=yi.c[2333].exports),qn.kOd(n,e,t,i,a,o,r,l)},__wbg_texImage2D_d26bd916ff0956a1:function(n,e,t,i,a,o,r,l,s,c,f){return void 0===Rn&&(Rn=yi.c[2333].exports),Rn.VMe(n,e,t,i,a,o,r,l,s,c,f)},__wbg_texImage2D_b46a9b691e69d90b:function(n,e,t,i,a,o,r){return void 0===On&&(On=yi.c[2333].exports),On.kll(n,e,t,i,a,o,r)},__wbg_texSubImage2D_d907a4c940fd6e41:function(n,e,t,i,a,o,r,l,s,c){return void 0===Mn&&(Mn=yi.c[2333].exports),Mn.R4G(n,e,t,i,a,o,r,l,s,c)},__wbg_texSubImage2D_d9dc0ffd91998f0d:function(n,e,t,i,a,o,r,l){return void 0===Ln&&(Ln=yi.c[2333].exports),Ln.RsM(n,e,t,i,a,o,r,l)},__wbg_uniform1fv_e6a2134edff4f2e9:function(n,e,t,i){return void 0===En&&(En=yi.c[2333].exports),En.RLh(n,e,t,i)},__wbg_uniformMatrix2fv_aaa4e0f7c15bca04:function(n,e,t,i,a){return void 0===Nn&&(Nn=yi.c[2333].exports),Nn.a64(n,e,t,i,a)},__wbg_uniformMatrix4fv_f07c6caf5a563616:function(n,e,t,i,a){return void 0===Fn&&(Fn=yi.c[2333].exports),Fn.zw$(n,e,t,i,a)},__wbg_activeTexture_74ed11a5c5d5af90:function(n,e){return void 0===jn&&(jn=yi.c[2333].exports),jn.pDF(n,e)},__wbg_attachShader_55dbe770f3ee32ca:function(n,e,t){return void 0===Hn&&(Hn=yi.c[2333].exports),Hn.y1d(n,e,t)},__wbg_bindBuffer_29d52e7bc48650c3:function(n,e,t){return void 0===Un&&(Un=yi.c[2333].exports),Un.ros(n,e,t)},__wbg_bindFramebuffer_bd35ddd23765c7b6:function(n,e,t){return void 0===Vn&&(Vn=yi.c[2333].exports),Vn.DKE(n,e,t)},__wbg_bindTexture_198c816345baca83:function(n,e,t){return void 0===Bn&&(Bn=yi.c[2333].exports),Bn.lvN(n,e,t)},__wbg_blendEquation_09d56f3be6f914f5:function(n,e){return void 0===Gn&&(Gn=yi.c[2333].exports),Gn.uOU(n,e)},__wbg_blendFunc_c8f1e0fb4467f57c:function(n,e,t){return void 0===Xn&&(Xn=yi.c[2333].exports),Xn.un$(n,e,t)},__wbg_blendFuncSeparate_494b1dae028cb9a9:function(n,e,t,i,a){return void 0===Jn&&(Jn=yi.c[2333].exports),Jn.yub(n,e,t,i,a)},__wbg_clear_2af1271959ec83d7:function(n,e){return void 0===$n&&($n=yi.c[2333].exports),$n.Dr9(n,e)},__wbg_clearColor_51c4f69c743c3252:function(n,e,t,i,a){return void 0===Yn&&(Yn=yi.c[2333].exports),Yn.jNe(n,e,t,i,a)},__wbg_compileShader_3b5f9ef4c67a0777:function(n,e){return void 0===Zn&&(Zn=yi.c[2333].exports),Zn.IhY(n,e)},__wbg_createBuffer_c40f37e1348bb91f:function(n){return void 0===Wn&&(Wn=yi.c[2333].exports),Wn.AFF(n)},__wbg_createFramebuffer_410b12a5cc5a8f13:function(n){return void 0===Kn&&(Kn=yi.c[2333].exports),Kn.G1q(n)},__wbg_createProgram_245520da1fb9e47b:function(n){return void 0===Qn&&(Qn=yi.c[2333].exports),Qn.E8L(n)},__wbg_createShader_4d8818a13cb825b3:function(n,e){return void 0===ne&&(ne=yi.c[2333].exports),ne.wnC(n,e)},__wbg_createTexture_f3a6a715d6bada45:function(n){return void 0===ee&&(ee=yi.c[2333].exports),ee.u$u(n)},__wbg_cullFace_c6fb8a7309c36a38:function(n,e){return void 0===te&&(te=yi.c[2333].exports),te._27(n,e)},__wbg_deleteBuffer_c708688b9e1b3518:function(n,e){return void 0===ie&&(ie=yi.c[2333].exports),ie.hWq(n,e)},__wbg_deleteFramebuffer_ca006f8649d4550a:function(n,e){return void 0===ae&&(ae=yi.c[2333].exports),ae.bDQ(n,e)},__wbg_deleteTexture_9159fb5927ed32c0:function(n,e){return void 0===oe&&(oe=yi.c[2333].exports),oe.AsT(n,e)},__wbg_disable_2b63b75dc6c27537:function(n,e){return void 0===re&&(re=yi.c[2333].exports),re.TL1(n,e)},__wbg_disableVertexAttribArray_aa8458b40dd08914:function(n,e){return void 0===le&&(le=yi.c[2333].exports),le.BFq(n,e)},__wbg_drawArrays_22c88d644a33fd59:function(n,e,t,i){return void 0===se&&(se=yi.c[2333].exports),se.XRw(n,e,t,i)},__wbg_drawElements_6e26500a25ecf478:function(n,e,t,i,a){return void 0===ce&&(ce=yi.c[2333].exports),ce.HyA(n,e,t,i,a)},__wbg_enable_8f6dd779ccb8e1de:function(n,e){return void 0===fe&&(fe=yi.c[2333].exports),fe.kmw(n,e)},__wbg_enableVertexAttribArray_4ed5f91d0718bee1:function(n,e){return void 0===ue&&(ue=yi.c[2333].exports),ue.RhP(n,e)},__wbg_framebufferTexture2D_31643260e5b0b294:function(n,e,t,i,a,o){return void 0===pe&&(pe=yi.c[2333].exports),pe.UYF(n,e,t,i,a,o)},__wbg_getActiveUniform_3851244f8fc5db53:function(n,e,t){return void 0===_e&&(_e=yi.c[2333].exports),_e.zv9(n,e,t)},__wbg_getAttribLocation_da5df7094096113d:function(n,e,t,i){return void 0===he&&(he=yi.c[2333].exports),he.Ux5(n,e,t,i)},__wbg_getExtension_c6ceee3244ee7f20:function(n,e,t){return void 0===de&&(de=yi.c[2333].exports),de.TPd(n,e,t)},__wbg_getProgramInfoLog_c253042b64e86027:function(n,e,t){return void 0===ve&&(ve=yi.c[2333].exports),ve.Woc(n,e,t)},__wbg_getProgramParameter_4f698af0dda0a2d4:function(n,e,t){return void 0===me&&(me=yi.c[2333].exports),me.Dd9(n,e,t)},__wbg_getShaderInfoLog_584794e3bcf1e19b:function(n,e,t){return void 0===xe&&(xe=yi.c[2333].exports),xe.HMS(n,e,t)},__wbg_getShaderParameter_64b1ffe576e5fa25:function(n,e,t){return void 0===ge&&(ge=yi.c[2333].exports),ge.dVB(n,e,t)},__wbg_getUniformLocation_703972f150a46500:function(n,e,t,i){return void 0===ye&&(ye=yi.c[2333].exports),ye.hNQ(n,e,t,i)},__wbg_linkProgram_5fdd57237c761833:function(n,e){return void 0===we&&(we=yi.c[2333].exports),we.Xb5(n,e)},__wbg_scissor_fb094c7db856e2a7:function(n,e,t,i,a){return void 0===be&&(be=yi.c[2333].exports),be.zAt(n,e,t,i,a)},__wbg_shaderSource_173ab97288934a60:function(n,e,t,i){return void 0===Ie&&(Ie=yi.c[2333].exports),Ie.BIh(n,e,t,i)},__wbg_texParameteri_caec5468f2a850c3:function(n,e,t,i){return void 0===Pe&&(Pe=yi.c[2333].exports),Pe.KcO(n,e,t,i)},__wbg_uniform1f_258478814234cf9c:function(n,e,t){return void 0===ze&&(ze=yi.c[2333].exports),ze.ERh(n,e,t)},__wbg_uniform1i_a0275676828a22b6:function(n,e,t){return void 0===Te&&(Te=yi.c[2333].exports),Te.U4n(n,e,t)},__wbg_uniform2f_b0af46ba675f2c0d:function(n,e,t,i){return void 0===Se&&(Se=yi.c[2333].exports),Se.kV8(n,e,t,i)},__wbg_uniform3f_65416973a351fbab:function(n,e,t,i,a){return void 0===Ce&&(Ce=yi.c[2333].exports),Ce.Uzm(n,e,t,i,a)},__wbg_uniform4f_e5d0a91bf98b35ad:function(n,e,t,i,a,o){return void 0===Ae&&(Ae=yi.c[2333].exports),Ae.YXT(n,e,t,i,a,o)},__wbg_useProgram_d5898a40ebe88916:function(n,e){return void 0===ke&&(ke=yi.c[2333].exports),ke.lVh(n,e)},__wbg_vertexAttribPointer_0d097efa33e3f45f:function(n,e,t,i,a,o,r){return void 0===De&&(De=yi.c[2333].exports),De.sbi(n,e,t,i,a,o,r)},__wbg_viewport_19577064127daf83:function(n,e,t,i,a){return void 0===qe&&(qe=yi.c[2333].exports),qe.N_v(n,e,t,i,a)},__wbg_error_ca520cb687b085a1:function(n){return void 0===Re&&(Re=yi.c[2333].exports),Re.q5V(n)},__wbg_log_fbd13631356d44e4:function(n){return void 0===Oe&&(Oe=yi.c[2333].exports),Oe.r2_(n)},__wbg_warn_97f10a6b0dbb8c5c:function(n){return void 0===Me&&(Me=yi.c[2333].exports),Me.WV6(n)},__wbg_scrollTop_5ebd5c6591748d6e:function(n){return void 0===Le&&(Le=yi.c[2333].exports),Le.ejV(n)},__wbg_hidden_f7a620ec4ab18ce5:function(n){return void 0===Ee&&(Ee=yi.c[2333].exports),Ee.l7F(n)},__wbg_sethidden_fdaefd7e7da7e4c0:function(n,e){return void 0===Ne&&(Ne=yi.c[2333].exports),Ne.UOw(n,e)},__wbg_style_16f5dd9624687c8f:function(n){return void 0===Fe&&(Fe=yi.c[2333].exports),Fe.cE3(n)},__wbg_offsetTop_45111254e7b26a1f:function(n){return void 0===je&&(je=yi.c[2333].exports),je.x_Z(n)},__wbg_offsetLeft_be5393bf9eec5766:function(n){return void 0===He&&(He=yi.c[2333].exports),He.B9D(n)},__wbg_offsetWidth_bc683e2f57ea2d6b:function(n){return void 0===Ue&&(Ue=yi.c[2333].exports),Ue.MAo(n)},__wbg_setonload_9235de4503eb82c8:function(n,e){return void 0===Ve&&(Ve=yi.c[2333].exports),Ve.s76(n,e)},__wbg_setonerror_939f617c2b40758c:function(n,e){return void 0===Be&&(Be=yi.c[2333].exports),Be.Qyx(n,e)},__wbg_blur_2156876090506146:function(n){return void 0===Ge&&(Ge=yi.c[2333].exports),Ge.kW7(n)},__wbg_focus_4434360545ac99cf:function(n){return void 0===Xe&&(Xe=yi.c[2333].exports),Xe.W47(n)},__wbg_drawElementsInstancedANGLE_e184bb1bad14df88:function(n,e,t,i,a,o){return void 0===Je&&(Je=yi.c[2333].exports),Je.rBg(n,e,t,i,a,o)},__wbg_vertexAttribDivisorANGLE_2dc41a79843a435c:function(n,e,t){return void 0===$e&&($e=yi.c[2333].exports),$e.lKQ(n,e,t)},__wbg_type_e32f387f5584c765:function(n,e){return void 0===Ye&&(Ye=yi.c[2333].exports),Ye._dw(n,e)},__wbg_preventDefault_fa00541ff125b78c:function(n){return void 0===Ze&&(Ze=yi.c[2333].exports),Ze.fPX(n)},__wbg_stopPropagation_da586180676fa914:function(n){return void 0===We&&(We=yi.c[2333].exports),We.HP8(n)},__wbg_name_9a61dbbdbfb2d0de:function(n,e){return void 0===Ke&&(Ke=yi.c[2333].exports),Ke.RDw(n,e)},__wbg_lastModified_0de23a8c5214f2fb:function(n){return void 0===Qe&&(Qe=yi.c[2333].exports),Qe.tP6(n)},__wbg_instanceof_HtmlCanvasElement_a6157e470d06b638:function(n){return void 0===nt&&(nt=yi.c[2333].exports),nt.CUx(n)},__wbg_width_cfa982e2a6ad6297:function(n){return void 0===et&&(et=yi.c[2333].exports),et.OWO(n)},__wbg_setwidth_362e8db8cbadbe96:function(n,e){return void 0===tt&&(tt=yi.c[2333].exports),tt.RAI(n,e)},__wbg_height_1b399500ca683487:function(n){return void 0===it&&(it=yi.c[2333].exports),it.T2i(n)},__wbg_setheight_28f53831182cc410:function(n,e){return void 0===at&&(at=yi.c[2333].exports),at.Si(n,e)},__wbg_getContext_10d5c2a4cc0737c8:function(n,e,t,i){return void 0===ot&&(ot=yi.c[2333].exports),ot.hW7(n,e,t,i)},__wbg_setsrc_b0a1ac4dd261ae2d:function(n,e,t){return void 0===rt&&(rt=yi.c[2333].exports),rt.BKi(n,e,t)},__wbg_setcrossOrigin_07e0e4935571a4c5:function(n,e,t){return void 0===lt&&(lt=yi.c[2333].exports),lt.C7I(n,e,t)},__wbg_width_6c4cad65073b3852:function(n){return void 0===st&&(st=yi.c[2333].exports),st.zV7(n)},__wbg_height_133772b066cfc559:function(n){return void 0===ct&&(ct=yi.c[2333].exports),ct.LNH(n)},__wbg_new_da67f111e299956e:function(){return void 0===ft&&(ft=yi.c[2333].exports),ft.BBY()},__wbg_keyCode_8a05b1390fced3c8:function(n){return void 0===ut&&(ut=yi.c[2333].exports),ut.Aqq(n)},__wbg_altKey_773e7f8151c49bb1:function(n){return void 0===pt&&(pt=yi.c[2333].exports),pt.mjq(n)},__wbg_ctrlKey_8c7ff99be598479e:function(n){return void 0===_t&&(_t=yi.c[2333].exports),_t.Jw8(n)},__wbg_shiftKey_894b631364d8db13:function(n){return void 0===ht&&(ht=yi.c[2333].exports),ht.X9z(n)},__wbg_metaKey_99a7d3732e1b7856:function(n){return void 0===dt&&(dt=yi.c[2333].exports),dt.pBw(n)},__wbg_isComposing_b892666abf384da9:function(n){return void 0===vt&&(vt=yi.c[2333].exports),vt.fLR(n)},__wbg_key_7f10b1291a923361:function(n,e){return void 0===mt&&(mt=yi.c[2333].exports),mt.KRE(n,e)},__wbg_name_4ada8b70ffadb5c0:function(n,e){return void 0===xt&&(xt=yi.c[2333].exports),xt.GWB(n,e)},__wbg_top_a24b8b81afea659b:function(n){return void 0===gt&&(gt=yi.c[2333].exports),gt.qX0(n)},__wbg_left_0e681cb8fd277739:function(n){return void 0===yt&&(yt=yi.c[2333].exports),yt.F_1(n)},__wbg_userAgent_3f63af8b4fe2331c:function(n,e){return void 0===wt&&(wt=yi.c[2333].exports),wt.Kdd(n,e)},__wbg_touches_7397ce4df4dceded:function(n){return void 0===bt&&(bt=yi.c[2333].exports),bt.b$n(n)},__wbg_changedTouches_363278e8a9a95419:function(n){return void 0===It&&(It=yi.c[2333].exports),It.nrY(n)},__wbindgen_is_undefined:function(n){return void 0===Pt&&(Pt=yi.c[2333].exports),Pt.XP4(n)},__wbg_newnoargs_f579424187aa1717:function(n,e){return void 0===zt&&(zt=yi.c[2333].exports),zt.bfV(n,e)},__wbg_get_f45dff51f52d7222:function(n,e){return void 0===Tt&&(Tt=yi.c[2333].exports),Tt.cUx(n,e)},__wbg_isArray_8480ed76e5369634:function(n){return void 0===St&&(St=yi.c[2333].exports),St.YPQ(n)},__wbg_length_7b60f47bde714631:function(n){return void 0===Ct&&(Ct=yi.c[2333].exports),Ct.W4u(n)},__wbg_call_89558c3e96703ca1:function(n,e){return void 0===At&&(At=yi.c[2333].exports),At.Z4J(n,e)},__wbg_resolve_4f8f547f26b30b27:function(n){return void 0===kt&&(kt=yi.c[2333].exports),kt.YpQ(n)},__wbg_then_a6860c82b90816ca:function(n,e){return void 0===Dt&&(Dt=yi.c[2333].exports),Dt.wW8(n,e)},__wbg_then_58a04e42527f52c6:function(n,e,t){return void 0===qt&&(qt=yi.c[2333].exports),qt.YIx(n,e,t)},__wbg_self_e23d74ae45fb17d1:function(){return void 0===Rt&&(Rt=yi.c[2333].exports),Rt.tL0()},__wbg_window_b4be7f48b24ac56e:function(){return void 0===Ot&&(Ot=yi.c[2333].exports),Ot.QuW()},__wbg_globalThis_d61b1f48a57191ae:function(){return void 0===Mt&&(Mt=yi.c[2333].exports),Mt.EBX()},__wbg_global_e7669da72fd7f239:function(){return void 0===Lt&&(Lt=yi.c[2333].exports),Lt.Ycj()},__wbg_buffer_5e74a88a1424a2e0:function(n){return void 0===Et&&(Et=yi.c[2333].exports),Et.rfx(n)},__wbg_newwithbyteoffsetandlength_278ec7532799393a:function(n,e,t){return void 0===Nt&&(Nt=yi.c[2333].exports),Nt.S7W(n,e,t)},__wbg_new_e3b800e570795b3c:function(n){return void 0===Ft&&(Ft=yi.c[2333].exports),Ft.TsK(n)},__wbg_newwithbyteoffsetandlength_bdb885cfc5e9bc43:function(n,e,t){return void 0===jt&&(jt=yi.c[2333].exports),jt.UX(n,e,t)},__wbg_newwithbyteoffsetandlength_ad2916c6fa7d4c6f:function(n,e,t){return void 0===Ht&&(Ht=yi.c[2333].exports),Ht.HKx(n,e,t)},__wbg_new_f5438c0cea22a3aa:function(n){return void 0===Ut&&(Ut=yi.c[2333].exports),Ut.drm(n)},__wbg_newwithlength_5f4ce114a24dfe1e:function(n){return void 0===Vt&&(Vt=yi.c[2333].exports),Vt._G0(n)},__wbg_length_30803400a8f15c59:function(n){return void 0===Bt&&(Bt=yi.c[2333].exports),Bt.Zu(n)},__wbg_set_5b8081e9d002f0df:function(n,e,t){return void 0===Gt&&(Gt=yi.c[2333].exports),Gt.Mzi(n,e,t)},__wbg_newwithlength_747b31c525d823ec:function(n){return void 0===Xt&&(Xt=yi.c[2333].exports),Xt.Zqg(n)},__wbg_subarray_e729e242fb317565:function(n,e,t){return void 0===Jt&&(Jt=yi.c[2333].exports),Jt.$hL(n,e,t)},__wbg_length_44449d3b5928d07c:function(n){return void 0===$t&&($t=yi.c[2333].exports),$t.xSW(n)},__wbg_set_7cb6639737aebb39:function(n,e,t){return void 0===Yt&&(Yt=yi.c[2333].exports),Yt.x3e(n,e,t)},__wbg_parse_e3e7e590474b89d2:function(n,e){return void 0===Zt&&(Zt=yi.c[2333].exports),Zt.Zp3(n,e)},__wbg_new_59cb74e423758ede:function(){return void 0===Wt&&(Wt=yi.c[2333].exports),Wt.h9()},__wbg_stack_558ba5917b466edd:function(n,e){return void 0===Kt&&(Kt=yi.c[2333].exports),Kt.Dze(n,e)},__wbg_error_4bb6c2a97407129a:function(n,e){return void 0===Qt&&(Qt=yi.c[2333].exports),Qt.kFF(n,e)},__wbindgen_debug_string:function(n,e){return void 0===ni&&(ni=yi.c[2333].exports),ni.fYP(n,e)},__wbindgen_throw:function(n,e){return void 0===ei&&(ei=yi.c[2333].exports),ei.Or8(n,e)},__wbindgen_memory:function(){return void 0===ti&&(ti=yi.c[2333].exports),ti.oHO()},__wbindgen_closure_wrapper1802:function(n,e,t){return void 0===ii&&(ii=yi.c[2333].exports),ii.NmI(n,e,t)},__wbindgen_closure_wrapper1804:function(n,e,t){return void 0===ai&&(ai=yi.c[2333].exports),ai.gTC(n,e,t)},__wbindgen_closure_wrapper3248:function(n,e,t){return void 0===oi&&(oi=yi.c[2333].exports),oi.NQs(n,e,t)},__wbindgen_closure_wrapper3250:function(n,e,t){return void 0===ri&&(ri=yi.c[2333].exports),ri.Pj7(n,e,t)},__wbindgen_closure_wrapper3252:function(n,e,t){return void 0===li&&(li=yi.c[2333].exports),li.Zxd(n,e,t)},__wbindgen_closure_wrapper3254:function(n,e,t){return void 0===si&&(si=yi.c[2333].exports),si.xc6(n,e,t)},__wbindgen_closure_wrapper3256:function(n,e,t){return void 0===ci&&(ci=yi.c[2333].exports),ci._oe(n,e,t)},__wbindgen_closure_wrapper3258:function(n,e,t){return void 0===fi&&(fi=yi.c[2333].exports),fi.Of5(n,e,t)},__wbindgen_closure_wrapper3260:function(n,e,t){return void 0===ui&&(ui=yi.c[2333].exports),ui.c3L(n,e,t)},__wbindgen_closure_wrapper3262:function(n,e,t){return void 0===pi&&(pi=yi.c[2333].exports),pi.quA(n,e,t)},__wbindgen_closure_wrapper3264:function(n,e,t){return void 0===_i&&(_i=yi.c[2333].exports),_i.SlT(n,e,t)},__wbindgen_closure_wrapper3434:function(n,e,t){return void 0===hi&&(hi=yi.c[2333].exports),hi.ehv(n,e,t)}}}}},mi={846:[182],995:[6516]},yi.w={},yi.f.wasm=function(n,e){(mi[n]||[]).forEach((function(t,i){var a=di[t];if(a)e.push(a);else{var o,r=vi[t](),l=fetch(yi.p+""+{846:{182:"f6ed028ddccac64cf3bf"},995:{6516:"e46a20eb9bcc54f52125"}}[n][t]+".module.wasm");o=r&&"function"==typeof r.then&&"function"==typeof WebAssembly.compileStreaming?Promise.all([WebAssembly.compileStreaming(l),r]).then((function(n){return WebAssembly.instantiate(n[0],n[1])})):"function"==typeof WebAssembly.instantiateStreaming?WebAssembly.instantiateStreaming(l,r):l.then((function(n){return n.arrayBuffer()})).then((function(n){return WebAssembly.instantiate(n,r)})),e.push(di[t]=o.then((function(n){return yi.w[t]=(n.instance||n).exports})))}}))},yi(6630)})();
//# sourceMappingURL=aladin.js.map