!function(n){function e(e){for(var t,i,a=e[0],o=e[1],s=0,l=[];s<a.length;s++)i=a[s],Object.prototype.hasOwnProperty.call(r,i)&&r[i]&&l.push(r[i][0]),r[i]=0;for(t in o)Object.prototype.hasOwnProperty.call(o,t)&&(n[t]=o[t]);for(f&&f(e);l.length;)l.shift()()}var t={},r={1:0};var i={};var a={50:function(){return{"./index_bg.js":{__wbindgen_json_serialize:function(n,e){return t[45].exports.Kc(n,e)},__wbindgen_object_drop_ref:function(n){return t[45].exports.Oc(n)},__wbg_deleteVertexArray_3f37aabaae61ca26:function(n,e){return t[45].exports.E(n,e)},__wbg_disableVertexAttribArray_1401ee870505cf02:function(n,e){return t[45].exports.F(n,e)},__wbg_deleteBuffer_988823f4e76e697d:function(n,e){return t[45].exports.C(n,e)},__wbindgen_object_clone_ref:function(n){return t[45].exports.Nc(n)},__wbg_instanceof_Window_fa4595281eb5ba83:function(n){return t[45].exports.jb(n)},__wbg_performance_800ff37c906b5f3b:function(n){return t[45].exports.Ib(n)},__wbg_now_9f22124bc74da886:function(n){return t[45].exports.Fb(n)},__wbg_setsrc_8742008d92b4e70e:function(n,e,r){return t[45].exports.cc(n,e,r)},__wbg_setonload_69f9426b613d7bd2:function(n,e){return t[45].exports.Zb(n,e)},__wbg_setonerror_e519d2d2cbd89b1d:function(n,e){return t[45].exports.Yb(n,e)},__wbg_open_c1608202d44b7d1c:function(n,e,r,i,a,o){return t[45].exports.Gb(n,e,r,i,a,o)},__wbg_setonload_c71ccab98777e104:function(n,e){return t[45].exports.ac(n,e)},__wbg_setonerror_1bea8ceda68d0d63:function(n,e){return t[45].exports.Xb(n,e)},__wbg_send_3e459af287bba919:function(n){return t[45].exports.Qb(n)},__wbg_activeTexture_32edab6336bd38a9:function(n,e){return t[45].exports.e(n,e)},__wbg_bindTexture_d659843380f373b5:function(n,e,r){return t[45].exports.i(n,e,r)},__wbg_texSubImage2D_43d09711529aa698:function(n,e,r,i,a,o,s,l){return t[45].exports.lc(n,e,r,i,a,o,s,l)},__wbg_canvas_dd578e51a2bc736f:function(n){return t[45].exports.q(n)},__wbg_instanceof_HtmlCanvasElement_c9f334afe4eed430:function(n){return t[45].exports.hb(n)},__wbg_setwidth_41b2497107faaff7:function(n,e){return t[45].exports.ec(n,e)},__wbg_setheight_e15cb9243262e701:function(n,e){return t[45].exports.Wb(n,e)},__wbg_viewport_86b156d5858adab9:function(n,e,r,i,a){return t[45].exports.zc(n,e,r,i,a)},__wbg_scissor_1f78ef0050a93516:function(n,e,r,i,a){return t[45].exports.Ob(n,e,r,i,a)},__wbindgen_cb_drop:function(n){return t[45].exports.Ec(n)},__wbg_deleteTexture_cf22af6782ebc54f:function(n,e){return t[45].exports.D(n,e)},__wbg_document_d8cce4c1031c64eb:function(n){return t[45].exports.H(n)},__wbg_getElementsByClassName_a5ef560ae6918226:function(n,e,r){return t[45].exports.T(n,e,r)},__wbg_getwithindex_bcf1a04b716019a9:function(n,e){return t[45].exports.ab(n,e)},__wbg_parse_b89e797098b3bc7b:function(n,e){return t[45].exports.Hb(n,e)},__wbg_getContext_a5ae0a2c4fe6f42b:function(n,e,r,i){return t[45].exports.R(n,e,r,i)},__wbg_instanceof_WebGl2RenderingContext_acac10ed74c696cb:function(n){return t[45].exports.ib(n)},__wbindgen_string_new:function(n,e){return t[45].exports.Qc(n,e)},__wbg_clearRect_620b55f817af6080:function(n,e,r,i,a){return t[45].exports.s(n,e,r,i,a)},__wbindgen_json_parse:function(n,e){return t[45].exports.Jc(n,e)},__wbg_cullFace_b0941c23a53ee9fc:function(n,e){return t[45].exports.B(n,e)},__wbg_bindVertexArray_520c05423d3d6641:function(n,e){return t[45].exports.j(n,e)},__wbg_blendFuncSeparate_13c318610edadb4a:function(n,e,r,i,a){return t[45].exports.k(n,e,r,i,a)},__wbg_blendFunc_8bd5998b54c12fd3:function(n,e,r){return t[45].exports.l(n,e,r)},__wbg_disable_827be6d0f77447e1:function(n,e){return t[45].exports.G(n,e)},__wbg_enable_65590f4951fd0112:function(n,e){return t[45].exports.M(n,e)},__wbg_useProgram_b1cc885b00b8f52c:function(n,e){return t[45].exports.wc(n,e)},__wbg_uniform4f_9941fe9c32da60ea:function(n,e,r,i,a,o){return t[45].exports.uc(n,e,r,i,a,o)},__wbg_uniform1i_a1e8f5ad954fa6b5:function(n,e,r){return t[45].exports.qc(n,e,r)},__wbg_uniform1f_fa50abe89ff891ea:function(n,e,r){return t[45].exports.oc(n,e,r)},__wbg_drawElements_c109bfea7998fd99:function(n,e,r,i,a){return t[45].exports.K(n,e,r,i,a)},__wbg_bindBuffer_4a7874f09df12419:function(n,e,r){return t[45].exports.g(n,e,r)},__wbindgen_memory:function(){return t[45].exports.Lc()},__wbg_buffer_e35e010c3ba9f945:function(n){return t[45].exports.o(n)},__wbg_newwithbyteoffsetandlength_7b9a415096aef9c1:function(n,e,r){return t[45].exports.Bb(n,e,r)},__wbg_bufferSubData_51f29e78449b2095:function(n,e,r,i){return t[45].exports.n(n,e,r,i)},__wbg_bufferData_80963d2bd1ecb1bc:function(n,e,r,i){return t[45].exports.m(n,e,r,i)},__wbg_newwithbyteoffsetandlength_a20c8edf0fedac40:function(n,e,r){return t[45].exports.Db(n,e,r)},__wbg_createVertexArray_5cbff3d8bbe1c324:function(n){return t[45].exports.A(n)},__wbg_createBuffer_4302ddbcbfc99048:function(n){return t[45].exports.v(n)},__wbg_vertexAttribPointer_3bb013e284cd07bf:function(n,e,r,i,a,o,s){return t[45].exports.yc(n,e,r,i,a,o,s)},__wbg_enableVertexAttribArray_413ef49912a23f9e:function(n,e){return t[45].exports.L(n,e)},__wbg_createTexture_8ba2e566eb313fcf:function(n){return t[45].exports.z(n)},__wbg_texParameteri_c0b2b665319f6a16:function(n,e,r,i){return t[45].exports.kc(n,e,r,i)},__wbg_texImage2D_a5dad82b8f689bbd:function(n,e,r,i,a,o,s,l,c,f,u){return t[45].exports.ic(n,e,r,i,a,o,s,l,c,f,u)},__wbg_log_a39f164b49616cb0:function(n,e){return t[45].exports.pb(n,e)},__wbg_width_d9e3643c351ff015:function(n){return t[45].exports.Bc(n)},__wbg_height_b92a879a29e66010:function(n){return t[45].exports.db(n)},__wbg_response_c70a68323728a385:function(n){return t[45].exports.Jb(n)},__wbg_new_139e70222494b1ff:function(n){return t[45].exports.sb(n)},__wbg_length_2cfa674c2a529bc1:function(n){return t[45].exports.lb(n)},__wbg_set_d771848e3c7935bb:function(n,e,r){return t[45].exports.Sb(n,e,r)},__wbg_newwithbyteoffsetandlength_836859e5deb44d3f:function(n,e,r){return t[45].exports.Cb(n,e,r)},__wbg_newwithbyteoffsetandlength_c274c3296a37fcb4:function(n,e,r){return t[45].exports.Eb(n,e,r)},__wbg_new_5b74a8dd0c5b71ac:function(n){return t[45].exports.wb(n)},__wbg_newwithbyteoffsetandlength_0c7ac30665ee26f8:function(n,e,r){return t[45].exports.Ab(n,e,r)},__wbg_new_c77df81d6c892c35:function(n){return t[45].exports.xb(n)},__wbg_new_fe24eae01e10f223:function(n){return t[45].exports.yb(n)},__wbg_clearColor_fc22409197a5bd68:function(n,e,r,i,a){return t[45].exports.r(n,e,r,i,a)},__wbg_clear_25e035ed3961f1c6:function(n,e){return t[45].exports.t(n,e)},__wbg_bindFramebuffer_abbc9985c473f160:function(n,e,r){return t[45].exports.h(n,e,r)},__wbg_uniform2f_ab7c909be2949448:function(n,e,r,i){return t[45].exports.sc(n,e,r,i)},__wbg_drawElementsInstanced_6a606cd25bdbafb3:function(n,e,r,i,a,o){return t[45].exports.J(n,e,r,i,a,o)},__wbg_drawArrays_f6e7af9c06f4f4ae:function(n,e,r,i){return t[45].exports.I(n,e,r,i)},__wbg_setfont_7d7b206c4c017729:function(n,e,r){return t[45].exports.Vb(n,e,r)},__wbg_settextAlign_0ab90671be8e1137:function(n,e,r){return t[45].exports.dc(n,e,r)},__wbg_setfillStyle_1b068f8d99084158:function(n,e){return t[45].exports.Ub(n,e)},__wbg_save_be2f4340f20bfe6f:function(n){return t[45].exports.Mb(n)},__wbg_translate_a603cdd310297ee8:function(n,e,r){return t[45].exports.nc(n,e,r)},__wbg_rotate_4ae42333a58388ed:function(n,e){return t[45].exports.Lb(n,e)},__wbg_fillText_aee0d6016521a3b2:function(n,e,r,i,a){return t[45].exports.O(n,e,r,i,a)},__wbg_restore_e6861230b7a8a25e:function(n){return t[45].exports.Kb(n)},__wbg_subarray_3c6f7cfb4edcc351:function(n,e,r){return t[45].exports.hc(n,e,r)},__wbg_texImage2D_bc294af8c1a6a435:function(n,e,r,i,a,o,s){return t[45].exports.jc(n,e,r,i,a,o,s)},__wbg_measureText_2a4b2ca71061d96c:function(n,e,r){return t[45].exports.qb(n,e,r)},__wbg_width_979b596f39ba8319:function(n){return t[45].exports.Ac(n)},__wbg_isArray_3320300beb1837ab:function(n){return t[45].exports.kb(n)},__wbg_length_8f15bbb4ecbf7e33:function(n){return t[45].exports.mb(n)},__wbg_get_40375c2067f479fc:function(n,e){return t[45].exports.Z(n,e)},__wbg_texSubImage2D_e13399a16dfb0646:function(n,e,r,i,a,o,s,l,c,f){return t[45].exports.mc(n,e,r,i,a,o,s,l,c,f)},__wbg_vertexAttribDivisor_bf07aa5a1a9fc2d1:function(n,e,r){return t[45].exports.xc(n,e,r)},__wbg_uniformMatrix4fv_82825540b9315680:function(n,e,r,i,a){return t[45].exports.vc(n,e,r,i,a)},__wbg_uniform1fv_7b33ccba8ca090e4:function(n,e,r,i){return t[45].exports.pc(n,e,r,i)},__wbg_uniform1iv_2c8af1d8286865f0:function(n,e,r,i){return t[45].exports.rc(n,e,r,i)},__wbg_uniform3f_a7c04d3d1c2b18aa:function(n,e,r,i,a){return t[45].exports.tc(n,e,r,i,a)},__wbg_createProgram_128698dd90ec070d:function(n){return t[45].exports.x(n)},__wbg_attachShader_5d53b7b00823cafb:function(n,e,r){return t[45].exports.f(n,e,r)},__wbg_linkProgram_370ed11b34456c89:function(n,e){return t[45].exports.ob(n,e)},__wbg_getProgramParameter_b949ba1d9662f6a2:function(n,e,r){return t[45].exports.V(n,e,r)},__wbindgen_boolean_get:function(n){return t[45].exports.Dc(n)},__wbg_getProgramInfoLog_f8f65be65281f691:function(n,e,r){return t[45].exports.U(n,e,r)},__wbindgen_number_get:function(n,e){return t[45].exports.Mc(n,e)},__wbg_getActiveUniform_70b770a58f551f8f:function(n,e,r){return t[45].exports.Q(n,e,r)},__wbg_name_4f3b7294acbeabad:function(n,e){return t[45].exports.rb(n,e)},__wbg_getUniformLocation_472b7459010900a5:function(n,e,r,i){return t[45].exports.Y(n,e,r,i)},__wbg_createShader_26e4f959d5d64d80:function(n,e){return t[45].exports.y(n,e)},__wbg_shaderSource_96ace5133c032f2f:function(n,e,r,i){return t[45].exports.fc(n,e,r,i)},__wbg_compileShader_f7e245515fa1405d:function(n,e){return t[45].exports.u(n,e)},__wbg_getShaderParameter_cced0ff8ba83f3e7:function(n,e,r){return t[45].exports.X(n,e,r)},__wbg_getShaderInfoLog_5412e8bc642139e8:function(n,e,r){return t[45].exports.W(n,e,r)},__wbg_innerWidth_aab6ec3242dff39e:function(n){return t[45].exports.fb(n)},__wbg_innerHeight_7e514d9823f7864e:function(n){return t[45].exports.eb(n)},__wbg_new_17bf587bb9ce55f1:function(){return t[45].exports.tb()},__wbg_setcrossOrigin_054bb95c5a2b2640:function(n,e,r){return t[45].exports.Tb(n,e,r)},__wbg_new_4f8fb2c75215d83a:function(){return t[45].exports.ub()},__wbg_setresponseType_09ae5e5481a8947d:function(n,e){return t[45].exports.bc(n,e)},__wbg_createFramebuffer_edeb035499d73077:function(n){return t[45].exports.w(n)},__wbg_framebufferTexture2D_bb45b3c3d234ddcd:function(n,e,r,i,a,o){return t[45].exports.P(n,e,r,i,a,o)},__wbg_lineWidth_a2c6059f833032d4:function(n,e){return t[45].exports.nb(n,e)},__wbg_setAttribute_fb8737b4573a65f8:function(n,e,r,i,a){return t[45].exports.Rb(n,e,r,i,a)},__wbg_getContext_d277f710e8035242:function(n,e,r){return t[45].exports.S(n,e,r)},__wbg_instanceof_CanvasRenderingContext2d_fbca10ed951560f3:function(n){return t[45].exports.gb(n)},__wbg_scale_e0fdce059098cd1b:function(n,e,r){return t[45].exports.Nb(n,e,r)},__wbg_new_59cb74e423758ede:function(){return t[45].exports.vb()},__wbg_stack_558ba5917b466edd:function(n,e){return t[45].exports.gc(n,e)},__wbg_error_4bb6c2a97407129a:function(n,e){return t[45].exports.N(n,e)},__wbg_self_eeabd9085c04fc17:function(){return t[45].exports.Pb()},__wbg_window_f110c13310da2c8f:function(){return t[45].exports.Cc()},__wbg_globalThis_a2669bee93faee43:function(){return t[45].exports.bb()},__wbg_global_a5584d717f4d6761:function(){return t[45].exports.cb()},__wbindgen_is_undefined:function(n){return t[45].exports.Ic(n)},__wbg_newnoargs_179d393e4626fcf7:function(n,e){return t[45].exports.zb(n,e)},__wbg_call_8487a9f580e47219:function(n,e){return t[45].exports.p(n,e)},__wbindgen_debug_string:function(n,e){return t[45].exports.Hc(n,e)},__wbindgen_throw:function(n,e){return t[45].exports.Rc(n,e)},__wbindgen_rethrow:function(n){return t[45].exports.Pc(n)},__wbindgen_closure_wrapper325:function(n,e,r){return t[45].exports.Fc(n,e,r)},__wbindgen_closure_wrapper555:function(n,e,r){return t[45].exports.Gc(n,e,r)}}}},49:function(){return{"./healpix_bg.js":{__wbindgen_throw:function(n,e){return t[46].exports.e(n,e)}}}}};function o(e){if(t[e])return t[e].exports;var r=t[e]={i:e,l:!1,exports:{}};return n[e].call(r.exports,r,r.exports,o),r.l=!0,r.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var s=new Promise((function(e,i){t=r[n]=[e,i]}));e.push(t[2]=s);var l,c=document.createElement("script");c.charset="utf-8",c.timeout=120,o.nc&&c.setAttribute("nonce",o.nc),c.src=function(n){return o.p+""+n+".aladin.js"}(n);var f=new Error;l=function(e){c.onerror=c.onload=null,clearTimeout(u);var t=r[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;f.message="Loading chunk "+n+" failed.\n("+i+": "+a+")",f.name="ChunkLoadError",f.type=i,f.request=a,t[1](f)}r[n]=void 0}};var u=setTimeout((function(){l({type:"timeout",target:c})}),12e4);c.onerror=c.onload=l,document.head.appendChild(c)}return({2:[50],3:[49]}[n]||[]).forEach((function(n){var t=i[n];if(t)e.push(t);else{var r,s=a[n](),l=fetch(o.p+""+{49:"4ad26a0146f15e957dda",50:"38faf0c5a3061353eedd"}[n]+".module.wasm");if(s instanceof Promise&&"function"==typeof WebAssembly.compileStreaming)r=Promise.all([WebAssembly.compileStreaming(l),s]).then((function(n){return WebAssembly.instantiate(n[0],n[1])}));else if("function"==typeof WebAssembly.instantiateStreaming)r=WebAssembly.instantiateStreaming(l,s);else{r=l.then((function(n){return n.arrayBuffer()})).then((function(n){return WebAssembly.instantiate(n,s)}))}e.push(i[n]=r.then((function(e){return o.w[n]=(e.instance||e).exports})))}})),Promise.all(e)},o.m=n,o.c=t,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="",o.oe=function(n){throw console.error(n),n},o.w={};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var f=l;o(o.s=44)}([function(n,e){SimbadPointer=(SimbadPointer={},SimbadPointer.MIRRORS=["https://alasky.u-strasbg.fr/cgi/simbad-flat/simbad-quick.py","https://alaskybis.u-strasbg.fr/cgi/simbad-flat/simbad-quick.py"],SimbadPointer.query=function(n,e,t,r){var i={Ident:new Coo(n,e,7).format("s/"),SR:t};Utils.loadFromMirrors(SimbadPointer.MIRRORS,{data:i,onSuccess:function(n){r.view.setCursor("pointer");var e=/(.*?)\/(.*?)\((.*?),(.*?)\)/g.exec(n);if(e){var t=new Coo;t.parse(e[1]);var i=e[2],a='<div class="aladin-sp-title"><a target="_blank" href="http://simbad.u-strasbg.fr/simbad/sim-id?Ident='+encodeURIComponent(i)+'">'+i+"</a></div>",o='<div class="aladin-sp-content">';o+="<em>Type: </em>"+e[4]+"<br>";var s=e[3];Utils.isNumber(s)&&(o+="<em>Mag: </em>"+s+"<br>"),o+='<br><a target="_blank" href="http://cdsportal.u-strasbg.fr/?target='+encodeURIComponent(i)+'">Query in CDS portal</a>',o+="</div>",r.showPopup(t.lon,t.lat,a,o)}else r.hidePopup()},onFailure:function(){r.view.setCursor("pointer"),r.hidePopup()},timeout:5})},SimbadPointer)},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 model;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_aitoff(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_mercator(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_arc(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_gnomonic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_mollweide(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\n\nuniform float current_time;\nuniform mat4 inv_model;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\nuniform vec2 kernel_size;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    vec3 p = vec3(inv_model * vec4(center, 1.0f));\n    p = check_inversed_longitude(p);\n\n    vec2 center_pos_clip_space = world2clip_orthographic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * czf)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nin vec3 out_p;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\nuniform float fov;\nuniform float strength;\nvoid main() {\n    if (out_p.z < 0.f) {\n        discard;\n    }\n\n    color = texture(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\n    color.r *= strength;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nin vec3 out_p;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\nuniform float fov;\nuniform float strength;\nvoid main() {\n    color = texture(kernel_texture, out_uv) / max(log2(fov*100.0), 1.0);\n    color.r *= strength;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nvec4 colormap_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2D;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    color = colormap_f(opacity);\n    color.a = o * alpha;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\nuniform float strength;\n\nfloat colormap_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat colormap_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat colormap_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat colormap_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 colormap_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(colormap_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(t) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float czf;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * czf);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 to_icrs;\nuniform mat4 inv_model;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_aitoff(vec2 pos_clip_space) {\n    if(!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    vec2 uv = vec2(pos_clip_space.x * PI * 0.5, pos_clip_space.y * PI);\n    //da uv a lat/lon\n    float c = length(uv);\n\n    float phi = asin(uv.y * sin(c) / c);\n    float theta = atan(uv.x * sin(c), c * cos(c)) * 2.0;\n\n    vec3 world = vec3(\n        sin(theta) * cos(phi),\n        sin(phi),\n        cos(theta) * cos(phi)\n    );\n    return world;\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 posmodel = pos_model;\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(posmodel, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, posmodel));\n\n    vec3 h_model = normalize(posmodel - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_aitoff(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    vec3 posmodel = pos_model;\n    float y = atan(posmodel.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_aitoff(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_mollweide(vec2 pos_clip_space) {\n    if (!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    float y2 = pos_clip_space.y * pos_clip_space.y;\n    float k = sqrt(1.0 - 4.0 * y2);\n\n    float theta = PI * pos_clip_space.x / k;\n    float delta = asin((2.0 * asin(2.0 * pos_clip_space.y) + 4.0 * pos_clip_space.y * k) / PI);\n    \n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mollweide(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_mollweide(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvec3 clip2world_orthographic(vec2 pos_clip_space) {\n    float z = 1.f - dot(pos_clip_space, pos_clip_space);\n    if (z > 0.f) {\n        return vec3(pos_clip_space.x, pos_clip_space.y, sqrt(z));\n    } else {\n        discard;\n    }\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_orthographic(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d*2.0;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_orthographic(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvec3 clip2world_mercator(vec2 p) {\n    float theta = p.x * PI;\n    float delta = atan(sinh(p.y)) * PI;\n\n    return vec3(sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mercator(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_mercator(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nfloat sinc_positive(float x) {\n    if (x > 1.0e-4) {\n        return sin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        x = x*x;\n        return 1.0 - x * (1.0 - x / 20.0) / 6.0;\n    }\n}\n\nvec3 clip2world_arc(vec2 pos_clip_space) {\n    // r <= pi\n    float x = pos_clip_space.x * PI;\n    float y = pos_clip_space.y * PI;\n    float r = length(vec2(x, y));\n    if (r <= PI) {\n        float z = cos(r);\n        r = sinc_positive(r);\n\n        return vec3(x * r, y * r, z);\n    }\n    discard;\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    h_world = check_inversed_longitude(h_world);\n    vec2 h_clip = world2clip_arc(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_arc(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f));\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\n\nout vec4 c;\nin vec2 pos_clip;\n\nuniform vec4 color;\nuniform mat4 model;\nuniform mat4 inv_model;\nuniform mat4 to_icrs;\nuniform float czf;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_gnomonic(vec2 pos_clip_space) {\n    float x_2d = pos_clip_space.x * PI;\n    float y_2d = pos_clip_space.y * PI;\n    float r = x_2d * x_2d + y_2d * y_2d;\n\n    float z = sqrt(1.0 + r);\n    return vec3(z * x_2d, z * y_2d, z);\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(inv_model * to_icrs * vec4(h_model, 1.f));\n    h_world = check_inversed_longitude(h_world);\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_gnomonic(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 p) {\n    float v = 1e10;\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float m = 0.0;\n    float mdist = 10.0;\n    for (int i = 0; i < num_meridians; i++) {\n        float tmp = meridians[i];\n        if (tmp > PI) {\n            tmp -= 2.0 * PI;\n        }\n        float d = abs(theta - tmp);\n        if (d < mdist) {\n            mdist = d;\n            m = tmp;\n        }\n    }\n\n    float par = 0.0;\n    float pdist = 10.0;\n    for (int i = 0; i < num_parallels; i++) {\n        float d = abs(delta - parallels[i]);\n        if (d < pdist) {\n            pdist = d;\n            par = parallels[i];\n        }\n    }\n\n    /*float a = 0.0;\n    if (mdist < pdist) {\n        a = d_isolon(p, m);\n    } else {\n        a = d_isolat(p, par);\n    }\n    v = min(a, v);*/\n    v = min(d_isolon(p, m), v);\n    v = min(d_isolat(p, par), v);\n\n    float eps = 3.0 * czf / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_gnomonic(pos_clip);\n    pos_world = check_inversed_longitude(pos_world);\n\n    vec3 pos_model = normalize(vec3(transpose(to_icrs) * model * vec4(pos_world, 1.f)));\n    float alpha = grid_alpha(pos_model);\n    c = mix(color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 ndc_pos;\n\nvoid main() {\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nout vec4 frag_color;\n\nuniform vec4 color;\nuniform float opacity;\n\nconst float PI = 3.141592653589793f;\n\nvoid main() {\n    frag_color = color;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout (location = 0) in vec2 pos_clip_space;\nlayout (location = 1) in vec2 lonlat;\nlayout (location = 2) in vec3 pos_world_space;\n\nout vec3 out_vert_pos;\nout vec2 out_lonlat;\n\nuniform mat4 model;\nuniform vec2 ndc_to_clip;\nuniform float czf;\n\nvoid main() {\n    gl_Position = vec4(pos_clip_space / (ndc_to_clip * czf), 0.0, 1.0);\n    //out_vert_pos = vec3(inverse(gal_to_icrs) * model * vec4(pos_world_space, 1.f));\n    out_vert_pos = vec3(model * vec4(pos_world_space, 1.f));\n    out_lonlat = vec2(atan(out_vert_pos.x, out_vert_pos.z), asin(out_vert_pos.y));\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\n\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    int empty;\n};\n\nuniform int current_depth;\nuniform Tile textures_tiles[12];\n\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex[0], uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex[1], uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex[2], uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nTileColor get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = get_color_from_texture(UV);\n    color.a = mix(color.a, blank_color.a, float(tile.empty));\n    \n    return TileColor(tile, color, true);\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nvoid main() {\n    vec3 frag_pos = normalize(out_vert_pos);\n\n    // Get the HEALPix cell idx and the uv in the texture\n    TileColor current_tile = get_tile_color(frag_pos);\n    float pixel_transparency = current_tile.color.a;\n    out_frag_color = vec4(current_tile.color.rgb, opacity * pixel_transparency);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 pos_clip;\nin vec2 out_lonlat;\n\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    int empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex[0], uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex[1], uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex[2], uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nTileColor get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = mix(get_color_from_grayscale_texture(UV), blank_color, float(tile.empty));\n    return TileColor(tile, color, true);\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nvoid main() {\n    vec3 frag_pos = normalize(out_vert_pos);\n    // Get the HEALPix cell idx and the uv in the texture\n\n    TileColor current_tile = get_tile_color(frag_pos);\n    out_frag_color = current_tile.color;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 pos_clip;\n\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    int empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float opacity;\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex[0], uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex[1], uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex[2], uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nTileColor get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = mix(get_colormap_from_grayscale_texture(UV), blank_color, float(tile.empty));\n    return TileColor(tile, color, true);\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nvoid main() {\n    vec3 frag_pos = normalize(out_vert_pos);\n    // Get the HEALPix cell idx and the uv in the texture\n\n    TileColor current_tile = get_tile_color(frag_pos);\n    out_frag_color = current_tile.color;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 pos_clip;\nin vec2 out_lonlat;\n\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    int empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nfloat get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return float(texture(tex[0], uv.xy).r);\n    } else if (idx_texture == 1) {\n        return float(texture(tex[1], uv.xy).r);\n    } else if (idx_texture == 2) {\n        return float(texture(tex[2], uv.xy).r);\n    } else {\n        return 0.0;\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform float opacity;\n\nTileColor get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n    int idx = result.idx;\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = mix(get_color_from_grayscale_texture(UV), blank_color, float(tile.empty));\n    return TileColor(tile, color, true);\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nvoid main() {\n    vec3 frag_pos = normalize(out_vert_pos);\n    // Get the HEALPix cell idx and the uv in the texture\n\n    TileColor current_tile = get_tile_color(frag_pos);\n    out_frag_color = current_tile.color;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 pos_clip;\nin vec2 out_lonlat;\n\nout vec4 out_frag_color;\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n    int empty;\n};\n\nuniform int current_depth;\n\nuniform Tile textures_tiles[12];\n\nuniform float opacity;\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec4 color;\n    bool found;\n};\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nfloat get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return float(texture(tex[0], uv.xy).r);\n    } else if (idx_texture == 1) {\n        return float(texture(tex[1], uv.xy).r);\n    } else if (idx_texture == 2) {\n        return float(texture(tex[2], uv.xy).r);\n    } else {\n        return 0.0;\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\nconst float TWICE_PI = 6.28318530718f;\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nint quarter(vec2 p) {\n    int x_neg = int(p.x < 0.0f);\n    int y_neg = int(p.y < 0.0f);\n    int q = (x_neg + y_neg) | (y_neg << 1);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nint ij2z(int i, int j) {\n    int i1 = i | (j << 16);\n\n    int j1 = (i1 ^ (i1 >> 8)) & 0x0000FF00;\n    int i2 = i1 ^ j1 ^ (j1 << 8);\n\n    int j2 = (i2 ^ (i2 >> 4)) & 0x00F000F0;\n    int i3 = i2 ^ j2 ^ (j2 << 4);\n\n    int j3 = (i3 ^ (i3 >> 2)) & 0x0C0C0C0C;\n    int i4 = i3 ^ j3 ^ (j3 << 2);\n\n    int j4 = (i4 ^ (i4 >> 1)) & 0x22222222;\n    int i5 = i4 ^ j4 ^ (j4 << 1);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    int idx;\n    float dx;\n    float dy;\n};\n\nuniform sampler2D ang2pixd;\nHashDxDy hash_with_dxdy2(vec2 radec) {\n    vec2 aa = vec2(radec.x/TWICE_PI + 1.0, (radec.y/PI) + 0.5);\n    vec3 v = texture(ang2pixd, aa).rgb;\n    return HashDxDy(\n        int(v.x * 255.0),\n        v.y,\n        v.z\n    );\n}\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    int nside = 1 << depth;\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    int q = quarter(p.xy);\n\n    int d0h = 0;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        int q01 = int(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        int q12 = int(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        int q03 = 1 - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        int q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(q01 + q12 - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2) + ((q + q1) & 3);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    int i = int(x);\n    int j = int(y);\n\n    return HashDxDy(\n        (d0h << (depth << 1)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nTileColor get_tile_color(vec3 pos) {\n    HashDxDy result = hash_with_dxdy(0, pos.zxy);\n\n    int idx = result.idx;\n\n    vec2 uv = vec2(result.dy, result.dx);\n\n    Tile tile = textures_tiles[idx];\n\n    int idx_texture = tile.texture_idx >> 6;\n    int off = tile.texture_idx & 0x3F;\n    float idx_row = float(off >> 3); // in [0; 7]\n    float idx_col = float(off & 0x7); // in [0; 7]\n\n    vec2 offset = (vec2(idx_col, idx_row) + uv)*0.125;\n    vec3 UV = vec3(offset, float(idx_texture));\n\n    vec4 color = mix(get_colormap_from_grayscale_texture(UV), blank_color, float(tile.empty));\n    return TileColor(tile, color, true);\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nvoid main() {\n    vec3 frag_pos = normalize(out_vert_pos);\n    // Get the HEALPix cell idx and the uv in the texture\n\n    TileColor current_tile = get_tile_color(frag_pos);\n    out_frag_color = current_tile.color;\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    vec2 ndc_pos = world2clip_orthographic(world_pos) / (ndc_to_clip * czf);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_mercator(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_aitoff(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_gnomonic(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_arc(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision mediump int;\n\nlayout (location = 0) in vec2 lonlat;\n//layout (location = 1) in vec3 position;\nlayout (location = 1) in vec2 ndc_pos;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\nlayout (location = 5) in float m0;\nlayout (location = 6) in float m1;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout float m_start;\nout float m_end;\n\nuniform mat4 inv_model;\nuniform vec2 ndc_to_clip;\n//uniform float czf;\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nuniform int inversed_longitude;\n\nconst mat3 inverseLongitude = mat3(\n    -1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n);\n\nconst mat4 GAL2J2000 = mat4(\n    -0.4448296299195045,\n    0.7469822444763707,\n    0.4941094279435681,\n    0.0,\n\n    -0.1980763734646737,\n    0.4559837762325372,\n    -0.8676661489811610,\n    0.0,\n\n    -0.873437090247923,\n    -0.4838350155267381,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nconst mat4 J20002GAL = mat4(\n    -0.4448296299195045,\n    -0.1980763734646737,\n    -0.873437090247923,\n    0.0,\n\n    0.7469822444763707,\n    0.4559837762325372,\n    -0.4838350155267381,\n    0.0,\n\n    0.4941094279435681,\n    -0.8676661489811610,\n    -0.0548755604024359,\n    0.0,\n\n    0.0,\n    0.0,\n    0.0,\n    1.0\n);\n\nvec3 check_inversed_longitude(vec3 p) {\n    if (inversed_longitude == 1) {\n        return inverseLongitude * p;\n    } else {\n        return p;\n    }\n}\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(p.x, p.y);\n}\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = 2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-6 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = (theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nfloat arc_sinc(float x) {\n    if (x > 1e-4) {\n        return asin(x) / x;\n    } else {\n        // If a is mall, use Taylor expension of asin(a) / a\n        // a = 1e-4 => a^4 = 1.e-16\n        float x2 = x*x;\n        return 1.0 + x2 * (1.0 + x2 * 9.0 / 20.0) / 6.0;\n    }\n}\n\nvec2 world2clip_arc(vec3 p) {\n    if (p.z > -1.0) {\n        // Distance in the Euclidean plane (xy)\n        // Angular distance is acos(x), but for small separation, asin(r)\n        // is more accurate.\n        float r = length(p.xy);\n        if (p.z > 0.0) { // Angular distance < PI/2, angular distance = asin(r)\n            r = arc_sinc(r);\n        } else { // Angular distance > PI/2, angular distance = acos(x)\n            r = acos(p.z) / r;\n        }\n        float x = p.x * r;\n        float y = p.y * r;\n\n        return vec2(x / PI, y / PI);\n    } else {\n        return vec2(1.0, 0.0);\n    }\n}\n\nvec2 world2clip_gnomonic(vec3 p) {\n    if (p.z <= 1e-2) { // Back hemisphere (x < 0) + diverges near x=0\n        return vec2(1.0, 0.0);\n    } else {\n        return vec2((p.x/p.z) / PI , (p.y/p.z) / PI);\n    }\n}\n\nvoid main() {\n    /*\n    vec3 world_pos = vec3(inv_model * vec4(position, 1.f));\n    world_pos = check_inversed_longitude(world_pos);\n\n    gl_Position = vec4(world2clip_mollweide(world_pos) / (ndc_to_clip * czf), 0.0, 1.0);\n    */\n    gl_Position = vec4(ndc_pos, 0.0, 1.0);\n\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n    m_start = m0;\n    m_end = m1;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\nuniform float opacity;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex[0], uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex[1], uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex[2], uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\n\nvoid main() {\n    vec4 color_start = get_color_from_texture(frag_uv_start);\n    vec4 color_end = get_color_from_texture(frag_uv_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = opacity * out_frag_color.a;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex[0], uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex[1], uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex[2], uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = get_color_from_grayscale_texture(uv);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}\n\n"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform sampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nvec4 get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return texture(tex[0], uv.xy);\n    } else if (idx_texture == 1) {\n        return texture(tex[1], uv.xy);\n    } else if (idx_texture == 2) {\n        return texture(tex[2], uv.xy);\n    } else {\n        return vec4(0.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nvec4 get_color_from_texture(vec3 UV) {\n    return get_pixels(UV);\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv).r;\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = get_colormap_from_grayscale_texture(uv);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nfloat get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return float(texture(tex[0], uv.xy).r);\n    } else if (idx_texture == 1) {\n        return float(texture(tex[1], uv.xy).r);\n    } else if (idx_texture == 2) {\n        return float(texture(tex[2], uv.xy).r);\n    } else {\n        return 0.0;\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = get_color_from_grayscale_texture(uv);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nprecision highp isampler2D;\nprecision mediump int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin float m_start;\nin float m_end;\n\nout vec4 out_frag_color;\n\n//const int MAX_NUM_TEX = 3;\nuniform isampler2D tex[3];\nuniform int num_tex;\n\nuniform float scale;\nuniform float offset;\nuniform float blank;\n\nuniform float min_value;\nuniform float max_value;\nuniform int H;\n\nuniform float size_tile_uv;\n\nuniform float tex_storing_integers;\nuniform int tex_storing_fits;\n\n// Blue & Pastel & Red\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 bluepastelred_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n// Red\nfloat c_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat c_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat c_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 red_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(c_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(c_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(c_blue(t) / 255.0, 0.0, 1.0);\n\n    return vec4(r, g, b, 1.0);\n}\n// Gray\nvec4 blackw_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n// IDLCBGnBu\nfloat cbgnbu_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat cbgnbu_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat cbgnbu_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 cbgnbu_f(float x) {\n    float r = clamp(cbgnbu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbgnbu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbgnbu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBYIGnBu\nfloat CBYIGnBu_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat CBYIGnBu_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat CBYIGnBu_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 CBYIGnBu_f(float x) {\n    float r = clamp(CBYIGnBu_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(CBYIGnBu_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(CBYIGnBu_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n// IDLCBBrBG\nfloat cbbrbg_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat cbbrbg_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat cbbrbg_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 cbbrbg_f(float x) {\n    float r = clamp(cbbrbg_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(cbbrbg_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(cbbrbg_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\nuniform int colormap;\n/*\nBlackWhiteLinear = 0,\nRedTemperature = 1,\nIDLCBGnBu = 2,\nIDLCBYIGnBu = 3,\nBluePastelRed = 4,\nIDLCBBrBG = 5,\n*/\nvec4 colormap_f(float x) {\n    // BlackWhiteLinear = 0,\n    if (colormap == 0) {\n        return blackw_f(x);\n    // RedTemperature = 1,\n    } else if (colormap == 1) {\n        return red_f(x);\n    // IDLCBGnBu = 2,\n    } else if (colormap == 2) {\n        return cbgnbu_f(x);\n    // IDLCBYIGnBu = 3,\n    } else if (colormap == 3) {\n        return CBYIGnBu_f(x);\n    // BluePastelRed = 4,\n    } else if (colormap == 4) {\n        return bluepastelred_f(x);\n    // IDLCBBrBG = 5,\n    } else {\n        return cbbrbg_f(x);\n    }\n}\nfloat linear_f(float x, float min_value, float max_value) {\n    return clamp((x - min_value)/(max_value - min_value), 0.0, 1.0);\n}\n\nfloat sqrt_f(float x, float min_value, float max_value) {\n    float a = linear_f(x, min_value, max_value);\n    return sqrt(a);\n}\n\nfloat log_f(float x, float min_value, float max_value) {\n    float y = linear_f(x, min_value, max_value);\n    float a = 1000.0;\n    return log(a*y + 1.0)/log(a);\n}\n\nfloat asinh_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return asinh(10.0*d)/3.0;\n}\n\nfloat pow2_f(float x, float min_value, float max_value) {\n    float d = linear_f(x, min_value, max_value);\n    return d*d;\n}\n\nfloat transfer_func(int H, float x, float min_value, float max_value) {\n    if (H == 0) {\n        return linear_f(x, min_value, max_value);\n    } else if (H == 1) {\n        return sqrt_f(x, min_value, max_value);\n    } else if (H == 2) {\n        return log_f(x, min_value, max_value);\n    } else if (H == 3) {\n        return asinh_f(x, min_value, max_value);\n    } else {\n        return pow2_f(x, min_value, max_value);\n    }\n}\n\nfloat get_pixels(vec3 uv) {\n    int idx_texture = int(uv.z);\n    if (idx_texture == 0) {\n        return float(texture(tex[0], uv.xy).r);\n    } else if (idx_texture == 1) {\n        return float(texture(tex[1], uv.xy).r);\n    } else if (idx_texture == 2) {\n        return float(texture(tex[2], uv.xy).r);\n    } else {\n        return 0.0;\n    }\n}\n\nvec3 reverse_uv(vec3 uv) {\n    uv.y = size_tile_uv + 2.0*size_tile_uv*floor(uv.y / size_tile_uv) - uv.y;\n\n    return uv;\n}\n\nuniform vec4 blank_color;\n\nvec4 get_colormap_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return colormap_f(h);\n    }\n}\n\nuniform vec3 C;\nuniform float K;\nvec4 get_color_from_grayscale_texture(vec3 UV) {\n    vec3 uv = UV;\n    // FITS data pixels are reversed along the y axis\n    if (tex_storing_fits == 1) {\n        uv = reverse_uv(uv);\n    }\n\n    float x = get_pixels(uv);\n    if (x == blank) {\n        return blank_color;\n    } else {\n        float alpha = x * scale + offset;\n        float h = transfer_func(H, alpha, min_value, max_value);\n\n        return vec4(C * K * h, 1.0);\n    }\n}\n\nuniform float opacity;\n\nvec4 get_color(vec3 uv, float empty) {\n    vec4 color = get_colormap_from_grayscale_texture(uv);\n    return color;\n}\n\nvoid main() {\n    vec4 color_start = get_color(frag_uv_start, m_start);\n    vec4 color_end = get_color(frag_uv_end, m_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n    out_frag_color.a = out_frag_color.a * opacity;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2DArray;\n\nlayout (location = 0) in vec2 pos;\nlayout (location = 1) in vec2 uv;\n// Per instance attributes\nlayout (location = 2) in vec2 center_letter;\nlayout (location = 3) in vec2 size_letter;\nlayout (location = 4) in vec2 pos_uv;\nlayout (location = 5) in vec2 size_uv;\nlayout (location = 6) in float idx_page;\n\nout vec3 out_uv;\n\nuniform vec2 window_size;\nuniform float scaling;\n\nvec2 screen_to_ndc(vec2 p) {\n    // Change of origin\n    vec2 origin = p - window_size/2.0;\n\n    // Scale to fit in [-1, 1]\n    return vec2(2.0 * (origin.x/window_size.x), -2.0 * (origin.y/window_size.y));\n}\n\nvoid main() {\n    vec2 ndc_pos = screen_to_ndc(center_letter + pos*32.0);\n\n    gl_Position = vec4(ndc_pos, 0.f, 1.f);\n    out_uv = vec3(uv, idx_page);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2DArray;\n\nuniform vec4 text_color;\nuniform sampler2DArray font_textures;\n\nin vec3 out_uv;\nout vec4 color;\n\nvoid main() {\n    vec3 uv = vec3(out_uv.x, 1.f - out_uv.y, out_uv.z);\n    vec4 mask = texture(font_textures, uv);\n    color = text_color * mask;\n    //color = vec4(1.0, 0.0, 0.0, 1.0);\n}"},function(n,e,t){"use strict";t.r(e),t.d(e,"Aladin",(function(){return De}));let r=function(){function n(n,e){this.domEl=$('<div class="aladin-popup-container"><div class="aladin-popup"><a class="aladin-closeBtn">&times;</a><div class="aladin-popupTitle"></div><div class="aladin-popupText"></div></div><div class="aladin-popup-arrow"></div></div>'),this.domEl.appendTo(n),this.view=e;var t=this;this.domEl.find(".aladin-closeBtn").click((function(){t.hide()}))}return n.prototype.hide=function(){this.domEl.hide(),this.view.mustClearCatalog=!0,this.view.catalogForPopup.hide()},n.prototype.show=function(){this.domEl.show()},n.prototype.setTitle=function(n){this.domEl.find(".aladin-popupTitle").html(n||"")},n.prototype.setText=function(n){this.domEl.find(".aladin-popupText").html(n||""),this.w=this.domEl.outerWidth(),this.h=this.domEl.outerHeight()},n.prototype.setSource=function(n){this.source&&(this.source.popup=null),n.popup=this,this.source=n,this.setPosition(n.x,n.y)},n.prototype.setPosition=function(n,e){var t=n-this.w/2,r=e-this.h;this.source&&(r+=this.source.catalog.sourceSize/2),this.domEl[0].style.left=t+"px",this.domEl[0].style.top=r+"px"},n}(),i=function(){function n(){}return n.prototype.redraw=function(n,e,t,r){var i,a;n.lineWidth=1,n.strokeStyle="rgb(150,150,220)",n.beginPath();for(var o=0,s=e.length;o<s;o++)a=(i=e[o]).ipix,n.moveTo(i[0].vx,i[0].vy),n.lineTo(i[1].vx,i[1].vy),n.lineTo(i[2].vx,i[2].vy);n.stroke(),n.strokeStyle="#FFDDDD",n.beginPath();for(o=0,s=e.length;o<s;o++)a=(i=e[o]).ipix,n.strokeText(r+"/"+a,(i[0].vx+i[2].vx)/2,(i[0].vy+i[2].vy)/2);n.stroke()},n}(),a={};a.cssScale=void 0,HTMLCanvasElement.prototype.relMouseCoords=function(n){if(n.offsetX)return{x:n.offsetX,y:n.offsetY};if(!a.cssScale){var e=window.getComputedStyle(document.body,null),t=(e.getPropertyValue("-webkit-transform")||e.getPropertyValue("-moz-transform")||e.getPropertyValue("-ms-transform")||e.getPropertyValue("-o-transform")||e.getPropertyValue("transform")).match(/matrix\((-?\d*\.?\d+),\s*0,\s*0,\s*(-?\d*\.?\d+),\s*0,\s*0\)/);a.cssScale=t?parseFloat(t[1]):1}var r=n,i=(r.target,r.target||r.srcElement),o=i.currentStyle||window.getComputedStyle(i,null),s=parseInt(o.borderLeftWidth,10),l=parseInt(o.borderTopWidth,10),c=i.getBoundingClientRect(),f=r.clientX,u=r.clientY;r.clientX?(f=r.clientX,u=r.clientY):(f=r.originalEvent.changedTouches[0].clientX,u=r.originalEvent.changedTouches[0].clientY);var h=f-s-c.left,p=u-l-c.top;return{x:parseInt(h/a.cssScale),y:parseInt(p/a.cssScale)}},Function.prototype.bind||(Function.prototype.bind=function(n){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=[].slice,t=e.call(arguments,1),r=this,i=function(){},a=function(){return r.apply(this instanceof i?this:n||{},t.concat(e.call(arguments)))};return a.prototype=this.prototype,a}),$.urlParam=function(n,e){return void 0===e&&(e=location.search),decodeURIComponent((new RegExp("[?|&]"+n+"=([^&;]+?)(&|#|;|$)").exec(e)||[,""])[1].replace(/\+/g,"%20"))||null},a.isNumber=function(n){return!isNaN(parseFloat(n))&&isFinite(n)},a.isInt=function(n){return a.isNumber(n)&&Math.floor(n)==n},a.debounce=function(n,e){var t=null;return function(){var r=this,i=arguments;clearTimeout(t),t=setTimeout((function(){n.apply(r,i)}),e)}},a.throttle=function(n,e,t){var r,i;return e||(e=250),function(){var a=t||this,o=+new Date,s=arguments;r&&o<r+e?(clearTimeout(i),i=setTimeout((function(){r=o,n.apply(a,s)}),e)):(r=o,n.apply(a,s))}},a.LRUCache=function(n){this._keys=[],this._items={},this._expires={},this._size=0,this._maxsize=n||1024},a.LRUCache.prototype={set:function(n,e){var t=this._keys,r=this._items,i=this._expires,a=this._size;a>=this._maxsize&&(t.sort((function(n,e){return i[n]>i[e]?-1:i[n]<i[e]?1:0})),a--,delete i[t[a]],delete r[t[a]]),t[a]=n,r[n]=e,i[n]=Date.now(),a++,this._keys=t,this._items=r,this._expires=i,this._size=a},get:function(n){var e=this._items[n];return e&&(this._expires[n]=Date.now()),e},keys:function(){return this._keys}},a.loadFromMirrors=function(n,e){var t=e&&e.data||null,r=(e&&e.method,e&&e.dataType||null),i=(e&&e.timeout,e&&e.onSuccess||null),o=e&&e.onFailure||null;if(0===n.length)"function"==typeof o&&o();else{var s={url:n[0],data:t};r&&(s.dataType=r),$.ajax(s).done((function(n){"function"==typeof i&&i(n)})).fail((function(){a.loadFromMirrors(n.slice(1),e)}))}},a.getAjaxObject=function(n,e,t,r){if(!1!==r&&(r=!0),!0===r)var i=De.JSONP_PROXY+"?url="+encodeURIComponent(n);else i=n;return e=e||"GET",t=t||null,$.ajax({url:i,method:e,dataType:t})},a.isHttpsContext=function(){return"https:"===window.location.protocol},a.getAbsoluteURL=function(n){var e=document.createElement("a");return e.href=n,e.href},a.uuidv4=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(n){var e=16*Math.random()|0;return("x"==n?e:3&e|8).toString(16)}))};let o=function(){function n(n){this.properties=n,this.id=this.getID(),this.obsTitle=n.obs_title,this.frame=n.hips_frame,this.order=parseInt(n.hips_order),this.clientSortKey=n.client_sort_key,this.tileFormats=n.hasOwnProperty("hips_tile_format")&&n.hips_tile_format.split(" "),this.urls=[],this.urls.push(n.hips_service_url);for(var e=1;n.hasOwnProperty("hips_service_url_"+e);)this.urls.push(n["hips_service_url_"+e]),e++;this.clientApplications=n.client_application}n.prototype={getServiceURLs:function(n){n=!0===n},getID:function(){if(this.properties.hasOwnProperty("ID"))return this.properties.ID;var n=null;return this.properties.hasOwnProperty("creator_did")&&(n=this.properties.creator_did),null==n&&this.properties.hasOwnProperty("publisher_did")&&(n=this.properties.publisher_did),null!=n&&("ivo://"===n.slice(0,6)&&(n=n.slice(6)),n=n.replace(/\?/g,"/")),n}};var e=[],t=[];n.LOCAL_STORAGE_KEY="aladin:hips-list";n.getLocalStorageDefinitions=function(){try{var e=window.localStorage.getItem(n.LOCAL_STORAGE_KEY);return null===e?[]:window.JSON.parse(e)}catch(n){return[]}},n.storeInLocalStorage=function(e){try{window.localStorage.setItem(n.LOCAL_STORAGE_KEY,window.JSON.stringify(e))}catch(n){return!1}return!0};var r=["http://alasky.u-strasbg.fr/MocServer/query","http://alaskybis.u-strasbg.fr/MocServer/query"],i=["https://alasky.u-strasbg.fr/MocServer/query","https://alaskybis.unistra.fr/MocServer/query"];n.getRemoteDefinitions=function(n,e,t){(n=n||{client_application:"AladinLite"}).fmt="json",n.fields="ID,obs_title,client_sort_key,client_application,hips_service_url*,hips_order,hips_tile_format,hips_frame";var o=a.isHttpsContext()?i:r;a.loadFromMirrors(o,{data:n,onSuccess:function(n){"function"==typeof e&&e(n)},onFailure:function(){console.error("Could not load HiPS definitions from urls "+o),"function"==typeof t&&t()},timeout:5})};var o=function(n,e){for(var t=[],r={},i=0;i<e.length;i++){r[(a=e[i]).ID]=a}for(i=0;i<n.length;i++){var a,o=(a=n[i]).ID;if(r.hasOwnProperty(o)){var s=r[o];a.hasOwnProperty("_last_used_url")&&!s.hasOwnProperty("_last_used_url")&&(s._last_used_url=a._last_used_url),t.push(s)}else t.push(a)}return t};return n.CACHE_RETENTION_TIME_SECONDS=604800,n.init=function(){t=e;for(var r=n.getLocalStorageDefinitions(),i=(new Date).getTime(),a=[],s=0;s<r.length;s++){var l=r[s];l.hasOwnProperty("_timestamp_retrieved")&&i-l._timestamp_retrieved>1e3*n.CACHE_RETENTION_TIME_SECONDS&&a.push(s)}for(s=a.length-1;s>=0;s--)r.splice(a[s],1);t=o(t,r),n.getRemoteDefinitions({dataproduct_type:"image",client_application:"AladinLite"},(function(e){for(var r=(new Date).getTime(),i=0;i<e.length;i++)e[i]._timestamp_retrieved=r;t=o(t,e),n.storeInLocalStorage(t)}))},n.getALDefaultHiPSDefinitions=function(){for(var e=[],r=0;r<t.length;r++){var i=t[r];!i.hasOwnProperty("client_application")||i.client_application.indexOf("AladinLite")<0||e.push(new n(i))}return e},n.getDefinitions=function(){for(var e=[],r=0;r<t.length;r++){var i=t[r];e.push(new n(i))}return e},n.parseHiPSProperties=function(n){if(null==n)return null;for(var e={},t=(n=n.replace(/[\r]/g,"")).split("\n"),r=0;r<t.length;r++){var i=$.trim(t[r]);if("#"!==i.slice(0,1)){var a=i.indexOf("=");if(!(a<0)){var o=$.trim(i.slice(0,a)),s=$.trim(i.slice(a+1));e[o]=s}}}return e},n.findByID=function(n,e){var t=findByIDLocal(n);t.length>0?"function"==typeof e&&e(t):findByIDRemote(n,e)},n.findByIDLocal=function(e,r){for(var i=[],a=0;a<t.length;a++){var o=t[a];null!=o.ID.match(e)&&i.push(new n(o))}return i},n.findByIDRemote=function(e,t){n.findHiPSRemote({ID:"*"+e+"*"},t)},n.findHiPSRemote=function(e,t){(e=e||{}).hasOwnProperty("dataproduct_type")||(e.dataproduct_type="image"),n.getRemoteDefinitions(e,(function(e){for(var r=[],i=0;i<e.length;i++)r.push(new n(e[i]));"function"==typeof t&&t(r)}))},n.fromURL=function(e,t){var r,i;"properties"===e.slice(-10)?r=(i=e).slice(0,-11):("/"===e.slice(-1)&&(e=e.slice(0,-1)),i=(r=e)+"/properties");var o=function(e){var i=n.parseHiPSProperties(e);i.hasOwnProperty("hips_service_url")||(i.hips_service_url=r),"function"==typeof t&&t(new n(i))};a.getAjaxObject(i,"GET","text",!1).done((function(n){o(n)})).fail((function(){a.getAjaxObject(i,"GET","text",!0).done((function(n){o(n)})).fail((function(){"function"==typeof t&&t(null)}))}))},n.fromProperties=function(e){return new n(e)},n.init(),n}(),s=function(){let n=function(e){if(!e)throw"An hosting survey URL or an ID (i.e. DSS2/red) must be given";let t=!1;console.log("root url",e),e.includes("http")&&(t=!0);let r=null;if(t){let t=e;return"/"===t.slice(-1)&&(t=t.substr(0,t.length-1)),t=a.getAbsoluteURL(t),a.isHttpsContext()&&(/u-strasbg.fr/i.test(t)||/unistra.fr/i.test(t))&&(t=t.replace("http://","https://")),console.log("ROOT URL",t),r=t+"/properties",(async()=>{console.log("properties url",r);let e=await fetch(r).then(n=>n.text());if(e=o.parseHiPSProperties(e),console.log("metadata",e),!e)throw"no surveys matching";const t=n.parseSurveyProperties(e);return console.log("survey ",t),t})()}{const t="https://alasky.unistra.fr/MocServer/query?ID=*"+encodeURIComponent(e)+"*&get=record&fmt=json";return(async()=>{let e=await(async n=>{const e=await fetch(n);return await e.json()})(t);if(!e)throw"no surveys matching";if(e.length>1){let n=[];throw e.forEach(e=>{n.push(e.ID)}),n+" surveys are matching. Please use one from this list."}if(0===e.length)throw"no surveys matching";e=e[0];return n.parseSurveyProperties(e)})()}};return n.parseSurveyProperties=function(n){n.hips_order;const e=n.hips_tile_format.split(" ");let t,r;e.indexOf("fits")>=0?(t={FITSImage:{bitpix:parseInt(n.hips_pixel_bitpix)}},r={Grayscale2Color:{color:[1,1,1],k:1,transfer:"asinh"}}):(r="Color",t=e.indexOf("png")>=0?{Image:{format:"png"}}:{Image:{format:"jpeg"}});let i=[void 0,void 0];n.hips_pixel_cut&&(i=n.hips_pixel_cut.split(" "));let a=512;if(n.hips_tile_width){let e=parseInt(n.hips_tile_width);!0===(e&&!(e&e-1))&&(a=e)}let o=n.hips_service_url;if(!o)throw"no valid service URL for retrieving the tiles";return o=o.startsWith("http://alasky")?o.replace("http","https"):"https://alasky.u-strasbg.fr/cgi/JSONProxy?url="+o,{properties:{url:o,maxOrder:parseInt(n.hips_order),frame:{label:"J2000",system:"J2000"},tileSize:a,format:t,minCutout:parseFloat(i[0]),maxCutout:parseFloat(i[1])},color:r}},n.create=async function(e,t){if(!e)return;return await new n(e)},n}(),l=function(){};l.D2R=Math.PI/180,l.R2D=180/Math.PI,l.sign=function(n){return n>0?1:n<0?-1:0},l.cosd=function(n){if(n%90==0)switch(Math.abs(Math.floor(n/90+.5))%4){case 0:return 1;case 1:return 0;case 2:return-1;case 3:return 0}return Math.cos(n*l.D2R)},l.sind=function(n){if(n%90==0)switch(Math.abs(Math.floor(n/90-.5))%4){case 0:return 1;case 1:return 0;case 2:return-1;case 3:return 0}return Math.sin(n*l.D2R)},l.tand=function(n){var e;return 0==(e=n%360)||180==Math.abs(e)?0:45==e||225==e?1:-135==e||-315==e?-1:Math.tan(n*l.D2R)},l.asind=function(n){return Math.asin(n)*l.R2D},l.acosd=function(n){return Math.acos(n)*l.R2D},l.atand=function(n){return Math.atan(n)*l.R2D},l.atan2=function(n,e){if(0==n)return e>0?0:e<0?Math.PI:NaN;var t=l.sign(n);if(0==e)return Math.PI/2*t;var r=Math.atan(Math.abs(n/e));return e>0?r*t:e<0?(Math.PI-r)*t:void 0},l.atan2d=function(n,e){return l.atan2(n,e)*l.R2D},l.cosh=function(n){return(Math.exp(n)+Math.exp(-n))/2},l.sinh=function(n){return(Math.exp(n)-Math.exp(-n))/2},l.tanh=function(n){return(Math.exp(n)-Math.exp(-n))/(Math.exp(n)+Math.exp(-n))},l.acosh=function(n){return Math.log(n+Math.sqrt(n*n-1))},l.asinh=function(n){return Math.log(n+Math.sqrt(n*n+1))},l.atanh=function(n){return.5*Math.log((1+n)/(1-n))},l.sinc=function(n){var e=Math.abs(n);return e<=.001?1-(e*=e)*(1-e/20)/6:Math.sin(e)/e},l.asinc=function(n){var e=Math.abs(n);return e<=.001?1+(e*=e)*(6+.45*e)/6:Math.asin(e)/e},l.hypot=function(n,e){return Math.sqrt(n*n+e*e)},l.eulerMatrix=function(n,e,t){var r=new Array(3);r[0]=new Array(3),r[1]=new Array(3),r[2]=new Array(3);var i=l.cosd(n),a=l.sind(n),o=l.cosd(e),s=l.sind(e),c=l.cosd(t),f=l.sind(t);return r[0][0]=c*o*i-f*a,r[0][1]=-f*o*i-c*a,r[0][2]=-s*i,r[1][0]=c*o*a+f*i,r[1][1]=-f*o*a+c*i,r[1][2]=-s*a,r[2][0]=-s*c,r[2][1]=-s*i,r[2][2]=o,r},l.displayMatrix=function(n){for(var e=n.length,t=0,r=0;r<e;r++)n[r].length>t&&(t=n[r].length);var i="<table>\n";for(r=0;r<e;r++){i+="<tr>";for(var a=0;a<e;a++)i+="<td>",r<n[r].length&&(i+=n[r][a].toString()),i+="</td>";i+="</td>\n"}return i+="</table>\n"};let c=function(n,e){this.PROJECTION=c.PROJ_TAN,this.ROT=this.tr_oR(n,e),this.longitudeIsReversed=!1};c.PROJ_TAN=1,c.PROJ_TAN2=2,c.PROJ_STG=2,c.PROJ_SIN=3,c.PROJ_SIN2=4,c.PROJ_ZEA=4,c.PROJ_ARC=5,c.PROJ_SCHMIDT=5,c.PROJ_AITOFF=6,c.PROJ_AIT=6,c.PROJ_GLS=7,c.PROJ_MERCATOR=8,c.PROJ_MER=8,c.PROJ_LAM=9,c.PROJ_LAMBERT=9,c.PROJ_TSC=10,c.PROJ_QSC=11,c.PROJ_MOLLWEIDE=12,c.PROJ_LIST=["Mercator",c.PROJ_MERCATOR,"Gnomonic",c.PROJ_TAN,"Stereographic",c.PROJ_TAN2,"Orthographic",c.PROJ_SIN,"Zenithal",c.PROJ_ZEA,"Schmidt",c.PROJ_SCHMIDT,"Aitoff",c.PROJ_AITOFF,"Lambert",c.PROJ_LAMBERT],c.PROJ_NAME=["-","Gnomonic","Stereographic","Orthographic","Equal-area","Schmidt plates","Aitoff","Global sin","Mercator","Lambert"],c.prototype={setCenter:function(n,e){this.ROT=this.tr_oR(n,e)},reverseLongitude:function(n){this.longitudeIsReversed=n},setProjection:function(n){this.PROJECTION=n},project:function(n,e){var t=this.tr_ou(n,e),r=this.tr_uu(t,this.ROT),i=this.tr_up(this.PROJECTION,r);return null==i?null:this.longitudeIsReversed?{X:i[0],Y:-i[1]}:{X:-i[0],Y:-i[1]}},unproject:function(n,e){this.longitudeIsReversed||(n=-n),e=-e;var t=this.tr_pu(this.PROJECTION,n,e),r=this.tr_uu1(t,this.ROT),i=this.tr_uo(r);return{ra:i[0],dec:i[1]}},tr_up:function(n,e){var t,r,i,a,o,s=e[0],f=e[1],u=e[2];if(0==(t=l.hypot(s,f))&&0==u)return null;switch(n){default:i=null;break;case c.PROJ_AITOFF:r=Math.sqrt(t*(t+s)/2),a=Math.sqrt(2*t*(t-s)),a/=r=Math.sqrt((1+r)/2),f<0&&(a=-a),i=[a,o=u/r];break;case c.PROJ_GLS:o=Math.asin(u),i=[a=0!=t?Math.atan2(f,s)*t:0,o];break;case c.PROJ_MERCATOR:i=0!=t?[a=Math.atan2(f,s),o=l.atanh(u)]:null;break;case c.PROJ_TAN:i=s>0?[a=f/s,o=u/s]:null;break;case c.PROJ_TAN2:i=(r=(1+s)/2)>0?[a=f/r,o=u/r]:null;break;case c.PROJ_ARC:s<=-1?(a=Math.PI,o=0):(t=l.hypot(f,u),a=f*(r=s>0?l.asinc(t):Math.acos(s)/t),o=u*r),i=[a,o];break;case c.PROJ_SIN:i=s>=0?[a=f,o=u]:null;break;case c.PROJ_SIN2:0!=(r=Math.sqrt((1+s)/2))?(a=f/r,o=u/r):(a=2,o=0),i=[a,o];break;case c.PROJ_LAMBERT:o=u,a=0,0!=t&&(a=Math.atan2(f,s)),i=[a,o]}return i},tr_pu:function(n,e,t){var r,i,a,o,s;switch(n){default:return null;case c.PROJ_AITOFF:if((r=e*e/8+t*t/2)>1)return null;a=1-r,s=t*(i=Math.sqrt(1-r/2)),0!=(r=l.hypot(a,o=e*i/2))&&(a=((i=a)*i-o*o)/r,o=2*i*o/r);break;case c.PROJ_GLS:if((r=1-(s=Math.sin(t))*s)<0)return null;i=0!=(r=Math.sqrt(r))?e/r:0,a=r*Math.cos(i),o=r*Math.sin(i);break;case c.PROJ_MERCATOR:s=l.tanh(t),a=(r=1/l.cosh(t))*Math.cos(e),o=r*Math.sin(e);break;case c.PROJ_LAMBERT:if((r=1-(s=t)*s)<0)return null;a=(r=Math.sqrt(r))*Math.cos(e),o=r*Math.sin(e);break;case c.PROJ_TAN:o=e*(a=1/Math.sqrt(1+e*e+t*t)),s=t*a;break;case c.PROJ_TAN2:a=(1-(r=(e*e+t*t)/4))/(i=1+r),o=e/i,s=t/i;break;case c.PROJ_ARC:if((r=l.hypot(e,t))>Math.PI)return null;i=l.sinc(r),a=Math.cos(r),o=i*e,s=i*t;break;case c.PROJ_SIN:if((i=1-e*e-t*t)<0)return null;a=Math.sqrt(i),o=e,s=t;break;case c.PROJ_SIN2:if((r=(e*e+t*t)/4)>1)return null;a=1-2*r,o=(i=Math.sqrt(1-r))*e,s=i*t}return[a,o,s]},tr_oR:function(n,e){var t=new Array(3);return t[0]=new Array(3),t[1]=new Array(3),t[2]=new Array(3),t[2][2]=l.cosd(e),t[0][2]=l.sind(e),t[1][1]=l.cosd(n),t[1][0]=-l.sind(n),t[1][2]=0,t[0][0]=t[2][2]*t[1][1],t[0][1]=-t[2][2]*t[1][0],t[2][0]=-t[0][2]*t[1][1],t[2][1]=t[0][2]*t[1][0],t},tr_ou:function(n,e){var t=new Array(3),r=l.cosd(e);return t[0]=r*l.cosd(n),t[1]=r*l.sind(n),t[2]=l.sind(e),t},tr_uu:function(n,e){var t=new Array(3),r=n[0],i=n[1],a=n[2];return t[0]=e[0][0]*r+e[0][1]*i+e[0][2]*a,t[1]=e[1][0]*r+e[1][1]*i+e[1][2]*a,t[2]=e[2][0]*r+e[2][1]*i+e[2][2]*a,t},tr_uu1:function(n,e){var t=new Array(3),r=n[0],i=n[1],a=n[2];return t[0]=e[0][0]*r+e[1][0]*i+e[2][0]*a,t[1]=e[0][1]*r+e[1][1]*i+e[2][1]*a,t[2]=e[0][2]*r+e[1][2]*i+e[2][2]*a,t},tr_uo:function(n){var e,t,r=n[0],i=n[1],a=n[2],o=r*r+i*i;if(0==o){if(0==a)return null;e=0,t=a>0?90:-90}else t=l.atand(a/Math.sqrt(o)),(e=l.atan2d(i,r))<0&&(e+=360);return[e,t]}};let f={SIN:c.PROJ_SIN,AITOFF:c.PROJ_AITOFF,MERCATOR:c.PROJ_MERCATOR,ARC:c.PROJ_ARC,TAN:c.PROJ_TAN,MOL:c.PROJ_MOLLWEIDE},u=function(n,e,t){this.lon=n,this.lat=e,this.prec=t,this.frame=null,this.computeDirCos()};function h(n,e){this.string=p.trim(n,e),this.sep=e,this.pos=0}function p(){}function d(){}u.factor=[3600,60,1],u.prototype={setFrame:function(n){this.frame=n},computeDirCos:function(){var n=l.cosd(this.lat);this.x=n*l.cosd(this.lon),this.y=n*l.sind(this.lon),this.z=l.sind(this.lat)},computeLonLat:function(){var n=this.x*this.x+this.y*this.y;this.lon=0,0==n?0==this.z?(this.lon=NaN,this.lat=NaN):this.lat=this.z>0?90:-90:(this.lon=l.atan2d(this.y,this.x),this.lat=l.atan2d(this.z,Math.sqrt(n)),this.lon<0&&(this.lon+=360))},dist2:function(n){var e=n.x-this.x,t=e*e;return t+=(e=n.y-this.y)*e,t+=(e=n.z-this.z)*e},distance:function(n){return 0==n.x&&0==n.y&&0==n.z||0==this.x&&0==this.y&&0==this.z?NaN:2*l.asind(.5*Math.sqrt(this.dist2(n)))},convertTo:function(n){this.frame.equals(n)||(this.frame.toICRS(this.coo),n.fromICRS(this.coo),this.frame=n,this.lon=this.lat=NaN)},rotate:function(n){var e,t,r;n!=Umatrix3&&(e=n[0][0]*this.x+n[0][1]*this.y+n[0][2]*this.z,t=n[1][0]*this.x+n[1][1]*this.y+n[1][2]*this.z,r=n[2][0]*this.x+n[2][1]*this.y+n[2][2]*this.z,this.x=e,this.y=t,this.z=r,this.lon=this.lat=NaN)},rotate_1:function(n){var e,t,r;n!=Umatrix3&&(e=n[0][0]*this.x+n[1][0]*this.y+n[2][0]*this.z,t=n[0][1]*this.x+n[1][1]*this.y+n[2][1]*this.z,r=n[0][2]*this.x+n[1][2]*this.y+n[2][2]*this.z,this.x=e,this.y=t,this.z=r,this.lon=this.lat=NaN)},equals:function(n){return this.x==n.x&&this.y==n.y&&this.z==n.z},parse:function(n){var e=n.indexOf("+");if(e<0&&(e=n.indexOf("-")),e<0&&(e=n.indexOf(" ")),e<0)return this.lon=NaN,this.lat=NaN,this.prec=0,!1;var t=n.substring(0,e),r=n.substring(e);return this.lon=this.parseLon(t),this.lat=this.parseLat(r),!0},parseLon:function(n){if((n=(n=n.trim()).replace(/:/g," ")).indexOf(" ")<0){var e=n.indexOf(".");return this.prec=e<0?0:n.length-e-1,parseFloat(n)}for(var t=new h(n," "),r=0,i=0,a=0;t.hasMore();){var o=t.nextToken(),s=o.indexOf(".");switch(i+=parseFloat(o)*u.factor[r],r){case 0:a=s<0?1:2;break;case 1:a=s<0?3:4;break;case 2:a=s<0?5:4+o.length-s}r++}return this.prec=a,15*i/3600},parseLat:function(n){var e;if("-"==(n=(n=n.trim()).replace(/:/g," ")).charAt(0)?(e=-1,n=n.substring(1)):"-"==n.charAt(0)?(e=1,n=n.substring(1)):e=1,n.indexOf(" ")<0){var t=n.indexOf(".");return this.prec=t<0?0:n.length-t-1,parseFloat(n)*e}for(var r=new h(n," "),i=0,a=0,o=0;r.hasMore();){var s=r.nextToken(),l=s.indexOf(".");switch(a+=parseFloat(s)*u.factor[i],i){case 0:o=l<0?1:2;break;case 1:o=l<0?3:4;break;case 2:o=l<0?5:4+s.length-l}i++}return this.prec=o,a*e/3600},format:function(n){isNaN(this.lon)&&this.computeLonLat();var e="",t="";if(n.indexOf("d")>=0)e=d.format(this.lon,this.prec),t=d.format(this.lat,this.prec);else{var r=this.lon/15;e=d.toSexagesimal(r,this.prec+1,!1),t=d.toSexagesimal(this.lat,this.prec,!1)}return this.lat>0&&(t="+"+t),n.indexOf("/")>=0?e+" "+t:n.indexOf("2")>=0?[e,t]:e+t}},h.prototype={hasMore:function(){return this.pos<this.string.length},nextToken:function(){for(var n=this.pos;n<this.string.length&&this.string.charAt(n)==this.sep;)n++;for(var e=n;e<this.string.length&&this.string.charAt(e)!=this.sep;)e++;return this.pos=e,this.string.substring(n,e)}},p.trim=function(n,e){for(var t=0,r=n.length-1;t<n.length&&n.charAt(t)==e;)t++;if(t==n.length)return"";for(;r>t&&n.charAt(r)==e;)r--;return n.substring(t,r+1)},d.pow10=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13,1e14],d.rndval=[.5,.05,.005,5e-4,5e-5,5e-6,5e-7,5e-8,5e-9,5e-10,5e-11,5e-12,5e-13,5e-14,5e-14],d.format=function(n,e){if(e<=0)return Math.round(n).toString();var t=n.toString(),r=t.indexOf("."),i=r>=0?t.length-r-1:0;if(e>=i){r<0&&(t+=".");for(var a=0;a<e-i;a++)t+="0";return t}return(t=(n+d.rndval[e]).toString()).substr(0,r+e+1)},d.toSexagesimal=function(n,e,t){var r=n<0?"-":t?"+":"",i=Math.abs(n);switch(e){case 1:return r+(o=Math.round(i)).toString();case 2:return r+d.format(i,1);case 3:return r+(o=Math.floor(i))+" "+(a=Math.round(60*(i-o)));case 4:var a=60*(i-(o=Math.floor(i)));return r+o+" "+d.format(a,1);case 5:a=60*(i-(o=Math.floor(i)));return r+o+" "+(s=Math.floor(a))+" "+(l=Math.round(60*(a-s)));case 6:case 7:case 8:var o;(o=Math.floor(i))<10&&(o="0"+o);var s;a=60*(i-o);(s=Math.floor(a))<10&&(s="0"+s);var l=60*(a-s);return r+o+" "+s+" "+d.format(l,e-5);default:return r+d.format(i,1)}};let _={SYSTEMS:v={J2000:"J2000",GAL:"Galactic"},J2000:{label:"J2000",system:v.J2000},J2000d:{label:"J2000d",system:v.J2000},GAL:{label:"Galactic",system:v.GAL},fromString:function(n,e){return n?0==(n=n.toLowerCase().replace(/^\s+|\s+$/g,"")).indexOf("j2000d")||0==n.indexOf("icrsd")?_.J2000d:0==n.indexOf("j2000")||0==n.indexOf("icrs")?_.J2000:0==n.indexOf("gal")?_.GAL:e||null:e||null}};var v;let m={xyToView:function(n,e,t,r,i,a,o){return null==o&&(o=!0),o?{vx:m.myRound(i/2*(1+a*n)-(i-t)/2),vy:m.myRound(i/2*(1+a*e)-(i-r)/2)}:{vx:i/2*(1+a*n)-(i-t)/2,vy:i/2*(1+a*e)-(i-r)/2}},viewToXy:function(n,e,t,r,i,a){return{x:((2*n+(i-t))/i-1)/a,y:((2*e+(i-r))/i-1)/a}},radecToViewXy:function(n,e,t){return t.aladin.webglAPI.worldToScreen(n,e)},myRound:function(n){return n<0?-1*(0|-n):0|n},isInsideViewXy:function(n,e,t,r){return n>=0&&n<t&&e>=0&&e<r},isHpxPixVisible:function(n,e,t){for(var r=0;r<n.length;r++)if(n[r].vx>=-20&&n[r].vx<e+20&&n[r].vy>=-20&&n[r].vy<t+20)return!0;return!1},ipixToIpix:function(n,e,t){},counterClockwiseTriangle:function(n,e,t,r,i,a){return n*r+e*i+t*a-i*r-a*n-t*e>=0},grow2:function(n,e){for(var t=0,r=0;r<4;r++)null==n[r]&&t++;if(t>1)return n;var i=[];for(r=0;r<4;r++)i.push({vx:n[r].vx,vy:n[r].vy});for(r=0;r<2;r++){var a,o,s=1==r?1:0,l=1==r?3:2;if(null==i[s]&&(0==s||3==s?(a=1,o=2):(a=0,o=3),i[s]={vx:(i[a].vx+i[o].vx)/2,vy:(i[a].vy+i[o].vy)/2}),null==i[l]&&(0==l||3==l?(a=1,o=2):(a=0,o=3),i[l]={vx:(i[a].vx+i[o].vx)/2,vy:(i[a].vy+i[o].vy)/2}),null!=i[s]&&null!=i[l]){var c=Math.atan2(i[l].vy-i[s].vy,i[l].vx-i[s].vx),f=e*Math.cos(c);i[s].vx-=f,i[l].vx+=f,f=e*Math.sin(c),i[s].vy-=f,i[l].vy+=f}}return i},SVG_ICONS:{CATALOG:'<svg xmlns="http://www.w3.org/2000/svg"><polygon points="1,0,5,0,5,3,1,3"  fill="FILLCOLOR" /><polygon points="7,0,9,0,9,3,7,3"  fill="FILLCOLOR" /><polygon points="10,0,12,0,12,3,10,3"  fill="FILLCOLOR" /><polygon points="13,0,15,0,15,3,13,3"  fill="FILLCOLOR" /><polyline points="1,5,5,9"  stroke="FILLCOLOR" /><polyline points="1,9,5,5" stroke="FILLCOLOR" /><line x1="7" y1="7" x2="15" y2="7" stroke="FILLCOLOR" stroke-width="2" /><polyline points="1,11,5,15"  stroke="FILLCOLOR" /><polyline points="1,15,5,11"  stroke="FILLCOLOR" /><line x1="7" y1="13" x2="15" y2="13" stroke="FILLCOLOR" stroke-width="2" /></svg>',MOC:'<svg xmlns="http://www.w3.org/2000/svg"><polyline points="0.5,7,2.5,7,2.5,5,7,5,7,3,10,3,10,5,13,5,13,7,15,7,15,9,13,9,13,12,10,12,10,14,7,14,7,12,2.5,12,2.5,10,0.5,10,0.5,7" stroke-width="1" stroke="FILLCOLOR" fill="transparent" /><line x1="1" y1="10" x2="6" y2="5" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="2" y1="12" x2="10" y2="4" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="5" y1="12" x2="12" y2="5" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="7" y1="13" x2="13" y2="7" stroke="FILLCOLOR" stroke-width="0.5" /><line x1="10" y1="13" x2="13" y2="10" stroke="FILLCOLOR" stroke-width="0.5" /></svg>',OVERLAY:'<svg xmlns="http://www.w3.org/2000/svg"><polygon points="10,5,10,1,14,1,14,14,2,14,2,9,6,9,6,5" fill="transparent" stroke="FILLCOLOR" stroke-width="2"/></svg>'}},g={};g.PI=Math.PI,g.C_PR=Math.PI/180,g.VLEV=2,g.EPS=1e-7,g.c=.105,g.LN10=Math.log(10),g.PIOVER2=Math.PI/2,g.TWOPI=2*Math.PI,g.TWOTHIRD=2/3,g.ARCSECOND_RADIAN=484813681109536e-20;let b=function(){let n=function(){};n.radecToPolar=function(n,e){return{theta:Math.PI/2-e/180*Math.PI,phi:n/180*Math.PI}},n.polarToRadec=function(n,e){return{ra:180*e/Math.PI,dec:180*(Math.PI/2-n)/Math.PI}},n.castToInt=function(n){return n>0?Math.floor(n):Math.ceil(n)};!function(){function n(n,e){this.theta=n,this.phi=e}n.prototype.toString=function(){return"theta: "+this.theta+", phi: "+this.phi}}();let e=function(){function n(){this.items=[]}return n.prototype.appendRange=function(n,e){for(var t=n;t<=e;t++)t in this.items||this.items.push(t)},n}();function t(n){this.nside=n}return t.NS_MAX=16384,t.ORDER_MAX=14,t.NSIDELIST=[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384],t.JRLL=[2,2,2,2,3,3,3,3,4,4,4,4],t.JPLL=[1,3,5,7,0,2,4,6,1,3,5,7],t.XOFFSET=[-1,-1,0,1,1,1,0,-1],t.YOFFSET=[0,1,1,1,0,-1,-1,-1],t.FACEARRAY=[[8,9,10,11,-1,-1,-1,-1,10,11,8,9],[5,6,7,4,8,9,10,11,9,10,11,8],[-1,-1,-1,-1,5,6,7,4,-1,-1,-1,-1],[4,5,6,7,11,8,9,10,11,8,9,10],[0,1,2,3,4,5,6,7,8,9,10,11],[1,2,3,0,0,1,2,3,5,6,7,4],[-1,-1,-1,-1,7,4,5,6,-1,-1,-1,-1],[3,0,1,2,3,0,1,2,4,5,6,7],[2,3,0,1,-1,-1,-1,-1,0,1,2,3]],t.SWAPARRAY=[[0,0,0,0,0,0,0,0,3,3,3,3],[0,0,0,0,0,0,0,0,6,6,6,6],[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,5,5,5,5],[0,0,0,0,0,0,0,0,0,0,0,0],[5,5,5,5,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0],[6,6,6,6,0,0,0,0,0,0,0,0],[3,3,3,3,0,0,0,0,0,0,0,0]],t.Z0=g.TWOTHIRD,t.prototype.init=function(){this.ctab=new Array(256),this.utab=new Array(256);for(var n=0;n<256;++n)this.ctab[n]=1&n|(2&n)<<7|(4&n)>>1|(8&n)<<6|(16&n)>>2|(32&n)<<5|(64&n)>>3|(128&n)<<4,this.utab[n]=1&n|(2&n)<<1|(4&n)<<2|(8&n)<<3|(16&n)<<4|(32&n)<<5|(64&n)<<6|(128&n)<<7;this.nl2=2*this.nside,this.nl3=3*this.nside,this.nl4=4*this.nside,this.npface=this.nside*this.nside,this.ncap=2*this.nside*(this.nside-1),this.npix=12*this.npface,this.fact2=4/this.npix,this.fact1=(this.nside<<1)*this.fact2,this.order=t.nside2order(this.nside)},t.calculateNSide=function(e){for(var r=0,i=e*e,a=180/g.PI,o=4*g.PI*a*a*3600*3600,s=n.castToInt(o/i)/12,l=Math.sqrt(s),c=t.NS_MAX,f=0,u=0;u<t.NSIDELIST.length;u++)if(Math.abs(l-t.NSIDELIST[u])<=c&&(c=Math.abs(l-t.NSIDELIST[u]),r=t.NSIDELIST[u],f=u),l>r&&l<t.NS_MAX&&(r=t.NSIDELIST[f+1]),l>t.NS_MAX)return console.log("nside cannot be bigger than "+t.NS_MAX),t.NS_MAX;return r},t.nside2order=function(e){return(e&e-1)>0?-1:n.castToInt(t.log2(e))},t.log2=function(n){return Math.log(n)/Math.log(2)},t.prototype.ang2pix_nest=function(e,r){var i,a,o,s,l,c,f,u,h,p;if(r>=g.TWOPI&&(r-=g.TWOPI),r<0&&(r+=g.TWOPI),e>g.PI||e<0)throw{name:"Illegal argument",message:"theta must be between 0 and "+g.PI};if(r>g.TWOPI||r<0)throw{name:"Illegal argument",message:"phi must be between 0 and "+g.TWOPI};if(i=Math.cos(e),a=Math.abs(i),o=r/g.PIOVER2,a<=t.Z0){var d,x=this.nside*(.5+o),_=this.nside*(.75*i),v=x+_;u=(l=(d=x-_)>>this.order)==(c=v>>this.order)?4==l?4:l+4:l<c?l:c+8,h=n.castToInt(v&this.nside-1),p=n.castToInt(this.nside-(d&this.nside-1)-1)}else{(f=n.castToInt(o))>=4&&(f=3),s=o-f;var m=this.nside*Math.sqrt(3*(1-a));d=n.castToInt(s*m),v=n.castToInt((1-s)*m),d=Math.min(t.NS_MAX-1,d),v=Math.min(t.NS_MAX-1,v),i>=0?(u=f,h=n.castToInt(this.nside-v-1),p=n.castToInt(this.nside-d-1)):(u=f+8,h=d,p=v)}return this.xyf2nest(h,p,u)},t.prototype.xyf2nest=function(n,e,t){return(t<<2*this.order)+(this.utab[255&n]|this.utab[n>>8&255]<<16|this.utab[n>>16&255]<<32|this.utab[n>>24&255]<<48|this.utab[255&e]<<1|this.utab[e>>8&255]<<17|this.utab[e>>16&255]<<33|this.utab[e>>24&255]<<49)},t.prototype.nest2xyf=function(n){var e={};e.face_num=n>>2*this.order;var t=n&this.npface-1,r=(93823560581120&t)>>16|(614882086624428e4&t)>>31|21845&t|(1431633920&t)>>15;return e.ix=this.ctab[255&r]|this.ctab[r>>8&255]<<4|this.ctab[r>>16&255]<<16|this.ctab[r>>24&255]<<20,r=(93823560581120&(t>>=1))>>16|(614882086624428e4&t)>>31|21845&t|(1431633920&t)>>15,e.iy=this.ctab[255&r]|this.ctab[r>>8&255]<<4|this.ctab[r>>16&255]<<16|this.ctab[r>>24&255]<<20,e},t.prototype.pix2ang_nest=function(n){if(n<0||n>this.npix-1)throw{name:"Illegal argument",message:"ipix out of range"};var e,r,i,a=this.nest2xyf(n),o=a.ix,s=a.iy,l=a.face_num,c=(t.JRLL[l]<<this.order)-o-s-1;c<this.nside?(r=1-(e=c)*e*this.fact2,i=0):c>this.nl3?(r=(e=this.nl4-c)*e*this.fact2-1,i=0):(e=this.nside,r=(this.nl2-c)*this.fact1,i=c-this.nside&1);var f=Math.acos(r),u=(t.JPLL[l]*e+o-s+1+i)/2;return u>this.nl4&&(u-=this.nl4),u<1&&(u+=this.nl4),{theta:f,phi:(u-.5*(i+1))*(g.PIOVER2/e)}},t.nside2Npix=function(n){if(n<0||(n&-n)!=n||n>t.NS_MAX)throw{name:"Illegal argument",message:"nside should be >0, power of 2, <"+t.NS_MAX};return 12*n*n},t.prototype.xyf2ring=function(n,e,r){var i,a,o,s=t.JRLL[r]*this.nside-n-e-1;s<this.nside?(o=2*(i=s)*(i-1),a=0):s>3*this.nside?(i=this.nl4-s,o=this.npix-2*(i+1)*i,a=0):(i=this.nside,o=this.ncap+(s-this.nside)*this.nl4,a=s-this.nside&1);var l=(t.JPLL[r]*i+n-e+1+a)/2;return l>this.nl4?l-=this.nl4:l<1&&(l+=this.nl4),o+l-1},t.prototype.nest2ring=function(n){var e=this.nest2xyf(n);return this.xyf2ring(e.ix,e.iy,e.face_num)},t.prototype.corners_nest=function(n,e){var t=this.nest2ring(n);return this.corners_ring(t,e)},t.prototype.pix2ang_ring=function(e){var t,r,i,a,o,s,l,c,f;if(e<0||e>this.npix-1)throw{name:"Illegal argument",message:"ipix out of range"};return(s=e+1)<=this.ncap?(f=n.castToInt(c=s/2),a=s-2*(i=n.castToInt(Math.sqrt(c-Math.sqrt(f)))+1)*(i-1),t=Math.acos(1-i*i*this.fact2),r=(a-.5)*g.PI/(2*i)):e<this.npix-this.ncap?(i=(o=e-this.ncap)/this.nl4+this.nside,a=o%this.nl4+1,l=(i+this.nside&1)>0?1:.5,t=Math.acos((this.nl2-i)*this.fact1),r=(a-l)*g.PI/this.nl2):(o=this.npix-e,a=4*(i=n.castToInt(.5*(1+Math.sqrt(2*o-1))))+1-(o-2*i*(i-1)),t=Math.acos(Math.pow(i,2)*this.fact2-1),r=(a-.5)*g.PI/(2*i)),[t,r]},t.prototype.ring=function(e){var t,r,i=0,a=e+1,o=0;return a<=this.ncap?(o=n.castToInt(r=a/2),i=n.castToInt(Math.sqrt(r-Math.sqrt(o)))+1):a<=this.nl2*(5*this.nside+1)?(t=n.castToInt(a-this.ncap-1),i=n.castToInt(t/this.nl4+this.nside)):(t=this.npix-a+1,o=n.castToInt(r=t/2),i=n.castToInt(Math.sqrt(r-Math.sqrt(o)))+1,i=this.nl4-i),i},t.prototype.integration_limits_in_costh=function(n){var e,t,r,i;return i=1*this.nside,n<=this.nside?(t=1-Math.pow(n,2)/3/this.npface,r=1-Math.pow(n-1,2)/3/this.npface,e=n==this.nside?2*(this.nside-1)/3/i:1-Math.pow(n+1,2)/3/this.npface):n<this.nl3?(t=2*(2*this.nside-n)/3/i,r=2*(2*this.nside-n+1)/3/i,e=2*(2*this.nside-n-1)/3/i):(r=n==this.nl3?2*(1-this.nside)/3/i:Math.pow(4*this.nside-n+1,2)/3/this.npface-1,e=Math.pow(this.nl4-n-1,2)/3/this.npface-1,t=Math.pow(this.nl4-n,2)/3/this.npface-1),[r,t,e]},t.prototype.pixel_boundaries=function(n,e,t,r){var i,a,o,s,l,c,f,u=1*this.nside;if(Math.abs(r)>=1-1/3/this.npface)return[c=t*g.PIOVER2,f=(t+1)*g.PIOVER2];if(1.5*r>=1)i=1/u/Math.sqrt(3*(1-r)),o=(a=e)-1,l=(s=n-e)+1,c=g.PIOVER2*(Math.max(o*i,1-l*i)+t),f=g.PIOVER2*(Math.min(1-s*i,a*i)+t);else if(-1<1.5*r){var h=.5*(1-1.5*r),p=h+1,d=this.nside+n%2;o=(a=e-(d-n)/2)-1,l=(s=(d+n)/2-e)+1,c=g.PIOVER2*(Math.max(p-l/u,o/u-h)+t),f=g.PIOVER2*(Math.min(p-s/u,a/u-h)+t)}else{i=1/u/Math.sqrt(3*(1+r));var x=2*this.nside;o=(a=n-x+e)-1,l=(s=x-e)+1,c=g.PIOVER2*(Math.max(1-(x-o)*i,(x-l)*i)+t),f=g.PIOVER2*(Math.min(1-(x-a)*i,(x-s)*i)+t)}return[c,f]},t.vector=function(n,e){var t=1*Math.sin(n)*Math.cos(e),r=1*Math.sin(n)*Math.sin(e),i=1*Math.cos(n);return new E(t,r,i)},t.prototype.corners_ring=function(e,r){var i=2*r+2,a=new Array(i),o=this.pix2ang_ring(e),s=Math.cos(o[0]),l=o[0],c=o[1],f=n.castToInt(c/g.PIOVER2),u=this.ring(e),h=Math.min(u,Math.min(this.nside,this.nl4-u)),p=0,d=g.PIOVER2/h;p=u>=this.nside&&u<=this.nl3?n.castToInt(c/d+u%2/2)+1:n.castToInt(c/d)+1,p-=f*h;var x=i/2,_=this.integration_limits_in_costh(u),v=Math.acos(_[0]),m=Math.acos(_[2]),y=this.pixel_boundaries(u,p,f,_[0]);if(a[0]=p>h/2?t.vector(v,y[1]):t.vector(v,y[0]),y=this.pixel_boundaries(u,p,f,_[2]),a[x]=p>h/2?t.vector(m,y[1]):t.vector(m,y[0]),1==r){var b=Math.acos(_[1]);y=this.pixel_boundaries(u,p,f,_[1]),a[1]=t.vector(b,y[0]),a[3]=t.vector(b,y[1])}else for(var E=(_[2]-_[0])/(r+1),w=1;w<=r;w++)s=_[0]+E*w,l=Math.acos(s),y=this.pixel_boundaries(u,p,f,s),a[w]=t.vector(l,y[0]),a[i-w]=t.vector(l,y[1]);return a},t.vec2Ang=function(n){var e=n.z/n.length(),t=Math.acos(e),r=0;return 0==n.x&&0==n.y||(r=Math.atan2(n.y,n.x)),r<0&&(r+=2*Math.PI),[t,r]},t.prototype.queryDisc=function(n,r,i,a){if(r<0||r>g.PI)throw{name:"Illegal argument",message:"angular radius is in RADIAN and should be in [0,pi]"};var o,s,l,c,f,u,h,p,d,x,_,v,m,y,b,E,w,I,C,S,P=new e,T=r;if(a&&(T+=g.PI/this.nl4),u=(c=t.vec2Ang(n))[0],h=c[1],_=this.fact2,v=this.fact1,f=Math.cos(u),C=1/Math.sqrt((1-f)*(1+f)),y=u-T,b=u+T,p=Math.cos(T),w=Math.cos(y),o=this.ringAbove(w)+1,E=Math.cos(b),(s=this.ringAbove(E))<o&&0==s&&(s=o),y<=0)for(var R=1;R<o;++R)this.inRing(R,0,Math.PI,P);for(l=o;l<=s;++l)x=1-(I=l<this.nside?1-l*l*_:l<=this.nl3?(this.nl2-l)*v:(this.nl4-l)*(this.nl4-l)*_-1)*I-(d=(p-I*f)*C)*d,m=Math.atan2(Math.sqrt(x),d),isNaN(m)&&(m=T),this.inRing(l,h,m,P);if(b>=Math.PI)for(R=s+1;R<this.nl4;++R)this.inRing(R,0,Math.PI,P,!1);if(i){for(var A=P.items,z=[],B=0;B<A.length;B++){var L=this.ring2nest(A[B]);z.indexOf(L)>=0||z.push(L)}S=z}else S=P.items;return S},t.prototype.inRing=function(e,t,r,i,a){var o,s,l,c,f,u=!1,h=!1,p=0,d=0,x=0,_=(t-r)%g.TWOPI-1e-12,v=t+r+1e-12,m=(t+r)%g.TWOPI+1e-12;if(Math.abs(r-g.PI)<1e-12&&(u=!0),e>=this.nside&&e<=this.nl3?(p=e-this.nside+1,f=(c=this.ncap+this.nl4*(p-1))+this.nl4-1,s=p%2,l=this.nl4):(e<this.nside?f=(c=2*(p=e)*(p-1))+4*p-1:(p=4*this.nside-e,f=(c=this.npix-2*p*(p+1))+4*p-1),l=4*p,s=1),u)i.appendRange(c,f);else{if(o=s/2,a)d=Math.round(l*_/g.TWOPI-o),d%=l,(x=Math.round(l*v/g.TWOPI-o))>l&&(x%=l);else{if(d=Math.ceil(l*_/g.TWOPI-o),(x=n.castToInt(l*m/g.TWOPI-o))<d&&1==e&&(x=n.castToInt(l*v/g.TWOPI-o)),d==x+1&&(d=x),d-x==1&&r*l<g.PI)return void console.log("the interval is too small and avay from center");d=Math.min(d,l-1),x=Math.max(x,0)}if(d>x&&(h=!0),h)d+=c,x+=c,i.appendRange(c,x),i.appendRange(d,f);else{if(d<0)return d=Math.abs(d),i.appendRange(c,c+x),void i.appendRange(f-d+1,f);d+=c,x+=c,i.appendRange(d,x)}}},t.prototype.ringAbove=function(e){var t=Math.abs(e);if(t>g.TWOTHIRD){var r=n.castToInt(this.nside*Math.sqrt(3*(1-t)));return e>0?r:4*this.nside-r-1}return n.castToInt(this.nside*(2-1.5*e))},t.prototype.ring2nest=function(n){var e=this.ring2xyf(n);return this.xyf2nest(e.ix,e.iy,e.face_num)},t.prototype.ring2xyf=function(e){var r,i,a,o,s={};if(e<this.ncap)i=e+1-2*(r=n.castToInt(.5*(1+Math.sqrt(1+2*e))))*(r-1),a=0,o=r,s.face_num=0,(p=i-1)>=2*r&&(s.face_num=2,p-=2*r),p>=r&&++s.face_num;else if(e<this.npix-this.ncap){var l=e-this.ncap;this.order>=0?(r=(l>>this.order+2)+this.nside,i=1+(l&this.nl4-1)):(r=l/this.nl4+this.nside,i=l%this.nl4+1),a=r+this.nside&1,o=this.nside;var c,f,u=r-this.nside+1,h=this.nl2+2-u;this.order>=0?(c=i-n.castToInt(u/2)+this.nside-1>>this.order,f=i-n.castToInt(h/2)+this.nside-1>>this.order):(c=(i-n.castToInt(u/2)+this.nside-1)/this.nside,f=(i-n.castToInt(h/2)+this.nside-1)/this.nside),s.face_num=f==c?4==f?4:n.castToInt(f)+4:f<c?n.castToInt(f):n.castToInt(c)+8}else{var p;l=this.npix-e;i=4*(r=n.castToInt(.5*(1+Math.sqrt(2*l-1))))+1-(l-2*r*(r-1)),a=0,o=r,r=2*this.nl2-r,s.face_num=8,(p=i-1)>=2*o&&(s.face_num=10,p-=2*o),p>=o&&++s.face_num}var d=r-t.JRLL[s.face_num]*this.nside+1,x=2*i-t.JPLL[s.face_num]*o-a-1;return x>=this.nl2&&(x-=8*this.nside),s.ix=x-d>>1,s.iy=-(x+d)>>1,s},t.utils=n,t}(),E=function(){function n(n,e,t){this.x=n,this.y=e,this.z=t,this.ra_=0,this.dec_=0,this.okRaDec_=!1}return n.prototype.setXYZ=function(n,e,t){this.x=n,this.y=e,this.z=t,this.okRaDec_=!1},n.prototype.length=function(){return Math.sqrt(this.lengthSquared())},n.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y+this.z*this.z},n.prototype.normalized=function(){var n=this.length();this.x/=n,this.y/=n,this.z/=n},n.prototype.set=function(n,e){this.ra_=n,this.dec_=e,this.okRaDec_=!0,this.updateXYZ()},n.prototype.angle=function(n){var e=this.y*n.z-this.z*n.y,t=this.z*n.x-this.x*n.z,r=this.x*n.y-this.y*n.x,i=Math.sqrt(e*e+t*t+r*r);return Math.abs(Math.atan2(i,dot(n)))},n.prototype.get=function(){return[x,y,z]},n.prototype.toString=function(){return"SpatialVector["+this.x+", "+this.y+", "+this.z+"]"},n.prototype.cross=function(e){return new n(this.y*e.z-e.y*this.z,this.z*e.x-e.z*this.x,this.x*e.y-e.x()*this.y)},n.prototype.equal=function(n){return this.x==n.x&&this.y==n.y&&this.z==n.z()},n.prototype.mult=function(e){return new n(e*this.x,e*this.y,e*this.z)},n.prototype.dot=function(n){return this.x*n.x+this.y*n.y+this.z*n.z},n.prototype.add=function(e){return new n(this.x+e.x,this.y+e.y,this.z+e.z)},n.prototype.sub=function(e){return new n(this.x-e.x,this.y-e.y,this.z-e.z)},n.prototype.dec=function(){return this.okRaDec_||(this.normalized(),this.updateRaDec()),this.dec_},n.prototype.ra=function(){return this.okRaDec_||(this.normalized(),this.updateRaDec()),this.ra_},n.prototype.updateXYZ=function(){var n=Math.cos(this.dec_*g.C_PR);this.x=Math.cos(this.ra_*g.C_PR)*n,this.y=Math.sin(this.ra_*g.C_PR)*n,this.z=Math.sin(this.dec_*g.C_PR)},n.prototype.updateRaDec=function(){this.dec_=Math.asin(this.z)/g.C_PR;var n=Math.cos(this.dec_*g.C_PR);n>g.EPS||n<-g.EPS?this.y>g.EPS||this.y<-g.EPS?this.y<0?this.ra_=360-Math.acos(this.x/n)/g.C_PR:this.ra_=Math.acos(this.x/n)/g.C_PR:this.ra_=this.x<0?180:0:this.ra_=0,this.okRaDec_=!0},n.prototype.toRaRadians=function(){var n=0;return 0==this.x&&0==this.y||(n=Math.atan2(this.y,this.x)),n<0&&(n+=2*Math.PI),n},n.prototype.toDeRadians=function(){var n=z/this.length(),e=Math.acos(n);return Math.PI/2-e},n}(),w=function(){let n={staticCache:{corners:{nside8:[]}},dynamicCache:{},lastNside:8,hpxIdxCache:null,init:function(){var e=new b(8);e.init();var t=b.nside2Npix(8);let r;for(var i=0;i<t;i++)r=e.corners_nest(i,1),n.staticCache.corners.nside8.push(r);n.hpxIdxCache=e}};return n.init(),n.corners_nest=function(e,t){return 8==t?n.staticCache.corners.nside8[e]:(t!=n.lastNside&&(n.hpxIdxCache=new b(t),n.hpxIdxCache.init(),n.lastNside=t),n.hpxIdxCache.corners_nest(e,1))},n}();var I=t(0);let C=function(){function n(n,e){this.img=n,this.url=e}return n.isImageOk=function(n){return!!n.allSkyTexture||!!n.src&&(!!n.complete&&(void 0===n.naturalWidth||0!=n.naturalWidth))},n}(),S=function(){function n(){this.pointer=0,this.tilesMap={},this.tilesArray=new Array(800);for(var n=0;n<800;n++)this.tilesArray[n]=new C(new Image,null)}return n.prototype.addTile=function(n){if(this.getTile(n))return null;var e=this.tilesArray[this.pointer];return null!=e.url&&(e.img.src=null,delete this.tilesMap[e.url]),this.tilesArray[this.pointer].url=n,this.tilesMap[n]=this.tilesArray[this.pointer],this.pointer++,this.pointer>=800&&(this.pointer=0),this.tilesMap[n]},n.prototype.getTile=function(n){return this.tilesMap[n]},n}(),P=function(){let n=function(n){this.view=n,this.nbDownloads=0,this.dlQueue=[],this.urlsInQueue={}};return n.prototype.emptyQueue=function(){this.dlQueue=[],this.urlsInQueue={}},n.prototype.requestDownload=function(n,e,t){e in this.urlsInQueue||(this.dlQueue.push({img:n,url:e,cors:t}),this.urlsInQueue[e]=1,this.tryDownload())},n.prototype.tryDownload=function(){for(;this.dlQueue.length>0&&this.nbDownloads<4;)this.startDownloadNext()},n.prototype.startDownloadNext=function(){var n=this.dlQueue.shift();if(n){this.nbDownloads++;var e=this;n.img.onload=function(){e.completeDownload(this,!0)},n.img.onerror=function(n){e.completeDownload(this,!1)},n.cors?n.img.crossOrigin="anonymous":void 0!==n.img.crossOrigin&&delete n.img.crossOrigin,n.img.src=n.url}},n.prototype.completeDownload=function(n,e){(delete this.urlsInQueue[n.src],n.onerror=null,n.onload=null,this.nbDownloads--,e)?this.view.requestRedraw():n.dlError=!0;this.tryDownload()},n}(),T=function(){function n(n,e,t){var r,i,a;for(i=0;i<30;i++)for(r=0;r<73;r++)n[a=4*(r+74*i)]=n[a+4],n[a+1]=n[a+5],n[a+2]=n[a+6];for(i=0;i<30;i++)a=4*(73+74*i),i<e?(n[a]=A[t].bg.r,n[a+1]=A[t].bg.g,n[a+2]=A[t].bg.b):(n[a]=A[t].fg.r,n[a+1]=A[t].fg.g,n[a+2]=A[t].fg.b)}var e,t,r,i,a,o,s,l,c,f,u,h,p,d,x=0,_=2,v=0,m=(new Date).getTime(),g=m,y=m,b=0,E=1e3,w=0,I=0,C=1e3,S=0,P=0,T=1e3,R=0,A={fps:{bg:{r:16,g:16,b:48},fg:{r:0,g:255,b:255}},ms:{bg:{r:16,g:48,b:16},fg:{r:0,g:255,b:0}},mb:{bg:{r:48,g:16,b:26},fg:{r:255,g:0,b:128}}};(e=document.createElement("div")).style.cursor="pointer",e.style.width="80px",e.style.opacity="0.9",e.style.zIndex="10001",e.addEventListener("click",(function(){switch(++x==_&&(x=0),t.style.display="none",s.style.display="none",u.style.display="none",x){case 0:t.style.display="block";break;case 1:s.style.display="block";break;case 2:u.style.display="block"}}),!1),(t=document.createElement("div")).style.backgroundColor="rgb("+Math.floor(A.fps.bg.r/2)+","+Math.floor(A.fps.bg.g/2)+","+Math.floor(A.fps.bg.b/2)+")",t.style.padding="2px 0px 3px 0px",e.appendChild(t),(r=document.createElement("div")).style.fontFamily="Helvetica, Arial, sans-serif",r.style.textAlign="left",r.style.fontSize="9px",r.style.color="rgb("+A.fps.fg.r+","+A.fps.fg.g+","+A.fps.fg.b+")",r.style.margin="0px 0px 1px 3px",r.innerHTML='<span style="font-weight:bold">FPS</span>',t.appendChild(r),(i=document.createElement("canvas")).width=74,i.height=30,i.style.display="block",i.style.marginLeft="3px",t.appendChild(i),(a=i.getContext("2d")).fillStyle="rgb("+A.fps.bg.r+","+A.fps.bg.g+","+A.fps.bg.b+")",a.fillRect(0,0,i.width,i.height),o=a.getImageData(0,0,i.width,i.height),(s=document.createElement("div")).style.backgroundColor="rgb("+Math.floor(A.ms.bg.r/2)+","+Math.floor(A.ms.bg.g/2)+","+Math.floor(A.ms.bg.b/2)+")",s.style.padding="2px 0px 3px 0px",s.style.display="none",e.appendChild(s),(l=document.createElement("div")).style.fontFamily="Helvetica, Arial, sans-serif",l.style.textAlign="left",l.style.fontSize="9px",l.style.color="rgb("+A.ms.fg.r+","+A.ms.fg.g+","+A.ms.fg.b+")",l.style.margin="0px 0px 1px 3px",l.innerHTML='<span style="font-weight:bold">MS</span>',s.appendChild(l),(i=document.createElement("canvas")).width=74,i.height=30,i.style.display="block",i.style.marginLeft="3px",s.appendChild(i),(c=i.getContext("2d")).fillStyle="rgb("+A.ms.bg.r+","+A.ms.bg.g+","+A.ms.bg.b+")",c.fillRect(0,0,i.width,i.height),f=c.getImageData(0,0,i.width,i.height);try{performance&&performance.memory&&performance.memory.totalJSHeapSize&&(_=3)}catch(n){}return(u=document.createElement("div")).style.backgroundColor="rgb("+Math.floor(A.mb.bg.r/2)+","+Math.floor(A.mb.bg.g/2)+","+Math.floor(A.mb.bg.b/2)+")",u.style.padding="2px 0px 3px 0px",u.style.display="none",e.appendChild(u),(h=document.createElement("div")).style.fontFamily="Helvetica, Arial, sans-serif",h.style.textAlign="left",h.style.fontSize="9px",h.style.color="rgb("+A.mb.fg.r+","+A.mb.fg.g+","+A.mb.fg.b+")",h.style.margin="0px 0px 1px 3px",h.innerHTML='<span style="font-weight:bold">MB</span>',u.appendChild(h),(i=document.createElement("canvas")).width=74,i.height=30,i.style.display="block",i.style.marginLeft="3px",u.appendChild(i),(p=i.getContext("2d")).fillStyle="#301010",p.fillRect(0,0,i.width,i.height),d=p.getImageData(0,0,i.width,i.height),{domElement:e,update:function(){v++,m=(new Date).getTime(),I=m-g,C=Math.min(C,I),S=Math.max(S,I),n(f.data,Math.min(30,30-I/200*30),"ms"),l.innerHTML='<span style="font-weight:bold">'+I+" MS</span> ("+C+"-"+S+")",c.putImageData(f,0,0),g=m,m>y+1e3&&(b=Math.round(1e3*v/(m-y)),E=Math.min(E,b),w=Math.max(w,b),n(o.data,Math.min(30,30-b/100*30),"fps"),r.innerHTML='<span style="font-weight:bold">'+b+" FPS</span> ("+E+"-"+w+")",a.putImageData(o,0,0),3==_&&(P=954e-9*performance.memory.usedJSHeapSize,T=Math.min(T,P),R=Math.max(R,P),n(d.data,Math.min(30,30-P/2),"mb"),h.innerHTML='<span style="font-weight:bold">'+Math.round(P)+" MB</span> ("+Math.round(T)+"-"+Math.round(R)+")",p.putImageData(d,0,0)),y=m,v=0)}}},R=function(){let n=function(n){this.view=n,this.reversed=!1,this.mapName="native",this.sig=this.signature()};return(n.MAPS={}).eosb={name:"Eos B",r:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,18,27,36,45,49,57,72,81,91,100,109,118,127,136,131,139,163,173,182,191,200,209,218,227,213,221,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,253,251,249,247,245,243,241,215,214,235,234,232,230,228,226,224,222,198,196,216,215,213,211,209,207,205,203,181,179,197,196,194,192,190,188,186,184,164,162,178,176,175,173,171,169,167,165,147,145,159,157,156,154,152,150,148,146,130,128,140,138,137,135,133,131,129,127,113,111,121,119,117,117],g:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,15,23,31,39,47,55,57,64,79,87,95,103,111,119,127,135,129,136,159,167,175,183,191,199,207,215,200,207,239,247,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,250,246,242,238,233,229,225,198,195,212,208,204,199,195,191,187,182,160,156,169,165,161,157,153,148,144,140,122,118,127,125,123,121,119,116,114,112,99,97,106,104,102,99,97,95,93,91,80,78,84,82,80,78,76,74,72,70,61,59,63,61,59,57,55,53,50,48,42,40,42,40,38,36,33,31,29,27,22,21,21,19,16,14,12,13,8,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],b:[116,121,127,131,136,140,144,148,153,157,145,149,170,174,178,182,187,191,195,199,183,187,212,216,221,225,229,233,238,242,221,225,255,247,239,231,223,215,207,199,172,164,175,167,159,151,143,135,127,119,100,93,95,87,79,71,63,55,47,39,28,21,15,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},n.MAPS.rainbow={name:"Rainbow",r:[0,4,9,13,18,22,27,31,36,40,45,50,54,58,61,64,68,69,72,74,77,79,80,82,83,85,84,86,87,88,86,87,87,87,85,84,84,84,83,79,78,77,76,71,70,68,66,60,58,55,53,46,43,40,36,33,25,21,16,12,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,21,25,29,33,42,46,51,55,63,67,72,76,80,89,93,97,101,110,114,119,123,131,135,140,144,153,157,161,165,169,178,182,187,191,199,203,208,212,221,225,229,233,242,246,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],g:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,16,21,25,29,38,42,46,51,55,63,67,72,76,84,89,93,97,106,110,114,119,127,131,135,140,144,152,157,161,165,174,178,182,187,195,199,203,208,216,220,225,229,233,242,246,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,242,238,233,229,221,216,212,208,199,195,191,187,178,174,170,165,161,153,148,144,140,131,127,123,119,110,106,102,97,89,85,80,76,72,63,59,55,51,42,38,34,29,21,17,12,8,0],b:[0,3,7,10,14,19,23,28,32,38,43,48,53,59,63,68,72,77,81,86,91,95,100,104,109,113,118,122,127,132,136,141,145,150,154,159,163,168,173,177,182,186,191,195,200,204,209,214,218,223,227,232,236,241,245,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,246,242,238,233,225,220,216,212,203,199,195,191,187,178,174,170,165,157,152,148,144,135,131,127,123,114,110,106,102,97,89,84,80,76,67,63,59,55,46,42,38,34,25,21,16,12,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},n.MAPS.cubehelix={name:"Cubehelix",r:[0,1,3,4,6,8,9,10,12,13,14,15,17,18,19,20,20,21,22,23,23,24,24,25,25,25,26,26,26,26,26,26,26,26,26,26,26,25,25,25,25,24,24,24,23,23,23,23,22,22,22,21,21,21,21,21,21,20,20,20,21,21,21,21,21,22,22,22,23,23,24,25,26,27,27,28,30,31,32,33,35,36,38,39,41,43,45,47,49,51,53,55,57,60,62,65,67,70,72,75,78,81,83,86,89,92,95,98,101,104,107,110,113,116,120,123,126,129,132,135,138,141,144,147,150,153,155,158,161,164,166,169,171,174,176,178,181,183,185,187,189,191,193,194,196,198,199,201,202,203,204,205,206,207,208,209,209,210,211,211,211,212,212,212,212,212,212,212,212,211,211,211,210,210,210,209,208,208,207,207,206,205,205,204,203,203,202,201,201,200,199,199,198,197,197,196,196,195,195,194,194,194,193,193,193,193,193,193,193,193,193,193,194,194,195,195,196,196,197,198,199,200,200,202,203,204,205,206,208,209,210,212,213,215,217,218,220,222,223,225,227,229,231,232,234,236,238,240,242,244,245,247,249,251,253,255],g:[0,0,1,1,2,2,3,4,4,5,6,6,7,8,9,10,11,11,12,13,14,15,17,18,19,20,21,22,24,25,26,28,29,31,32,34,35,37,38,40,41,43,45,46,48,50,52,53,55,57,58,60,62,64,66,67,69,71,73,74,76,78,79,81,83,84,86,88,89,91,92,94,95,97,98,99,101,102,103,104,106,107,108,109,110,111,112,113,114,114,115,116,116,117,118,118,119,119,120,120,120,121,121,121,121,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,121,121,121,121,121,121,121,121,121,120,120,120,120,120,120,120,120,120,120,121,121,121,121,121,122,122,122,123,123,124,124,125,125,126,127,127,128,129,130,131,131,132,133,135,136,137,138,139,140,142,143,144,146,147,149,150,152,154,155,157,158,160,162,164,165,167,169,171,172,174,176,178,180,182,183,185,187,189,191,193,194,196,198,200,202,203,205,207,208,210,212,213,215,216,218,219,221,222,224,225,226,228,229,230,231,232,233,235,236,237,238,239,240,240,241,242,243,244,244,245,246,247,247,248,248,249,250,250,251,251,252,252,253,253,254,255],b:[0,1,3,4,6,8,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,48,50,52,54,56,57,59,60,62,63,65,66,67,69,70,71,72,73,74,74,75,76,76,77,77,77,78,78,78,78,78,78,78,77,77,77,76,76,75,75,74,73,73,72,71,70,69,68,67,66,66,65,64,63,61,60,59,58,58,57,56,55,54,53,52,51,51,50,49,49,48,48,47,47,47,46,46,46,46,46,47,47,47,48,48,49,50,50,51,52,53,55,56,57,59,60,62,64,65,67,69,71,74,76,78,81,83,86,88,91,94,96,99,102,105,108,111,114,117,120,124,127,130,133,136,140,143,146,149,153,156,159,162,165,169,172,175,178,181,184,186,189,192,195,197,200,203,205,207,210,212,214,216,218,220,222,224,226,227,229,230,231,233,234,235,236,237,238,239,239,240,241,241,242,242,242,243,243,243,243,243,243,243,243,243,243,242,242,242,242,241,241,241,241,240,240,240,239,239,239,239,239,238,238,238,238,238,238,238,238,239,239,239,240,240,240,241,242,242,243,244,245,246,247,248,249,250,252,253,255]},n.MAPS_NAMES=["native","grayscale"].concat(n.MAPS_CUSTOM=["cubehelix","eosb","rainbow"]),n.prototype.reverse=function(n){this.reversed=n||!this.reversed,this.sig=this.signature(),this.view.requestRedraw()},n.prototype.signature=function(){var n=this.mapName;return this.reversed&&(n+=" reversed"),n},n.prototype.update=function(n){this.mapName=n,this.sig=this.signature(),this.view.requestRedraw()},n.prototype.apply=function(e){if("native"==this.sig)return e;if(e.cmSig==this.sig)return e.cmImg;var t=document.createElement("canvas");t.width=e.width,t.height=e.height;var r=t.getContext("2d");r.drawImage(e,0,0);var i,a,o,s=r.getImageData(0,0,t.width,t.height),l=s.data,c=l.length,f=3;"grayscale"==this.mapName?f=1:n.MAPS_CUSTOM.indexOf(this.mapName)>=0&&(f=2);for(var u=0;u<c;u+=4){switch(f){case 1:i=a=o=m.myRound((l[u]+l[u+1]+l[u+2])/3);break;case 2:this.reversed?(i=n.MAPS[this.mapName].r[255-l[u]],a=n.MAPS[this.mapName].g[255-l[u+1]],o=n.MAPS[this.mapName].b[255-l[u+2]]):(i=n.MAPS[this.mapName].r[l[u]],a=n.MAPS[this.mapName].g[l[u+1]],o=n.MAPS[this.mapName].b[l[u+2]]);break;default:i=l[u],a=l[u+1],o=l[u+2]}2!=f&&this.reversed&&(i=255-i,a=255-a,o=255-o),l[u]=i,l[u+1]=a,l[u+2]=o}return r.putImageData(s,0,0),e.cmSig=this.sig,e.cmImg=t,e.cmImg},n}(),B=function(){let n=function(n){this.polygons=n,this.overlay=null,this.id="footprint-"+a.uuidv4(),this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.dispatchClickEvent=function(){this.overlay&&this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent("footprintClicked",{detail:{footprintId:this.id,overlayName:this.overlay.name}}))},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n}(),L=function(){let n=function(n,e,t){t=t||{},this.color=t.color||void 0,this.id="circle-"+a.uuidv4(),this.setCenter(n),this.setRadius(e),this.overlay=null,this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.dispatchClickEvent=function(){this.overlay&&this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent("footprintClicked",{detail:{footprintId:this.id,overlayName:this.overlay.name}}))},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n.prototype.setCenter=function(n){this.centerRaDec=n,this.overlay&&this.overlay.reportChange()},n.prototype.setRadius=function(n){this.radiusDegrees=n,this.overlay&&this.overlay.reportChange()},n.prototype.draw=function(n,e,t,r,i,a,o,s,l){if(!this.isShowing)return;l=!0===l||!1;var c=m.radecToViewXy(this.centerRaDec[0],this.centerRaDec[1],e);if(!c)return;var f=this.centerRaDec[0],u=this.centerRaDec[1]+(f>0?-this.radiusDegrees:this.radiusDegrees);let h=m.radecToViewXy(f,u,e);if(h){var p=h[0]-c[0],d=h[1]-c[1],x=Math.sqrt(p*p+d*d),_=this.color;!_&&this.overlay&&(_=this.overlay.color),_||(_="#ff0000"),this.isSelected?n.strokeStyle=Overlay.increaseBrightness(_,50):n.strokeStyle=_,n.beginPath(),n.arc(c[0],c[1],x,0,2*Math.PI,!1),l||n.stroke()}},n}(),k=function(){let n={GALACTIC_TO_J2000:[-.0548755604024359,.4941094279435681,-.867666148981161,-.8734370902479237,-.4448296299195045,-.1980763734646737,-.4838350155267381,.7469822444763707,.4559837762325372],J2000_TO_GALACTIC:[-.0548755604024359,-.873437090247923,-.4838350155267381,.4941094279435681,-.4448296299195045,.7469822444763707,-.867666148981161,-.1980763734646737,.4559837762325372],Transform:function(n,e){n[0]=n[0]*Math.PI/180,n[1]=n[1]*Math.PI/180;var t=new Array(Math.cos(n[0])*Math.cos(n[1]),Math.sin(n[0])*Math.cos(n[1]),Math.sin(n[1])),r=new Array(t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8]),i=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]),a=new Array(0,0);a[1]=Math.asin(r[2]/i);var o=r[0]/i/Math.cos(a[1]),s=r[1]/i/Math.cos(a[1]);return a[0]=Math.atan2(s,o),a[0]<0&&(a[0]=a[0]+2*Math.PI),a[0]=180*a[0]/Math.PI,a[1]=180*a[1]/Math.PI,a},GalacticToJ2000:function(e){return n.Transform(e,n.GALACTIC_TO_J2000)},J2000ToGalactic:function(e){return n.Transform(e,n.J2000_TO_GALACTIC)}};return n}(),O=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;var D=t(1),M=t.n(D),q=t(2),N=t.n(q),F=t(3),G=t.n(F),j=t(4),H=t.n(j),U=t(5),V=t.n(U),Y=t(6),J=t.n(Y),X=t(7),W=t.n(X),Z=t(8),K=t.n(Z),Q=t(9),nn=t.n(Q),en=t(10),tn=t.n(en),rn=t(11),an=t.n(rn),on=t(12),sn=t.n(on),ln=t(13),cn=t.n(ln),fn=t(14),un=t.n(fn),hn=t(15),pn=t.n(hn),dn=t(16),xn=t.n(dn),_n=t(17),vn=t.n(_n),mn=t(18),gn=t.n(mn),yn=t(19),bn=t.n(yn),En=t(20),wn=t.n(En),In=t(21),Cn=t.n(In),Sn=t(22),Pn=t.n(Sn),Tn=t(23),Rn=t.n(Tn),An=t(24),zn=t.n(An),Bn=t(25),Ln=t.n(Bn),kn=t(26),On=t.n(kn),Dn=t(27),Mn=t.n(Dn),qn=t(28),Nn=t.n(qn),Fn=t(29),Gn=t.n(Fn),jn=t(30),Hn=t.n(jn),Un=t(31),Vn=t.n(Un),Yn=t(32),Jn=t.n(Yn),Xn=t(33),$n=t.n(Xn),Wn=t(34),Zn=t.n(Wn),Kn=t(35),Qn=t.n(Kn),ne=t(36),ee=t.n(ne),te=t(37),re=t.n(te),ie=t(38),ae=t.n(ie),oe=t(39),se=t.n(oe),le=t(40),ce=t.n(le),fe=t(41),ue=t.n(fe),he=t(42),pe=t.n(he),de=t(43),xe=t.n(de);let _e=[{id:"CatalogAitoffVS",content:M.a},{id:"CatalogMercatVS",content:N.a},{id:"CatalogArcVS",content:G.a},{id:"CatalogTanVS",content:H.a},{id:"CatalogMollVS",content:V.a},{id:"CatalogOrthoVS",content:J.a},{id:"CatalogOrthoFS",content:W.a},{id:"CatalogFS",content:K.a},{id:"ColormapVS",content:nn.a},{id:"ColormapBlackWhiteFS",content:tn.a},{id:"ColormapBluePastelRedFS",content:an.a},{id:"ColormapIDL_CB_BrBGFS",content:sn.a},{id:"ColormapIDL_CB_GnBuFS",content:cn.a},{id:"ColormapIDL_CB_YIGnBuFS",content:un.a},{id:"ColormapRedTemperatureFS",content:pn.a},{id:"GridVS",content:xn.a},{id:"GridAitoffFS",content:vn.a},{id:"GridMollFS",content:gn.a},{id:"GridOrthoFS",content:bn.a},{id:"GridMercatorFS",content:wn.a},{id:"GridArcFS",content:Cn.a},{id:"GridTanFS",content:Pn.a},{id:"GridFS_CPU",content:zn.a},{id:"GridVS_CPU",content:Rn.a},{id:"RayTracerVS",content:Ln.a},{id:"RayTracerColorFS",content:On.a},{id:"RayTracerGrayscale2ColorFS",content:Mn.a},{id:"RayTracerGrayscale2ColormapFS",content:Nn.a},{id:"RayTracerGrayscale2ColorIntegerFS",content:Gn.a},{id:"RayTracerGrayscale2ColormapIntegerFS",content:Hn.a},{id:"RasterizerOrthoVS",content:Vn.a},{id:"RasterizerMercatorVS",content:Jn.a},{id:"RasterizerAitoffVS",content:$n.a},{id:"RasterizerArcVS",content:Qn.a},{id:"RasterizerGnomonicVS",content:Zn.a},{id:"RasterizerMollVS",content:ee.a},{id:"RasterizerColorFS",content:re.a},{id:"RasterizerGrayscale2ColorFS",content:ae.a},{id:"RasterizerGrayscale2ColormapFS",content:se.a},{id:"RasterizerGrayscale2ColorIntegerFS",content:ce.a},{id:"RasterizerGrayscale2ColormapIntegerFS",content:ue.a},{id:"TextVS",content:pe.a},{id:"TextFS",content:xe.a}];var ve=t.p+"ccdb93d24585bd08a4261722b95e9e3d.png";let me=function(){let n=function(n){this.surveys=new Map,this.name=n};return n.prototype.addImageSurvey=async function(n){const e=await s.create(n);this.surveys.set(n,e)},n.prototype.removeImageSurvey=function(n){this.surveys.remove(n)},n.prototype.clear=function(){this.surveys.clear()},n.prototype.getSurveys=function(){return this.surveys.values()},n}(),ge=function(){function n(e,t,a,s,l){this.aladin=e,this.options=e.options,this.aladinDiv=this.aladin.aladinDiv,this.popup=new r(this.aladinDiv,this),this.createCanvases();let u=_e,h={kernel:ve};var p;if(this.aladin.webglAPI=new De.wasmLibs.webgl.WebClient(u,h),this.aladin.webglAPI.resize(500,400),this.location=t,this.fovDiv=a,this.mustClearCatalog=!0,this.mustRedrawReticle=!0,this.imageSurveysToSet=[],this.mode=n.PAN,this.minFOV=this.maxFOV=null,this.fov_limit=180,this.healpixGrid=new i(this.imageCanvas),p=0,this.projectionMethod=f.SIN,this.projection=new c(p,0),this.projection.setProjection(this.projectionMethod),this.prev=0,this.zoomFactor=this.aladin.webglAPI.getClipZoomFactor(),this.viewCenter={lon:p,lat:0},this.cooFrame=s||_.GAL,s.system===_.SYSTEMS.GAL){console.log();const n=De.wasmLibs.webgl.GALCooSys();this.aladin.webglAPI.setCooSystem(n)}else{const n=De.wasmLibs.webgl.ICRSJ2000CooSys();this.aladin.webglAPI.setCooSystem(n)}l&&this.setZoom(l),this.imageSurveys=new Map,this.catalogs=[];var d=document.createElement("canvas");d.width=d.height=24;var x=d.getContext("2d");x.lineWidth=6,x.beginPath(),x.strokeStyle="#eee",x.arc(12,12,8,0,2*Math.PI,!0),x.stroke(),x.lineWidth=3,x.beginPath(),x.strokeStyle="#c38",x.arc(12,12,8,0,2*Math.PI,!0),x.stroke(),this.catalogForPopup=A.catalog({shape:d,sourceSize:24}),this.catalogForPopup.hide(),this.catalogForPopup.setView(this),this.overlays=[],this.mocs=[],this.allOverlayLayers=[],this.tileBuffer=new S,this.fixLayoutDimensions(),this.firstHiPS=!0,this.curNorder=1,this.realNorder=1,this.curOverlayNorder=1,this.dragging=!1,this.dragx=null,this.dragy=null,this.needRedraw=!0,this.pinchZoomParameters={isPinching:!1,initialFov:void 0,initialDistance:void 0},this.downloader=new P(this),this.flagForceRedraw=!1,this.fadingLatestUpdate=null,this.dateRequestRedraw=null,this.showGrid=!1,o(this),this.resizeTimer=null;var v=this;$(window).resize((function(){clearTimeout(v.resizeTimer),v.resizeTimer=setTimeout((function(){v.fixLayoutDimensions(v)}),100)})),setTimeout((function(){var n=$(v.aladinDiv).width(),e=$(v.aladinDiv).height();v.width===n&&v.height!==e||(v.fixLayoutDimensions(),v.updateZoomState())}),1e3)}n.PAN=0,n.SELECT=1,n.TOOL_SIMBAD_POINTER=2,n.DRAW_SOURCES_WHILE_DRAGGING=!0,n.DRAW_MOCS_WHILE_DRAGGING=!0,n.CALLBACKS_THROTTLE_TIME_MS=100,n.prototype.createCanvases=function(){var n=$(this.aladinDiv);n.find(".aladin-imageCanvas").remove(),n.find(".aladin-catalogCanvas").remove(),n.find(".aladin-reticleCanvas").remove(),n.find(".aladin-gridCanvas").remove(),this.imageCanvas=$("<canvas class='aladin-imageCanvas'></canvas>").appendTo(this.aladinDiv)[0],this.gridCanvas=$("<canvas class='aladin-gridCanvas'></canvas>").appendTo(this.aladinDiv)[0],this.catalogCanvas=$("<canvas class='aladin-catalogCanvas'></canvas>").appendTo(this.aladinDiv)[0],this.reticleCanvas=$("<canvas class='aladin-reticleCanvas'></canvas>").appendTo(this.aladinDiv)[0]},n.prototype.fixLayoutDimensions=function(){a.cssScale=void 0;var n=$(this.aladinDiv).width(),t=$(this.aladinDiv).height();this.width=Math.max(n,1),this.height=Math.max(t,1),this.cx=this.width/2,this.cy=this.height/2,this.largestDim=Math.max(this.width,this.height),this.smallestDim=Math.min(this.width,this.height),this.ratio=this.largestDim/this.smallestDim,this.mouseMoveIncrement=160/this.largestDim,this.imageCtx=this.imageCanvas.getContext("webgl2"),this.aladin.webglAPI.resize(this.width,this.height),this.catalogCtx=this.catalogCanvas.getContext("2d"),this.reticleCtx=this.reticleCanvas.getContext("2d"),this.gridCtx=this.gridCanvas.getContext("2d"),this.imageCtx.canvas.width=this.width,this.catalogCtx.canvas.width=this.width,this.reticleCtx.canvas.width=this.width,this.gridCtx.canvas.width=this.width,this.imageCtx.canvas.height=this.height,this.catalogCtx.canvas.height=this.height,this.reticleCtx.canvas.height=this.height,this.gridCtx.canvas.height=this.height,e(this.imageCtx,this.aladin.options.pixelateCanvas),this.logoDiv||(this.logoDiv=$(this.aladinDiv).find(".aladin-logo")[0]),this.width>800?($(this.logoDiv).removeClass("aladin-logo-small"),$(this.logoDiv).addClass("aladin-logo-large"),$(this.logoDiv).css("width","90px")):($(this.logoDiv).addClass("aladin-logo-small"),$(this.logoDiv).removeClass("aladin-logo-large"),$(this.logoDiv).css("width","32px")),this.computeNorder()};var e=function(n,e){var t=!e;n.imageSmoothingEnabled=t,n.webkitImageSmoothingEnabled=t,n.mozImageSmoothingEnabled=t,n.msImageSmoothingEnabled=t,n.oImageSmoothingEnabled=t};n.prototype.setMode=function(e){this.mode=e,this.mode==n.SELECT?this.setCursor("crosshair"):this.mode==n.TOOL_SIMBAD_POINTER?(this.popup.hide(),this.reticleCanvas.style.cursor="",$(this.reticleCanvas).addClass("aladin-sp-cursor")):this.setCursor("default")},n.prototype.setCursor=function(e){this.reticleCanvas.style.cursor!=e&&this.mode!=n.TOOL_SIMBAD_POINTER&&(this.reticleCanvas.style.cursor=e)},n.prototype.getCanvasDataURL=function(n,e,t){n=n||"image/png";var r=document.createElement("canvas");e=e||this.width,t=t||this.height,r.width=e,r.height=t;var i=r.getContext("2d");return i.drawImage(this.imageCanvas,0,0,r.width,r.height),i.drawImage(this.catalogCanvas,0,0,r.width,r.height),i.drawImage(this.reticleCanvas,0,0,r.width,r.height),i.drawImage(this.gridCanvas,0,0,r.width,r.height),r.toDataURL(n)};var t=function(e){var t=!1;"ontouchstart"in window&&(t=!0);let r=function(n){var t,r=e.imageCanvas.relMouseCoords(n);try{var i=e.aladin.webglAPI.screenToWorld(r.x,r.y)}catch(n){return}t=i,e.pointTo(t[0],t[1],{forceAnimation:!0})};var i;t||$(e.reticleCanvas).dblclick(r),$(e.reticleCanvas).bind("mousedown touchstart",(function(t){if("touchstart"===t.type&&t.originalEvent&&t.originalEvent.targetTouches&&2==t.originalEvent.targetTouches.length){e.dragging=!1,e.pinchZoomParameters.isPinching=!0;var r=e.aladin.webglAPI.getFieldOfView();return e.pinchZoomParameters.initialFov=r,void(e.pinchZoomParameters.initialDistance=Math.sqrt(Math.pow(t.originalEvent.targetTouches[0].clientX-t.originalEvent.targetTouches[1].clientX,2)+Math.pow(t.originalEvent.targetTouches[0].clientY-t.originalEvent.targetTouches[1].clientY,2)))}var i=e.imageCanvas.relMouseCoords(t);return t.originalEvent&&t.originalEvent.targetTouches?(e.dragx=t.originalEvent.targetTouches[0].clientX,e.dragy=t.originalEvent.targetTouches[0].clientY):(e.dragx=i.x,e.dragy=i.y),e.dragging=!0,e.mode==n.PAN?e.setCursor("move"):e.mode==n.SELECT&&(e.selectStartCoo={x:e.dragx,y:e.dragy}),e.aladin.webglAPI.pressLeftMouseButton(),!1})),$(e.reticleCanvas).bind("click mouseout touchend",(function(t){if("touchend"===t.type&&e.pinchZoomParameters.isPinching)return e.pinchZoomParameters.isPinching=!1,void(e.pinchZoomParameters.initialFov=e.pinchZoomParameters.initialDistance=void 0);var r=!0===e.realDragging,i=e.mode===n.SELECT&&e.dragging;if(e.dragging&&(e.setCursor("default"),e.dragging=!1,r)){e.realDragging=!1;var a=e.aladin.callbacksByEventName.positionChanged;if("function"==typeof a)void 0!==(h=e.aladin.pix2world(e.width/2,e.height/2))&&a({ra:h[0],dec:h[1],dragging:!1})}if(i)return e.aladin.fire("selectend",e.getObjectsInBBox(e.selectStartCoo.x,e.selectStartCoo.y,e.dragx-e.selectStartCoo.x,e.dragy-e.selectStartCoo.y)),e.mustRedrawReticle=!0,void e.requestRedraw();if(e.mustClearCatalog=!0,e.mustRedrawReticle=!0,e.dragx=e.dragy=null,"mouseout"!==t.type&&"touchend"!==t.type||(e.requestRedraw(!0),l(e,e.width/2,e.height/2,!0),"mouseout"!==t.type)){var o=e.imageCanvas.relMouseCoords(t);if(e.mode==n.TOOL_SIMBAD_POINTER){var s=e.aladin.pix2world(o.x,o.y);return e.setMode(n.PAN),e.setCursor("wait"),void I.SimbadPointer.query(s[0],s[1],Math.min(1,15*e.fov/e.largestDim),e.aladin)}var c=e.closestObjects(o.x,o.y,5);if(!r&&c){var f=c[0];f instanceof B||f instanceof L?f.dispatchClickEvent():f.marker?(e.popup.setTitle(f.popupTitle),e.popup.setText(f.popupDesc),e.popup.setSource(f),e.popup.show()):(e.lastClickedObject&&e.lastClickedObject.actionOtherObjectClicked&&e.lastClickedObject.actionOtherObjectClicked(),f.actionClicked()),e.lastClickedObject=f,"function"==typeof(u=e.aladin.callbacksByEventName.objectClicked)&&u(f)}else{var u;if(e.lastClickedObject&&!r)e.aladin.measurementTable.hide(),e.popup.hide(),e.lastClickedObject instanceof B||e.lastClickedObject.actionOtherObjectClicked(),e.lastClickedObject=null,"function"==typeof(u=e.aladin.callbacksByEventName.objectClicked)&&u(null)}var h,p=e.aladin.callbacksByEventName.click;if("function"==typeof p)void 0!==(h=e.aladin.pix2world(o.x,o.y))&&p({ra:h[0],dec:h[1],x:o.x,y:o.y,isDragging:r});e.refreshProgressiveCats(),e.requestRedraw(!0),e.aladin.webglAPI.releaseLeftButtonMouse()}else e.mode===n.TOOL_SIMBAD_POINTER&&e.setMode(n.PAN)}));var o=null;let s=e.aladin.webglAPI;$(e.reticleCanvas).bind("mousemove touchmove",(function(r){if(r.preventDefault(),"touchmove"===r.type&&e.pinchZoomParameters.isPinching&&r.originalEvent&&r.originalEvent.touches&&2==r.originalEvent.touches.length){var a=Math.sqrt(Math.pow(r.originalEvent.touches[0].clientX-r.originalEvent.touches[1].clientX,2)+Math.pow(r.originalEvent.touches[0].clientY-r.originalEvent.touches[1].clientY,2));return void e.setZoom(e.pinchZoomParameters.initialFov*e.pinchZoomParameters.initialDistance/a)}var c,f,u=e.imageCanvas.relMouseCoords(r);if(!e.dragging||t){l(e,u.x,u.y);var h=e.aladin.callbacksByEventName.mouseMove;if("function"==typeof h){var p=e.aladin.pix2world(u.x,u.y);void 0!==p?h({ra:p[0],dec:p[1],x:u.x,y:u.y}):null!=o&&h({ra:null,dec:null,x:u.x,y:u.y}),o=p}if(!e.dragging&&!e.mode==n.SELECT){var d=e.closestObjects(u.x,u.y,5);if(d){if(e.setCursor("pointer"),"function"==typeof(x=e.aladin.callbacksByEventName.objectHovered)&&d[0]!=i)x(d[0]);i=d[0]}else{var x;if(e.setCursor("default"),"function"==typeof(x=e.aladin.callbacksByEventName.objectHovered)&&i){i=null;x(null)}}}if(!t)return}if(!e.dragging)return;if(r.originalEvent&&r.originalEvent.targetTouches?(c={x:e.dragx,y:e.dragy},f={x:r.originalEvent.targetTouches[0].clientX,y:r.originalEvent.targetTouches[0].clientY}):(c={x:e.dragx,y:e.dragy},f={x:u.x,y:u.y}),r.originalEvent&&r.originalEvent.targetTouches?(e.dragx=r.originalEvent.targetTouches[0].clientX,e.dragy=r.originalEvent.targetTouches[0].clientY):(e.dragx=u.x,e.dragy=u.y),e.mode==n.SELECT)return void e.requestRedraw();e.viewCenter.lat>90?e.viewCenter.lat=90:e.viewCenter.lat<-90&&(e.viewCenter.lat=-90),e.viewCenter.lon<0?e.viewCenter.lon=360+e.viewCenter.lon:e.viewCenter.lon>360&&(e.viewCenter.lon=e.viewCenter.lon%360),e.realDragging=!0,s.goFromTo(c.x,c.y,f.x,f.y);let _=s.getCenter();e.viewCenter.lon=_[0],e.viewCenter.lat=_[1],e.requestRedraw()})),$(e.aladinDiv).onselectstart=function(){return!1},$(e.reticleCanvas).on("wheel",(function(n){n.preventDefault(),n.stopPropagation();var t=n.deltaY;if(n.hasOwnProperty("originalEvent")&&(t=-n.originalEvent.deltaY),e.aladin.webglAPI.registerWheelEvent(t),e.updateZoomState(),!e.debounceProgCatOnZoom){var r=e;e.debounceProgCatOnZoom=a.debounce((function(){r.refreshProgressiveCats()}),300)}return e.debounceProgCatOnZoom(),!1}))},o=function(e){var r=new T;r.domElement.style.top="50px",$("#aladin-statsDiv").length>0&&$("#aladin-statsDiv")[0].appendChild(r.domElement),e.stats=r,t(e),e.executeCallbacksThrottled=a.throttle((function(){var n=e.aladin.pix2world(e.width/2,e.height/2),t=e.fov;if(void 0!==n&&void 0!==t){var r=n[0],i=n[1];if(r!==this.ra||i!==this.dec){var a=e.aladin.callbacksByEventName.positionChanged;"function"==typeof a&&a({ra:r,dec:i,dragging:!0}),this.ra=r,this.dec=i}if(t!==this.old_fov){var o=e.aladin.callbacksByEventName.zoomChanged;"function"==typeof o&&o(t),this.old_fov=t}}}),n.CALLBACKS_THROTTLE_TIME_MS),e.displayHpxGrid=!1,e.displaySurvey=!0,e.displayCatalog=!1,e.displayReticle=!0};function l(n,e,t,r){if(n.projection){var i;try{i=n.aladin.webglAPI.screenToWorld(e,t)}catch(n){}i&&(n.aladin.webglAPI.cooSystem()===De.wasmLibs.webgl.GALCooSys()&&(i=n.aladin.webglAPI.J20002Gal(i[0],i[1])),n.location.update(i[0],i[1],n.cooFrame,r))}}n.prototype.requestRedrawAtDate=function(n){this.dateRequestDraw=n},n.prototype.getBackgroundColor=function(){var n="rgb(0, 0, 0)";if(!this.imageSurvey)return n;var e=this.imageSurvey.getColorMap();if(!e)return n;if("native"==e.mapName||"grayscale"==e.mapName)return e.reversed?"rgb(255, 255, 255)":n;var t=e.reversed?255:0;return"rgb("+R.MAPS[e.mapName].r[t]+","+R.MAPS[e.mapName].g[t]+","+R.MAPS[e.mapName].b[t]+")"},n.prototype.getViewParams=function(){var n=this.width>this.height?this.fov/this.width:this.fov/this.height;return{fov:[this.width*n,this.height*n],width:this.width,height:this.height}},n.prototype.redraw=function(){var e=this.needRedraw;O(this.redraw.bind(this));var t,r,i=Date.now(),a=i-this.prev;if(this.ready=this.aladin.webglAPI.isReady(),null!==this.imageSurveysToSet&&(this.firstHiPS||this.ready)&&(console.log("surveyes",this.imageSurveysToSet),this.aladin.webglAPI.setImageSurveys(this.imageSurveysToSet),this.imageSurveysToSet=null,this.firstHiPS=!1),this.aladin.webglAPI.update(a,this.needRedraw),t=this,isNaN(t.fov)?t.fovDiv.html("FoV:"):(r=t.fov>1?Math.round(100*t.fov)/100+"°":60*t.fov>1?Math.round(60*t.fov*100)/100+"'":Math.round(3600*t.fov*100)/100+'"',t.fovDiv.html("FoV: "+r)),this.aladin.webglAPI.isCatalogLoaded()){var o=this.aladin.callbacksByEventName.catalogReady;"function"==typeof o&&o()}this.aladin.webglAPI.render(this.needRedraw);this.imageCtx;this.projection.setCenter(this.viewCenter.lon,this.viewCenter.lat);var s=null;if(this.overlayImageSurvey&&this.overlayImageSurvey.isReady,this.displayHpxGrid){var l=this.getVisibleCells(3);s=null;this.curNorder>=3&&(s=3==this.curNorder?l:this.getVisibleCells(this.curNorder)),this.gridCtx.clearRect(0,0,this.imageCanvas.width,this.imageCanvas.height),s&&this.curNorder>3?this.healpixGrid.redraw(this.gridCtx,s,this.fov,this.curNorder):this.healpixGrid.redraw(this.gridCtx,l,this.fov,3)}var c=this.catalogCtx,f=!1;if(this.mustClearCatalog&&(c.clearRect(0,0,this.width,this.height),f=!0,this.mustClearCatalog=!1),this.catalogs&&this.catalogs.length>0&&this.displayCatalog&&(!this.dragging||n.DRAW_SOURCES_WHILE_DRAGGING)){f||(c.clearRect(0,0,this.width,this.height),f=!0);for(var u=0;u<this.catalogs.length;u++){this.catalogs[u].draw(c,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor)}}this.catalogForPopup.isShowing&&this.catalogForPopup.sources.length>0&&(f||(c.clearRect(0,0,this.width,this.height),f=!0),this.catalogForPopup.draw(c,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor));var h=this.catalogCtx;if(this.overlays&&this.overlays.length>0&&(!this.dragging||n.DRAW_SOURCES_WHILE_DRAGGING)){f||(c.clearRect(0,0,this.width,this.height),f=!0);for(u=0;u<this.overlays.length;u++)this.overlays[u].draw(h,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor)}var p=this.catalogCtx;if(this.mocs&&this.mocs.length>0&&(!this.dragging||n.DRAW_MOCS_WHILE_DRAGGING)){f||(c.clearRect(0,0,this.width,this.height),f=!0);for(u=0;u<this.mocs.length;u++)this.mocs[u].draw(p,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor,this.fov)}this.mode==n.SELECT&&(mustRedrawReticle=!0);var d=this.reticleCtx;if((this.mustRedrawReticle||this.mode==n.SELECT)&&d.clearRect(0,0,this.width,this.height),this.displayReticle){if(!this.reticleCache){var x=document.createElement("canvas"),_=this.options.reticleSize;x.width=_,x.height=_;var v=x.getContext("2d");v.lineWidth=2,v.strokeStyle=this.options.reticleColor,v.beginPath(),v.moveTo(_/2,_/2+(_/2-1)),v.lineTo(_/2,_/2+2),v.moveTo(_/2,_/2-(_/2-1)),v.lineTo(_/2,_/2-2),v.moveTo(_/2+(_/2-1),_/2),v.lineTo(_/2+2,_/2),v.moveTo(_/2-(_/2-1),_/2),v.lineTo(_/2-2,_/2),v.stroke(),this.reticleCache=x}d.drawImage(this.reticleCache,this.width/2-this.reticleCache.width/2,this.height/2-this.reticleCache.height/2),this.mustRedrawReticle=!1}e==this.needRedraw&&(this.needRedraw=!1),this.dragging||this.updateObjectsLookup(),this.prev=i},n.prototype.forceRedraw=function(){this.flagForceRedraw=!0},n.prototype.refreshProgressiveCats=function(){if(this.catalogs)for(var n=0;n<this.catalogs.length;n++)"progressivecat"==this.catalogs[n].type&&this.catalogs[n].loadNeededTiles()},n.prototype.getVisiblePixList=function(n,e){var t,r=Math.pow(2,n),i=b.nside2Npix(r);if(this.fov>80){t=[];for(var a=0;a<i;a++)t.push(a)}else{var o=new b(r);o.init();var s=new E;let n=this.aladin.webglAPI.screenToWorld(this.cx,this.cy),e={ra:n[0],dec:n[1]};var l;l=[e.ra,e.dec],s.set(l[0],l[1]);var c=.5*this.fov*this.ratio;this.fov>60?c*=1.6:this.fov>12?c*=1.45:c*=1.1,t=o.queryDisc(s,c*Math.PI/180,!0,!0);var f=b.utils.radecToPolar(l[0],l[1]),u=o.ang2pix_nest(f.theta,f.phi);t.unshift(u)}return t},n.prototype.setAngleRotation=function(n){},n.prototype.getVisibleCells=function(n,e){!e&&this.imageSurvey&&(e=this.imageSurvey.cooFrame);var t,r,i,a,o=[],s=[],l=new E,c=Math.pow(2,n),u=b.nside2Npix(c),h=null;if(this.fov>80){t=[];for(var p=0;p<u;p++)t.push(p)}else{var d=new b(c);d.init();var x=new E,v=(m.viewToXy(this.cx,this.cy,this.width,this.height,this.largestDim,this.zoomFactor),{ra:(v=this.aladin.webglAPI.screenToWorld(this.cx,this.cy))[0],dec:v[1]}),g=[];e&&e.system!=this.cooFrame.system?e.system==_.SYSTEMS.J2000?g=k.GalacticToJ2000([v.ra,v.dec]):e.system==_.SYSTEMS.GAL&&(g=k.J2000ToGalactic([v.ra,v.dec])):g=[v.ra,v.dec],x.set(g[0],g[1]);var y=.5*this.fov*this.ratio;this.fov>60?y*=1.6:this.fov>12?y*=1.45:y*=1.1,t=d.queryDisc(x,y*Math.PI/180,!0,!0);var I=b.utils.radecToPolar(g[0],g[1]);h=d.ang2pix_nest(I.theta,I.phi),t.unshift(h)}for(var C=0,S=t.length;C<S;C++)if(!((p=t[C])==h&&C>0)){var P=[];a=w.corners_nest(p,c);for(var T=0;T<4;T++){if(l.setXYZ(a[T].x,a[T].y,a[T].z),e&&e.system!=this.cooFrame.system){if(e.system==_.SYSTEMS.J2000)r=(v=k.J2000ToGalactic([l.ra(),l.dec()]))[0],i=v[1];else if(e.system==_.SYSTEMS.GAL){r=(v=k.GalacticToJ2000([l.ra(),l.dec()]))[0],i=v[1]}}else r=l.ra(),i=l.dec();s[T]=this.aladin.webglAPI.worldToScreen(r,i)}if(null!=s[0]&&null!=s[1]&&null!=s[2]&&null!=s[3]){for(T=0;T<4;T++)P[T]={vx:s[T][0],vy:s[T][1]};P[0].vx<0&&P[1].vx<0&&P[2].vx<0&&P[3].vx<0||P[0].vy<0&&P[1].vy<0&&P[2].vy<0&&P[3].vy<0||P[0].vx>=this.width&&P[1].vx>=this.width&&P[2].vx>=this.width&&P[3].vx>=this.width||P[0].vy>=this.height&&P[1].vy>=this.height&&P[2].vy>=this.height&&P[3].vy>=this.height||(this.projection.PROJECTION==f.SIN||this.projection.PROJECTION==f.TAN||m.counterClockwiseTriangle(P[0].vx,P[0].vy,P[1].vx,P[1].vy,P[2].vx,P[2].vy)&&m.counterClockwiseTriangle(P[0].vx,P[0].vy,P[2].vx,P[2].vy,P[3].vx,P[3].vy))&&(P.ipix=p,o.push(P))}}return o},n.prototype.getPositionsInView=function(n,e){for(var t,r,i=new E,a=Math.pow(2,e),o=[],s=w.corners_nest(n,a),l=0;l<4;l++){if(i.setXYZ(s[l].x,s[l].y,s[l].z),this.imageSurvey&&this.imageSurvey.cooFrame.system!=this.cooFrame.system){if(this.imageSurvey.cooFrame.system==_.SYSTEMS.J2000)t=(c=k.J2000ToGalactic([i.ra(),i.dec()]))[0],r=c[1];else if(this.imageSurvey.cooFrame.system==_.SYSTEMS.GAL){var c;t=(c=k.GalacticToJ2000([i.ra(),i.dec()]))[0],r=c[1]}}else t=i.ra(),r=i.dec();let n=this.aladin.webglAPI.worldToScreen(t,r);o[l]={vx:n.x,vy:n.y}}return null==o[0]||null==o[1]||null==o[2]||null==o[3]?null:o},n.prototype.setZoom=function(n){n<0||(this.aladin.webglAPI.setFieldOfView(n),this.updateZoomState())},n.prototype.increaseZoom=function(){for(let n=0;n<5;n++)this.aladin.webglAPI.registerWheelEvent(.01)},n.prototype.decreaseZoom=function(){for(let n=0;n<5;n++)this.aladin.webglAPI.registerWheelEvent(-.01)},n.prototype.setShowGrid=function(n){this.showGrid=n,n?this.aladin.webglAPI.enableGrid():this.aladin.webglAPI.disableGrid(),this.requestRedraw()},n.prototype.updateZoomState=function(){this.zoomFactor=this.aladin.webglAPI.getClipZoomFactor(),this.fov=this.aladin.webglAPI.getFieldOfView(),this.computeNorder(),this.forceRedraw()},n.prototype.computeNorder=function(){var n=this.fov/this.largestDim,e=b.calculateNSide(1843200*n),t=Math.log(e)/Math.log(2);t=Math.max(t,1),this.realNorder=t,this.fov<=50&&t<=2&&(t=3),this.imageSurvey&&t<=2&&this.imageSurvey.minOrder>2&&(t=this.imageSurvey.minOrder);var r=t;this.imageSurvey&&t>this.imageSurvey.maxOrder&&(t=this.imageSurvey.maxOrder),this.overlayImageSurvey&&r>this.overlayImageSurvey.maxOrder&&(r=this.overlayImageSurvey.maxOrder),t>b.ORDER_MAX&&(t=b.ORDER_MAX),r>b.ORDER_MAX&&(r=b.ORDER_MAX),this.curNorder=t,this.curOverlayNorder=r},n.prototype.untaintCanvases=function(){this.createCanvases(),t(this),this.fixLayoutDimensions()},n.prototype.setOverlayImageSurvey=async function(n){if(!n)return;let e=await new s(n);this.aladin.webglAPI.setOverlayHiPS(e)},n.prototype.setUnknownSurveyIfNeeded=function(){u&&(this.setImageSurvey(u),u=void 0)};var u=void 0;return n.prototype.addImageSurvey=function(n,e){const t=n.properties.url;n.layer=e,this.imageSurveys.get(e).set(t,n),this.setHiPS()},n.prototype.setImageSurvey=function(n,e){const t=n.properties.url;n.layer=e,this.imageSurveys.set(e,new Map),this.imageSurveys.get(e).set(t,n),this.setHiPS()},n.prototype.setImageSurveysLayer=function(n,e){this.imageSurveys.set(e,new Map),n.forEach(n=>{const t=n.properties.url;n.layer=e,this.imageSurveys.get(e).set(t,n)}),this.setHiPS()},n.prototype.removeImageSurveysLayer=function(n){this.imageSurveys.delete(n),this.setHiPS()},n.prototype.moveImageSurveysLayerForward=function(n){this.aladin.webglAPI.moveImageSurveysLayerForward(n)},n.prototype.setHiPS=function(){let n=[];for(let e of this.imageSurveys.values())for(let t of e.values())n.push(t);this.imageSurveysToSet=n},n.prototype.requestRedraw=function(){this.needRedraw=!0},n.prototype.changeProjection=function(n){switch(n){case"aitoff":this.projectionMethod=f.AITOFF;break;case"tan":this.projectionMethod=f.TAN;break;case"arc":this.projectionMethod=f.ARC;break;case"mercator":this.projectionMethod=f.MERCATOR;break;case"mollweide":this.projectionMethod=f.MOL;break;case"sinus":default:this.projectionMethod=f.SIN}this.projection.setProjection(this.projectionMethod),this.aladin.webglAPI.setProjection(n),this.requestRedraw()},n.prototype.changeFrame=function(n){var e=this.cooFrame;if(this.cooFrame=n,console.log("change frame"),this.cooFrame.system==_.SYSTEMS.GAL&&this.cooFrame.system!=e.system){var t=k.J2000ToGalactic([this.viewCenter.lon,this.viewCenter.lat]);this.viewCenter.lon=t[0],this.viewCenter.lat=t[1];const n=De.wasmLibs.webgl.GALCooSys();this.aladin.webglAPI.setCooSystem(n)}else if(this.cooFrame.system==_.SYSTEMS.J2000&&this.cooFrame.system!=e.system){var r=k.GalacticToJ2000([this.viewCenter.lon,this.viewCenter.lat]);this.viewCenter.lon=r[0],this.viewCenter.lat=r[1];const n=De.wasmLibs.webgl.ICRSJ2000CooSys();this.aladin.webglAPI.setCooSystem(n)}this.location.update(this.viewCenter.lon,this.viewCenter.lat,this.cooFrame,!0),this.requestRedraw()},n.prototype.showHealpixGrid=function(n){n||this.gridCtx.clearRect(0,0,this.imageCanvas.width,this.imageCanvas.height),this.displayHpxGrid=n,this.requestRedraw()},n.prototype.showSurvey=function(n){this.displaySurvey=n,this.requestRedraw()},n.prototype.showCatalog=function(n){this.displayCatalog=n,this.displayCatalog||(this.mustClearCatalog=!0),this.requestRedraw()},n.prototype.showReticle=function(n){this.displayReticle=n,this.mustRedrawReticle=!0,this.requestRedraw()},n.prototype.pointTo=function(n,e,t){if(t=t||{},n=parseFloat(n),e=parseFloat(e),!isNaN(n)&&!isNaN(e)){this.viewCenter.lon=n,this.viewCenter.lat=e,this.location.update(this.viewCenter.lon,this.viewCenter.lat,this.cooFrame,!0),t&&!1===t.forceAnimation?this.aladin.webglAPI.setCenter(this.viewCenter.lon,this.viewCenter.lat):t&&!0===t.forceAnimation||this.fov>30?this.aladin.webglAPI.moveToLocation(this.viewCenter.lon,this.viewCenter.lat):this.aladin.webglAPI.setCenter(this.viewCenter.lon,this.viewCenter.lat),this.forceRedraw(),this.requestRedraw();var r=this;setTimeout((function(){r.refreshProgressiveCats()}),1e3)}},n.prototype.makeUniqLayerName=function(n){if(!this.layerNameExists(n))return n;for(var e=1;;++e){var t=n+"_"+e;if(!this.layerNameExists(t))return t}},n.prototype.layerNameExists=function(n){for(var e=this.allOverlayLayers,t=0;t<e.length;t++)if(n==e[t].name)return!0;return!1},n.prototype.removeLayers=function(){this.catalogs=[],this.overlays=[],this.mocs=[],this.allOverlayLayers=[],this.requestRedraw()},n.prototype.addCatalog=function(n){n.name=this.makeUniqLayerName(n.name),this.allOverlayLayers.push(n),this.catalogs.push(n),"catalog"==n.type?n.setView(this):"progressivecat"==n.type&&n.init(this)},n.prototype.addOverlay=function(n){n.name=this.makeUniqLayerName(n.name),this.overlays.push(n),this.allOverlayLayers.push(n),n.setView(this)},n.prototype.addMOC=function(n){n.name=this.makeUniqLayerName(n.name),this.mocs.push(n),this.allOverlayLayers.push(n),n.setView(this)},n.prototype.getObjectsInBBox=function(n,e,t,r){t<0&&(n+=t,t=-t),r<0&&(e+=r,r=-r);var i,a,o,s=[];if(this.catalogs)for(var l=0;l<this.catalogs.length;l++)if((i=this.catalogs[l]).isShowing){a=i.getSources();for(var c=0;c<a.length;c++)(o=a[c]).isShowing&&o.x&&o.y&&o.x>=n&&o.x<=n+t&&o.y>=e&&o.y<=e+r&&s.push(o)}return s},n.prototype.updateObjectsLookup=function(){var n,e,t,r,i;if(this.objLookup=[],this.catalogs)for(var a=0;a<this.catalogs.length;a++)if((n=this.catalogs[a]).isShowing){e=n.getSources();for(var o=0;o<e.length;o++)(t=e[o]).isShowing&&t.x&&t.y&&(r=Math.round(t.x),i=Math.round(t.y),void 0===this.objLookup[r]&&(this.objLookup[r]=[]),void 0===this.objLookup[r][i]&&(this.objLookup[r][i]=[]),this.objLookup[r][i].push(t))}},n.prototype.closestObjects=function(n,e,t){var r,i,a,o=this.catalogCanvas.getContext("2d");if(o.lineWidth=6,this.overlays)for(var s=0;s<this.overlays.length;s++){r=this.overlays[s];for(var l=0;l<r.overlays.length;l++){for(var c=r.overlays[l],f=[],u=0;u<c.polygons.length;u++){var h=m.radecToViewXy(c.polygons[u][0],c.polygons[u][1],this);h&&f.push({x:h[0],y:h[1]})}for(var p=0;p<f.length-1;p++)if(o.beginPath(),o.moveTo(f[p].x,f[p].y),o.lineTo(f[p+1].x,f[p+1].y),o.isPointInStroke(n,e))return[i=c]}for(l=0;l<r.overlay_items.length;l++)if(r.overlay_items[l]instanceof L&&(r.overlay_items[l].draw(o,this,this.projection,this.cooFrame,this.width,this.height,this.largestDim,this.zoomFactor,!0),o.isPointInStroke(n,e)))return[i=r.overlay_items[l]]}if(!this.objLookup)return null;for(var d=0;d<=t;d++){i=a=null;for(var x=-t;x<=t;x++)if(this.objLookup[n+x])for(var _=-t;_<=t;_++)if(this.objLookup[n+x][e+_]){var v=x*x+_*_;i?v<a&&(a=v,i=this.objLookup[n+x][e+_]):(i=this.objLookup[n+x][e+_],a=v)}if(i)return i}return null},n}(),ye=function(){let n={};var e,t,r,i,a,o,s,l,c,f,u,h,p,d,x={}.hasOwnProperty,_=function(n,e){for(var t in e)x.call(e,t)&&(n[t]=e[t]);function r(){this.constructor=n}return r.prototype=e.prototype,n.prototype=new r,n.__super__=e.prototype,n},v=[].slice;return e=function(){function n(){}return n.include=function(n){var e,t;for(e in n)t=n[e],this.prototype[e]=t;return this},n.extend=function(n){var e,t;for(e in n)t=n[e],this[e]=t;return this},n.prototype.proxy=function(n){var e=this;return function(){return n.apply(e,arguments)}},n.prototype.invoke=function(n,e,t){var r;if(r=null!=(null!=e?e.context:void 0)?e.context:this,null!=n)return n.call(r,t,e)},n}(),h=function(e){function t(n,e,t){var r,i=this;this.arg=n,this.callback=e,this.opts=t,this.hdus=[],this.blockCount=0,this.begin=0,this.end=this.BLOCKLENGTH,this.offset=0,this.headerStorage=new Uint8Array,"string"==typeof this.arg?(this.readNextBlock=this._readBlockFromBuffer,(r=new XMLHttpRequest).open("GET",this.arg),r.responseType="arraybuffer",r.onerror=function(){i.invoke(i.callback,i.opts)},r.onload=function(){if(200===r.status)return i.arg=r.response,i.length=i.arg.byteLength,i.readFromBuffer();i.invoke(i.callback,i.opts)},r.send()):(this.length=this.arg.size,this.readNextBlock=this._readBlockFromFile,this.readFromFile())}return _(t,e),t.prototype.LINEWIDTH=80,t.prototype.BLOCKLENGTH=2880,File.prototype.slice=File.prototype.slice||File.prototype.webkitSlice,Blob.prototype.slice=Blob.prototype.slice||Blob.prototype.webkitSlice,t.prototype.readFromBuffer=function(){var n;return n=this.arg.slice(this.begin+this.offset,this.end+this.offset),this.readBlock(n)},t.prototype.readFromFile=function(){var n,e=this;return this.reader=new FileReader,this.reader.onloadend=function(n){return e.readBlock(n.target.result)},n=this.arg.slice(this.begin+this.offset,this.end+this.offset),this.reader.readAsArrayBuffer(n)},t.prototype.readBlock=function(n){var e,t,r,i,a,o,c,f,u,h,p,d,x;for(e=new Uint8Array(n),u=new Uint8Array(this.headerStorage),this.headerStorage=new Uint8Array(this.end),this.headerStorage.set(u,0),this.headerStorage.set(e,this.begin),o=this.BLOCKLENGTH/this.LINEWIDTH;o--;)if(32!==e[a=o*this.LINEWIDTH]){if(69===e[a]&&78===e[a+1]&&68===e[a+2]&&32===e[a+3]){for(c="",p=0,d=(x=this.headerStorage).length;p<d;p++)h=x[p],c+=String.fromCharCode(h);return i=new l(c),this.start=this.end+this.offset,t=i.getDataLength(),f=this.arg.slice(this.start,this.start+t),i.hasDataUnit()&&(r=this.createDataUnit(i,f)),this.hdus.push(new s(i,r)),this.offset+=this.end+t+this.excessBytes(t),this.offset===this.length?(this.headerStorage=null,void this.invoke(this.callback,this.opts,this)):(this.blockCount=0,this.begin=this.blockCount*this.BLOCKLENGTH,this.end=this.begin+this.BLOCKLENGTH,this.headerStorage=new Uint8Array,n=this.arg.slice(this.begin+this.offset,this.end+this.offset),void this.readNextBlock(n))}break}this.blockCount+=1,this.begin=this.blockCount*this.BLOCKLENGTH,this.end=this.begin+this.BLOCKLENGTH,n=this.arg.slice(this.begin+this.offset,this.end+this.offset),this.readNextBlock(n)},t.prototype._readBlockFromBuffer=function(n){return this.readBlock(n)},t.prototype._readBlockFromFile=function(n){return this.reader.readAsArrayBuffer(n)},t.prototype.createDataUnit=function(e,t){var r;return r=e.getDataType(),new n.FITS[r](e,t)},t.prototype.excessBytes=function(n){return(this.BLOCKLENGTH-n%this.BLOCKLENGTH)%this.BLOCKLENGTH},t.prototype.isEOF=function(){return this.offset===this.length},t}(e),(o=function(n){function e(n,e,t){var r,i=this;this.arg=n,r=new h(this.arg,(function(n){return i.hdus=r.hdus,i.invoke(e,t,i)}))}return _(e,n),e.prototype.getHDU=function(n){var e,t,r,i;if(null!=n&&null!=this.hdus[n])return this.hdus[n];for(t=0,r=(i=this.hdus).length;t<r;t++)if((e=i[t]).hasData())return e},e.prototype.getHeader=function(n){return this.getHDU(n).header},e.prototype.getDataUnit=function(n){return this.getHDU(n).data},e}(e)).version="0.6.5",n.FITS=o,i=function(n){function e(n,e){e instanceof ArrayBuffer?this.buffer=e:this.blob=e}return _(e,n),e.swapEndian={B:function(n){return n},I:function(n){return n<<8|n>>8},J:function(n){return(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255}},e.swapEndian[8]=e.swapEndian.B,e.swapEndian[16]=e.swapEndian.I,e.swapEndian[32]=e.swapEndian.J,e}(e),n.FITS.DataUnit=i,c={verifyOrder:function(n,e){if(e!==this.cardIndex)return console.warn(n+" should appear at index "+this.cardIndex+" in the FITS header")},verifyBetween:function(n,e,t,r){if(!(e>=t&&e<=r))throw"The "+n+" value of "+e+" is not between "+t+" and "+r},verifyBoolean:function(n){return"T"===n},VerifyFns:{SIMPLE:function(){var n;return 1<=arguments.length?v.call(arguments,0):[],n=arguments[0],this.primary=!0,this.verifyOrder("SIMPLE",0),this.verifyBoolean(n)},XTENSION:function(){return 1<=arguments.length?v.call(arguments,0):[],this.extension=!0,this.extensionType=arguments[0],this.verifyOrder("XTENSION",0),this.extensionType},BITPIX:function(){var n,e;if(1<=arguments.length?v.call(arguments,0):[],n="BITPIX",e=parseInt(arguments[0]),this.verifyOrder(n,1),8!==e&&16!==e&&32!==e&&-32!==e&&-64!==e)throw n+" value "+e+" is not permitted";return e},NAXIS:function(){var n,e,t,r;if(1<=arguments.length?v.call(arguments,0):[],n="NAXIS",t=parseInt(arguments[0]),!arguments[1]&&(this.verifyOrder(n,2),this.verifyBetween(n,t,0,999),this.isExtension()&&("TABLE"===(r=this.extensionType)||"BINTABLE"===r)&&t!==(e=2)))throw n+" must be "+e+" for TABLE and BINTABLE extensions";return t},PCOUNT:function(){var n,e,t,r,i;if(1<=arguments.length?v.call(arguments,0):[],n="PCOUNT",r=parseInt(arguments[0]),e=3+this.get("NAXIS"),this.verifyOrder(n,e),this.isExtension()&&("IMAGE"===(i=this.extensionType)||"TABLE"===i)&&r!==(t=0))throw n+" must be "+t+" for the "+this.extensionType+" extensions";return r},GCOUNT:function(){var n,e,t,r,i;if(1<=arguments.length?v.call(arguments,0):[],n="GCOUNT",r=parseInt(arguments[0]),e=3+this.get("NAXIS")+1,this.verifyOrder(n,e),this.isExtension()&&("IMAGE"===(i=this.extensionType)||"TABLE"===i||"BINTABLE"===i)&&r!==(t=1))throw n+" must be "+t+" for the "+this.extensionType+" extensions";return r},EXTEND:function(){var n;if(1<=arguments.length?v.call(arguments,0):[],n=arguments[0],!this.isPrimary())throw"EXTEND must only appear in the primary header";return this.verifyBoolean(n)},BSCALE:function(){return 1<=arguments.length?v.call(arguments,0):[],parseFloat(arguments[0])},BZERO:function(){return 1<=arguments.length?v.call(arguments,0):[],parseFloat(arguments[0])},BLANK:function(){var n;return 1<=arguments.length?v.call(arguments,0):[],n=arguments[0],this.get("BITPIX")>0||console.warn("BLANK is not to be used for BITPIX = "+this.get("BITPIX")),parseInt(n)},DATAMIN:function(){return 1<=arguments.length?v.call(arguments,0):[],parseFloat(arguments[0])},DATAMAX:function(){return 1<=arguments.length?v.call(arguments,0):[],parseFloat(arguments[0])},EXTVER:function(){return 1<=arguments.length?v.call(arguments,0):[],parseInt(arguments[0])},EXTLEVEL:function(){return 1<=arguments.length?v.call(arguments,0):[],parseInt(arguments[0])},TFIELDS:function(){var n;return 1<=arguments.length?v.call(arguments,0):[],n=parseInt(arguments[0]),this.verifyBetween("TFIELDS",n,0,999),n},TBCOL:function(){var n,e;return 1<=arguments.length?v.call(arguments,0):[],e=arguments[0],n=arguments[2],this.verifyBetween("TBCOL",n,0,this.get("TFIELDS")),e},ZIMAGE:function(){return 1<=arguments.length?v.call(arguments,0):[],this.verifyBoolean(arguments[0])},ZCMPTYPE:function(){var n;if(1<=arguments.length?v.call(arguments,0):[],"GZIP_1"!==(n=arguments[0])&&"RICE_1"!==n&&"PLIO_1"!==n&&"HCOMPRESS_1"!==n)throw"ZCMPTYPE value "+n+" is not permitted";if("RICE_1"!==n)throw"Compress type "+n+" is not yet implement";return n},ZBITPIX:function(){var n;if(1<=arguments.length?v.call(arguments,0):[],8!==(n=parseInt(arguments[0]))&&16!==n&&32!==n&&64!==n&&-32!==n&&-64!==n)throw"ZBITPIX value "+n+" is not permitted";return n},ZNAXIS:function(){var n;return 1<=arguments.length?v.call(arguments,0):[],n=n=parseInt(arguments[0]),arguments[1]||this.verifyBetween("ZNAXIS",n,0,999),n},ZTILE:function(){return 1<=arguments.length?v.call(arguments,0):[],parseInt(arguments[0])},ZSIMPLE:function(){return 1<=arguments.length?v.call(arguments,0):[],"T"===arguments[0]},ZPCOUNT:function(){return 1<=arguments.length?v.call(arguments,0):[],parseInt(arguments[0])},ZGCOUNT:function(){return 1<=arguments.length?v.call(arguments,0):[],parseInt(arguments[0])},ZDITHER0:function(){return 1<=arguments.length?v.call(arguments,0):[],parseInt(arguments[0])}}},n.FITS.HeaderVerify=c,l=function(n){function e(n){var e,t,r;for(t in this.primary=!1,this.extension=!1,this.verifyCard={},r=this.VerifyFns)e=r[t],this.verifyCard[t]=this.proxy(e);this.cards={},this.cards.COMMENT=[],this.cards.HISTORY=[],this.cardIndex=0,this.block=n,this.readBlock(n)}return _(e,n),e.include(c),e.prototype.arrayPattern=/(\D+)(\d+)/,e.prototype.maxLines=600,e.prototype.get=function(n){return this.contains(n)?this.cards[n].value:null},e.prototype.set=function(n,e,t){return t=t||"",this.cards[n]={index:this.cardIndex,value:e,comment:t},this.cardIndex+=1},e.prototype.contains=function(n){return this.cards.hasOwnProperty(n)},e.prototype.readLine=function(n){var e,t,r,i,a;if(!(""===(r=n.slice(0,8).trim()))){if(t=n.slice(8,10),i=n.slice(10),"= "===t)return a=i.split(" /"),i=a[0],e=a[1],"'"===(i=i.trim())[0]?i=i.slice(1,-1).trim():"T"!==i&&"F"!==i&&(i=parseFloat(i)),i=this.validate(r,i),this.set(r,i,e);"COMMENT"!==r&&"HISTORY"!==r||this.cards[r].push(i.trim())}},e.prototype.validate=function(n,e){var t,r,i,a;return r=null,t=n,(i=this.arrayPattern.test(n))&&(t=(a=this.arrayPattern.exec(n).slice(1))[0],r=a[1]),t in this.verifyCard&&(e=this.verifyCard[t](e,i,r)),e},e.prototype.readBlock=function(n){var e,t,r,i,a,o;for(80,o=[],e=i=0,a=(r=(r=n.length/80)<this.maxLines?r:this.maxLines)-1;0<=a?i<=a:i>=a;e=0<=a?++i:--i)t=n.slice(80*e,80*(e+1)),o.push(this.readLine(t));return o},e.prototype.hasDataUnit=function(){return 0!==this.get("NAXIS")},e.prototype.getDataLength=function(){var n,e,t,r,i;if(!this.hasDataUnit())return 0;for(t=[],n=r=1,i=this.get("NAXIS");1<=i?r<=i:r>=i;n=1<=i?++r:--r)t.push(this.get("NAXIS"+n));return e=t.reduce((function(n,e){return n*e}))*Math.abs(this.get("BITPIX"))/8,e+=this.get("PCOUNT")},e.prototype.getDataType=function(){switch(this.extensionType){case"BINTABLE":return this.contains("ZIMAGE")?"CompressedImage":"BinaryTable";case"TABLE":return"Table";default:return this.hasDataUnit()?"Image":null}},e.prototype.isPrimary=function(){return this.primary},e.prototype.isExtension=function(){return this.extension},e}(e),n.FITS.Header=l,u={getExtent:function(n){var e,t,r,i;for(e=n.length;e--;)if(i=n[e],!isNaN(i)){r=t=i;break}if(-1===e)return[NaN,NaN];for(;e--;)i=n[e],isNaN(i)||(i<r&&(r=i),i>t&&(t=i));return[r,t]},getPixel:function(n,e,t){return n[t*this.width+e]}},n.FITS.ImageUtils=u,f=function(n){function e(n,t){var r,i,a,o,s,l,c;for(e.__super__.constructor.apply(this,arguments),o=n.get("NAXIS"),this.bitpix=n.get("BITPIX"),this.naxis=[],a=s=1;1<=o?s<=o:s>=o;a=1<=o?++s:--s)this.naxis.push(n.get("NAXIS"+a));for(this.width=n.get("NAXIS1"),this.height=n.get("NAXIS2")||1,this.depth=n.get("NAXIS3")||1,this.bzero=n.get("BZERO")||0,this.bscale=n.get("BSCALE")||1,this.bytes=Math.abs(this.bitpix)/8,this.length=this.naxis.reduce((function(n,e){return n*e}))*Math.abs(this.bitpix)/8,this.frame=0,this.frameOffsets=[],this.frameLength=this.bytes*this.width*this.height,this.nBuffers=null!=this.buffer?1:2,a=l=0,c=this.depth-1;0<=c?l<=c:l>=c;a=0<=c?++l:--l)i={begin:r=a*this.frameLength},null!=this.buffer&&(i.buffers=[this.buffer.slice(r,r+this.frameLength)]),this.frameOffsets.push(i)}return _(e,n),e.include(u),e.prototype.allocationSize=16777216,e.prototype._getFrame=function(n,e,t,r){var i,a,o,s,l,c,f;if(a=Math.abs(e)/8,s=o=n.byteLength/a,Math.abs(e),e>0){switch(e){case 8:c=new Uint8Array(n),c=new Uint16Array(c),l=function(n){return n};break;case 16:c=new Int16Array(n),l=function(n){return(255&n)<<8|n>>8&255};break;case 32:c=new Int32Array(n),l=function(n){return(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255}}for(i=parseInt(t)!==t||parseInt(r)!==r?new Float32Array(c.length):c;s--;)c[s]=l(c[s]),i[s]=t+r*c[s]}else{for(i=new Uint32Array(n),l=function(n){return(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255};o--;)f=i[o],i[o]=l(f);for(i=new Float32Array(n);s--;)i[s]=t+r*i[s]}return i},e.prototype._getFrameAsync=function(n,e,t){var r,i,a,o,s,l,c,f,u,h,p,d,x,_=this;o="onmessage = "+(o=function(n){var e,t,r,i,a,o,s;return i=(o=n.data).buffer,t=o.bitpix,a=o.bzero,r=o.bscale,s=o.url,importScripts(s),e=_getFrame(i,t,a,r),postMessage(e)}.toString().replace("return postMessage","postMessage")),s=(s=this._getFrame.toString()).replace("function","function _getFrame"),c="application/javascript",a=new Blob([o],{type:c}),i=new Blob([s],{type:c}),r=window.URL||window.webkitURL,d=r.createObjectURL(a),p=r.createObjectURL(i),x=new Worker(d),f={buffer:n[0],bitpix:this.bitpix,bzero:this.bzero,bscale:this.bscale,url:p},l=0,u=null,h=0,x.onmessage=function(i){var a;return a=i.data,null==u&&(u=new a.constructor(_.width*_.height)),u.set(a,h),h+=a.length,(l+=1)===_.nBuffers?(_.invoke(e,t,u),r.revokeObjectURL(d),r.revokeObjectURL(p),x.terminate()):(f.buffer=n[l],x.postMessage(f,[n[l]]))},x.postMessage(f,[n[0]])},e.prototype.getFrame=function(n,e,t){var r,i,a,o,s,l,c,f,u,h,p,d=this;if(this.frame=n||this.frame,(null!=(o=(l=this.frameOffsets[this.frame]).buffers)?o.length:void 0)===this.nBuffers)return this._getFrameAsync(o,e,t);for(this.frameOffsets[this.frame].buffers=[],r=l.begin,i=this.blob.slice(r,r+this.frameLength),a=[],s=Math.floor(this.height/this.nBuffers)*this.bytes*this.width,c=h=0,p=this.nBuffers-1;0<=p?h<=p:h>=p;c=0<=p?++h:--h)u=c*s,c===this.nBuffers-1?a.push(i.slice(u)):a.push(i.slice(u,u+s));return o=[],(f=new FileReader).frame=this.frame,c=0,f.onloadend=function(r){var i;return n=r.target.frame,i=r.target.result,d.frameOffsets[n].buffers.push(i),(c+=1)===d.nBuffers?d.getFrame(n,e,t):f.readAsArrayBuffer(a[c])},f.readAsArrayBuffer(a[0])},e.prototype.getFrames=function(n,e,t,r){var i,a=this;return i=function(r,o){if(a.invoke(t,o,r),n+=1,e-=1)return a.getFrame(n,i,o)},this.getFrame(n,i,r)},e.prototype.isDataCube=function(){return this.naxis.length>2},e}(i),n.FITS.Image=f,d=function(n){function e(n,t){e.__super__.constructor.apply(this,arguments),this.rowByteSize=n.get("NAXIS1"),this.rows=n.get("NAXIS2"),this.cols=n.get("TFIELDS"),this.length=this.rowByteSize*this.rows,this.heapLength=n.get("PCOUNT"),this.columns=this.getColumns(n),null!=this.buffer?(this.rowsInMemory=this._rowsInMemoryBuffer,this.heap=this.buffer.slice(this.length,this.length+this.heapLength)):(this.rowsInMemory=this._rowsInMemoryBlob,this.firstRowInBuffer=this.lastRowInBuffer=0,this.nRowsInBuffer=Math.floor(this.maxMemory/this.rowByteSize)),this.accessors=[],this.descriptors=[],this.elementByteLengths=[],this.setAccessors(n)}return _(e,n),e.prototype.maxMemory=1048576,e.prototype._rowsInMemoryBuffer=function(){return!0},e.prototype._rowsInMemoryBlob=function(n,e){return!(n<this.firstRowInBuffer)&&!(e>this.lastRowInBuffer)},e.prototype.getColumns=function(n){var e,t,r,i,a;for(e=[],t=i=1,a=this.cols;1<=a?i<=a:i>=a;t=1<=a?++i:--i){if(r="TTYPE"+t,!n.contains(r))return null;e.push(n.get(r))}return e},e.prototype.getColumn=function(n,e,t){var r,i,a,o,s,l,c,f,u,h,p=this;return null!=this.blob?(f=this.columns.indexOf(n),o=this.descriptors[f],r=this.accessors[f],this.elementByteLengths[f],s=0===(s=this.elementByteLengths.slice(0,f)).length?0:s.reduce((function(n,e){return n+e})),a=null!=this.typedArray[o]?new this.typedArray[o](this.rows):[],h=~~(this.maxMemory/this.rowByteSize),h=Math.min(h,this.rows),l=this.rows/h,u=Math.floor(l)===l?l:Math.floor(l)+1,c=0,f=0,i=function(n,t){var o,l,d,x;for(o=n.byteLength/p.rowByteSize,x=new DataView(n),l=s;o--;)a[c]=r(x,l)[0],c+=1,l+=p.rowByteSize;if(f+=1,u-=1)return d=f*h,p.getTableBuffer(d,h,i,t);p.invoke(e,t,a)},this.getTableBuffer(0,h,i,t)):(i=function(t,r){return a=t.map((function(e){return e[n]})),p.invoke(e,r,a)},this.getRows(0,this.rows,i,t))},e.prototype.getTableBuffer=function(n,e,t,r){var i,a,o,s,l=this;return e=Math.min(this.rows-n,e),o=(i=n*this.rowByteSize)+e*this.rowByteSize,a=this.blob.slice(i,o),(s=new FileReader).row=n,s.number=e,s.onloadend=function(n){return l.invoke(t,r,n.target.result)},s.readAsArrayBuffer(a)},e.prototype.getRows=function(n,e,t,r){var i,a,o,s,l,c,f=this;return this.rowsInMemory(n,n+e)?(null!=this.blob?o=this.buffer:(s=(i=n*this.rowByteSize)+e*this.rowByteSize,o=this.buffer.slice(i,s)),c=this._getRows(o,e),this.invoke(t,r,c),c):(s=(i=n*this.rowByteSize)+Math.max(this.nRowsInBuffer*this.rowByteSize,e*this.rowByteSize),a=this.blob.slice(i,s),(l=new FileReader).row=n,l.number=e,l.onloadend=function(i){var a;return a=i.target,f.buffer=a.result,f.firstRowInBuffer=f.lastRowInBuffer=a.row,f.lastRowInBuffer+=a.number,f.getRows(n,e,t,r)},l.readAsArrayBuffer(a))},e}(i),n.FITS.Tabular=d,p=function(n){function e(){return e.__super__.constructor.apply(this,arguments)}return _(e,n),e.prototype.dataAccessors={A:function(n){return n.trim()},I:function(n){return parseInt(n)},F:function(n){return parseFloat(n)},E:function(n){return parseFloat(n)},D:function(n){return parseFloat(n)}},e.prototype.setAccessors=function(n){var e,t,r,i,a,o,s,l=this;for(i=/([AIFED])(\d+)\.*(\d+)*/,s=[],r=a=1,o=this.cols;1<=o?a<=o:a>=o;r=1<=o?++a:--a)t=n.get("TFORM"+r),n.get("TTYPE"+r),e=i.exec(t)[1],s.push(function(n){var e;return e=function(e){return l.dataAccessors[n](e)},l.accessors.push(e)}(e));return s},e.prototype._getRows=function(n){var e,t,r,i,a,o,s,l,c,f,u,h,p,d,x,_,v,m,g;for(l=n.byteLength/this.rowByteSize,t=new Uint8Array(n),f=[],a=p=0,m=l-1;0<=m?p<=m:p>=m;a=0<=m?++p:--p){for(i=(r=a*this.rowByteSize)+this.rowByteSize,s="",d=0,_=(u=t.subarray(r,i)).length;d<_;d++)h=u[d],s+=String.fromCharCode(h);for(s=s.trim().split(/\s+/),c={},o=x=0,v=(g=this.accessors).length;x<v;o=++x)e=g[o],h=s[o],c[this.columns[o]]=e(h);f.push(c)}return f},e}(d),n.FITS.Table=p,t=function(n){function e(){return e.__super__.constructor.apply(this,arguments)}return _(e,n),e.prototype.typedArray={B:Uint8Array,I:Uint16Array,J:Uint32Array,E:Float32Array,D:Float64Array,1:Uint8Array,2:Uint16Array,4:Uint32Array},e.offsets={L:1,B:1,I:2,J:4,K:8,A:1,E:4,D:8,C:8,M:16},e.prototype.dataAccessors={L:function(n,e){return[84===n.getInt8(e),e+=1]},B:function(n,e){return[n.getUint8(e),e+=1]},I:function(n,e){return[n.getInt16(e),e+=2]},J:function(n,e){return[n.getInt32(e),e+=4]},K:function(n,e){var t,r;return t=Math.abs(n.getInt32(e)),e+=4,[((r=t%10)?-1:1)*((t-=r)<<32|Math.abs(n.getInt32(e))),e+=4]},A:function(n,e){var t;return t=n.getUint8(e),[t=String.fromCharCode(t),e+=1]},E:function(n,e){return[n.getFloat32(e),e+=4]},D:function(n,e){return[n.getFloat64(e),e+=8]},C:function(n,e){var t;return t=n.getFloat32(e),e+=4,[[t,n.getFloat32(e)],e+=4]},M:function(n,e){var t;return t=n.getFloat64(e),e+=8,[[t,n.getFloat64(e)],e+=8]}},e.prototype.toBits=function(n){var e,t;for(e=[],t=128;t>=1;)e.push(n&t?1:0),t/=2;return e},e.prototype.getFromHeap=function(n,e,t){var r,i,a,o,s;for(s=n.getInt32(e),e+=4,i=n.getInt32(e),e+=4,a=this.heap.slice(i,i+s),o=(r=new this.typedArray[t](a)).length;o--;)r[o]=this.constructor.swapEndian[t](r[o]);return[r,e]},e.prototype.setAccessors=function(n){var e,t,r,i,o,s,l,c,f,u,h,p=this;for(l=/(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/,h=[],i=f=1,u=this.cols;1<=u?f<=u:f>=u;i=1<=u?++f:--f)r=n.get("TFORM"+i),c=n.get("TTYPE"+i),s=l.exec(r),e=parseInt(s[1])||1,o=s[2],t=s[3],h.push(function(n,e){var t,r;if(p.descriptors.push(n),p.elementByteLengths.push(p.constructor.offsets[n]*e),o)switch(c){case"COMPRESSED_DATA":t=function(e,t){var r,i,o;return r=(o=p.getFromHeap(e,t,n))[0],t=o[1],i=new p.typedArray[p.algorithmParameters.BYTEPIX](p.ztile[0]),a.Rice(r,p.algorithmParameters.BLOCKSIZE,p.algorithmParameters.BYTEPIX,i,p.ztile[0],a.RiceSetup),[i,t]};break;case"GZIP_COMPRESSED_DATA":t=function(n,e){var t;for(t=new Float32Array(p.width),i=t.length;i--;)t[i]=NaN;return[t,e]};break;default:t=function(e,t){return p.getFromHeap(e,t,n)}}else 1===e?t=function(e,t){var r;return[(r=p.dataAccessors[n](e,t))[0],t=r[1]]}:"X"===n?(r=Math.log(e)/Math.log(2),t=function(n,t){var i,a,o,s,l,c,f;for(o=n.buffer.slice(t,t+r),a=[],c=0,f=(l=new Uint8Array(o)).length;c<f;c++)s=l[c],i=p.toBits(s),a=a.concat(i);return t+=r,[a.slice(0,+(e-1)+1||9e9),t]}):t="A"===n?function(n,t){var r,i,a,o,s,l;for(i=n.buffer.slice(t,t+e),a="",s=0,l=(r=new Uint8Array(i)).length;s<l;s++)o=r[s],a+=String.fromCharCode(o);return[a=a.trim(),t+=e]}:function(t,r){var a,o,s;for(i=e,a=[];i--;)o=(s=p.dataAccessors[n](t,r))[0],r=s[1],a.push(o);return[a,r]};return p.accessors.push(t)}(t,e));return h},e.prototype._getRows=function(n,e){var t,r,i,a,o,s,l,c,f,u;for(s=new DataView(n),r=0,a=[];e--;){for(i={},t=l=0,c=(f=this.accessors).length;l<c;t=++l)o=(u=(0,f[t])(s,r))[0],r=u[1],i[this.columns[t]]=o;a.push(i)}return a},e}(d),n.FITS.BinaryTable=t,a={RiceSetup:{1:function(n){return 1,3,6,[3,6,n[0],1]},2:function(n){var e;return 2,4,14,e=0,e|=n[0]<<8,[4,14,e|=n[1],2]},4:function(n){var e;return 4,5,25,e=0,e|=n[0]<<24,e|=n[1]<<16,e|=n[2]<<8,[5,25,e|=n[3],4]}},Rice:function(n,e,t,r,i,a){var o,s,l,c,f,u,h,p,d,x,_,v,m,g,y,b;for(s=1<<f,f=(y=a[t](n))[0],u=y[1],x=y[2],g=y[3],v=new Uint8Array(256),m=8,d=(b=[128,255])[0],h=b[1];h>=0;){for(;h>=d;)v[h]=m,h-=1;d/=2,m-=1}for(v[0]=0,o=n[g++],_=8,h=0;h<i;){for(_-=f;_<0;)o=o<<8|n[g++],_+=8;if(c=(o>>_)-1,o&=(1<<_)-1,(p=h+e)>i&&(p=i),c<0)for(;h<p;)r[h]=x,h+=1;else if(c===u)for(;h<p;){for(l=o<<(d=s-_),d-=8;d>=0;)l|=(o=n[g++])<<d,d-=8;_>0?(l|=(o=n[g++])>>-d,o&=(1<<_)-1):o=0,0==(1&l)?l>>=1:l=~(l>>1),r[h]=l+x,x=r[h],h++}else for(;h<p;){for(;0===o;)_+=8,o=n[g++];for(o^=1<<(_-=(m=_-v[o])+1),_-=c;_<0;)o=o<<8|n[g++],_+=8;l=m<<c|o>>_,o&=(1<<_)-1,0==(1&l)?l>>=1:l=~(l>>1),r[h]=l+x,x=r[h],h++}}return r}},n.FITS.Decompress=a,r=function(n){function e(n,t){var r,i,a,o,s,l;for(e.__super__.constructor.apply(this,arguments),this.zcmptype=n.get("ZCMPTYPE"),this.zbitpix=n.get("ZBITPIX"),this.znaxis=n.get("ZNAXIS"),this.zblank=n.get("ZBLANK"),this.blank=n.get("BLANK"),this.zdither=n.get("ZDITHER0")||0,this.ztile=[],r=s=1,l=this.znaxis;1<=l?s<=l:s>=l;r=1<=l?++s:--s)o=n.contains("ZTILE"+r)?n.get("ZTILE"+r):1===r?n.get("ZNAXIS1"):1,this.ztile.push(o);for(this.width=n.get("ZNAXIS1"),this.height=n.get("ZNAXIS2")||1,this.algorithmParameters={},"RICE_1"===this.zcmptype&&(this.algorithmParameters.BLOCKSIZE=32,this.algorithmParameters.BYTEPIX=4),r=1;i="ZNAME"+r,n.contains(i);)a="ZVAL"+r,this.algorithmParameters[n.get(i)]=n.get(a),r+=1;this.zmaskcmp=n.get("ZMASKCMP"),this.zquantiz=n.get("ZQUANTIZ")||"LINEAR_SCALING",this.bzero=n.get("BZERO")||0,this.bscale=n.get("BSCALE")||1}return _(e,n),e.include(u),e.extend(a),e.randomGenerator=function(){var n,e,t,r,i,a;for(16807,e=2147483647,r=1,t=new Float32Array(1e4),n=a=0;a<=9999;n=++a)r=(i=16807*r)-e*parseInt(i/e),t[n]=r/e;return t},e.randomSequence=e.randomGenerator(),e.prototype._getRows=function(n,e){var t,r,i,a,o,s,l,c,f,u,h,p,d,x,_,v,m,g,y,b;for(d=new DataView(n),s=0,t=new Float32Array(this.width*this.height);e--;){for(f={},a=_=0,m=(y=this.accessors).length;_<m;a=++_)p=(b=(0,y[a])(d,s))[0],s=b[1],f[this.columns[a]]=p;for(r=f.COMPRESSED_DATA||f.UNCOMPRESSED_DATA||f.GZIP_COMPRESSED_DATA,f.ZBLANK||this.zblank,u=f.ZSCALE||this.bscale,x=f.ZZERO||this.bzero,h=((o=this.height-e)+this.zdither-1-1)%1e4,c=parseInt(500*this.constructor.randomSequence[h]),a=v=0,g=r.length;v<g;a=++v)p=r[a],i=(o-1)*this.width+a,-2147483647===p?t[i]=NaN:-2147483646===p?t[i]=0:(l=this.constructor.randomSequence[c],t[i]=(p-l+.5)*u+x),1e4===(c+=1)&&(h=(h+1)%1e4,c=parseInt(500*this.randomSequence[h]))}return t},e.prototype.getFrame=function(n,e,t){var r,i,a=this;return this.heap?(this.frame=n||this.frame,this.getRows(0,this.rows,e,t)):(r=this.blob.slice(this.length,this.length+this.heapLength),(i=new FileReader).onloadend=function(r){return a.heap=r.target.result,a.getFrame(n,e,t)},i.readAsArrayBuffer(r))},e}(t),n.FITS.CompressedImage=r,s=function(){function n(n,e){this.header=n,this.data=e}return n.prototype.hasData=function(){return null!=this.data},n}(),n.FITS.HDU=s,n}(),be=function(){let n=function(n){this.order=void 0,this.type="moc",n=n||{},this.name=n.name||"MOC",this.color=n.color||Color.getNextColor(),this.opacity=n.opacity||1,this.opacity=Math.max(0,Math.min(1,this.opacity)),this.lineWidth=n.lineWidth||1,this.adaptativeDisplay=!1!==n.adaptativeDisplay,this.proxyCalled=!1,this._highResIndexOrder3=new Array(768),this._lowResIndexOrder3=new Array(768);for(var e=0;e<768;e++)this._highResIndexOrder3[e]={},this._lowResIndexOrder3[e]={};this.nbCellsDeepestLevel=0,this.isShowing=!0,this.ready=!1};n.MAX_NORDER=13,n.LOWRES_MAXORDER=6,n.HIGHRES_MAXORDER=11,n.PIVOT_FOV=30,n.prototype._removeDuplicatesFromIndexes=function(){for(var n,e,r=0;r<768;r++){for(var i in this._highResIndexOrder3[r])n=this._highResIndexOrder3[r][i],e=t(n),this._highResIndexOrder3[r][i]=e;for(var i in this._lowResIndexOrder3[r])n=this._lowResIndexOrder3[r][i],e=t(n),this._lowResIndexOrder3[r][i]=e}},n.prototype._addPix=function(e,t){var r=Math.floor(t*Math.pow(4,3-e));if(e<=n.LOWRES_MAXORDER)e in this._lowResIndexOrder3[r]||(this._lowResIndexOrder3[r][e]=[],this._highResIndexOrder3[r][e]=[]),this._lowResIndexOrder3[r][e].push(t),this._highResIndexOrder3[r][e].push(t);else if(e<=n.HIGHRES_MAXORDER){e in this._highResIndexOrder3[r]||(this._highResIndexOrder3[r][e]=[]),this._highResIndexOrder3[r][e].push(t);var i=n.LOWRES_MAXORDER,a=Math.floor(t/Math.pow(4,e-i)),o=Math.floor(a*Math.pow(4,3-i));i in this._lowResIndexOrder3[o]||(this._lowResIndexOrder3[o][i]=[]),this._lowResIndexOrder3[o][i].push(a)}else{i=n.LOWRES_MAXORDER,a=Math.floor(t/Math.pow(4,e-i)),o=Math.floor(a*Math.pow(4,3-i));i in this._lowResIndexOrder3[o]||(this._lowResIndexOrder3[o][i]=[]),this._lowResIndexOrder3[o][i].push(a),i=n.HIGHRES_MAXORDER,a=Math.floor(t/Math.pow(4,e-i));o=Math.floor(a*Math.pow(4,3-i));i in this._highResIndexOrder3[o]||(this._highResIndexOrder3[o][i]=[]),this._highResIndexOrder3[o][i].push(a)}this.nbCellsDeepestLevel+=Math.pow(4,this.order-e)},n.prototype.skyFraction=function(){return this.nbCellsDeepestLevel/(12*Math.pow(4,this.order))},n.prototype.dataFromJSON=function(n){var e,t;for(var r in n)if(n.hasOwnProperty(r)){e=parseInt(r),(void 0===this.order||e>this.order)&&(this.order=e);for(var i=0;i<n[r].length;i++)t=n[r][i],this._addPix(e,t)}this.reportChange(),this.ready=!0},n.prototype.dataFromFITSURL=function(n,e){var t=this,r=function(){var n;try{if(0==this.hdus.length){if(!0!==t.proxyCalled){t.proxyCalled=!0;var i=De.JSONP_PROXY+"?url="+encodeURIComponent(t.dataURL);new ye.FITS(i,r)}return}n=this.getHeader(0)}catch(n){return void console.error("Could not get header of extension #0")}var a=this.getHeader(1);if(n.contains("HPXMOC"))t.order=n.get("HPXMOC");else if(n.contains("MOCORDER"))t.order=n.get("MOCORDER");else if(a.contains("HPXMOC"))t.order=a.get("HPXMOC");else{if(!a.contains("MOCORDER"))return void console.error("Can not find MOC order in FITS file");t.order=a.get("MOCORDER")}var o=this.getDataUnit(1),s=o.columns[0];o.getRows(0,o.rows,(function(n){for(var e=0;e<n.length;e++){var r=n[e][s],i=Math.floor(Math.floor((o=Math.floor(r/4),Math.log(o)/Math.LN2))/2),a=r-4*Math.pow(4,i);t._addPix(i,a)}var o})),o=null,t._removeDuplicatesFromIndexes(),e&&e(),t.reportChange(),t.ready=!0};this.dataURL=n,new ye.FITS(this.dataURL,r)},n.prototype.setView=function(n){this.view=n,this.reportChange()},n.prototype.draw=function(e,t,r,i,a,o,s,l){if(this.isShowing&&this.ready){var c=l>n.PIVOT_FOV&&this.adaptativeDisplay?this._lowResIndexOrder3:this._highResIndexOrder3;this._drawCells(e,c,l,t,r,_.J2000,i,a,o,s)}},n.prototype._drawCells=function(n,t,i,a,o,s,l,c,f,u){n.lineWidth=this.lineWidth,1==this.opacity?n.strokeStyle=this.color:(n.fillStyle=this.color,n.globalAlpha=this.opacity),n.beginPath();for(var h=[],p=0;p<768;p++){var d=t[p];for(var x in d)h.push(parseInt(x))}h.sort((function(n,e){return n-e}));var v,m,g=h[h.length-1],y=this.view.getVisiblePixList(3,_.J2000),b=[];for(p=0;p<y.length;p++){var E=y[p];(m=r(8,E,o,s,l,c,f,u,a,this.view))&&b.push(E)}for(var w=0;w<=g;w++){v=1<<w;for(var I=0;I<b.length;I++){if(void 0!==(d=t[b[I]])[w])if(w<=3)for(var C=0;C<d[w].length;C++){E=d[w][C];var S=Math.pow(4,3-w),P=E*S;for(p=0;p<S;p++)(m=r(8,P+p,o,s,l,c,f,u,a,this.view))&&e(n,m)}else for(C=0;C<d[w].length;C++){E=d[w][C];Math.floor(E/Math.pow(4,w-3));(m=r(v,E,o,s,l,c,f,u,a,this.view))&&e(n,m)}}}1==this.opacity?n.stroke():(n.fill(),n.globalAlpha=1)};var e=function(n,e){n.moveTo(e[0].vx,e[0].vy),n.lineTo(e[1].vx,e[1].vy),n.lineTo(e[2].vx,e[2].vy),n.lineTo(e[3].vx,e[3].vy),n.lineTo(e[0].vx,e[0].vy)},t=function(n){for(var e={},t=[],r=n.length,i=0,a=0;a<r;a++){var o=n[a];1!==e[o]&&(e[o]=1,t[i++]=o)}return t},r=function(n,e,t,r,i,a,o,s,l,c){for(var u,h,p=[],d=De.wasmLibs.hpx.nestedVertices(Math.log2(n),e),x=0;x<4;x++){if(u=d[2*x],h=d[2*x+1],p[x]=c.aladin.webglAPI.worldToScreen(u,h),!p[x])return null;p[x]={vx:p[x][0],vy:p[x][1]}}return p[0].vx<0&&p[1].vx<0&&p[2].vx<0&&p[3].vx<0||p[0].vy<0&&p[1].vy<0&&p[2].vy<0&&p[3].vy<0||p[0].vx>=i&&p[1].vx>=i&&p[2].vx>=i&&p[3].vx>=i||p[0].vy>=a&&p[1].vy>=a&&p[2].vy>=a&&p[3].vy>=a?null:l.PROJECTION==f.SIN||l.PROJECTION==f.TAN||m.counterClockwiseTriangle(p[0].vx,p[0].vy,p[1].vx,p[1].vy,p[2].vx,p[2].vy)&&m.counterClockwiseTriangle(p[0].vx,p[0].vy,p[2].vx,p[2].vy,p[3].vx,p[3].vy)?p:null};return n.prototype.reportChange=function(){this.view&&this.view.requestRedraw()},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.reportChange())},n.prototype.contains=function(n,e){var t=new HealpixIndex(Math.pow(2,this.order));t.init();for(var r=HealpixIndex.utils.radecToPolar(n,e),i=t.ang2pix_nest(r.theta,r.phi),a={},o=0;o<=this.order;o++)a[o]=Math.floor(i/Math.pow(4,this.order-o));for(var s=0;s<768;s++){var l=this._highResIndexOrder3[s];for(var c in l)if(c<3)for(var f=l[c].length;f>=0;f--)if(a[c]==l[c][f])return!0}s=a[3],l=this._highResIndexOrder3[s];for(var c in l)for(f=l[c].length;f>=0;f--)if(a[c]==l[c][f])return!0;return!1},n}(),Ee=function(){let n=function(n,e,t,r){this.x1=n,this.y1=e,this.x2=t,this.y2=r};return n.prototype.isInsideView=function(e,t){if(this.x1>=0&&this.x1<=e&&this.y1>=0&&this.y1<=t)return!0;if(this.x2>=0&&this.x2<=e&&this.y2>=0&&this.y2<=t)return!0;let r=n.intersectLine(this.x1,this.y1,this.x2,this.y2,0,0,0,t),i=n.intersectLine(this.x1,this.y1,this.x2,this.y2,e,0,e,t),a=n.intersectLine(this.x1,this.y1,this.x2,this.y2,0,0,e,0),o=n.intersectLine(this.x1,this.y1,this.x2,this.y2,0,t,e,t);return!!(r||i||a||o)},n.prototype.draw=function(n){n.moveTo(this.x1,this.y1),n.lineTo(this.x2,this.y2)},n.intersectLine=function(n,e,t,r,i,a,o,s){let l=((o-i)*(e-a)-(s-a)*(n-i))/((s-a)*(t-n)-(o-i)*(r-e)),c=((t-n)*(e-a)-(r-e)*(n-i))/((s-a)*(t-n)-(o-i)*(r-e));return l>=0&&l<=1&&c>=0&&c<=1},n}(),we=function(){let n=function(n){n=n||{},this.type="overlay",this.name=n.name||"overlay",this.color=n.color||Color.getNextColor(),this.lineWidth=n.lineWidth||2,this.overlays=[],this.overlay_items=[],this.isShowing=!0};return n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.reportChange())},n.parseSTCS=function(n){for(var e=[],t=n.match(/\S+/g),r=0,i=t.length;r<i;){var a=t[r].toLowerCase();if("polygon"==a){var o=[];if("icrs"==(c=t[++r].toLowerCase())||"j2000"==c||"fk5"==c){for(;r+2<i;){var s=parseFloat(t[r+1]);if(isNaN(s))break;var l=parseFloat(t[r+2]);o.push([s,l]),r+=2}o.push(o[0]),e.push(new B(o))}}else if("circle"==a){var c,f;if("icrs"==(c=t[++r].toLowerCase())||"j2000"==c||"fk5"==c)s=parseFloat(t[r+1]),l=parseFloat(t[r+2]),f=parseFloat(t[r+3]),e.push(A.circle(s,l,f)),r+=3}r++}return e},n.prototype.addFootprints=function(n){for(var e=0,t=n.length;e<t;e++)this.add(n[e],!1);this.view.requestRedraw()},n.prototype.add=function(n,e){e=void 0===e||e,n instanceof B?this.overlays.push(n):this.overlay_items.push(n),n.setOverlay(this),e&&this.view.requestRedraw()},n.prototype.getFootprint=function(n){return n<this.footprints.length?this.footprints[n]:null},n.prototype.setView=function(n){this.view=n},n.prototype.removeAll=function(){this.overlays=[],this.overlay_items=[]},n.prototype.draw=function(e,t,r,i,a,o,s){if(this.isShowing){e.strokeStyle=this.color,e.lineWidth=this.lineWidth,e.beginPath();for(var l=[],c=0,f=this.overlays.length;c<f;c++)l.push(this.drawFootprint(this.overlays[c],e,t,r,i,a,o,s));e.stroke(),e.strokeStyle=n.increaseBrightness(this.color,50),e.beginPath();for(c=0,f=this.overlays.length;c<f;c++)this.overlays[c].isSelected&&this.drawFootprintSelected(e,l[c]);e.stroke();for(c=0;c<this.overlay_items.length;c++)this.overlay_items[c].draw(e,this.view,t,r,i,a,o,s)}},n.increaseBrightness=function(n,e){3==(n=n.replace(/^\s*#|\s*$/g,"")).length&&(n=n.replace(/(.)/g,"$1$1"));var t=parseInt(n.substr(0,2),16),r=parseInt(n.substr(2,2),16),i=parseInt(n.substr(4,2),16);return"#"+(0|256+t+(256-t)*e/100).toString(16).substr(1)+(0|256+r+(256-r)*e/100).toString(16).substr(1)+(0|256+i+(256-i)*e/100).toString(16).substr(1)},n.prototype.drawFootprint=function(n,e,t,r,i,a,o,s){if(!n.isShowing)return null;for(var l=n.polygons,c=0;c<l.length-1;c++){let n=this.view.aladin.webglAPI.projectLine(l[c][0],l[c][1],l[c+1][0],l[c+1][1]);for(var f=0;f<n.length;f+=4){let t=new Ee(n[f],n[f+1],n[f+2],n[f+3]);t.isInsideView(i,a)&&t.draw(e)}}return[]},n.prototype.drawFootprintSelected=function(n,e){if(e){var t=e;n.moveTo(t[0].vx,t[0].vy);for(var r=1,i=t.length;r<i;r++)n.lineTo(t[r].vx,t[r].vy)}},n.prototype.reportChange=function(){this.view.requestRedraw()},n}(),Ie=function(){let n=function(n,e,t,r,i){i=i||{},this.color=i.color||void 0,this.id="ellipse-"+a.uuidv4(),this.setCenter(n),this.setRadiuses(e,t),this.setRotation(r),this.overlay=null,this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.dispatchClickEvent=function(){this.overlay&&this.overlay.view.aladinDiv.dispatchEvent(new CustomEvent("footprintClicked",{detail:{footprintId:this.id,overlayName:this.overlay.name}}))},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n.prototype.setCenter=function(n){this.centerRaDec=n,this.overlay&&this.overlay.reportChange()},n.prototype.setRotation=function(n){let e=n*Math.PI/180;this.rotation=e,this.overlay&&this.overlay.reportChange()},n.prototype.setRadiuses=function(n,e){this.radiusXDegrees=n,this.radiusYDegrees=e,this.overlay&&this.overlay.reportChange()},n.prototype.draw=function(n,e,t,r,i,a,o,s,l){if(!this.isShowing)return;l=!0===l||!1;var c=m.radecToViewXy(this.centerRaDec[0],this.centerRaDec[1],e);if(!c)return;let f=m.radecToViewXy(this.centerRaDec[0]+this.radiusXDegrees,this.centerRaDec[1],e),u=m.radecToViewXy(this.centerRaDec[0],this.centerRaDec[1]+this.radiusYDegrees,e);if(!f||!u)return;var h=f[0]-c[0],p=f[1]-c[1],d=Math.sqrt(h*h+p*p),x=u[0]-c[0],_=u[1]-c[1],v=Math.sqrt(x*x+_*_);if(h*_-x*p<=0)return;var g=this.color;!g&&this.overlay&&(g=this.overlay.color),g||(g="#ff0000"),this.isSelected?n.strokeStyle=Overlay.increaseBrightness(g,50):n.strokeStyle=g;let y=this.centerRaDec,b=[this.centerRaDec[0],this.centerRaDec[1]+.001],E=this.overlay.view.aladin.webglAPI.worldToScreen(y[0],y[1]),w=this.overlay.view.aladin.webglAPI.worldToScreen(b[0],b[1]),I=[w[0]-E[0],w[1]-E[1]],C=Math.sqrt(I[0]*I[0]+I[1]*I[1]);I=[I[0]/C,I[1]/C];let S=[1,0],P=S[0],T=S[1],R=I[0],A=I[1],z=Math.atan2(P*A-T*R,P*R+T*A),B=-this.rotation+z;n.beginPath(),n.ellipse(c[0],c[1],d,v,B,0,2*Math.PI,!1),l||n.stroke()},n}(),Ce=function(){let n=function(n,e){e=e||{},this.color=e.color||void 0,this.radecArray=n,this.overlay=null,this.isShowing=!0,this.isSelected=!1};return n.prototype.setOverlay=function(n){this.overlay=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.overlay&&this.overlay.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.overlay&&this.overlay.reportChange())},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.overlay&&this.overlay.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.overlay&&this.overlay.reportChange())},n.prototype.draw=function(n,e,t,r,i,a,o,s){if(this.isShowing&&this.radecArray&&!(this.radecArray.length<2)){this.color&&(n.strokeStyle=this.color),n.beginPath();for(var l=0;l<this.radecArray.length-1;l++){let t=e.aladin.webglAPI.projectLine(this.radecArray[l][0],this.radecArray[l][1],this.radecArray[l+1][0],this.radecArray[l+1][1]);for(var c=0;c<t.length;c+=4){let e=new Ee(t[c],t[c+1],t[c+2],t[c+3]);e.isInsideView(i,a)&&e.draw(n)}}n.stroke()}},n}(),Se={log:function(n,e){try{var t="";e&&(t=JSON.stringify(e)),$.ajax({url:"//alasky.unistra.fr/cgi/AladinLiteLogger/log.py",data:{action:n,params:t,pageUrl:window.location.href,referer:document.referrer?document.referrer:""},method:"GET",dataType:"json"})}catch(n){window.console&&console.log("Exception: "+n)}}},Pe=function(){let n=function(n,e,t,r){this.ra=n,this.dec=e,this.data=t,this.catalog=null,this.marker=r&&r.marker||!1,this.marker&&(this.popupTitle=r&&r.popupTitle?r.popupTitle:"",this.popupDesc=r&&r.popupDesc?r.popupDesc:"",this.useMarkerDefaultIcon=!r||void 0===r.useMarkerDefaultIcon||r.useMarkerDefaultIcon),this.isShowing=!0,this.isSelected=!1};return n.prototype.setCatalog=function(n){this.catalog=n},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.catalog&&this.catalog.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.catalog&&this.catalog.reportChange())},n.prototype.select=function(){this.isSelected||(this.isSelected=!0,this.catalog&&this.catalog.reportChange())},n.prototype.deselect=function(){this.isSelected&&(this.isSelected=!1,this.catalog&&this.catalog.reportChange())},n.prototype.actionClicked=function(){if(this.catalog&&this.catalog.onClick){var n=this.catalog.view;if("showTable"==this.catalog.onClick)n.aladin.measurementTable.showMeasurement(this),this.select();else if("showPopup"==this.catalog.onClick){n.popup.setTitle("<br><br>");var e='<div class="aladin-marker-measurement">';for(var t in e+="<table>",this.data)e+="<tr><td>"+t+"</td><td>"+this.data[t]+"</td></tr>";e+="</table>",e+="</div>",n.popup.setText(e),n.popup.setSource(this),n.popup.show()}else"function"==typeof this.catalog.onClick&&(this.catalog.onClick(this),n.lastClickedObject=this)}},n.prototype.actionOtherObjectClicked=function(){this.catalog&&this.catalog.onClick&&this.deselect()},n}(),Te=function(){let n={curIdx:0,colors:["#ff0000","#0000ff","#99cc00","#ffff00","#000066","#00ffff","#9900cc","#0099cc","#cc9900","#cc0099","#00cc99","#663333","#ffcc9a","#ff9acc","#ccff33","#660000","#ffcc33","#ff00ff","#00ff00","#ffffff"],getNextColor:function(){var e=n.colors[n.curIdx%n.colors.length];return n.curIdx++,e},getLabelColorForBackground:function(n){var e=n.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);if(null==e)return"#111";return 1-(.299*parseInt(e[1])+.587*parseInt(e[2])+.114*parseInt(e[3]))/255<.5?"#111":"#eee"}};return n}(),Re=function(){function n(n){n=n||{},this.type="catalog",this.name=n.name||"catalog",this.color=n.color||Te.getNextColor(),this.sourceSize=n.sourceSize||8,this.markerSize=n.sourceSize||12,this.shape=n.shape||"square",this.maxNbSources=n.limit||void 0,this.onClick=n.onClick||void 0,this.raField=n.raField||void 0,this.decField=n.decField||void 0,this.indexationNorder=5,this.sources=[],this.hpxIdx=new b(this.indexationNorder),this.hpxIdx.init(),this.displayLabel=n.displayLabel||!1,this.labelColor=n.labelColor||this.color,this.labelFont=n.labelFont||"10px sans-serif",this.displayLabel&&(this.labelColumn=n.labelColumn,this.labelColumn||(this.displayLabel=!1)),(this.shape instanceof Image||this.shape instanceof HTMLCanvasElement)&&(this.sourceSize=this.shape.width),this._shapeIsFunction=!1,$.isFunction(this.shape)&&(this._shapeIsFunction=!0),this.selectionColor="#00ff00",this.updateShape(n),this.cacheMarkerCanvas=document.createElement("canvas"),this.cacheMarkerCanvas.width=this.markerSize,this.cacheMarkerCanvas.height=this.markerSize;var e=this.cacheMarkerCanvas.getContext("2d");e.fillStyle=this.color,e.beginPath();var t=this.markerSize/2;e.arc(t,t,t-2,0,2*Math.PI,!1),e.fill(),e.lineWidth=2,e.strokeStyle="#ccc",e.stroke(),this.isShowing=!0}function e(n,e,t){var r,i;if(r=i=null,e)for(var o=0,s=n.length;o<s;o++){var l=n[o];if(a.isInt(e)&&e<n.length){r=e;break}if(l.ID&&l.ID===e||l.name&&l.name===e){r=o;break}}if(t)for(o=0,s=n.length;o<s;o++){l=n[o];if(a.isInt(t)&&t<n.length){i=t;break}if(l.ID&&l.ID===t||l.name&&l.name===t){i=o;break}}for(o=0,s=n.length;o<s&&(null==r||null==i);o++){var c;l=n[o];r||!l.ucd||0!=(c=$.trim(l.ucd.toLowerCase())).indexOf("pos.eq.ra")&&0!=c.indexOf("pos_eq_ra")?i||!l.ucd||0!=(c=$.trim(l.ucd.toLowerCase())).indexOf("pos.eq.dec")&&0!=c.indexOf("pos_eq_dec")||(i=o):r=o}if(null==r&&null==i)for(o=0,s=n.length;o<s;o++){var f=(l=n[o]).name||l.ID||"";f=f.toLowerCase(),r||0!=f.indexOf("ra")&&0!=f.indexOf("_ra")&&0!=f.indexOf("ra(icrs)")&&0!=f.indexOf("_ra")&&0!=f.indexOf("alpha")?i||0!=f.indexOf("dej2000")&&0!=f.indexOf("_dej2000")&&0!=f.indexOf("de")&&0!=f.indexOf("de(icrs)")&&0!=f.indexOf("_de")&&0!=f.indexOf("delta")||(i=o):r=o}return null!=r&&null!=i||(r=0,i=1),[r,i]}return n.createShape=function(n,e,t){if(n instanceof Image||n instanceof HTMLCanvasElement)return n;var r=document.createElement("canvas");r.width=r.height=t;var i=r.getContext("2d");return i.beginPath(),i.strokeStyle=e,i.lineWidth=2,"plus"==n?(i.moveTo(t/2,0),i.lineTo(t/2,t),i.stroke(),i.moveTo(0,t/2),i.lineTo(t,t/2),i.stroke()):"cross"==n?(i.moveTo(0,0),i.lineTo(t-1,t-1),i.stroke(),i.moveTo(t-1,0),i.lineTo(0,t-1),i.stroke()):"rhomb"==n?(i.moveTo(t/2,0),i.lineTo(0,t/2),i.lineTo(t/2,t),i.lineTo(t,t/2),i.lineTo(t/2,0),i.stroke()):"triangle"==n?(i.moveTo(t/2,0),i.lineTo(0,t-1),i.lineTo(t-1,t-1),i.lineTo(t/2,0),i.stroke()):"circle"==n?(i.arc(t/2,t/2,t/2-1,0,2*Math.PI,!0),i.stroke()):(i.moveTo(1,0),i.lineTo(1,t-1),i.lineTo(t-1,t-1),i.lineTo(t-1,1),i.lineTo(1,1),i.stroke()),r},n.parseVOTable=function(n,t,r,i,o,s){a.getAjaxObject(n,"GET","text",i).done((function(n){!function(n,t){n=n.replace(/^\s+/g,"");var i=["name","ID","ucd","utype","unit","datatype","arraysize","width","precision"],l=[],c=0,f=$($.parseXML(n)),h=function(n){var e;if(n.find("RESOURCE").length>0)e="";else{if(0==(e=n.find("*").first()).length)return"";var t=(e=e.prop("tagName")).indexOf(":");e=e.substring(0,t)+"\\:"}return e}(f);f.find(h+"FIELD").each((function(){for(var n={},e=0;e<i.length;e++){var t=i[e];$(this).attr(t)&&(n[t]=$(this).attr(t))}n.ID||(n.ID="col_"+c),l.push(n),c++}));var p,d,x=e(l,o,s);p=x[0],d=x[1];var _,v,m=[],g=new u;f.find(h+"TR").each((function(){var n={},e=0;$(this).find(h+"TD").each((function(){var t=l[e].name?l[e].name:l[e].id;n[t]=$(this).text(),e++}));var t=l[p].name?l[p].name:l[p].id,i=l[d].name?l[d].name:l[d].id;if(a.isNumber(n[t])&&a.isNumber(n[i])?(_=parseFloat(n[t]),v=parseFloat(n[i])):(g.parse(n[t]+" "+n[i]),_=g.lon,v=g.lat),m.push(new Pe(_,v,n)),r&&m.length==r)return!1})),t&&t(m)}(n,t)}))},n.prototype.updateShape=function(e){e=e||{},this.color=e.color||this.color||Te.getNextColor(),this.sourceSize=e.sourceSize||this.sourceSize||6,this.shape=e.shape||this.shape||"square",this.selectSize=this.sourceSize+2,this.cacheCanvas=n.createShape(this.shape,this.color,this.sourceSize),this.cacheSelectCanvas=n.createShape("square",this.selectionColor,this.selectSize),this.reportChange()},n.prototype.addSources=function(n){n=[].concat(n),this.sources=this.sources.concat(n);for(var e=0,t=n.length;e<t;e++)n[e].setCatalog(this);this.reportChange()},n.prototype.addSourcesAsArray=function(n,t){for(var r=[],i=0;i<n.length;i++)r.push({name:n[i]});var o,s,l=e(r,this.raField,this.decField);o=l[0],s=l[1];for(var c,f,h,p,d=[],x=new u,_=0;_<t.length;_++){h=t[_],a.isNumber(h[o])&&a.isNumber(h[s])?(c=parseFloat(h[o]),f=parseFloat(h[s])):(x.parse(h[o]+" "+h[s]),c=x.lon,f=x.lat),p={};for(i=0;i<n.length;i++)p[n[i]]=h[i];d.push(A.source(c,f,p))}this.addSources(d)},n.prototype.getSources=function(){return this.sources},n.prototype.selectAll=function(){if(this.sources)for(var n=0;n<this.sources.length;n++)this.sources[n].select()},n.prototype.deselectAll=function(){if(this.sources)for(var n=0;n<this.sources.length;n++)this.sources[n].deselect()},n.prototype.getSource=function(n){return n<this.sources.length?this.sources[n]:null},n.prototype.setView=function(n){this.view=n,this.reportChange()},n.prototype.remove=function(n){var e=this.sources.indexOf(n);e<0||(this.sources[e].deselect(),this.sources.splice(e,1),this.reportChange())},n.prototype.removeAll=n.prototype.clear=function(){this.sources=[]},n.prototype.draw=function(e,t,r,i,a,o,s){if(this.isShowing){this._shapeIsFunction&&e.save();for(var l,c=[],f=0,u=this.sources.length;f<u;f++){n.drawSource(this,this.sources[f],e,t,r,i,a,o,s)&&c.push(this.sources[f])}this._shapeIsFunction&&e.restore(),e.strokeStyle=this.selectionColor;for(f=0,u=c.length;f<u;f++)(l=c[f]).isSelected&&n.drawSourceSelection(this,l,e);if(this.displayLabel){e.fillStyle=this.labelColor,e.font=this.labelFont;for(f=0,u=c.length;f<u;f++)n.drawSourceLabel(this,c[f],e)}}},n.drawSource=function(n,e,t,r,i,a,o,s,l){if(!e.isShowing)return!1;var c=n.sourceSize,f=n.view.aladin.webglAPI.worldToScreen(e.ra,e.dec);if(f){var u={vx:f[0],vy:f[1]},h=e.popup?100:e.sourceSize;if(u){if(u.vx>a+h||u.vx<0-h||u.vy>o+h||u.vy<0-h)return e.x=e.y=void 0,!1;e.x=u.vx,e.y=u.vy,n._shapeIsFunction?n.shape(e,t,n.view.getViewParams()):e.marker&&e.useMarkerDefaultIcon?t.drawImage(n.cacheMarkerCanvas,e.x-c/2,e.y-c/2):t.drawImage(n.cacheCanvas,e.x-n.cacheCanvas.width/2,e.y-n.cacheCanvas.height/2),e.popup&&e.popup.setPosition(e.x,e.y)}return!0}return!1},n.drawSourceSelection=function(n,e,t){if(e&&e.isShowing&&e.x&&e.y){var r=n.selectSize;t.drawImage(n.cacheSelectCanvas,e.x-r/2,e.y-r/2)}},n.drawSourceLabel=function(n,e,t){if(e&&e.isShowing&&e.x&&e.y){var r=e.data[n.labelColumn];r&&t.fillText(r,e.x,e.y)}},n.prototype.reportChange=function(){this.view&&this.view.requestRedraw()},n.prototype.show=function(){this.isShowing||(this.isShowing=!0,this.reportChange())},n.prototype.hide=function(){this.isShowing&&(this.isShowing=!1,this.view&&this.view.popup&&this.view.popup.source&&this.view.popup.source.catalog==this&&this.view.popup.hide(),this.reportChange())},n}(),Ae=function(){let n=function(n,e,t,r){r=r||{},this.type="progressivecat",this.rootUrl=n,a.isHttpsContext()&&(/u-strasbg.fr/i.test(this.rootUrl)||/unistra.fr/i.test(this.rootUrl))&&(this.rootUrl=this.rootUrl.replace("http://","https://")),this.frameStr=e,this.frame=_.fromString(e)||_.J2000,this.maxOrder=t,this.isShowing=!0,this.name=r.name||"progressive-cat",this.color=r.color||Te.getNextColor(),this.shape=r.shape||"square",this.sourceSize=r.sourceSize||6,this.selectSize=this.sourceSize+2,this.selectionColor="#00ff00",this.filterFn=r.filter||void 0,this.onClick=r.onClick||void 0,this.sourcesCache=new a.LRUCache(100),this.updateShape(r),this.maxOrderAllsky=2,this.isReady=!1};function e(n,e){var t=["name","ID","ucd","utype","unit","datatype","arraysize","width","precision"],r=[],i=0;return n.keyRa=n.keyDec=null,$(e).find("FIELD").each((function(){for(var e={},a=0;a<t.length;a++){var o=t[a];$(this).attr(o)&&(e[o]=$(this).attr(o))}e.ID||(e.ID="col_"+i),n.keyRa||!e.ucd||0!=e.ucd.indexOf("pos.eq.ra")&&0!=e.ucd.indexOf("POS_EQ_RA")||(e.name?n.keyRa=e.name:n.keyRa=e.ID),n.keyDec||!e.ucd||0!=e.ucd.indexOf("pos.eq.dec")&&0!=e.ucd.indexOf("POS_EQ_DEC")||(e.name?n.keyDec=e.name:n.keyDec=e.ID),r.push(e),i++})),r}function t(n,e,t){if(!n.keyRa||!n.keyDec)return[];for(var r=e.split("\n"),i=[],o=0;o<t.length;o++)t[o].name?i.push(t[o].name):i.push(t[o].ID);for(var s,l=[],c=new u,f=2;f<r.length;f++){var h={},p=r[f].split("\t");if(!(p.length<i.length)){for(var d=0;d<i.length;d++)h[i[d]]=p[d];var x,_;a.isNumber(h[n.keyRa])&&a.isNumber(h[n.keyDec])?(x=parseFloat(h[n.keyRa]),_=parseFloat(h[n.keyDec])):(c.parse(h[n.keyRa]+" "+h[n.keyDec]),x=c.lon,_=c.lat),s=new Pe(x,_,h),l.push(s),s.setCatalog(n)}}return l}return n.readProperties=function(n,e,t){if(e){var r=n+"/properties";$.ajax({url:r,method:"GET",dataType:"text",success:function(n){for(var t={},r=n.split("\n"),i=0;i<r.length;i++){var a=r[i],o=a.indexOf("="),s=$.trim(a.substring(0,o)),l=$.trim(a.substring(o+1));t[s]=l}e(t)},error:function(n){t&&t(n)}})}},n.prototype={init:function(e){var t=this;this.view=e,this.maxOrder&&this.frameStr?this._loadMetadata():n.readProperties(t.rootUrl,(function(n){t.properties=n,t.maxOrder=t.properties.hips_order,t.frame=_.fromString(t.properties.hips_frame),t._loadMetadata()}),(function(n){console.log("Could not find properties for HiPS "+t.rootUrl)}))},updateShape:Re.prototype.updateShape,_loadMetadata:function(){var n=this;$.ajax({url:n.rootUrl+"/Metadata.xml",method:"GET",success:function(t){n.fields=e(n,t),n._loadAllskyNewMethod()},error:function(e){n._loadAllskyOldMethod()}})},_loadAllskyNewMethod:function(){var n=this;$.ajax({url:n.rootUrl+"/Norder1/Allsky.tsv",method:"GET",success:function(e){n.order1Sources=t(n,e,n.fields),n.order2Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}}),$.ajax({url:n.rootUrl+"/Norder2/Allsky.tsv",method:"GET",success:function(e){n.order2Sources=t(n,e,n.fields),n.order1Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}})},_loadAllskyOldMethod:function(){this.maxOrderAllsky=3,this._loadLevel2Sources(),this._loadLevel3Sources()},_loadLevel2Sources:function(){var n=this;$.ajax({url:n.rootUrl+"/Norder2/Allsky.xml",method:"GET",success:function(r){n.fields=e(n,r),n.order2Sources=t(n,$(r).find("CSV").text(),n.fields),n.order3Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}})},_loadLevel3Sources:function(){var n=this;$.ajax({url:n.rootUrl+"/Norder3/Allsky.xml",method:"GET",success:function(e){n.order3Sources=t(n,$(e).find("CSV").text(),n.fields),n.order2Sources&&(n.isReady=!0,n._finishInitWhenReady())},error:function(n){console.log("Something went wrong: "+n)}})},_finishInitWhenReady:function(){this.view.requestRedraw(),this.loadNeededTiles()},draw:function(n,e,t,r,i,a,o){if(this.isShowing&&this.isReady&&(this.drawSources(this.order1Sources,n,e,t,r,i,a,o),this.drawSources(this.order2Sources,n,e,t,r,i,a,o),this.drawSources(this.order3Sources,n,e,t,r,i,a,o),this.tilesInView))for(var s,l,c,f=0;f<this.tilesInView.length;f++)l=(c=this.tilesInView[f])[0]+"-"+c[1],(s=this.sourcesCache.get(l))&&this.drawSources(s,n,e,t,r,i,a,o)},drawSources:function(n,e,t,r,i,a,o,s){if(n){for(var l,c=0,f=n.length;c<f;c++)l=n[c],this.filterFn&&!this.filterFn(l)||Re.drawSource(this,l,e,t,r,i,a,o,s);for(c=0,f=n.length;c<f;c++)(l=n[c]).isSelected&&(this.filterFn&&!this.filterFn(l)||Re.drawSourceSelection(this,l,e))}},getSources:function(){var n=[];if(this.order1Sources&&(n=n.concat(this.order1Sources)),this.order2Sources&&(n=n.concat(this.order2Sources)),this.order3Sources&&(n=n.concat(this.order3Sources)),this.tilesInView)for(var e,t,r,i=0;i<this.tilesInView.length;i++)t=(r=this.tilesInView[i])[0]+"-"+r[1],(e=this.sourcesCache.get(t))&&(n=n.concat(e));return n},deselectAll:function(){if(this.order1Sources)for(var n=0;n<this.order1Sources.length;n++)this.order1Sources[n].deselect();if(this.order2Sources)for(n=0;n<this.order2Sources.length;n++)this.order2Sources[n].deselect();if(this.order3Sources)for(n=0;n<this.order3Sources.length;n++)this.order3Sources[n].deselect();var e=this.sourcesCache.keys();for(key in e)if(this.sourcesCache[key]){var t=this.sourcesCache[key];for(n=0;n<t.length;n++)t[n].deselect()}},show:function(){this.isShowing||(this.isShowing=!0,this.loadNeededTiles(),this.reportChange())},hide:function(){this.isShowing&&(this.isShowing=!1,this.reportChange())},reportChange:function(){this.view.requestRedraw()},getTileURL:function(n,e){var t=1e4*Math.floor(e/1e4);return this.rootUrl+"/Norder"+n+"/Dir"+t+"/Npix"+e+".tsv"},loadNeededTiles:function(){if(this.isShowing){this.tilesInView=[];var n=this.view.realNorder;if(n>this.maxOrder&&(n=this.maxOrder),!(n<=this.maxOrderAllsky)){for(var e,r,i,a,o=this.view.getVisibleCells(n,this.frame),s=3;s<=n;s++){e=[];for(var l=0;l<o.length;l++)r=Math.floor(o[l].ipix/Math.pow(4,n-s)),e.indexOf(r)<0&&e.push(r);for(var c=0;c<e.length;c++)this.tilesInView.push([s,e[c]])}for(l=0;l<this.tilesInView.length;l++)a=(i=this.tilesInView[l])[0]+"-"+i[1],this.sourcesCache.get(a)||function(n,e,r){var i=e+"-"+r;$.ajax({url:n.getTileURL(e,r),method:"GET",success:function(e){n.sourcesCache.set(i,t(n,e,n.fields))},error:function(){n.sourcesCache.set(i,[])}})}(this,i[0],i[1])}}},reportChange:function(){this.view&&this.view.requestRedraw()}},n}(),ze=function(){let n={cache:{},SESAME_URL:"http://cds.u-strasbg.fr/cgi-bin/nph-sesame.jsonp",getTargetRADec:function(e,t,r){if(t)if(/[a-zA-Z]/.test(e))n.resolve(e,(function(n){t({ra:n.Target.Resolver.jradeg,dec:n.Target.Resolver.jdedeg})}),(function(n){r&&r()}));else{var i=new Coo;i.parse(e),t&&t({ra:i.lon,dec:i.lat})}},resolve:function(e,t,r){var i=n.SESAME_URL;a.isHttpsContext()&&(i=i.replace("http://","https://")),$.ajax({url:i,data:{object:e},method:"GET",dataType:"jsonp",success:function(n){n.Target&&n.Target.Resolver&&n.Target.Resolver?t(n):r(n)},error:r})}};return n}(),Be=function(){function n(n){this.isShowing=!1,this.divEl=$('<div class="aladin-measurement-div"></div>'),$(n).append(this.divEl)}return n.prototype.showMeasurement=function(n){this.divEl.empty();var e="<thead><tr>",t="<tr>";for(let r in n.data)e+="<th>"+r+"</th>",t+="<td>"+n.data[r]+"</td>";e+="</tr></thead>",t+="</tr>",this.divEl.append("<table>"+e+t+"</table>"),this.show()},n.prototype.show=function(){this.divEl.show()},n.prototype.hide=function(){this.divEl.hide()},n}(),Le=function(){function n(n){this.$div=$(n)}return n.prototype.update=function(n,e,t,r){r=r&&!0===r||!1;var i=new u(n,e,7);t==_.J2000?this.$div.html(i.format("s/")):(_.J2000d,this.$div.html(i.format("d/"))),this.$div.toggleClass("aladin-reticleColor",r)},n}(),ke={buildSimbadCSURL:function(n,e){return n&&"object"==typeof n&&"ra"in n&&"dec"in n&&(n=new u(n.ra,n.dec,7).format("s")),"https://alasky.unistra.fr/cgi/simbad-flat/simbad-cs.py?target="+encodeURIComponent(n)+"&SR="+e+"&format=votable&SRUNIT=deg&SORTBY=nbref"},buildNEDPositionCSURL:function(n,e,t){return"https://ned.ipac.caltech.edu/cgi-bin/nph-objsearch?search_type=Near+Position+Search&of=xml_main&RA="+n+"&DEC="+e+"&SR="+t},buildNEDObjectCSURL:function(n,e){return"https://ned.ipac.caltech.edu/cgi-bin/nph-objsearch?search_type=Near+Name+Search&radius="+60*e+"&of=xml_main&objname="+n},buildVizieRCSURL:function(n,e,t,r){console.log(e),e&&"object"==typeof e&&"ra"in e&&"dec"in e&&(e=new u(e.ra,e.dec,7).format("s"));var i=1e5;return r&&r.hasOwnProperty("limit")&&a.isNumber(r.limit)&&(i=parseInt(r.limit)),"https://vizier.unistra.fr/viz-bin/votable?-source="+n+"&-c="+encodeURIComponent(e)+"&-out.max="+i+"&-c.rd="+t},buildSkyBotCSURL:function(n,e,t,r,i){var a="http://vo.imcce.fr/webservices/skybot/skybotconesearch_query.php?-from=AladinLite";if(a+="&RA="+encodeURIComponent(n),a+="&DEC="+encodeURIComponent(e),a+="&SR="+encodeURIComponent(t),a+="&EPOCH="+encodeURIComponent(r),i)for(var o in i)i.hasOwnProperty(o)&&(a+="&"+o+"="+encodeURIComponent(i[o]));return a}},Oe=function(n){new Vue({el:"#ui",methods:{getFovCorners:()=>n.getFovCorners(),getCenter:()=>n.getRaDec(),addImage(e){e.hips_order;const t=e.hips_tile_format.split(" ");let r,i;t.indexOf("fits")>=0?(r={FITSImage:{bitpix:parseInt(e.hips_pixel_bitpix)}},i={Grayscale2Color:{color:[1,1,1],k:1,transfer:"asinh"}}):(i="Color",r=t.indexOf("png")>=0?{Image:{format:"png"}}:{Image:{format:"jpeg"}});let a=[void 0,void 0];e.hips_pixel_cut&&(a=e.hips_pixel_cut.split(" "));let o=512;if(e.hips_tile_width){let n=parseInt(e.hips_tile_width);!0===(n&&!(n&n-1))&&(o=n)}let s=e.hips_service_url;s=s.startsWith("http://alasky")?s.replace("http","https"):"https://alasky.u-strasbg.fr/cgi/JSONProxy?url="+s;let l={properties:{url:s,maxOrder:parseInt(e.hips_order),frame:{label:"J2000",system:"J2000"},tileSize:o,format:r,minCutout:parseFloat(a[0]),maxCutout:parseFloat(a[1])},color:i};n.webglAPI.setHiPS([l])},addCatalog(e,t,r){if(e.hips_service_url){const t=A.catalogHiPS(e.hips_service_url,{onClick:"showTable",name:e.ID});n.addCatalog(t)}else{console.log(e.obs_id,"center, ",t," radius, ",r);const i=A.catalogFromVizieR(e.obs_id,{ra:t[0],dec:t[1]},r,{onClick:"showTable",limit:1e3});n.addCatalog(i)}},addCoverage(e){const t=A.MOCFromURL(e.moc_access_url);n.addMOC(t)}}})},De=function(){var n=function(e,t){if(0!=$(e).length){this.webglAPI=null;var r=this;if(void 0===t&&(t=this.getOptionsFromQueryString()),"zoom"in(t=t||{})){var i=t.zoom;delete t.zoom,t.fov=i}var a={};for(var o in n.DEFAULT_OPTIONS)void 0!==t[o]?a[o]=t[o]:a[o]=n.DEFAULT_OPTIONS[o];for(var o in t)void 0===n.DEFAULT_OPTIONS[o]&&(a[o]=t[o]);this.options=a,$("<style type='text/css'> .aladin-reticleColor { color: "+this.options.reticleColor+"; font-weight:bold;} </style>").appendTo(e),this.aladinDiv=e,this.reduceDeformations=!0,$(e).addClass("aladin-container");var s=_.fromString(a.cooFrame,_.J2000),l=$('<div class="aladin-location">'+(a.showFrame?'<select class="aladin-frameChoice"><option value="'+_.J2000.label+'" '+(s==_.J2000?'selected="selected"':"")+'>J2000</option><option value="'+_.J2000d.label+'" '+(s==_.J2000d?'selected="selected"':"")+'>J2000d</option><option value="'+_.GAL.label+'" '+(s==_.GAL?'selected="selected"':"")+">GAL</option></select>":"")+'<span class="aladin-location-text"></span></div>').appendTo(e),c=$('<div class="aladin-fov"></div>').appendTo(e);a.showZoomControl&&$('<div class="aladin-zoomControl"><a href="#" class="zoomPlus" title="Zoom in">+</a><a href="#" class="zoomMinus" title="Zoom out">&ndash;</a></div>').appendTo(e),a.showFullscreenControl&&$('<div class="aladin-fullscreenControl aladin-maximize" title="Full screen"></div>').appendTo(e),this.fullScreenBtn=$(e).find(".aladin-fullscreenControl"),this.fullScreenBtn.click((function(){r.toggleFullscreen(r.options.realFullscreen)})),$(document).on("fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange",(function(n){var e=document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement;if(null==e){r.fullScreenBtn.removeClass("aladin-restore"),r.fullScreenBtn.addClass("aladin-maximize"),r.fullScreenBtn.attr("title","Full screen"),$(r.aladinDiv).removeClass("aladin-fullscreen");var t=r.callbacksByEventName.fullScreenToggled,i=r.fullScreenBtn.hasClass("aladin-restore");"function"==typeof t&&t(i)}})),$("<div class='aladin-logo-container'><a href='https://aladin.unistra.fr/' title='Powered by Aladin Lite' target='_blank'><div class='aladin-logo'></div></a></div>").appendTo(e),this.boxes=[],this.measurementTable=new Be(e);var f=new Le(l.find(".aladin-location-text"));if(this.view=new ge(this,f,c,s,a.fov),this.view.setShowGrid(a.showCooGrid),a.showLayersControl){(d=$('<div class="aladin-layersControl-container" title="Manage layers"><div class="aladin-layersControl"></div></div>')).appendTo(e);var u=$('<div class="aladin-box aladin-layerBox aladin-cb-list"></div>');u.appendTo(e),this.boxes.push(u),d.click((function(){return r.hideBoxes(),r.showLayerBox(),!1}))}if(a.showGotoControl){(d=$('<div class="aladin-gotoControl-container" title="Go to position"><div class="aladin-gotoControl"></div></div>')).appendTo(e);var h=$('<div class="aladin-box aladin-gotoBox"><a class="aladin-closeBtn">&times;</a><div style="clear: both;"></div><form class="aladin-target-form">Go to: <input type="text" placeholder="Object name/position" /></form></div>');h.appendTo(e),this.boxes.push(h);var p=h.find(".aladin-target-form input");p.on("paste keydown",(function(){$(this).removeClass("aladin-unknownObject")})),d.click((function(){return r.hideBoxes(),p.val(""),p.removeClass("aladin-unknownObject"),h.show(),p.focus(),!1})),h.find(".aladin-closeBtn").click((function(){return r.hideBoxes(),!1}))}if(a.showSimbadPointerControl)(d=$('<div class="aladin-simbadPointerControl-container" title="SIMBAD pointer"><div class="aladin-simbadPointerControl"></div></div>')).appendTo(e),d.click((function(){r.view.setMode(ge.TOOL_SIMBAD_POINTER)}));if(a.showShareControl){var d;(d=$('<div class="aladin-shareControl-container" title="Get link for current view"><div class="aladin-shareControl"></div></div>')).appendTo(e);var x=$('<div class="aladin-box aladin-shareBox"><a class="aladin-closeBtn">&times;</a><div style="clear: both;"></div>Link to previewer: <span class="info"></span><input type="text" class="aladin-shareInput" /></div>');x.appendTo(e),this.boxes.push(x),d.click((function(){r.hideBoxes(),x.show();var n=r.getShareURL();return x.find(".aladin-shareInput").val(n).select(),document.execCommand("copy"),!1})),x.find(".aladin-closeBtn").click((function(){return r.hideBoxes(),!1}))}if(this.gotoObject(a.target,void 0,{forceAnimation:!1}),a.log){var v=t;v.version=n.VERSION,Se.log("startup",v)}if(this.showReticle(a.showReticle),a.catalogUrls)for(var m=0,g=a.catalogUrls.length;m<g;m++)this.createCatalogFromVOTable(a.catalogUrls[m]);a.survey&&(async()=>{if(typeof a.survey===Array){let e=0;a.survey.forEach(async t=>{const r=await n.createImageSurvey(t);0==e?this.setImageSurvey(r,"base"):this.addImageSurvey(r,"base"),e++})}else{const e=await n.createImageSurvey(a.survey,"base");this.setImageSurvey(e,"base")}})(),this.view.showCatalog(a.showCatalog);var y=this;$(e).find(".aladin-frameChoice").change((function(){y.setFrame($(this).val())})),$(e).find(".aladin-target-form").submit((function(){return y.gotoObject($(this).find("input").val(),(function(){$(e).find(".aladin-target-form input").addClass("aladin-unknownObject")})),!1}));var b=$(e).find(".zoomPlus");b.click((function(){return y.increaseZoom(),!1})),b.bind("mousedown",(function(n){n.preventDefault()}));var E=$(e).find(".zoomMinus");E.click((function(){return y.decreaseZoom(),!1})),E.bind("mousedown",(function(n){n.preventDefault()})),this.callbacksByEventName={},"undefined"!=typeof Vue&&(this.discoverytree=new Oe(this)),this.view.redraw(),a.fullScreen&&window.setTimeout((function(){r.toggleFullscreen(r.options.realFullscreen)}),10)}};n.VERSION="{ALADIN-LITE-VERSION-NUMBER}",n.JSONP_PROXY="https://alasky.unistra.fr/cgi/JSONProxy",n.wasmLibs={},n.webglAPI=[],n.DEFAULT_OPTIONS={target:"0 +0",cooFrame:"J2000",survey:"P/DSS2/color",fov:60,showReticle:!0,showZoomControl:!0,showFullscreenControl:!0,showLayersControl:!0,showGotoControl:!0,showSimbadPointerControl:!1,showShareControl:!1,showCatalog:!0,showFrame:!0,showCooGrid:!1,fullScreen:!1,reticleColor:"rgb(178, 50, 178)",reticleSize:22,log:!0,allowFullZoomout:!1,realFullscreen:!1,showAllskyRing:!1,allskyRingColor:"#c8c8ff",allskyRingWidth:8,pixelateCanvas:!0},n.prototype.toggleFullscreen=function(n){n=Boolean(n),this.fullScreenBtn.toggleClass("aladin-maximize aladin-restore");var e=this.fullScreenBtn.hasClass("aladin-restore");if(this.fullScreenBtn.attr("title",e?"Restore original size":"Full screen"),$(this.aladinDiv).toggleClass("aladin-fullscreen"),n)if(e){var t=this.aladinDiv;t.requestFullscreen?t.requestFullscreen():t.webkitRequestFullscreen?t.webkitRequestFullscreen():t.mozRequestFullScreen?t.mozRequestFullScreen():t.msRequestFullscreen&&t.msRequestFullscreen()}else document.exitFullscreen?document.exitFullscreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen();this.view.fixLayoutDimensions();var r=this.callbacksByEventName.zoomChanged;"function"==typeof r&&r(this.view.fov);var i=this.callbacksByEventName.fullScreenToggled;"function"==typeof i&&i(e)},n.prototype.updateSurveysDropdownList=function(n){n=n.sort((function(n,e){return n.order?n.order&&n.order>e.order?1:-1:n.id>e.id}));var e=$(this.aladinDiv).find(".aladin-surveySelection");e.empty();for(var t=0;t<n.length;t++){var r=this.view.imageSurvey.id==n[t].id;e.append($("<option />").attr("selected",r).val(n[t].id).text(n[t].name))}},n.prototype.setAngleRotation=function(n){this.view.setAngleRotation(n)},n.prototype.getOptionsFromQueryString=function(){var n={},e=$.urlParam("target");e&&(n.target=e);var t=$.urlParam("frame");t&&_[t]&&(n.frame=t);var r=$.urlParam("survey");r&&s.getSurveyInfoFromId(r)&&(n.survey=r);var i=$.urlParam("zoom");i&&i>0&&i<180&&(n.zoom=i);var a=$.urlParam("showReticle");a&&(n.showReticle="true"==a.toLowerCase());var o=$.urlParam("cooFrame");o&&(n.cooFrame=o);var l=$.urlParam("fullScreen");return void 0!==l&&(n.fullScreen=l),n},n.prototype.setFoV=n.prototype.setFov=function(n){this.view.setZoom(n)},n.prototype.adjustFovForObject=function(n){var e=this;this.getFovForObject(n,(function(n){e.setFoV(n)}))},n.prototype.getFovForObject=function(n,e){var t="//simbad.u-strasbg.fr/simbad/sim-tap/sync?query="+encodeURIComponent("SELECT galdim_majaxis, V FROM basic JOIN ident ON oid=ident.oidref JOIN allfluxes ON oid=allfluxes.oidref WHERE id='"+n+"'")+"&request=doQuery&lang=adql&format=json&phase=run";a.getAjaxObject(t,"GET","json",!1).done((function(n){var t=4/60;if("data"in n&&n.data.length>0){var r=a.isNumber(n.data[0][0])?n.data[0][0]/60:null,i=a.isNumber(n.data[0][1])?n.data[0][1]:null;null!==r?t=2*r:null!==i&&i<10&&(t=2*Math.pow(2,6-i/2)/60)}"function"==typeof e&&e(t)}))},n.prototype.setFrame=function(n){if(n){var e=_.fromString(n,_.J2000);e!=this.view.cooFrame&&(this.view.changeFrame(e),$(this.aladinDiv).find(".aladin-frameChoice").val(e.label))}},n.prototype.setProjection=function(n){n&&(n=n.toLowerCase(),this.view.changeProjection(n))},n.prototype.gotoObject=function(e,t,r){let i=void 0,a=void 0;if("object"==typeof t?(t.hasOwnProperty("success")&&(i=t.success),t.hasOwnProperty("error")&&(a=t.error)):"function"==typeof t&&(a=t),/[a-zA-Z]/.test(e)){var o=this;ze.resolve(e,(function(n){var e=n.Target.Resolver.jradeg,t=n.Target.Resolver.jdedeg;o.view.pointTo(e,t,r),"function"==typeof i&&i(o.getRaDec())}),(function(n){console&&(console.log("Could not resolve object name "+e),console.log(n)),"function"==typeof a&&a()}))}else{var s=new u;s.parse(e);var l=[s.lon,s.lat];this.view.aladin.webglAPI.cooSystem()===n.wasmLibs.webgl.GALCooSys()&&(l=this.view.aladin.webglAPI.Gal2J2000(s.lon,s.lat)),this.view.pointTo(l[0],l[1],r),"function"==typeof i&&i(this.getRaDec())}},n.prototype.gotoPosition=function(n,e){var t;t=this.view.cooFrame==_.GAL?k.GalacticToJ2000([n,e]):[n,e],this.view.pointTo(t[0],t[1])};var e=function(n){var t=n.animationParams;if(null!=t&&t.running){var r=(new Date).getTime();if(r>t.end)return n.gotoRaDec(t.raEnd,t.decEnd),void(t.complete&&t.complete());var i=(r-t.start)/(t.end-t.start),a=function(n,e,t,r,i){function a(n){return n*Math.PI/180}function o(n){return 180*n/Math.PI}e=a(e),n=a(n),r=a(r),t=a(t);var s=2*Math.asin(Math.sqrt(Math.pow(Math.sin((e-r)/2),2)+Math.cos(e)*Math.cos(r)*Math.pow(Math.sin((n-t)/2),2))),l=Math.sin((1-i)*s)/Math.sin(s),c=Math.sin(i*s)/Math.sin(s),f=l*Math.cos(e)*Math.cos(n)+c*Math.cos(r)*Math.cos(t),u=l*Math.cos(e)*Math.sin(n)+c*Math.cos(r)*Math.sin(t),h=l*Math.sin(e)+c*Math.sin(r),p=Math.atan2(u,f),d=Math.atan2(h,Math.sqrt(Math.pow(f,2)+Math.pow(u,2)));return[o(p),o(d)]}(t.raStart,t.decStart,t.raEnd,t.decEnd,i),o=a[0],s=a[1];n.gotoRaDec(o,s),setTimeout((function(){e(n)}),50)}};n.prototype.stopAnimation=function(){this.zoomAnimationParams&&(this.zoomAnimationParams.running=!1),this.animationParams&&(this.animationParams.running=!1)},n.prototype.animateToRaDec=function(n,t,r,i){r=r||5,this.animationParams=null;var a={};a.start=(new Date).getTime(),a.end=(new Date).getTime()+1e3*r;var o=this.getRaDec();a.raStart=o[0],a.decStart=o[1],a.raEnd=n,a.decEnd=t,a.complete=i,a.running=!0,this.animationParams=a,e(this)};var t=function(n){var e=n.zoomAnimationParams;if(null!=e&&e.running){var r=(new Date).getTime();if(r>e.end)return n.setFoV(e.fovEnd),void(e.complete&&e.complete());var i=(r-e.start)/(e.end-e.start),a=e.fovStart+(e.fovEnd-e.fovStart)*Math.sqrt(i);n.setFoV(a),setTimeout((function(){t(n)}),50)}};return n.prototype.zoomToFoV=function(n,e,r){e=e||5,this.zoomAnimationParams=null;var i={};i.start=(new Date).getTime(),i.end=(new Date).getTime()+1e3*e;var a=this.getFov();i.fovStart=Math.max(a[0],a[1]),i.fovEnd=n,i.complete=r,i.running=!0,this.zoomAnimationParams=i,t(this)},n.prototype.getRaDec=function(){return this.webglAPI.getCenter()},n.prototype.gotoRaDec=function(n,e){this.view.pointTo(n,e)},n.prototype.showHealpixGrid=function(n){this.view.showHealpixGrid(n)},n.prototype.showSurvey=function(n){this.view.showSurvey(n)},n.prototype.showCatalog=function(n){this.view.showCatalog(n)},n.prototype.showReticle=function(n){this.view.showReticle(n),$("#displayReticle").attr("checked",n)},n.prototype.removeLayers=function(){this.view.removeLayers()},n.prototype.addCatalog=function(n){this.view.addCatalog(n)},n.prototype.addOverlay=function(n){this.view.addOverlay(n)},n.prototype.addMOC=function(n){this.view.addMOC(n)},n.createImageSurvey=async function(n){return await s.create(n)},n.prototype.setImageSurvey=function(n,e){let t;t=e||"base",this.view.setImageSurvey(n,t)},n.prototype.setImageSurveysLayer=function(n,e){let t;t=e||"base",this.view.setImageSurveysLayer(n,t)},n.prototype.removeImageSurveysLayer=function(n){let e;e=n||"base",this.view.removeImageSurveysLayer(e)},n.prototype.moveImageSurveysLayerForward=function(n){this.view.moveImageSurveysLayerForward(surveys,layerName)},n.prototype.addImageSurvey=function(n,e){let t;t=e||"base",this.view.addImageSurvey(n,t)},n.prototype.setOpacityLayer=function(n,e){let t;t=e||"base",this.webglAPI.setOpacityLayer(n,e)},n.prototype.setBaseImageSurveysLayer=function(n){this.view.setImageSurveysLayer(n,"base")},n.prototype.setBaseImageSurvey=function(n){this.view.setImageSurvey(n,"base")},n.prototype.increaseZoom=function(n){this.view.increaseZoom()},n.prototype.decreaseZoom=function(n){this.view.decreaseZoom()},n.prototype.createProgressiveCatalog=function(n,e,t,r){return new Ae(n,e,t,r)},n.prototype.createOverlay=function(n){return new we(n)},n.AVAILABLE_CALLBACKS=["select","objectClicked","objectHovered","footprintClicked","footprintHovered","positionChanged","zoomChanged","click","mouseMove","fullScreenToggled","catalogReady"],n.prototype.on=function(e,t){n.AVAILABLE_CALLBACKS.indexOf(e)<0||(this.callbacksByEventName[e]=t)},n.prototype.select=function(){this.fire("selectstart")},n.prototype.fire=function(n,e){if("selectstart"===n)this.view.setMode(ge.SELECT);else if("selectend"===n){this.view.setMode(ge.PAN);var t=this.callbacksByEventName.select;"function"==typeof t&&t(e)}},n.prototype.hideBoxes=function(){if(this.boxes)for(var n=0;n<this.boxes.length;n++)this.boxes[n].hide()},n.prototype.updateCM=function(){},n.prototype.showLayerBox=function(){var n=this,e=$(this.aladinDiv).find(".aladin-layerBox");e.empty(),e.append('<a class="aladin-closeBtn">&times;</a><div style="clear: both;"></div></div>'),e.append('<div class="aladin-label">Projection</div><select id="projectionChoice"><option id="sinus" value="sinus">SINUS</option><option id="aitoff" value="aitoff">AITOFF</option><option id="mollweide" value="mollweide">MOLLWEIDE</option><option id="mercator" value="mercator">MERCATOR</option><option id="arc" value="arc">ARC</option><option id="tan" value="tan">TAN</option></select><br/>'),$("#projectionChoice").change((function(){aladin.setProjection($(this).val())})),e.append('<div class="aladin-box-separator"></div><div class="aladin-label">Overlay layers</div>');for(var t=this.view.allOverlayLayers,r="<ul>",i=t.length-1;i>=0;i--){var a=t[i],o=a.name,s="";a.isShowing&&(s='checked="checked"');var l="",c="";if("catalog"==a.type||"progressivecat"==a.type){var f=a.getSources().length;l=f+" source"+(f>1?"s":""),c=m.SVG_ICONS.CATALOG}else"moc"==a.type?(l="Coverage: "+(100*a.skyFraction()).toFixed(3)+" % of sky",c=m.SVG_ICONS.MOC):"overlay"==a.type&&(c=m.SVG_ICONS.OVERLAY);var u=$("<div></div>").css("color",a.color).css("color"),h=Te.getLabelColorForBackground(u);r+='<li><div class="aladin-stack-icon" style=\'background-image: url("data:image/svg+xml;base64,'+window.btoa(c.replace(/FILLCOLOR/g,a.color))+"\");'></div>",r+='<input type="checkbox" '+s+' id="aladin_lite_'+o+'"></input><label for="aladin_lite_'+o+'" class="aladin-layer-label" style="background: '+a.color+"; color:"+h+';" title="'+l+'">'+o+"</label></li>"}r+="</ul>",e.append(r),e.append('<div class="aladin-blank-separator"></div>');s="";this.view.displayReticle&&(s='checked="checked"');var p=$('<input type="checkbox" '+s+' id="displayReticle" />');e.append(p).append('<label for="displayReticle">Reticle</label><br/>'),p.change((function(){n.showReticle($(this).is(":checked"))})),s="",this.view.displayHpxGrid&&(s='checked="checked"');var d=$('<input type="checkbox" '+s+' id="displayHpxGrid"/>');e.append(d).append('<label for="displayHpxGrid">HEALPix grid</label><br/>'),d.change((function(){n.showHealpixGrid($(this).is(":checked"))})),s="",this.view.showGrid&&(s='checked="checked"');var x=$('<input type="checkbox" '+s+' id="displayEquatorialGrid"/>');e.append(x).append('<label for="displayEquatorialGrid">Equatorial grid</label><br/>'),x.change((function(){let e=$(this).is(":checked");n.view.setShowGrid(e)})),e.append('<div class="aladin-box-separator"></div><div class="aladin-label">Tools</div>');var _=$('<button class="aladin-btn" type="button">Export view as PNG</button>');e.append(_),_.click((function(){n.exportAsPNG()})),e.find(".aladin-closeBtn").click((function(){return n.hideBoxes(),!1})),$(this.aladinDiv).find(".aladin-layerBox ul input").change((function(){var e=$(this).attr("id").substr(12),t=n.layerByName(e);$(this).is(":checked")?t.show():t.hide()})),e.show()},n.prototype.layerByName=function(n){for(var e=this.view.allOverlayLayers,t=0;t<e.length;t++)if(n==e[t].name)return e[t];return null},n.prototype.exportAsPNG=function(n){var e=window.open();e.document.write('<img src="'+this.getViewDataURL()+'">'),e.document.title="Aladin Lite snapshot"},n.prototype.getViewDataURL=function(n){"object"!=typeof(n=n||{})&&(n={format:n});return this.view.getCanvasDataURL(n.format,n.width,n.height)},n.prototype.getViewWCS=function(n){var e=this.getRaDec(),t=this.getFov();return{NAXIS:2,NAXIS1:this.view.width,NAXIS2:this.view.height,RADECSYS:"ICRS",CRPIX1:this.view.width/2,CRPIX2:this.view.height/2,CRVAL1:e[0],CRVAL2:e[1],CTYPE1:"RA---SIN",CTYPE2:"DEC--SIN",CD1_1:t[0]/this.view.width,CD1_2:0,CD2_1:0,CD2_2:t[1]/this.view.height}},n.prototype.setFovRange=n.prototype.setFOVRange=function(n,e){if(n>e){var t=n;n=e,e=t}this.view.minFOV=n,this.view.maxFOV=e},n.prototype.pix2world=function(e,t){if(this.view){var r,i;try{r=this.view.aladin.webglAPI.screenToWorld(e,t)}catch(n){return}return this.view.aladin.webglAPI.cooSystem()===n.wasmLibs.webgl.GALCooSys()&&(i=this.view.aladin.webglAPI.Gal2J2000(r[0],r[1])),i}},n.prototype.world2pix=function(n,e){if(this.view){var t;if(this.view.cooFrame==_.GAL){var r=k.J2000ToGalactic([n,e]);t=this.view.projection.project(r[0],r[1])}else t=this.view.projection.project(n,e);if(t){var i=m.xyToView(t.X,t.Y,this.view.width,this.view.height,this.view.largestDim,this.view.zoomFactor);return[i.vx,i.vy]}return null}},n.prototype.getFovCorners=function(n){(!n||n<1)&&(n=1);for(var e,t,r,i,a=[],o=0;o<4;o++){e=0==o||3==o?0:this.view.width-1,t=o<2?0:this.view.height-1,r=o<2?this.view.width-1:0,i=1==o||2==o?this.view.height-1:0;for(var s=0;s<n;s++){let o=this.webglAPI.screenToWorld(e+s/n*(r-e),t+s/n*(i-t));a.push(o)}}return a},n.prototype.getFov=function(){var n=this.view.fov,e=this.getSize(),t=e[1]/e[0]*n;return[n=Math.min(n,180),t=Math.min(t,180)]},n.prototype.getSize=function(){return[this.view.width,this.view.height]},n.prototype.getParentDiv=function(){return $(this.aladinDiv)},n}(),Me={aladin:function(n,e){return new De($(n)[0],e)},source:function(n,e,t,r){return new Pe(n,e,t,r)},marker:function(n,e,t,r){return(t=t||{}).marker=!0,Me.source(n,e,r,t)},createImageSurvey:async function(n){return await s.create(n)},polygon:function(n){var e=n.length;return e>0&&(n[0][0]==n[e-1][0]&&n[0][1]==n[e-1][1]||n.push([n[0][0],n[0][1]])),new B(n)},polyline:function(n,e){return new Ce(n,e)},circle:function(n,e,t,r){return new L([n,e],t,r)},ellipse:function(n,e,t,r,i,a){return new Ie([n,e],t,r,i,a)},graphicOverlay:function(n){return new we(n)},imageSurveyLayer:function(n){return new me(n)},catalog:function(n){return new Re(n)},catalogHiPS:function(n,e){return new Ae(n,null,null,e)}};De.prototype.box=function(n){var e=new Box(n);return e.$parentDiv.appendTo(this.aladinDiv),e},De.prototype.showPopup=function(n,e,t,r){this.view.catalogForPopup.removeAll();var i=Me.marker(n,e,{popupTitle:t,popupDesc:r,useMarkerDefaultIcon:!1});this.view.catalogForPopup.addSources(i),this.view.catalogForPopup.show(),this.view.popup.setTitle(t),this.view.popup.setText(r),this.view.popup.setSource(i),this.view.popup.show()},De.prototype.hidePopup=function(){this.view.popup.hide()},De.prototype.getShareURL=function(){var n=this.getRaDec(),e=new u;return e.prec=7,e.lon=n[0],e.lat=n[1],"https://aladin.unistra.fr/AladinLite/?target="+encodeURIComponent(e.format("s"))+"&fov="+this.getFov()[0].toFixed(2)+"&survey="+encodeURIComponent(this.getBaseImageLayer().id||this.getBaseImageLayer().rootUrl)},De.prototype.getEmbedCode=function(){var n=this.getRaDec(),e=new u;e.prec=7,e.lon=n[0],e.lat=n[1];var t="";return t+='<link rel="stylesheet" href="https://aladin.unistra.fr/AladinLite/api/v2/latest/aladin.min.css" />\n',t+='<script type="text/javascript" src="https://code.jquery.com/jquery-1.9.1.min.js" charset="utf-8"><\/script>\n',t+='<div id="aladin-lite-div" style="width:400px;height:400px;"></div>\n',t+='<script type="text/javascript" src="https://aladin.unistra.fr/AladinLite/api/v2/latest/aladin.min.js" charset="utf-8"><\/script>\n',t+='<script type="text/javascript">\n',t+='var aladin = A.aladin("#aladin-lite-div", {survey: "'+this.getBaseImageLayer().id+'P/DSS2/color", fov: '+this.getFov()[0].toFixed(2)+', target: "'+e.format("s")+'"});\n',t+="<\/script>"},De.prototype.displayFITS=function(n,e,t,r,i){var a={url:n};(t=t||{}).color&&(a.color=!0),t.outputFormat&&(a.format=t.outputFormat),t.order&&(a.order=t.order),t.nocache&&(a.nocache=t.nocache);let o=this;$.ajax({url:"https://alasky.unistra.fr/cgi/fits2HiPS",data:a,method:"GET",dataType:"json",success:function(n){if("success"!=n.status)return console.error("An error occured: "+n.message),void(i&&i(n.message));t.label;var a=n.data.meta;(async()=>{let i=await De.createImageSurvey(n.data.url);var s=t&&t.transparency||1,l=!0;r&&(l=r(a.ra,a.dec,a.fov)),!0===l&&(o.webglAPI.setCenter(a.ra,a.dec),o.setFoV(a.fov)),o.setImageSurvey(i,e),o.setOpacityLayer(s,e)})()}})},De.prototype.displayJPG=De.prototype.displayPNG=function(n,e,t,r,i){(t=t||{}).color=!0,t.label="JPG/PNG image",t.outputFormat="png",this.displayFITS(n,e,t,r,i)},De.prototype.setReduceDeformations=function(n){this.reduceDeformations=n,this.view.requestRedraw()},Me.footprintsFromSTCS=function(n){return we.parseSTCS(n)},Me.MOCFromURL=function(n,e,t){var r=new be(e);return r.dataFromFITSURL(n,t),r},Me.MOCFromJSON=function(n,e){var t=new be(e);return t.dataFromJSON(n),t},Me.catalogFromURL=function(n,e,t,r){var i=Me.catalog(e);return Re.parseVOTable(n,(function(n){i.addSources(n),t&&t(n)}),i.maxNbSources,r,i.raField,i.decField),i},Me.catalogFromSimbad=function(n,e,t,r){"name"in(t=t||{})||(t.name="Simbad");var i=ke.buildSimbadCSURL(n,e);return Me.catalogFromURL(i,t,r,!1)},Me.catalogFromNED=function(n,e,t,r){var i;if("name"in(t=t||{})||(t.name="NED"),n&&"object"==typeof n)"ra"in n&&"dec"in n&&(i=ke.buildNEDPositionCSURL(n.ra,n.dec,e));else if(/[a-zA-Z]/.test(n))i=ke.buildNEDObjectCSURL(n,e);else{var a=new u;a.parse(n),i=ke.buildNEDPositionCSURL(a.lon,a.lat,e)}return Me.catalogFromURL(i,t,r)},Me.catalogFromVizieR=function(n,e,t,r,i){"name"in(r=r||{})||(r.name="VizieR:"+n);var a=ke.buildVizieRCSURL(n,e,t,r);return console.log(a),Me.catalogFromURL(a,r,i,!1)},Me.catalogFromSkyBot=function(n,e,t,r,i,a,o){i=i||{},"name"in(a=a||{})||(a.name="SkyBot");var s=ke.buildSkyBotCSURL(n,e,t,r,i);return Me.catalogFromURL(s,a,o,!1)},Me.hipsDefinitionFromURL=function(n,e){o.fromURL(n,e)},Me.init=Promise.all([Promise.all([t.e(0),t.e(3)]).then(t.bind(null,54)),Promise.all([t.e(0),t.e(2)]).then(t.bind(null,55))]).then(async n=>{let[e,t]=n;De.wasmLibs.hpx=e,De.wasmLibs.webgl=t}),window.A=Me}]);
//# sourceMappingURL=aladin.js.map