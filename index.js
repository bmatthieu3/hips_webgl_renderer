!function(n){function e(e){for(var t,r,i=e[0],a=e[1],c=0,l=[];c<i.length;c++)r=i[c],Object.prototype.hasOwnProperty.call(o,r)&&o[r]&&l.push(o[r][0]),o[r]=0;for(t in a)Object.prototype.hasOwnProperty.call(a,t)&&(n[t]=a[t]);for(u&&u(e);l.length;)l.shift()()}var t={},o={0:0};var r={};var i={50:function(){return{"./webgl_bg.js":{__wbg_performance_f7851e83824fd096:function(n){return t[48].exports.rb(n)},__wbg_now_0aafc2276b5e8d61:function(n){return t[48].exports.pb(n)},__wbindgen_object_drop_ref:function(n){return t[48].exports.gc(n)},__wbg_createShader_d75402f5935812f0:function(n,e){return t[48].exports.t(n,e)},__wbg_shaderSource_34af5e76165e6a02:function(n,e,o,r){return t[48].exports.Ab(n,e,o,r)},__wbg_compileShader_937cb022d149ec18:function(n,e){return t[48].exports.p(n,e)},__wbg_getShaderParameter_d526091c5166c9a7:function(n,e,o){return t[48].exports.S(n,e,o)},__wbindgen_boolean_get:function(n){return t[48].exports.Vb(n)},__wbg_getShaderInfoLog_c4c33d53565d30d6:function(n,e,o){return t[48].exports.R(n,e,o)},__wbg_useProgram_c410661f5bd7e81b:function(n,e){return t[48].exports.Pb(n,e)},__wbg_activeTexture_cd2bdafe6ac6a0ca:function(n,e){return t[48].exports.b(n,e)},__wbg_bindTexture_c152014c1f590c01:function(n,e,o){return t[48].exports.f(n,e,o)},__wbg_uniform1i_4ddec7fb50640fc1:function(n,e,o){return t[48].exports.Lb(n,e,o)},__wbg_uniform4f_c4d40e40e608ea3b:function(n,e,o,r,i,a){return t[48].exports.Nb(n,e,o,r,i,a)},__wbg_uniform1f_1d29b82642fdb790:function(n,e,o){return t[48].exports.Jb(n,e,o)},__wbg_uniformMatrix4fv_007cb082e7936bd4:function(n,e,o,r,i){return t[48].exports.Ob(n,e,o,r,i)},__wbg_uniform1fv_f7f36e76fc1b2c9a:function(n,e,o,r){return t[48].exports.Kb(n,e,o,r)},__wbg_new_59cb74e423758ede:function(){return t[48].exports.lb()},__wbg_stack_558ba5917b466edd:function(n,e){return t[48].exports.Bb(n,e)},__wbg_error_4bb6c2a97407129a:function(n,e){return t[48].exports.H(n,e)},__wbg_self_d1b58dbab69d5bb1:function(){return t[48].exports.tb()},__wbg_window_de445cb18819ad4b:function(){return t[48].exports.Ub()},__wbg_globalThis_68afcb0d98f0112d:function(){return t[48].exports.V()},__wbg_global_baed4e4fa850c0d0:function(){return t[48].exports.W()},__wbindgen_is_undefined:function(n){return t[48].exports.bc(n)},__wbg_newnoargs_db0587fa712f9acc:function(n,e){return t[48].exports.mb(n,e)},__wbg_call_79ca0d435495a83a:function(n,e){return t[48].exports.l(n,e)},__wbindgen_memory:function(){return t[48].exports.dc()},__wbg_buffer_44855aefa83ea48c:function(n){return t[48].exports.k(n)},__wbg_newwithbyteoffsetandlength_b86dda8c37255ca3:function(n,e,o){return t[48].exports.nb(n,e,o)},__wbindgen_debug_string:function(n,e){return t[48].exports.ac(n,e)},__wbindgen_throw:function(n,e){return t[48].exports.jc(n,e)},__wbindgen_rethrow:function(n){return t[48].exports.hc(n)},__wbindgen_object_clone_ref:function(n){return t[48].exports.fc(n)},__wbg_instanceof_Window_747b56d25bab9510:function(n){return t[48].exports.cb(n)},__wbg_new_0599e1276155199a:function(){return t[48].exports.kb()},__wbg_log_d85e484a8ba03c98:function(n){return t[48].exports.hb(n)},__wbg_isArray_9daeb1a30751fdc8:function(n){return t[48].exports.db(n)},__wbg_log_9aa6786f4afc2ed4:function(n,e){return t[48].exports.gb(n,e)},__wbg_length_b6f1989cb582d53f:function(n){return t[48].exports.eb(n)},__wbg_get_f5f75a85b3c573d3:function(n,e){return t[48].exports.U(n,e)},__wbindgen_json_serialize:function(n,e){return t[48].exports.cc(n,e)},__wbindgen_string_new:function(n,e){return t[48].exports.ic(n,e)},__wbg_createTexture_0656936373117662:function(n){return t[48].exports.u(n)},__wbg_texParameteri_605a63bf3a0a4b49:function(n,e,o,r){return t[48].exports.Gb(n,e,o,r)},__wbg_texImage3D_2327f290d4c5740d:function(n,e,o,r,i,a,c,l,s,u,_,f){return t[48].exports.Fb(n,e,o,r,i,a,c,l,s,u,_,f)},__wbg_generateMipmap_77c3e72f06e7a4c2:function(n,e){return t[48].exports.J(n,e)},__wbg_texSubImage3D_c2face1549f0ffe2:function(n,e,o,r,i,a,c,l,s,u,_,f){return t[48].exports.Ib(n,e,o,r,i,a,c,l,s,u,_,f)},__wbg_bindVertexArray_0157543bdbffb06e:function(n,e){return t[48].exports.g(n,e)},__wbg_bufferData_30e5070c8f83f307:function(n,e,o,r){return t[48].exports.i(n,e,o,r)},__wbg_bufferSubData_d4cc046d2735031b:function(n,e,o,r){return t[48].exports.j(n,e,o,r)},__wbg_new_05020d898fee9291:function(n){return t[48].exports.jb(n)},__wbg_subarray_2b50278eea0fd249:function(n,e,o){return t[48].exports.Cb(n,e,o)},__wbg_setcrossOrigin_7c6eec94244d24ba:function(n,e,o){return t[48].exports.ub(n,e,o)},__wbg_setonload_f35002b2488461d3:function(n,e){return t[48].exports.xb(n,e)},__wbg_setonerror_eb00bf5798315cb9:function(n,e){return t[48].exports.wb(n,e)},__wbg_setsrc_7e888e4ced74b27b:function(n,e,o){return t[48].exports.yb(n,e,o)},__wbg_texSubImage3D_5eef3d9da8cea53b:function(n,e,o,r,i,a,c,l,s,u,_,f,p){return t[48].exports.Hb(n,e,o,r,i,a,c,l,s,u,_,f,p)},__wbg_width_8d70143974f53aba:function(n){return t[48].exports.Tb(n)},__wbg_height_5de843709a60a262:function(n){return t[48].exports.X(n)},__wbg_deleteBuffer_3f297711135614ba:function(n,e){return t[48].exports.x(n,e)},__wbg_deleteTexture_bd49372545cdb940:function(n,e){return t[48].exports.y(n,e)},__wbg_document_c9bb82e72b87972b:function(n){return t[48].exports.C(n)},__wbg_getElementById_66a113a03886aac6:function(n,e,o){return t[48].exports.M(n,e,o)},__wbg_instanceof_HtmlCanvasElement_0feb941e3d100079:function(n){return t[48].exports.ab(n)},__wbg_parse_bf586351f316755f:function(n,e){return t[48].exports.qb(n,e)},__wbg_getContext_7fb33d2f2a33d083:function(n,e,o,r){return t[48].exports.L(n,e,o,r)},__wbg_instanceof_WebGl2RenderingContext_0f1d0ce1f564cddc:function(n){return t[48].exports.bb(n)},__wbg_createProgram_0e01a0272abf80f2:function(n){return t[48].exports.s(n)},__wbg_attachShader_703542f74d3f4655:function(n,e,o){return t[48].exports.c(n,e,o)},__wbg_linkProgram_13df874c1ec00220:function(n,e){return t[48].exports.fb(n,e)},__wbg_getProgramParameter_30ca8607cd79baba:function(n,e,o){return t[48].exports.Q(n,e,o)},__wbg_getProgramInfoLog_a7e39255ecb0047b:function(n,e,o){return t[48].exports.P(n,e,o)},__wbindgen_number_get:function(n,e){return t[48].exports.ec(n,e)},__wbg_getActiveUniform_30cc8778e1ba660f:function(n,e,o){return t[48].exports.K(n,e,o)},__wbg_name_3db390fc2fc091fb:function(n,e){return t[48].exports.ib(n,e)},__wbg_getUniformLocation_2085f6ce304f30ee:function(n,e,o,r){return t[48].exports.T(n,e,o,r)},__wbg_blendFuncSeparate_a1abbb6bdfc0a7dc:function(n,e,o,r,i){return t[48].exports.h(n,e,o,r,i)},__wbg_enable_a684b41864515bb5:function(n,e){return t[48].exports.G(n,e)},__wbg_cullFace_bf527eb4959a8aa8:function(n,e){return t[48].exports.w(n,e)},__wbg_innerWidth_32946fda40a6a23f:function(n){return t[48].exports.Z(n)},__wbg_innerHeight_58f8a4f389150bf7:function(n){return t[48].exports.Y(n)},__wbg_canvas_c621ddfce1286dee:function(n){return t[48].exports.m(n)},__wbg_setwidth_7a7150718cc3f0e6:function(n,e){return t[48].exports.zb(n,e)},__wbg_setheight_c61e5a9990ad7131:function(n,e){return t[48].exports.vb(n,e)},__wbg_viewport_b47ae83b1f5bfbe9:function(n,e,o,r,i){return t[48].exports.Sb(n,e,o,r,i)},__wbg_scissor_40f682e522ab20d2:function(n,e,o,r,i){return t[48].exports.sb(n,e,o,r,i)},__wbg_createBuffer_45e7132a460d7416:function(n){return t[48].exports.q(n)},__wbg_bindBuffer_cc67660a7f99cf8b:function(n,e,o){return t[48].exports.d(n,e,o)},__wbindgen_cb_forget:function(n){return t[48].exports.Xb(n)},__wbg_getExtension_59696a785661b89b:function(n,e,o){return t[48].exports.N(n,e,o)},__wbg_texImage2D_3c5bf32a5f1e7dff:function(n,e,o,r,i,a,c,l,s,u,_){return t[48].exports.Db(n,e,o,r,i,a,c,l,s,u,_)},__wbg_createFramebuffer_28e45abdb795ab52:function(n){return t[48].exports.r(n)},__wbg_bindFramebuffer_47d9a15ce41e5299:function(n,e,o){return t[48].exports.e(n,e,o)},__wbg_framebufferTexture2D_58968036d9154ea5:function(n,e,o,r,i,a){return t[48].exports.I(n,e,o,r,i,a)},__wbg_vertexAttribPointer_eee48ed0873e601b:function(n,e,o,r,i,a,c){return t[48].exports.Rb(n,e,o,r,i,a,c)},__wbg_enableVertexAttribArray_2fb0e0e3bd9efecc:function(n,e){return t[48].exports.F(n,e)},__wbg_vertexAttribDivisor_97df148c554b5fea:function(n,e,o){return t[48].exports.Qb(n,e,o)},__wbg_clearColor_56271725c115c7e9:function(n,e,o,r,i){return t[48].exports.n(n,e,o,r,i)},__wbg_clear_7a35983521c8dcf9:function(n,e){return t[48].exports.o(n,e)},__wbg_disable_e64678c1a700d912:function(n,e){return t[48].exports.B(n,e)},__wbg_getParameter_4e62c3b9e299eba2:function(n,e){return t[48].exports.O(n,e)},__wbg_texImage2D_ee1e475e0e91b3b2:function(n,e,o,r,i,a,c){return t[48].exports.Eb(n,e,o,r,i,a,c)},__wbindgen_cb_drop:function(n){return t[48].exports.Wb(n)},__wbg_uniform2f_278c281b29e9e2c3:function(n,e,o,r){return t[48].exports.Mb(n,e,o,r)},__wbg_createVertexArray_cac6aa68bf3644e0:function(n){return t[48].exports.v(n)},__wbg_drawElements_0f9b6bbedd3bebcf:function(n,e,o,r,i){return t[48].exports.E(n,e,o,r,i)},__wbg_deleteVertexArray_adb9b163093754e8:function(n,e){return t[48].exports.z(n,e)},__wbg_newwithbyteoffsetandlength_d16ea40443d82e07:function(n,e,o){return t[48].exports.ob(n,e,o)},__wbg_drawElementsInstanced_28f7d73790509e68:function(n,e,o,r,i,a){return t[48].exports.D(n,e,o,r,i,a)},__wbg_disableVertexAttribArray_73c64380cd778613:function(n,e){return t[48].exports.A(n,e)},__wbindgen_closure_wrapper3422:function(n,e,o){return t[48].exports.Yb(n,e,o)},__wbindgen_closure_wrapper3498:function(n,e,o){return t[48].exports.Zb(n,e,o)}}}}};function a(e){if(t[e])return t[e].exports;var o=t[e]={i:e,l:!1,exports:{}};return n[e].call(o.exports,o,o.exports,a),o.l=!0,o.exports}a.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var c=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=c);var l,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(n){return a.p+""+n+".index.js"}(n);var u=new Error;l=function(e){s.onerror=s.onload=null,clearTimeout(_);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;u.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",u.name="ChunkLoadError",u.type=r,u.request=i,t[1](u)}o[n]=void 0}};var _=setTimeout((function(){l({type:"timeout",target:s})}),12e4);s.onerror=s.onload=l,document.head.appendChild(s)}return({2:[50]}[n]||[]).forEach((function(n){var t=r[n];if(t)e.push(t);else{var o,c=i[n](),l=fetch(a.p+""+{50:"b3c02a551ad43243a0fb"}[n]+".module.wasm");if(c instanceof Promise&&"function"==typeof WebAssembly.compileStreaming)o=Promise.all([WebAssembly.compileStreaming(l),c]).then((function(n){return WebAssembly.instantiate(n[0],n[1])}));else if("function"==typeof WebAssembly.instantiateStreaming)o=WebAssembly.instantiateStreaming(l,c);else{o=l.then((function(n){return n.arrayBuffer()})).then((function(n){return WebAssembly.instantiate(n,c)}))}e.push(r[n]=o.then((function(e){return a.w[n]=(e.instance||e).exports})))}})),Promise.all(e)},a.m=n,a.c=t,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)a.d(t,o,function(e){return n[e]}.bind(null,o));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="",a.oe=function(n){throw console.error(n),n},a.w={};var c=window.webpackJsonp=window.webpackJsonp||[],l=c.push.bind(c);c.push=e,c=c.slice();for(var s=0;s<c.length;s++)e(c[s]);var u=l;a(a.s=47)}([function(n,e,t){var o,r=function(n){if(document.querySelector){var e={selector:0,source:0,minChars:3,delay:150,offsetLeft:0,offsetTop:1,cache:1,menuClass:"",renderItem:function(n,e){e=e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");var t=new RegExp("("+e.split(" ").join("|")+")","gi");return'<div class="autocomplete-suggestion" data-val="'+n+'">'+n.replace(t,"<b>$1</b>")+"</div>"},onSelect:function(n,e,t){}};for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);for(var o="object"==typeof e.selector?[e.selector]:document.querySelectorAll(e.selector),r=0;r<o.length;r++){var i=o[r];i.sc=document.createElement("div"),i.sc.className="autocomplete-suggestions "+e.menuClass,i.autocompleteAttr=i.getAttribute("autocomplete"),i.setAttribute("autocomplete","off"),i.cache={},i.last_val="",i.updateSC=function(n,t){var o=i.getBoundingClientRect();if(i.sc.style.left=Math.round(o.left+(window.pageXOffset||document.documentElement.scrollLeft)+e.offsetLeft)+"px",i.sc.style.top=Math.round(o.bottom+(window.pageYOffset||document.documentElement.scrollTop)+e.offsetTop)+"px",i.sc.style.width=Math.round(o.right-o.left)+"px",!n&&(i.sc.style.display="block",i.sc.maxHeight||(i.sc.maxHeight=parseInt((window.getComputedStyle?getComputedStyle(i.sc,null):i.sc.currentStyle).maxHeight)),i.sc.suggestionHeight||(i.sc.suggestionHeight=i.sc.querySelector(".autocomplete-suggestion").offsetHeight),i.sc.suggestionHeight))if(t){var r=i.sc.scrollTop,a=t.getBoundingClientRect().top-i.sc.getBoundingClientRect().top;a+i.sc.suggestionHeight-i.sc.maxHeight>0?i.sc.scrollTop=a+i.sc.suggestionHeight+r-i.sc.maxHeight:a<0&&(i.sc.scrollTop=a+r)}else i.sc.scrollTop=0},l(window,"resize",i.updateSC),document.body.appendChild(i.sc),u("autocomplete-suggestion","mouseleave",(function(n){var e=i.sc.querySelector(".autocomplete-suggestion.selected");e&&setTimeout((function(){e.className=e.className.replace("selected","")}),20)}),i.sc),u("autocomplete-suggestion","mouseover",(function(n){var e=i.sc.querySelector(".autocomplete-suggestion.selected");e&&(e.className=e.className.replace("selected","")),this.className+=" selected"}),i.sc),u("autocomplete-suggestion","mousedown",(function(n){if(c(this,"autocomplete-suggestion")){var t=this.getAttribute("data-val");i.value=t,e.onSelect(n,t,this),i.sc.style.display="none"}}),i.sc),i.blurHandler=function(){try{var n=document.querySelector(".autocomplete-suggestions:hover")}catch(e){n=0}n?i!==document.activeElement&&setTimeout((function(){i.focus()}),20):(i.last_val=i.value,i.sc.style.display="none",setTimeout((function(){i.sc.style.display="none"}),350))},l(i,"blur",i.blurHandler);var a=function(n){var t=i.value;if(i.cache[t]=n,n.length&&t.length>=e.minChars){for(var o="",r=0;r<n.length;r++)o+=e.renderItem(n[r],t);i.sc.innerHTML=o,i.updateSC(0)}else i.sc.style.display="none"};i.keydownHandler=function(n){var t,o=window.event?n.keyCode:n.which;if((40==o||38==o)&&i.sc.innerHTML)return(r=i.sc.querySelector(".autocomplete-suggestion.selected"))?(t=40==o?r.nextSibling:r.previousSibling)?(r.className=r.className.replace("selected",""),t.className+=" selected",i.value=t.getAttribute("data-val")):(r.className=r.className.replace("selected",""),i.value=i.last_val,t=0):((t=40==o?i.sc.querySelector(".autocomplete-suggestion"):i.sc.childNodes[i.sc.childNodes.length-1]).className+=" selected",i.value=t.getAttribute("data-val")),i.updateSC(0,t),!1;if(27==o)i.value=i.last_val,i.sc.style.display="none";else if(13==o||9==o){var r;(r=i.sc.querySelector(".autocomplete-suggestion.selected"))&&"none"!=i.sc.style.display&&(e.onSelect(n,r.getAttribute("data-val"),r),setTimeout((function(){i.sc.style.display="none"}),20))}},l(i,"keydown",i.keydownHandler),i.keyupHandler=function(n){var t=window.event?n.keyCode:n.which;if(!t||(t<35||t>40)&&13!=t&&27!=t){var o=i.value;if(o.length>=e.minChars){if(o!=i.last_val){if(i.last_val=o,clearTimeout(i.timer),e.cache){if(o in i.cache)return void a(i.cache[o]);for(var r=1;r<o.length-e.minChars;r++){var c=o.slice(0,o.length-r);if(c in i.cache&&!i.cache[c].length)return void a([])}}i.timer=setTimeout((function(){e.source(o,a)}),e.delay)}}else i.last_val=o,i.sc.style.display="none"}},l(i,"keyup",i.keyupHandler),i.focusHandler=function(n){i.last_val="\n",i.keyupHandler(n)},e.minChars||l(i,"focus",i.focusHandler)}this.destroy=function(){for(var n=0;n<o.length;n++){var e=o[n];s(window,"resize",e.updateSC),s(e,"blur",e.blurHandler),s(e,"focus",e.focusHandler),s(e,"keydown",e.keydownHandler),s(e,"keyup",e.keyupHandler),e.autocompleteAttr?e.setAttribute("autocomplete",e.autocompleteAttr):e.removeAttribute("autocomplete"),document.body.removeChild(e.sc),e=null}}}function c(n,e){return n.classList?n.classList.contains(e):new RegExp("\\b"+e+"\\b").test(n.className)}function l(n,e,t){n.attachEvent?n.attachEvent("on"+e,t):n.addEventListener(e,t)}function s(n,e,t){n.detachEvent?n.detachEvent("on"+e,t):n.removeEventListener(e,t)}function u(n,e,t,o){l(o||document,e,(function(e){for(var o,r=e.target||e.srcElement;r&&!(o=c(r,n));)r=r.parentElement;o&&t.call(r,e)}))}};void 0===(o=function(){return r}.call(e,t,e,n))||(n.exports=o)},function(n,e,t){"use strict";var o,r=function(){return void 0===o&&(o=Boolean(window&&document&&document.all&&!window.atob)),o},i=function(){var n={};return function(e){if(void 0===n[e]){var t=document.querySelector(e);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(n){t=null}n[e]=t}return n[e]}}(),a=[];function c(n){for(var e=-1,t=0;t<a.length;t++)if(a[t].identifier===n){e=t;break}return e}function l(n,e){for(var t={},o=[],r=0;r<n.length;r++){var i=n[r],l=e.base?i[0]+e.base:i[0],s=t[l]||0,u="".concat(l," ").concat(s);t[l]=s+1;var _=c(u),f={css:i[1],media:i[2],sourceMap:i[3]};-1!==_?(a[_].references++,a[_].updater(f)):a.push({identifier:u,updater:v(f,e),references:1}),o.push(u)}return o}function s(n){var e=document.createElement("style"),o=n.attributes||{};if(void 0===o.nonce){var r=t.nc;r&&(o.nonce=r)}if(Object.keys(o).forEach((function(n){e.setAttribute(n,o[n])})),"function"==typeof n.insert)n.insert(e);else{var a=i(n.insert||"head");if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(e)}return e}var u,_=(u=[],function(n,e){return u[n]=e,u.filter(Boolean).join("\n")});function f(n,e,t,o){var r=t?"":o.media?"@media ".concat(o.media," {").concat(o.css,"}"):o.css;if(n.styleSheet)n.styleSheet.cssText=_(e,r);else{var i=document.createTextNode(r),a=n.childNodes;a[e]&&n.removeChild(a[e]),a.length?n.insertBefore(i,a[e]):n.appendChild(i)}}function p(n,e,t){var o=t.css,r=t.media,i=t.sourceMap;if(r?n.setAttribute("media",r):n.removeAttribute("media"),i&&btoa&&(o+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),n.styleSheet)n.styleSheet.cssText=o;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(o))}}var d=null,m=0;function v(n,e){var t,o,r;if(e.singleton){var i=m++;t=d||(d=s(e)),o=f.bind(null,t,i,!1),r=f.bind(null,t,i,!0)}else t=s(e),o=p.bind(null,t,e),r=function(){!function(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n)}(t)};return o(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;o(n=e)}else r()}}n.exports=function(n,e){(e=e||{}).singleton||"boolean"==typeof e.singleton||(e.singleton=r());var t=l(n=n||[],e);return function(n){if(n=n||[],"[object Array]"===Object.prototype.toString.call(n)){for(var o=0;o<t.length;o++){var r=c(t[o]);a[r].references--}for(var i=l(n,e),s=0;s<t.length;s++){var u=c(t[s]);0===a[u].references&&(a[u].updater(),a.splice(u,1))}t=i}}}},function(n,e,t){"use strict";n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=function(n,e){var t=n[1]||"",o=n[3];if(!o)return t;if(e&&"function"==typeof btoa){var r=(a=o,c=btoa(unescape(encodeURIComponent(JSON.stringify(a)))),l="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(c),"/*# ".concat(l," */")),i=o.sources.map((function(n){return"/*# sourceURL=".concat(o.sourceRoot||"").concat(n," */")}));return[t].concat(i).concat([r]).join("\n")}var a,c,l;return[t].join("\n")}(e,n);return e[2]?"@media ".concat(e[2]," {").concat(t,"}"):t})).join("")},e.i=function(n,t,o){"string"==typeof n&&(n=[[null,n,""]]);var r={};if(o)for(var i=0;i<this.length;i++){var a=this[i][0];null!=a&&(r[a]=!0)}for(var c=0;c<n.length;c++){var l=[].concat(n[c]);o&&r[l[0]]||(t&&(l[2]?l[2]="".concat(t," and ").concat(l[2]):l[2]=t),e.push(l))}},e}},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 model;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\nuniform vec2 kernel_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = -2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvoid main() {\n    vec3 p = vec3(model * vec4(center, 1.0f));\n    vec2 center_pos_clip_space = world2clip_aitoff(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * clip_zoom_factor)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density;\n\nvoid main() {\n    color += texture(kernel_texture, out_uv) / log2(max_density + 1.0);\n\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 model;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\nuniform vec2 kernel_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nvec2 world2clip_mercator(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = -theta / PI;\n    //float y = log(tan(PI * 0.25f + delta * 0.5f)) / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nvoid main() {\n    vec3 p = vec3(model * vec4(center, 1.0f));\n    vec2 center_pos_clip_space = world2clip_mercator(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * clip_zoom_factor)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density;\n\nvoid main() {\n    color += texture(kernel_texture, out_uv) / log2(max_density + 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\nuniform float current_time;\nuniform mat4 model;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\nuniform vec2 kernel_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-4 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = -(theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvoid main() {\n    vec3 p = vec3(model * vec4(center, 1.0f));\n    vec2 center_pos_clip_space = world2clip_mollweide(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * clip_zoom_factor)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density;\n\nvoid main() {\n    color += texture(kernel_texture, out_uv) / log2(max_density + 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nlayout (location = 0) in vec2 offset;\nlayout (location = 1) in vec2 uv;\n\nlayout (location = 2) in vec3 center;\nlayout (location = 3) in vec2 center_lonlat;\n\n\nuniform float current_time;\nuniform mat4 model;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\nuniform vec2 kernel_size;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nout vec2 out_uv;\nout vec3 out_p;\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(-p.x, p.y);\n}\n\nvoid main() {\n    vec3 p = vec3(model * vec4(center, 1.0f));\n    vec2 center_pos_clip_space = world2clip_orthographic(p);\n\n    vec2 pos_clip_space = center_pos_clip_space;\n    gl_Position = vec4((pos_clip_space / (ndc_to_clip * clip_zoom_factor)) + offset * kernel_size , 0.f, 1.f);\n\n    out_uv = uv;\n    out_p = p;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nin vec3 out_p;\n\nout vec4 color;\n\nuniform sampler2D kernel_texture;\nuniform float max_density; // max number of sources in a kernel sized HEALPix cell at the current depth\n\nvoid main() {\n    if (out_p.z < 0.f) {\n        discard;\n    }\n\n    color += texture(kernel_texture, out_uv) / log2(max_density + 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nvec4 colormap_f(float x) {\n    float d = clamp(x, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    if (x < 0.1131206452846527) {\n        return (-9.40943766883858E+02 * x - 1.84146720562529E+02) * x + 3.28713709677420E+01;\n    } else if (x < 0.5116005837917328) {\n        return 0.0;\n    } else if (x < 0.5705677568912506) {\n        return (-2.22507913165263E+03 * x + 2.76053354341733E+03) * x - 8.29909138655453E+02;\n    } else if (x < 0.622047244) {\n        return (-1.84774532967032E+04 * x + 2.30647002747253E+04) * x - 7.12389120879120E+03;\n    } else if (x < 0.7922459542751312) {\n        return ((((1.29456468589020E+06 * x - 4.64095889653844E+06) * x + 6.62951004830418E+06) * x - 4.71587036142377E+06) * x + 1.67048886368434E+06) * x - 2.35682532934682E+05;\n    } else {\n        return 3.34889230769210E+02 * x - 1.41006123680226E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.114394336938858) {\n        return 0.0;\n    } else if (x < 0.4417250454425812) {\n        return (9.43393359191585E+02 * x + 1.86774918014536E+02) * x - 3.37113020096108E+01;\n    } else if (x < 0.4964917968308496) {\n        return 3.11150000000070E+02 * x + 9.54249999999731E+01;\n    } else if (x < 0.6259051214039278) {\n        return -1.03272635599706E+03 * x + 7.62648586707481E+02;\n    } else if (x < 0.8049814403057098) {\n        return -2.92799028677160E+02 * x + 2.99524283071235E+02;\n    } else {\n        return (1.34145201311283E+03 * x - 2.75066701126586E+03) * x + 1.40880802982723E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.4424893036638088) {\n        return 3.09636968527514E+02 * x + 9.62203074056821E+01;\n    } else if (x < 0.5) {\n        return -4.59921428571535E+02 * x + 4.36741666666678E+02;\n    } else if (x < 0.5691165986930345) {\n        return -1.81364912280674E+03 * x + 1.05392982456125E+03;\n    } else if (x < 0.6279306709766388) {\n        return 1.83776470588197E+02 * x - 8.28382352940910E+01;\n    } else {\n        return ((-1.14087926835422E+04 * x + 2.47091243363548E+04) * x - 1.80428756181930E+04) * x + 4.44421976986281E+03;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    /*if (opacity < 0.01f) {\n        discard;\n    }*/\n\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    if (x < 0.4128910005092621) {\n        return (-6.30796693758704E+02 * x + 6.59139629181867E+02) * x + 8.16592339699109E+01;\n    } else if (x < 0.5004365747118258) {\n        return -1.99292307692284E+01 * x + 2.54503076923075E+02;\n    } else if (x < 0.6000321805477142) {\n        return -4.46903540903651E+02 * x + 4.68176638176691E+02;\n    } else {\n        return ((2.43537534073204E+03 * x - 5.03831150657605E+03) * x + 2.73595321475367E+03) * x - 1.53778856560153E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.3067105114459991) {\n        return (((((-1.43558931121826E+06 * x + 1.21789289489746E+06) * x - 3.88754308517456E+05) * x + 5.87745165729522E+04) * x - 3.61237992835044E+03) * x + 4.00139210969209E+02) * x + 4.80612502318691E+01;\n    } else if (x < 0.4045854562297116) {\n        return 3.64978461538455E+02 * x + 8.50984615384636E+01;\n    } else if (x < 0.5035906732082367) {\n        return 1.25827692307720E+02 * x + 1.81855384615367E+02;\n    } else {\n        return ((((-2.83948052403926E+04 * x + 1.08768529946603E+05) * x - 1.62569302478295E+05) * x + 1.17919256227845E+05) * x - 4.16776268978779E+04) * x + 6.01529271177582E+03;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.1012683545126085) {\n        return 5.85993431855501E+01 * x + 4.56403940886700E+00;\n    } else if (x < 0.2050940692424774) {\n        return 3.51072173913048E+02 * x - 2.50542028985514E+01;\n    } else if (x < 0.5022056996822357) {\n        return (-7.65121475963620E+02 * x + 1.20827362856208E+03) * x - 1.68677387505814E+02;\n    } else if (x < 0.5970333516597748) {\n        return -1.62299487179500E+02 * x + 3.26660512820525E+02;\n    } else {\n        return ((1.27993125066091E+03 * x - 3.19799978871341E+03) * x + 2.16242391471484E+03) * x - 1.93738146367890E+02;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    float v = ((((-2.83671754639782E+03 * x + 6.51753994553536E+03) * x - 5.00110948171466E+03) * x + 1.30359712298773E+03) * x - 2.89958300810074E+02) * x + 2.48458039402758E+02;\n    if (v < 8.0) {\n        return 8.0;\n    } else {\n        return v;\n    }\n}\n\nfloat colormap_green(float x) {\n    return (((((-1.36304822155833E+03 * x + 4.37691418182849E+03) * x - 5.01802019417285E+03) * x + 2.39971481269598E+03) * x - 5.65401491984724E+02) * x - 1.48189675724133E+01) * x + 2.50507618187374E+02;\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.3756393599187693) {\n        return (9.62948273917718E+01 * x - 1.96136874142438E+02) * x + 2.41033490809633E+02;\n    } else if (x < 0.6215448666633865) {\n        return 1.21184043778803E+02 * x + 1.35422939068100E+02;\n    } else if (x < 0.8830064316178203) {\n        return -1.53052165744713E+02 * x + 3.05873047350666E+02;\n    } else {\n        return -3.49468965517114E+02 * x + 4.79310344827486E+02;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    if (x < 0.2523055374622345) {\n        return (-5.80630393656902E+02 * x - 8.20261301968494E+01) * x + 2.53829637096771E+02;\n    } else if (x < 0.6267540156841278) {\n        return (((-4.07958939010649E+03 * x + 8.13296992114899E+03) * x - 5.30725139102868E+03) * x + 8.58474724851723E+02) * x + 2.03329669375107E+02;\n    } else if (x < 0.8763731146612115) {\n        return 3.28717357910916E+01 * x + 8.82117255504255E+00;\n    } else {\n        return -2.29186583577707E+02 * x + 2.38482038123159E+02;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.4578040540218353) {\n        return ((4.49001704856054E+02 * x - 5.56217473429394E+02) * x + 2.09812296466262E+01) * x + 2.52987561849833E+02;\n    } else {\n        return ((1.28031059709139E+03 * x - 2.71007279113343E+03) * x + 1.52699334501816E+03) * x - 6.48190622715140E+01;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.1239372193813324) {\n        return (1.10092779856059E+02 * x - 3.41564374557536E+02) * x + 2.17553885630496E+02;\n    } else if (x < 0.7535201013088226) {\n        return ((((3.86204601547122E+03 * x - 8.79126469446648E+03) * x + 6.80922226393264E+03) * x - 2.24007302003438E+03) * x + 3.51344388740066E+02) * x + 1.56774650431396E+02;\n    } else {\n        return (((((-7.46693234167480E+06 * x + 3.93327773566702E+07) * x - 8.61050867447971E+07) * x + 1.00269040461745E+08) * x - 6.55080846112976E+07) * x + 2.27664953009389E+07) * x - 3.28811994253461E+06;\n    }\n}\n\nvec4 colormap_f(float x) {\n    float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 uv;\n\nout vec2 out_uv;\n\nvoid main() {\n    gl_Position = vec4(position, 0.f, 1.f);\n    out_uv = uv;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nin vec2 out_uv;\nout vec4 color;\n\nuniform sampler2D texture_fbo;\nuniform sampler2D colormap;\nuniform float alpha;\n\nfloat colormap_red(float x) {\n    return 1.448953446096850 * x - 5.02253539008443e-1;\n}\n\nfloat colormap_green(float x) {\n    return 1.889376646180860 * x - 2.272028094820020e2;\n}\n\nfloat colormap_blue(float x) {\n    return 3.92613636363636 * x - 7.46528409090909e+2;\n}\n\nvec4 colormap_f(float x) {\n    float t = x * 255.0;\n    float r = clamp(colormap_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(t) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvoid main() {\n    float opacity = texture(texture_fbo, out_uv).r;\n\n    float o = smoothstep(0.f, 0.1f, opacity);\n\n    //color = texture(colormap, vec2(opacity, 0.5f));\n    color = colormap_f(opacity);\n    color.a = alpha * o;\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * clip_zoom_factor);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nout vec4 color;\nin vec2 pos_clip;\n\nuniform vec4 grid_color;\nuniform mat4 world2model;\nuniform mat4 model2world;\nuniform float clip_zoom_factor;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\n\nuniform vec2 window_size;\n\nconst float PI = 3.141592653589793f;\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = -2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_aitoff(vec2 pos_clip_space) {\n    if(!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    vec2 uv = vec2(pos_clip_space.x * PI * 0.5, pos_clip_space.y * PI);\n    //da uv a lat/lon\n    float c = length(uv);\n\n    float phi = asin(uv.y * sin(c) / c);\n    float theta = atan(uv.x * sin(c), c * cos(c)) * 2.0;\n\n    return vec3(\n        -sin(theta) * cos(phi),\n        sin(phi),\n        cos(theta) * cos(phi)\n    );\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(model2world * vec4(h_model, 1.f));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_aitoff(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 pos_model) {\n    float v = 1e10;\n    \n    for (int i = 0; i < num_meridians; i++) {\n        float a = d_isolon(pos_model, meridians[i]);\n\n        v = min(a, v);\n    }\n    \n    for (int i = 0; i < num_parallels; i++) {\n        float a = d_isolat(pos_model, parallels[i]);\n\n        v = min(a, v);\n    }\n\n    float eps = 3.0 * clip_zoom_factor / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_aitoff(pos_clip);\n    vec3 pos_model = vec3(world2model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    color = mix(grid_color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * clip_zoom_factor);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nout vec4 color;\nin vec2 pos_clip;\n\nuniform vec4 grid_color;\nuniform mat4 world2model;\nuniform mat4 model2world;\nuniform float clip_zoom_factor;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\nuniform vec2 window_size;\n\nconst float PI = 3.141592653589793f;\n\n\n/// World to screen space transformation\n/// X is between [-1, 1]\n/// Y is between [-0.5, 0.5]\n/// \n/// # Arguments\n/// \n/// * `pos_world_space` - Position in the world space. Must be a normalized vector\nvec2 world2clip_mollweide(vec3 p) {\n    float lat = asin(p.y);\n    float lon = atan(p.x, p.z);\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    const float eps = 1e-3;\n    const int max_iter = 10;\n\n    float cst = PI * sin(lat);\n\n    float theta = lat;\n    float f = theta + sin(theta) - cst;\n\n    int k = 0;\n    while (abs(f) > eps && k < max_iter) {\n        theta = theta - f / (1.0 + cos(theta));\n        f = theta + sin(theta) - cst;\n\n        k += 1;\n    }\n\n    theta = theta * 0.5;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    return vec2(\n        -(lon / PI) * cos(theta),\n        0.5 * sin(theta)\n    );\n}\n\nbool is_included_inside_projection(vec2 pos_clip_space) {\n    float px2 = pos_clip_space.x * pos_clip_space.x;\n    float py2 = pos_clip_space.y * pos_clip_space.y;\n\n    return (px2 * 0.25 + py2) <= 0.25;\n}\n\n/// View to world space transformation\n/// \n/// This returns a normalized vector along its first 3 dimensions.\n/// Its fourth component is set to 1.\n/// \n/// The Aitoff projection maps screen coordinates from [-pi; pi] x [-pi/2; pi/2]\n/// \n/// # Arguments\n/// \n/// * `x` - in normalized device coordinates between [-1; 1]\n/// * `y` - in normalized device coordinates between [-1; 1]\nvec3 clip2world_mollweide(vec2 pos_clip_space) {\n    if (!is_included_inside_projection(pos_clip_space)) {\n        discard;\n    }\n\n    float y2 = pos_clip_space.y * pos_clip_space.y;\n    float k = sqrt(1.0 - 4.0 * y2);\n\n    float theta = PI * pos_clip_space.x / k;\n    float delta = asin((2.0 * asin(2.0 * pos_clip_space.y) + 4.0 * pos_clip_space.y * k) / PI);\n    \n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    return vec3(-sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(model2world * vec4(h_model, 1.f));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mollweide(h_world);\n    \n    return length(pos_clip - h_clip) * 2.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 pos_model) {\n    float v = 1e10;\n    \n    for (int i = 0; i < num_meridians; i++) {\n        float a = d_isolon(pos_model, meridians[i]);\n\n        v = min(a, v);\n    }\n    \n    for (int i = 0; i < num_parallels; i++) {\n        float a = d_isolat(pos_model, parallels[i]);\n\n        v = min(a, v);\n    }\n\n    float eps = 3.0 * clip_zoom_factor / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_mollweide(pos_clip);\n    vec3 pos_model = vec3(world2model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    color = mix(grid_color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * clip_zoom_factor);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nout vec4 color;\nin vec2 pos_clip;\n\nuniform vec4 grid_color;\nuniform mat4 world2model;\nuniform mat4 model2world;\nuniform float clip_zoom_factor;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\nuniform vec2 window_size;\n\nconst float PI = 3.141592653589793f;\n\nvec2 world2clip_orthographic(vec3 p) {\n    return vec2(-p.x, p.y);\n}\n\nvec3 clip2world_orthographic(vec2 pos_clip_space) {\n    float z = 1.f - dot(pos_clip_space, pos_clip_space);\n    if (z > 0.f) {\n        return vec3(-pos_clip_space.x, pos_clip_space.y, sqrt(z));\n    } else {\n        discard;\n    }\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(model2world * vec4(h_model, 1.f));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_orthographic(h_world);\n    \n    return length(pos_clip - h_clip);\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 pos_model) {\n    float v = 1e10;\n    \n    for (int i = 0; i < num_meridians; i++) {\n        float a = d_isolon(pos_model, meridians[i]);\n\n        v = min(a, v);\n    }\n    \n    for (int i = 0; i < num_parallels; i++) {\n        float a = d_isolat(pos_model, parallels[i]);\n\n        v = min(a, v);\n    }\n\n    float eps = clip_zoom_factor / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_orthographic(pos_clip);\n    vec3 pos_model = vec3(world2model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    color = mix(grid_color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 pos_clip;\n\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n\nvoid main() {\n    pos_clip = position * (ndc_to_clip * clip_zoom_factor);\n\n    gl_Position = vec4(position, 0.0, 1.0);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\n\nout vec4 color;\nin vec2 pos_clip;\n\nuniform vec4 grid_color;\nuniform mat4 world2model;\nuniform mat4 model2world;\nuniform float clip_zoom_factor;\n\nuniform float meridians[20];\nuniform int num_meridians;\nuniform float parallels[10];\nuniform int num_parallels;\nuniform vec2 window_size;\n\nconst float PI = 3.141592653589793f;\n\nvec2 world2clip_mercator(vec3 p) {\n    float theta = atan(p.x, p.z);\n    float delta = asin(p.y);\n\n    float x = -theta / PI;\n    float y = asinh(tan(delta / PI));\n\n    return vec2(x, y);\n}\n\nvec3 clip2world_mercator(vec2 p) {\n    float theta = p.x * PI;\n    float delta = atan(sinh(p.y)) * PI;\n\n    return vec3(-sin(theta) * cos(delta), sin(delta), cos(theta) * cos(delta));\n}\n\nfloat d_isolon(vec3 pos_model, float theta) {\n    vec3 n = vec3(cos(theta), 0.0, -sin(theta));\n    // Discard the (theta + PI) meridian\n    /*vec3 e_xz = vec3(-n.z, 0.0, n.x);\n    if (dot(pos_model, e_xz) < 0.0) {\n        return 1e3;\n    }*/\n\n    float d = abs(dot(n, pos_model));\n\n    vec3 h_model = normalize(pos_model - n*d);\n    vec3 h_world = vec3(model2world * vec4(h_model, 1.f));\n\n    // Project to screen x and h and compute the distance\n    // between the two\n    vec2 h_clip = world2clip_mercator(h_world);\n    \n    return length(pos_clip - h_clip) * 3.0;\n}\nfloat d_isolat(vec3 pos_model, float delta) {\n    float y = atan(pos_model.y, length(pos_model.xz));\n    float d = abs(y - delta);\n    return d;\n}\n\nfloat grid_alpha(vec3 pos_model) {\n    float v = 1e10;\n    \n    for (int i = 0; i < num_meridians; i++) {\n        float a = d_isolon(pos_model, meridians[i]);\n\n        v = min(a, v);\n    }\n    \n    for (int i = 0; i < num_parallels; i++) {\n        float a = d_isolat(pos_model, parallels[i]);\n\n        v = min(a, v);\n    }\n\n    float eps = 3.0 * clip_zoom_factor / window_size.x;\n    return smoothstep(eps, 2.0*eps, v);\n}\n\nvoid main() {\n    vec4 transparency = vec4(0.f, 0.f, 0.f, 0.f);\n\n    vec3 pos_world = clip2world_mercator(pos_clip);\n    vec3 pos_model = vec3(world2model * vec4(pos_world, 1.f));\n\n    float alpha = grid_alpha(pos_model);\n    color = mix(grid_color, transparency, alpha);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nlayout (location = 0) in vec2 pos_clip_space;\nlayout (location = 1) in vec3 pos_world_space;\n\nout vec3 out_vert_pos;\nout vec2 pos_clip;\n\nuniform mat4 model;\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n\nvoid main() {\n    gl_Position = vec4(pos_clip_space / (ndc_to_clip * clip_zoom_factor), 0.0, 1.0);\n    pos_clip = pos_clip_space;\n    out_vert_pos = vec3(model * vec4(pos_world_space, 1.f));\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision lowp sampler3D;\nprecision lowp sampler2D;\nprecision highp int;\n\nin vec3 out_vert_pos;\nin vec2 pos_clip;\n\nout vec4 out_frag_color;\n\nconst float PI = 3.141592653589793f;\nconst float FOUR_OVER_PI = 1.27323954474f;\nconst float TRANSITION_Z = 0.66666666666f;\nconst float TRANSITION_Z_INV = 1.5f;\n\nuint quarter(vec2 p) {\n    uint x_neg = uint(p.x < 0.0f);\n    uint y_neg = uint(p.y < 0.0f);\n    uint q = (x_neg + y_neg) | (y_neg << 1U);\n    return q;\n}\n\nfloat xpm1(vec2 p) {\n    bool x_neg = (p.x < 0.0f);\n    //debug_assert!(x_neg <= 1);\n    bool y_neg = (p.y < 0.0f);\n    //debug_assert!(y_neg <= 1);\n    // The purpose it to have the same numerical precision for each base cell\n    // by avoiding subtraction by 1 or 3 or 5 or 7\n    float lon = atan(abs(p.y), abs(p.x));\n    //debug_assert!(0.0 <= lon && lon <= PI / 2.0);\n    float x02 = lon * FOUR_OVER_PI;\n    //debug_assert!(0.0 <= x02 && x02 <= 2.0);\n    if (x_neg != y_neg) { // Could be replaced by a sign copy from (x_neg ^ y_neg) << 32\n        return 1.0f - x02;\n    } else {\n        return x02 - 1.0f;\n    }\n}\n\nfloat one_minus_z_pos(vec3 p) {\n    //debug_assert!(z > 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n\n    if (d2 < 1e-1f) { // <=> dec > 84.27 deg\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return 1.0f - p.z;\n}\n\nfloat one_minus_z_neg(vec3 p) {\n    //debug_assert!(z < 0.0);\n    float d2 = dot(p.xy, p.xy); // z = sqrt(1 - d2) AND sqrt(1 - x) = 1 - x / 2 - x^2 / 8 - x^3 / 16 - 5 x^4/128 - 7 * x^5/256\n    if (d2 < 1e-1f) { // <=> dec < -84.27 deg\n        // 0.5 * d2 + 0.125 * d2 * d2\n        return d2 * (0.5f + d2 * (0.125f + d2 * (0.0625f + d2 * (0.0390625f + d2 * 0.02734375f))));\n    }\n    return p.z + 1.0f;\n}\n\n// Z-Order curve projection.\nuint ij2z(uint i, uint j) {\n    uint i1 = i | (j << 16U);\n\n    uint j1 = (i1 ^ (i1 >> 8U)) & 0x0000FF00U;\n    uint i2 = i1 ^ j1 ^ (j1 << 8U);\n\n    uint j2 = (i2 ^ (i2 >> 4U)) & 0x00F000F0U;\n    uint i3 = i2 ^ j2 ^ (j2 << 4U);\n\n    uint j3 = (i3 ^ (i3 >> 2U)) & 0x0C0C0C0CU;\n    uint i4 = i3 ^ j3 ^ (j3 << 2U);\n\n    uint j4 = (i4 ^ (i4 >> 1U)) & 0x22222222U;\n    uint i5 = i4 ^ j4 ^ (j4 << 1U);\n\n    return i5;\n}\n\nstruct HashDxDy {\n    uint idx;\n    float dx;\n    float dy;\n};\n\n// Returns the cell number (hash value) associated with the given position on the unit sphere, \n// together with the offset `(dx, dy)` on the Euclidean plane of the projected position with\n// respect to the origin of the cell (South vertex).\n// # Inputs:\n// - `depth` in `[0, 14]` (so that and HEALPix cell number can be stored on an unsigned integer)\n// - `x`: in `[-1.0, 1.0]`\n// - `y`: in `[-1.0, 1.0]`\n// - `z`: in `[-1.0, 1.0]`\n// # Output\n// - the cell number (hash value) associated with the given position on the unit sphere,\n//   in `[0, 12*nside^2[`\n// - `dx`: the positional offset $\\in [0, 1[$ along the south-to-east axis\n// - `dy`: the positional offset $\\in [0, 1[$ along the south-to-west axis\n// # WARNING\n// - The function assumes, without checking, that the input vector is a unit vector \n//   (hence `x^2 + y^2 + z^2 = 1`) !!\n// - Operations being made on simple precision float, the precision is lower than `~0.2 arcsec` only!!\n// - At depth 13, the precision on `(dx, dy)` is better than `(1/512, 1/512)`, i.e. 2e-3.\nHashDxDy hash_with_dxdy(int depth, vec3 p) {\n    //assert!(depth <= 14);\n    //assert!(-1.0 <= x && x <= 1.0);\n    //assert!(-1.0 <= y && y <= 1.0);\n    //assert!(-1.0 <= z && z <= 1.0);\n    //debug_assert!(1.0 - (x * x + y * y + z * z) < 1e-5);\n    // A f32 mantissa contains 23 bits.\n    // - it basically means that when storing (x, y) coordinates,\n    //   we can go as deep as depth 24 (or maybe 25)\n    \n    uint nside = 1U << uint(depth);\n    float half_nside = float(nside) * 0.5f;\n\n    float x_pm1 = xpm1(p.xy);\n    uint q = quarter(p.xy);\n\n    uint d0h = 0U;\n    vec2 p_proj = vec2(0.f);\n    if (p.z > TRANSITION_Z) {\n        // North polar cap, Collignon projection.\n        // - set the origin to (PI/4, 0)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_pos(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, 2.0f - sqrt_3_one_min_z);\n        d0h = q;\n    } else if (p.z < -TRANSITION_Z) {\n        // South polar cap, Collignon projection\n        // - set the origin to (PI/4, -PI/2)\n        float sqrt_3_one_min_z = sqrt(3.0f * one_minus_z_neg(p));\n        p_proj = vec2(x_pm1 * sqrt_3_one_min_z, sqrt_3_one_min_z);\n        d0h = q + 8U;\n    } else {\n        // Equatorial region, Cylindrical equal area projection\n        // - set the origin to (PI/4, 0)               if q = 2\n        // - set the origin to (PI/4, -PI/2)           if q = 0\n        // - set the origin to (0, -TRANSITION_LAT)    if q = 3\n        // - set the origin to (PI/2, -TRANSITION_LAT) if q = 1\n        // let zero_or_one = (x_cea as u8) & 1;\n        float y_pm1 = p.z * TRANSITION_Z_INV;\n        // |\\2/|\n        // .3X1.\n        // |/0\\|\n        uint q01 = uint(x_pm1 > y_pm1);  // 0/1\n        //debug_assert!(q01 == 0 || q01 == 1);\n        uint q12 = uint(x_pm1 >= -y_pm1); // 0\\1\n        //debug_assert!(q12 == 0 || q12 == 1);\n        uint q03 = 1U - q12; // 1\\0\n        //let q13 = q01 ^ q12; debug_assert!(q13 == 0 || q13 == 1);\n        uint q1 = q01 & q12; // = 1 if q1, 0 else\n        //debug_assert!( q1 == 0 ||  q1 == 1);\n        // x: xcea - 0 if q3 | xcea - 2 if q1 | xcea - 1 if q0 or q2\n        //let x_proj = x_pm1 - ((q01 + q12) as i8 - 1) as f32;\n        // y: y - 0 if q2 | y - 1 if q1 or q3 | y - 2 if q0 \n        //let y_proj = y_pm1 + (q01 + q03) as f32;\n        p_proj = vec2(\n            x_pm1 - float(int(q01 + q12) - 1),\n            y_pm1 + float(q01 + q03)\n        );\n        // d0h: +8 if q0 | +4 if q3 | +5 if q1\n        d0h = ((q01 + q03) << 2U) + ((q + q1) & 3U);\n    }\n\n    // Coords inside the base cell\n    float x = (half_nside * (p_proj.x + p_proj.y));\n    float y = (half_nside * (p_proj.y - p_proj.x));\n    uint i = uint(x);\n    uint j = uint(y);\n    // Deal with numerical inaccuracies, rare so branch miss-prediction negligible\n    /*if (i == nside) {\n        i = i - 1U;\n    }\n    // Deal with numerical inaccuracies, rare so branch miss-prediction negligible\n    if (j == nside) {\n        j = j - 1U;\n    }*/\n\n    return HashDxDy(\n        (d0h << (uint(depth) << 1U)) | ij2z(i, j),\n        x - float(i),\n        y - float(j)\n    );\n}\n\nuniform int user_action;\n\nstruct Tile {\n    int uniq; // Healpix cell\n    int texture_idx; // Index in the texture buffer\n    float start_time; // Absolute time that the load has been done in ms\n};\n\nuniform int current_depth;\n\nuniform sampler2DArray tex;\nuniform Tile textures_tiles[64];\n\nuniform int num_textures;\n\nuniform float current_time; // current time in ms\nstruct TileColor {\n    Tile tile;\n    vec3 color;\n    bool found;\n};\n\nTileColor get_tile_color(vec3 pos, int depth) {\n    HashDxDy result = hash_with_dxdy(depth, pos.zxy);\n    uint idx = result.idx;\n    //int uniq = (1 << ((int(depth) + 1) << 1)) + int(idx);\n    int uniq = (16 << (int(depth) << 1)) | int(idx);\n\n    vec2 uv = vec2(result.dy, result.dx);\n\n    int a = 0;\n    int b = num_textures;\n\n    if (depth == 0) {\n        b = 11;\n    }\n\n    int i = (b + a) / 2;\n\n    int h = int(log2(float(b))) + 1;\n    // Binary search among the tile idx\n    for(int step = 0; step < h; step++) {\n        if (uniq == textures_tiles[i].uniq) {\n            Tile tile = textures_tiles[i];\n\n            int idx_texture = tile.texture_idx / 64;\n            int off = tile.texture_idx % 64;\n            float idx_row = float(off / 8); // in [0; 7]\n            float idx_col = float(off % 8); // in [0; 7]\n\n            vec2 offset = (vec2(idx_col, idx_row) + uv)/8.f;\n\n            vec3 color = texture(tex, vec3(offset, float(idx_texture))).rgb;\n\n            return TileColor(tile, color, true);\n        } else if (uniq < textures_tiles[i].uniq) {\n            // go to left\n            b = i - 1;\n        } else {\n            // go to right\n            a = i + 1;\n        }\n        i = (a + b)/2;\n    }\n\n    // code unreachable\n    Tile empty = Tile(0, -1, current_time);\n    return TileColor(empty, vec3(0.f), false);\n}\n\nconst float duration = 500.f; // 500ms\nuniform int max_depth; // max depth of the HiPS\n\nvoid main() {\n    vec3 frag_pos = normalize(out_vert_pos);\n    // Get the HEALPix cell idx and the uv in the texture\n\n    TileColor current_tile = get_tile_color(frag_pos, current_depth);\n    out_frag_color = vec4(current_tile.color, 1.f);\n\n    if (!current_tile.found) {\n        vec3 out_color = vec3(0.f);\n        int depth = 0;\n        if (user_action == 1) {\n            // zoom\n            depth = max(0, current_depth - 1);\n        } else {\n            // unzoom\n            depth = min(max_depth, current_depth + 1);\n        }\n\n        TileColor prev_tile = get_tile_color(frag_pos, depth);\n        float alpha = clamp((current_time - prev_tile.tile.start_time) / duration, 0.f, 1.f);\n        if (alpha == 1.f) {\n            out_frag_color = vec4(prev_tile.color, 1.f);\n            return;\n        }\n\n        TileColor base_tile = get_tile_color(frag_pos, 0);\n\n        out_color = mix(base_tile.color, prev_tile.color, alpha);\n        out_frag_color = vec4(out_color, 1.f);\n        return;\n    }\n\n    float alpha = clamp((current_time - current_tile.tile.start_time) / duration, 0.f, 1.f);\n    \n    // Little optimization: if the current tile is loaded since the time duration\n    // then we do not need to evaluate the frag position for the previous/next depth\n    if (alpha == 1.f) {\n        out_frag_color = vec4(current_tile.color, 1.f);\n        return;\n    }\n    vec3 out_color = vec3(0.f);\n    int depth = 0;\n    if (user_action == 1) {\n        // zoom\n        depth = max(0, current_depth - 1);\n    } else if (user_action == 2) {\n        // unzoom\n        depth = min(max_depth, current_depth + 1);\n    }\n\n    TileColor tile = get_tile_color(frag_pos, depth);\n    if (!tile.found) {\n        tile = get_tile_color(frag_pos, 0);\n    }\n\n    out_color = mix(tile.color, current_tile.color, alpha);\n    out_frag_color = vec4(out_color, 1.f);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nlayout (location = 0) in vec2 lonlat;\nlayout (location = 1) in vec3 position;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout vec2 screen_pos;\n\nuniform mat4 model;\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nvec2 world2clip_aitoff(vec3 p) {\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float theta_by_two = theta * 0.5f;\n\n    float alpha = acos(cos(delta)*cos(theta_by_two));\n    float inv_sinc_alpha = 1.f;\n    if (alpha > 1e-3f) {\n        inv_sinc_alpha = alpha / sin(alpha);\n    }\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = -2.f * inv_sinc_alpha * cos(delta) * sin(theta_by_two);\n    float y = inv_sinc_alpha * sin(delta);\n\n    return vec2(x / PI, y / PI);\n}\n\nvoid main() {\n    vec3 world_pos = vec3(inverse(model) * vec4(position, 1.f));\n    gl_Position = vec4(world2clip_aitoff(world_pos) / (ndc_to_clip * clip_zoom_factor), 0.0, 1.0);\n\n    screen_pos = gl_Position.xy;\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin vec2 screen_pos;\n\nout vec4 out_frag_color;\n\nuniform sampler2DArray tex;\n\nvoid main() {\n    vec4 color_start = vec4(0.f);\n    color_start = texture(tex, frag_uv_start);\n\n    vec4 color_end = vec4(0.f);\n    color_end = texture(tex, frag_uv_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nlayout (location = 0) in vec2 lonlat;\nlayout (location = 1) in vec3 position;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout vec2 screen_pos;\n\nuniform mat4 model;\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nvec2 world2clip_mollweide(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float cst = PI * sin(delta);\n\n    float phi = delta;\n    float f = phi + sin(phi) - cst;\n\n    int k = 0;\n    while (abs(f) > 1e-4 && k < max_iter) {\n        phi = phi - f / (1.f + cos(phi));\n        f = phi + sin(phi) - cst;\n\n        k = k + 1;\n    }\n\n    phi = phi * 0.5f;\n\n    // The minus is an astronomical convention.\n    // longitudes are increasing from right to left\n    float x = -(theta / PI) * cos(phi);\n    float y = 0.5f * sin(phi);\n\n    return vec2(x, y);\n}\n\nvoid main() {\n    vec3 world_pos = vec3(inverse(model) * vec4(position, 1.f));\n    gl_Position = vec4(world2clip_mollweide(world_pos) / (ndc_to_clip * clip_zoom_factor), 0.0, 1.0);\n\n    screen_pos = gl_Position.xy;\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin vec2 screen_pos;\n\nout vec4 out_frag_color;\n\nuniform sampler2DArray tex;\n\nvoid main() {\n    vec4 color_start = vec4(0.f);\n    color_start = texture(tex, frag_uv_start);\n\n    vec4 color_end = vec4(0.f);\n    color_end = texture(tex, frag_uv_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nlayout (location = 0) in vec2 lonlat;\nlayout (location = 1) in vec3 position;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout vec2 screen_pos;\n\nuniform mat4 model;\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n// current time in ms\nuniform float current_time;\n\nvec2 world2screen_orthographic(vec3 p) {\n    return vec2(-p.x, p.y);\n}\n\nvoid main() {\n    vec3 world_pos = vec3(inverse(model) * vec4(position, 1.f));\n    gl_Position = vec4(world2screen_orthographic(world_pos) / (ndc_to_clip * clip_zoom_factor), 0.0, 1.0);\n\n    screen_pos = gl_Position.xy;\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\n\nout vec4 out_frag_color;\n\nuniform sampler2DArray tex;\n\nvoid main() {\n    vec4 color_start = texture(tex, frag_uv_start);\n    vec4 color_end = texture(tex, frag_uv_end);\n\n    //out_frag_color = mix(vec4(1.0, 0.0, 0.0, 1.0), color_end, frag_blending_factor);\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nlayout (location = 0) in vec2 lonlat;\nlayout (location = 1) in vec3 position;\nlayout (location = 2) in vec3 uv_start;\nlayout (location = 3) in vec3 uv_end;\nlayout (location = 4) in float time_tile_received;\n\nout vec3 frag_uv_start;\nout vec3 frag_uv_end;\nout float frag_blending_factor;\nout vec2 screen_pos;\n\nuniform mat4 model;\nuniform vec2 ndc_to_clip;\nuniform float clip_zoom_factor;\n// current time in ms\nuniform float current_time;\n\nconst float PI = 3.1415926535897932384626433832795f;\n\nvec2 world2clip_mercator(vec3 p) {\n    // X in [-1, 1]\n    // Y in [-1/2; 1/2] and scaled by the screen width/height ratio\n    int max_iter = 10;\n\n    float delta = asin(p.y);\n    float theta = atan(p.x, p.z);\n\n    float x = -theta / PI;\n    float y = log(tan(PI * 0.25f + delta * 0.5f)) / PI;\n\n    return vec2(x, y);\n}\n\nvoid main() {\n    vec3 world_pos = vec3(inverse(model) * vec4(position, 1.f));\n    gl_Position = vec4(world2clip_mercator(world_pos) / (ndc_to_clip * clip_zoom_factor), 0.0, 1.0);\n\n    screen_pos = gl_Position.xy;\n    frag_uv_start = uv_start;\n    frag_uv_end = uv_end;\n    frag_blending_factor = min((current_time - time_tile_received) / 500.f, 1.f);\n}"},function(n,e){n.exports="#version 300 es\nprecision highp float;\nprecision lowp sampler2DArray;\nprecision highp int;\n\nin vec3 frag_uv_start;\nin vec3 frag_uv_end;\nin float frag_blending_factor;\nin vec2 screen_pos;\n\nout vec4 out_frag_color;\n\nuniform sampler2DArray tex;\n\nvoid main() {\n    vec4 color_start = vec4(0.f);\n    color_start = texture(tex, frag_uv_start);\n\n    vec4 color_end = vec4(0.f);\n    color_end = texture(tex, frag_uv_end);\n\n    out_frag_color = mix(color_start, color_end, frag_blending_factor);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2DArray;\n\nlayout (location = 0) in vec2 pos;\nlayout (location = 1) in vec2 uv;\n// Per instance attributes\nlayout (location = 2) in vec2 center_letter;\nlayout (location = 3) in vec2 size_letter;\nlayout (location = 4) in vec2 pos_uv;\nlayout (location = 5) in vec2 size_uv;\nlayout (location = 6) in float idx_page;\n\nout vec3 out_uv;\n\nuniform vec2 window_size;\nuniform float scaling;\n\nvec2 screen_to_ndc(vec2 p) {\n    // Change of origin\n    vec2 origin = p - window_size/2.0;\n\n    // Scale to fit in [-1, 1]\n    return vec2(2.0 * (origin.x/window_size.x), -2.0 * (origin.y/window_size.y));\n}\n\nvoid main() {\n    vec2 ndc_pos = screen_to_ndc(center_letter + pos*32.0);\n\n    gl_Position = vec4(ndc_pos, 0.f, 1.f);\n    out_uv = vec3(uv, idx_page);\n}"},function(n,e){n.exports="#version 300 es\nprecision lowp float;\nprecision lowp sampler2DArray;\n\nuniform vec4 text_color;\nuniform sampler2DArray font_textures;\n\nin vec3 out_uv;\nout vec4 color;\n\nvoid main() {\n    vec3 uv = vec3(out_uv.x, 1.f - out_uv.y, out_uv.z);\n    vec4 mask = texture(font_textures, uv);\n    color = text_color * mask;\n    //color = vec4(1.0, 0.0, 0.0, 1.0);\n}"},function(n,e,t){var o=t(1),r=t(44);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[n.i,r,""]]);var i={insert:"head",singleton:!1};o(r,i);n.exports=r.locals||{}},function(n,e,t){(e=t(2)(!1)).push([n.i,"* {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\nhtml {\n    line-height: 1.15;\n}\n\nbody {\n    /* Disable scrollbars */\n    overflow: hidden;\n}\n\n#nav {\n    width: 15em;\n    top: 0;\n    display: block;\n    position: fixed;\n    background-color: black;\n}\n\nselect {\n    position: relative;\n    width: 100%;\n    height: 2em;\n    line-height: 2;\n    background: black;\n    overflow: hidden;\n    border-radius: .25em;\n\n    color: #fff;\n    cursor: pointer;\n}\n/* Pure CSS input */\n\ninput[type=text] {\n    display: block;\n    width: 100%;\n    padding: .5em .6em;\n    display: inline-block;\n    border: 1px solid #ccc;\n    -webkit-box-shadow: inset 0 1px 3px #ddd;\n    box-shadow: inset 0 1px 3px #ddd;\n    border-radius: 4px;\n    vertical-align: middle;\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n}",""]),n.exports=e},function(n,e,t){var o=t(1),r=t(46);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[n.i,r,""]]);var i={insert:"head",singleton:!1};o(r,i);n.exports=r.locals||{}},function(n,e,t){(e=t(2)(!1)).push([n.i,".autocomplete-suggestions {\n    text-align: left; cursor: default; border: 1px solid #ccc; border-top: 0; background: #fff; box-shadow: -1px 1px 3px rgba(0,0,0,.1);\n\n    /* core styles should not be changed */\n    position: absolute; display: none; z-index: 9999; max-height: 254px; overflow: hidden; overflow-y: auto; box-sizing: border-box;\n}\n.autocomplete-suggestion { position: relative; padding: 0 .6em; line-height: 23px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 1.02em; color: #333; }\n.autocomplete-suggestion b { font-weight: normal; color: #1f8dd6; }\n.autocomplete-suggestion.selected { background: #f0f0f0; }\n",""]),n.exports=e},function(n,e,t){"use strict";t.r(e);var o=t(3),r=t.n(o),i=t(4),a=t.n(i),c=t(5),l=t.n(c),s=t(6),u=t.n(s),_=t(7),f=t.n(_),p=t(8),d=t.n(p),m=t(9),v=t.n(m),h=t(10),g=t.n(h),x=t(11),b=t.n(x),w=t(12),y=t.n(w),E=t(13),z=t.n(E),T=t(14),I=t.n(T),P=t(15),q=t.n(P),j=t(16),C=t.n(j),A=t(17),D=t.n(A),k=t(18),S=t.n(k),O=t(19),N=t.n(O),L=t(20),H=t.n(L),M=t(21),R=t.n(M),U=t(22),G=t.n(U),B=t(23),W=t.n(B),F=t(24),Y=t.n(F),V=t(25),X=t.n(V),Z=t(26),$=t.n(Z),J=t(27),Q=t.n(J),K=t(28),nn=t.n(K),en=t(29),tn=t.n(en),on=t(30),rn=t.n(on),an=t(31),cn=t.n(an),ln=t(32),sn=t.n(ln),un=t(33),_n=t.n(un),fn=t(34),pn=t.n(fn),dn=t(35),mn=t.n(dn),vn=t(36),hn=t.n(vn),gn=t(37),xn=t.n(gn),bn=t(38),wn=t.n(bn),yn=t(39),En=t.n(yn),zn=t(40),Tn=t.n(zn),In=t(41),Pn=t.n(In),qn=t(42),jn=t.n(qn);let Cn=[{name:"catalog_aitoff",vert:r.a,frag:a.a},{name:"catalog_mercator",vert:l.a,frag:u.a},{name:"catalog_mollweide",vert:f.a,frag:d.a},{name:"catalog_ortho",vert:v.a,frag:g.a},{name:"black_white_linear",vert:b.a,frag:y.a},{name:"BluePastelRed",vert:z.a,frag:I.a},{name:"IDL_CB_BrBG",vert:q.a,frag:C.a},{name:"IDL_CB_GnBu",vert:D.a,frag:S.a},{name:"IDL_CB_YIGnBu",vert:N.a,frag:H.a},{name:"red_temperature",vert:R.a,frag:G.a},{name:"grid_aitoff",vert:W.a,frag:Y.a},{name:"grid_ortho",vert:Q.a,frag:nn.a},{name:"grid_mollweide",vert:X.a,frag:$.a},{name:"grid_mercator",vert:tn.a,frag:rn.a},{name:"raytracer",vert:cn.a,frag:sn.a},{name:"rasterizer_aitoff",vert:_n.a,frag:pn.a},{name:"rasterizer_mercator",vert:En.a,frag:Tn.a},{name:"rasterizer_mollweide",vert:mn.a,frag:hn.a},{name:"rasterizer_ortho",vert:xn.a,frag:wn.a},{name:"text",vert:Pn.a,frag:jn.a}];t(43),t(45),t.p,t.p;class An{constructor(n){this.aladin=n,this.ongoingTouches=new Array,this.canvas=document.getElementById("canvas"),this.createEvents(),this.then=Date.now()}ongoingTouchIndexById(n){for(let e=0;e<this.ongoingTouches.length;e++){if(this.ongoingTouches[e].identifier===n)return e}return-1}removeTouchFromOnGoingTouches(n){for(let e=0;e<this.ongoingTouches.length;e++)if(this.ongoingTouches[e].identifier==n.identifier){this.ongoingTouches.splice(e,1);break}}updateTouch(n){let e=this.ongoingTouchIndexById(n.identifier);this.ongoingTouches.splice(e,1,n)}touchEventsOccuring(){return this.ongoingTouches.length>0}update(n){return this.aladin.update(n)}render(){this.aladin.render()}createEvents(){let n={NOTHING:0,MOVING:1,ZOOMING:2,properties:{2:{unZoom:!1,startFov:void 0,startDist:void 0}}},e=n.NOTHING;this.canvas.addEventListener("touchstart",t=>{t.preventDefault();let o=t.changedTouches[0];this.ongoingTouches.push(o);let r=this.ongoingTouches.length;if(1==r){e=n.MOVING;let[t,r]=this.aladin.screenToWorld(o.pageX,o.pageY);this.aladin.setCenter(t,r)}else if(2==r){let t=this.ongoingTouches[0],o=this.ongoingTouches[1],[r,i]=this.aladin.screenToWorld(t.pageX,t.pageY);this.aladin.setCenter(r,i),e=n.ZOOMING,n.properties[e].startDist=Math.hypot(t.pageX-o.pageX,t.pageY-o.pageY),n.properties[e].startFov=this.aladin.getFieldOfView()}else e=n.NOTHING},!1);let t=t=>{t.preventDefault();let o=t.changedTouches[0];if(this.removeTouchFromOnGoingTouches(o),e===n.ZOOMING){let[t,o]=this.aladin.screenToWorld(this.ongoingTouches[0].pageX,this.ongoingTouches[0].pageY);this.aladin.setCenter(t,o),e=n.MOVING}else if(e===n.MOVING){let[t,r]=this.aladin.screenToWorld(o.pageX,o.pageY);this.aladin.setCenter(t,r),this.aladin.startInertia(),e=n.NOTHING}};this.canvas.addEventListener("touchend",t,!1),this.canvas.addEventListener("touchcancel",t,!1),this.canvas.addEventListener("touchleave",t,!1),this.canvas.addEventListener("touchmove",t=>{t.preventDefault();let o=t.changedTouches[0];if(this.updateTouch(o),e===n.MOVING){let[n,e]=this.aladin.screenToWorld(o.pageX,o.pageY);this.aladin.setCenter(n,e)}else if(e===n.ZOOMING){let t=Math.hypot(this.ongoingTouches[0].pageX-this.ongoingTouches[1].pageX,this.ongoingTouches[0].pageY-this.ongoingTouches[1].pageY),o=n.properties[e].startFov,r=n.properties[e].startDist;this.aladin.setFieldOfView(o*r/t)}},!1);var o=0;window.addEventListener("mousedown",n=>{++o}),window.addEventListener("mouseup",n=>{--o}),this.canvas.addEventListener("mousedown",n=>{if(this.touchEventsOccuring())return;let[e,t]=this.aladin.screenToWorld(n.clientX,n.clientY);this.aladin.setCenter(e,t)}),this.canvas.addEventListener("mouseup",n=>{if(this.touchEventsOccuring())return;let[e,t]=this.aladin.screenToWorld(n.clientX,n.clientY);this.aladin.setCenter(e,t),this.aladin.startInertia()}),this.canvas.addEventListener("mousemove",n=>{if(o){if(this.touchEventsOccuring())return;let[e,t]=this.aladin.screenToWorld(n.clientX,n.clientY);this.aladin.setCenter(e,t)}}),this.canvas.addEventListener("dblclick",n=>{if(this.touchEventsOccuring())return;let[e,t]=this.aladin.screenToWorld(n.clientX,n.clientY);this.aladin.moveToLocation(e,t)}),this.canvas.addEventListener("wheel",n=>{if(this.touchEventsOccuring())return;n.deltaY;let e=this.aladin.getFieldOfView();n.deltaY>0?e*=Math.pow(2,1.5):e/=Math.pow(2,1.5);try{let[t,o]=this.aladin.screenToWorld(n.clientX,n.clientY);this.aladin.zoomToLocation(t,o,e)}catch(n){let[t,o]=this.aladin.getCenter();this.aladin.zoomToLocation(t,o,e)}},!1),window.addEventListener("resize",()=>{let n=window.innerWidth,e=window.innerHeight;this.aladin.resize(n,e)})}}var Dn=t(0),kn=t.n(Dn);async function Sn(n){var e={method:"GET",headers:new Headers,mode:"cors",cache:"default"};let[t,o]=await fetch("https://alasky.u-strasbg.fr/MocServer/query?expr=dataproduct_type%3Dcatalog%26%26nb_rows<%3D500000%26%26nb_rows>%3D50000%26%26data_ucd%3Dpos.parallax*%26%26data_ucd%3Dphot.mag*&get=record&fmt=json",e).then(n=>n.json()).then(n=>{let e=[],t=new Map;for(var o=0;o<n.length;o++){var r=n[o].ID;t[r]={obs_id:n[o].obs_id},e.push(r)}return[e,t]});new kn.a({selector:"#catalog",minChars:2,source:function(n,e){n=n.toLowerCase();var o=t,r=[];for(let e=0;e<o.length;e++)o[e].toLowerCase().indexOf(n)>=0&&r.push(o[e]);console.log("MATCHES",r),e(r)},renderItem:function(n,e){e=e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");var t=new RegExp("("+e.split(" ").join("|")+")","gi");return'<div class="autocomplete-suggestion" data-val="'+n+'">'+n.replace(t,"<b>$1</b>")+"</div>"},onSelect:async function(e,t,o){let r=t;await async function(n,e){let t=await On(e,"pos.parallax");console.log("parallax column name: ",t);let o=await On(e,"phot.mag");console.log("phot mag column name: ",o);let r=await On(e,"pos.eq.ra"),i=await On(e,"pos.eq.dec");(function(n,e,t="*"){let o=[];e.forEach(e=>{console.log(e),o.push('"'+n+'"."'+encodeURIComponent(e)+'"')});let r="SELECT "+o.join(", ")+' FROM "'+n+'"';console.log(r);let i=encodeURI("https://alasky.u-strasbg.fr/cgi/JSONProxy?url=")+encodeURIComponent("http://tapvizier.u-strasbg.fr/TAPVizieR/tap/sync?phase=RUN&lang=adql&format=json&request=doQuery&query="+encodeURIComponent(r));var a={method:"GET",headers:new Headers,mode:"cors",cache:"default"};return fetch(i,a).then(n=>n.json()).then(n=>n.data)})(e.substring(4),[r,i,o,t]).then(e=>{n.add_catalog("Test",e)})}(n,r)}})}function On(n,e){let t=n.substring(4),o=encodeURI("https://alasky.u-strasbg.fr/cgi/JSONProxy?url=")+encodeURIComponent("http://tapvizier.u-strasbg.fr/TAPVizieR/tap/sync?phase=RUN&lang=adql&format=json&request=doQuery&query=SELECT%20TOP%201%20table_name%2C%20column_name%2C%20ucd%20FROM%20TAP_SCHEMA.columns%20WHERE%20table_name%3D%27"+encodeURIComponent(t)+"%27%20AND%20ucd%20LIKE%20%27"+encodeURIComponent(e)+"%25%27");var r={method:"GET",headers:new Headers,mode:"cors",cache:"default"};return fetch(o,r).then(n=>n.json()).then(t=>(console.log(n,e,": here are the data",t.data),t.data[0][1]))}window.addEventListener("load",async()=>{const n=await Promise.all([t.e(1),t.e(2)]).then(t.bind(null,55));let e=await Cn;console.log(e);let o=new n.WebClient(e);!async function(n){var e={method:"GET",headers:new Headers,mode:"cors",cache:"default"};let[t,o]=await fetch("https://alasky.u-strasbg.fr/MocServer/query?hips_service_url*=*alasky*&&dataproduct_type=image&&hips_tile_format=*png*,*jpeg*&get=record&fmt=json",e).then(n=>n.json()).then(n=>{let e=[],t=new Map;for(let o=0;o<n.length;o++){let r=n[o].ID;t[r]={hips_service_url:n[o].hips_service_url,max_depth:n[o].hips_order,tile_width:n[o].hips_tile_width,hips_tile_format:n[o].hips_tile_format},e.push(r)}return[e,t]});new kn.a({selector:"#hips",minChars:2,source:function(n,e){n=n.toLowerCase();var o=t,r=[];for(let e=0;e<o.length;e++)o[e].toLowerCase().indexOf(n)>=0&&r.push(o[e]);e(r)},renderItem:function(n,e){e=e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");var t=new RegExp("("+e.split(" ").join("|")+")","gi");return'<div class="autocomplete-suggestion" data-val="'+n+'">'+n.replace(t,"<b>$1</b>")+"</div>"},onSelect:function(e,t,r){let i=t,{hips_service_url:a,max_depth:c,hips_tile_format:l,tile_width:s}=o[i];console.log(o[i]),n.setHiPS(a,+s,+c,l)}})}(o),Sn(o);let r=document.getElementById("projection");r.addEventListener("change",()=>{let n=r.value;o.set_projection(n),console.log("change projection to: ",n)},!1);let i=new An(o);!function n(){window.requestAnimationFrame(n);let e=Date.now(),t=e-i.then;i.then=e;i.update(t)?(i.render(),console.log("render ")):console.log("render not")}()})}]);